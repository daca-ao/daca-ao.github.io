---
title: JVM 初探
date: 2021-07-07 22:44:49
tags:
- Java
- JVM
---

JVM 作为 Java 程序的容器，是所有 Java 程序依赖的平台。

<!-- more -->

JVM 执行 Java 程序的过程：
1. 通过类加载器加载各个 `.class` 文件
2. 为程序管理并分配内存
3. 在适当的时候执行垃圾回收

多一些阅读[官方文档（Java 13）](https://docs.oracle.com/javase/specs/jvms/se13/html/index.html)，涉猎 JVM 的原理，有助于 Java Developer 们避开开发过程中的许多陷阱。

<br/>

# 基本结构

顶层：**类加载器** **Class Loader**
* 加载 JVM .class 文件

中间：Java 虚拟机内存（**Runtime Data Area**, **运行时数据区**，重点关注），即 JVM 在系统中能掌控到的内存部分，主要包括 5 部分：
* <font color="#548235">**方法区**</font> (Method Area)
* <font color="#548235">**堆**</font> (Heap, 存放 Java 对象和数组实例)
* <font color="#FFC000">**本地方法栈**</font> (Native Method Stack)
* <font color="#FFC000">**程序计数器**</font> (Program Counter Registers)
* <font color="#FFC000">**虚拟机栈**</font> (VM Stack，也有理解为 Java 方法栈的)

底层：运行引擎 (Execution Engine)
* 通过本地方法接口（Native Interfaces）与本地方法库（Native Libraries）交互

![](jvm-basics/jvm-overview.png)

JVM 在初始运行的时候，会分配好 <font color="#548235">Method Area</font>（方法区）和 <font color="#548235">Heap</font>（堆）；在为程序管理并分配内存的时候，每遇到一个线程，就会为其分配一个 <font color="#FFC000">Program Counter Register</font>（程序计数器），一个 <font color="#FFC000">Native Method Stack</font>（本地方法栈） 和一个 <font color="#FFC000">VM Stack</font>（虚拟机栈）。
* 即：**线程私有**的三块（<font color="#FFC000">程序计数器</font>、<font color="#FFC000">本地方法栈</font>和<font color="#FFC000">虚拟机栈</font>）区域的生命周期与 Java 程序中的某个所属线程相同；**线程共享**的<font color="#548235">方法区</font>和<font color="#548235">堆</font>与 Java 程序运行的生命周期相同。
* 所以：这也是系统垃圾回收只发生在线程共享的区域（大部分只发生在**堆**中）的原因。

当线程终止时：线程私有的程序计数器、本地方法栈和虚拟机栈所占用的空间会被释放掉。

<br/>

我们知道，计算机存储数据主要利用三个空间：**寄存器**、**栈**和**堆**。
* Java 不能直接控制和处理寄存器，只能操作栈空间和堆空间。
* 对于每一个运行在内存中的 Java 程序，Java 虚拟机都为其分配好相应的栈空间和堆空间。

栈空间（Stack）：
* 存储空间较小，不能存放大量的数据
* JVM 将 Java 方法、基本类型的数据，以及对对象（包括数组和字符串）的引用存放在栈空间
* 存取数据效率高，仅次于寄存器
* 管理数据：先进后出（LIFO）

堆空间（Heap）：
* 存储数据的空间大，能存放大容量的数据（数组、字符串、对象等）
* 但存取数据的效率最低
* 在堆空间中，数据存放的位置随机分配

<br/>

## <font color="#548235">线程共享区域</font>
包括**方法区**和**堆**。

![](jvm-basics/jvm-shared.png)

**<big>1. 堆 Heap</big>**

JVM 只有一个堆区，在 JVM 启动的时候被创建，被所有线程共享，更是垃圾回收的主要战场。  
堆用于存储对象（包括数组，因为数组也是一种对象），是 JVM 的内存数据区。分为以下几个部分：
* **新生代**（`YoungGen`, Y）
    * = `Eden`(4/5) + `From Survivor`(1/10) + `To Survivor`(1/10)
    * Eden 空间不足时，存活的对象转移到 Survivor，多个 Survivor 用于交换
    * JVM 每次只会使用 Eden 和其中一块 Survivor 来为对象服务，所以无论什么时候，总会有另一块 Survivor 是空闲着的
    * 因此，新生代实际可用的内存空间为 9/10（即 90%）的新生代空间。
* **老年代**（`OldGen`, O）
    * 存放生命周期长的对象

另：**永久区**（`PermGen`, P）
* 存在于 Java 8 之前的 Hotspot 虚拟机中，其他类型 JVM 没有这个概念
* 从 Java 8 开始，PermGen 被取消，以 Metaspace 元空间代替
* 存放 Class 和 Meta 信息等，GC 时一般不清理。

实际上，堆只保存对象实例的**属性值**、**属性类型**和**对象本身类型标记**等，并不保存对象的方法（保存在栈里）。  
对象实例在堆中被分配好之后，需要在栈中保存一个 4 字节的**堆内存地址**，用来定位该对象实例在堆中的位置，以便实例被找到。

注：堆处于**物理不连续**的内存空间中，只要逻辑上连续即可。

<br/>

**<big>2. 方法区 Method Area</big>**

方法区存放的东西有很多，主要包括：
1. Object Class Data（类的类定义数据，即类型信息）
2. 域（Field）信息
3. 方法（Method）信息
4. 常量及静态变量
5. 即时编译器 JIT 编译后的代码缓存（CodeCache）

对于每一个要加载的**类型**（类 Class、接口、枚举、注解），JVM 必须在方法区存储以下类型的信息：
* 类的类型（`class` / `interface`）
* 类的全限定名
* 类的直接父类的全限定名（接口和 `java.lang.Object` 除外：它们没有父类）
* 访问修饰符（`public` / `abstract` / `final`）
* 实现的接口的全限定名的有序列表
* 常量池（Java 6 及之前版本）
* 除常量外的静态变量
* 该类型的所有域的信息，以及所有域的声明顺序
* 该类型的所有方法的信息，以及所有方法的声明顺序
* 指向 ClassLoader 的引用：JVM 在动态链接的时候需要这个信息
* 指向 Class 实例的引用

如上述，JVM 加载了所需每个类型中的每一个**域**（Field，又称字段、变量）的信息。对于每一个域，包括：
* 域的名称
* 域的类型
* 域的修饰符（`public`, `private`, `protected`, `static`, `final`, `volatile`, `transient`）

JVM 加载了所需每个类型中的每一个**方法**（Method）的信息。对于每一个方法，包括：
* 方法名称
* 方法返回类型，或 `void`
* 方法参数的数量和类型（按顺序）
* 方法修饰符（`public`, `private`, `protected`, `static`, `final`, `synchronized`, `native`, `abstract`）
* 方法的字节码、局部变量表及大小、操作数栈及大小（抽象方法和本地方法 native method 除外）
* 方法异常表（抽象方法和本地方法 native method 除外）：记录了每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。

和堆一样，方法区可以由不连续的区域组成，并且可以设置固定大小，也可设置为可扩展。  
方法区的大小决定了系统**可以保存多少个类**，如果类太多导致方法区溢出，则会抛出异常：`java.lang.OutOfMemoryError: PermGen Space`（until Java 7）或 `java.lang.OutOfMemoryError: Metaspace`（since Java 8）。

正是因为方法区所存储的数据与堆有一种类比关系，而且方法区不属于堆的一部分，所以也被称为“非堆” No-Heap。  
不过，正因为方法区不属于堆，所以它很少会触发垃圾回收，发生内存回收的目的主要是针对**常量池的回收**和**类的卸载**。

![](jvm-basics/method-area.png)


<big>**随 JDK 版本变迁的方法区实现（对于 Hotspot 虚拟机而言）**</big>

方法区是 JVM 的一个**概念**，各个不同的 JVM 有不一样的具体实现。这里只讨论 Hotspot 虚拟机：
* Until Java 6：PermGen 被分配在 JVM 堆中，与堆相互隔离，大小在启动 JVM 时固定
* Java 7：将 PermGen 中的静态变量、字符串常量池等移到堆中，其他不变
    * 原因：永久区回收效率低，而开发中会有大量字符串创建，回收效率低的话，容易导致内存不足。
* Since Java 8：取消 PermGen，改为 Metaspace（元空间，顾名思义，即存储类相关的**元数据**）实现，与堆共同分配在本地内存（使用本地内存），大小可以动态调整。

![](jvm-basics/jvm-shared-6.png)
![](jvm-basics/jvm-shared-7.png)
![](jvm-basics/jvm-shared-8.png)

元空间和永久区最大的区别是：元空间不存在虚拟机设置的内存中，而是直接使用**本地内存**。

Java 8 使用元空间替换 Java 7 及以前的永久区的目的：
1. 设置的永久区空间大小，不太好确定，更容易遇到内存溢出的问题
2. 对永久区调优比较困难

<br/>
<br/>

## <font color="#FFC000">线程私有区域</font>
包括**程序计数器**、**本地方法栈**和**虚拟机栈**。

**<big>1. 程序计数器 Program Counter Register</big>**
* 当前线程执行的字节码的行号位置指示器：正在执行的字节码的地址
    * 类似于操作系统的 PC 计数器
    * 指定下一条需要执行的虚拟机字节码指令的地址
* 指示执行哪条指令，分支、循环、跳转、异常等情况，以及线程恢复等基础功能均依赖其指示来实现；
* 由于 Java 多线程由时间片轮转实现，因此每个线程私有程序计数器，以便切换后线程内的代码能恢复执行；
* 比较小，是唯一没有规定 OOM 的区域。


**<big>2. 虚拟机栈 VM Stack</big>**

又叫栈内存。线程创建时被创建，线程结束后，内存就被释放。有的翻译译作“Java 方法栈”的，大概是因为它描述的是 Java **方法执行**时的内存模型。

我们都知道，Java 指令是由**操作码**（方法本身）和**操作数**（方法内部变量）组成的。操作码保存在栈内存中；操作数跟在操作码之后，基本类型的变量保存在栈中，对象类型的变量将地址保存在栈中，将值保存在堆中。

也就是说，Java 对象方法本身、基本类型变量和对象地址都存储在虚拟机栈里。
* 每个方法执行时创建栈帧（stack frame），压入虚拟机栈，返回时弹栈
    * 返回至返回地址（Return Address，即指针）
* 每个栈帧对应于一个方法名
    * 包括 main() 方法：main 栈帧
    * 栈帧中只保存原生数据类型（primitive）和对对象的引用（reference）
* 每个方法从被调用开始直至执行完毕的全过程，对应着该栈帧在虚拟机栈的入栈和出栈过程。
* 考虑到可能的多线程环境，虚拟机栈是每个线程**私有**的
* 注意区分：<font color="#FFC000">栈</font>存储的是**方法内部变量**，<font color="#548235">方法区</font>存储的是**常量和静态变量**。

每个虚拟机栈的栈帧存储了：

**1. 局部变量表 Local Variables**
* 是一个以一个字长（8 bits）为单位、从 0 开始计数的数组：通过 index 索引访问
* 存放了编译期可知的各种基本数据类型，以及对象的引用
* `short`、`byte`、`char` 和 `boolean` 等类型变量值在存入该数组前要被转换成 **`int`** 值
* 而 `long` 和 `double` 因为在数组中会占据连续的两项：
    * 在访问局部变量中的 `long` 或 `double` 时，只需取出连续两项的第一项的索引值即可
    * 如某个 `long` 值在局部变量区中占据的索引为 3、4 项，取值时指令只需取索引为 3 的 `long` 值即可
* 其内存空间在编译期完成分配，运行时也不会被改变

**2. 操作数栈 Operand Stack**
* 结构与局部变量表一致，但对它的访问是通过 push 和 pop 操作来进行的，而不是通过索引；
* 可以被看成是栈帧所对应的方法的计算过程中，数据的临时存储区域

**3. 帧数据 Frame Data**

包括：
* 解析方法内引用的常量池中的数据
* 保存返回地址 Return Address（指向下一条字节码指令的地址），用于方法执行完后返回，恢复调用方的现场
* 保存异常表，用于方法执行过程中抛出异常时的异常处理
    * 当出现异常时，虚拟机查找相对应的异常表看是否有对应的 catch 语句
    * 如没有就抛出异常终止该方法调用


**<big>3. 本地方法栈 Native Method Stack</big>**
* 与虚拟机栈作用类似
* 虚拟机栈为 JVM 提供执行 Java 方法的服务，而本地方法栈则是为 JVM 提供执行 native 方法的服务

<br/>

比如：一个 Java 类中定义了 doMath() 方法。
* 执行该方法的时候，除了 main 栈帧及其它方法对应的栈帧之外，栈帧 doMath 的变量表、操作数栈、帧数据的变化，以及程序计数器、本地方法栈等如下图：

![](jvm-basics/vm-stack.png)
