---
title: Java 内存模型 JMM
date: 2021-07-10 00:05:24
tags:
- Java
---

Java Memory Model, JMM

<!-- more -->

* JVM 规范定义了 JMM
* 用以屏蔽各种硬件和操作系统的内存访问差异
    * 以实现让 Java 程序在各种平台都能达到一致的并发效果
* 目标：规范了 JVM 与计算机内存是如何协同工作的
    * 规定了一个线程如何，以及何时能看到由其他线程修改过后的共享变量的值
    * 必须如何同步地访问共享变量
    * 即：定义在虚拟机中如何将变量存储进内存，以及从内存取出来的细节

基本：

* 一个本地变量可能是原始类型——总是在线程栈上
* 一个本地变量可能是指向一个对象的引用——引用存放在线程栈，对象本身在堆上
* 一个对象可能包含方法，方法包含本地变量——本地变量在线程栈上，即便方法所属对象在堆上
* 一个对象的成员变量可能随着该对象自身放在堆上
    * 不管是原始类型还是引用类型
* 静态成员变量跟随类定义一起存放到堆上
* 堆上的对象可被所有持有对该对象引用的线程访问
    * 当一个线程可访问一个对象时，它也可以访问该对象的成员变量
    * 如两个线程同时调用同一对象的同一方法：将都会访问该对象的成员变量，但每个线程各拥有一份该成员变量的私有拷贝

JMM 定义了线程和主存间的抽象关系：
* 线程之间的共享变量存储在主存中
* 每个线程都有一份私有本地内存（Local Memory）
    * JMM 抽象概念，并不真实存在
    * 涵盖了缓存、写缓冲区、寄存器及其它硬件和编译器优化
    * 存储了该线程以读/写共享变量的拷贝副本
* 主存是硬件的内存，为获取更好运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中
* JMM 的工作内存（working memory）是 CPU 的寄存器和高速缓存的抽象描述
    * JVM 静态内存储模型（JVM 内存模型）只是一种对内存的划分，只局限在 JVM 内存

具体的交互协议：
同步操作及规则

定义了 8 种操作完成主内存与工作内存具体的交互细节：
lock（锁定）
* 作用于主内存的变量
* 将一个变量标识为一条线程独占状态
unlock（解锁）
* 作用于主内存的变量
* 将一个处于锁定状态的变量释放，释放后的变量才可被其他线程锁定
read（读取）
* 作用于主内存的变量
* 将一个变量值从主内存传输到线程工作内存中，以便随后的 load 操作使用
load（载入）
* 作用于工作内存的变量
* 将 read 操作从主内存得到的变量值放入工作内存的变量副本中
use（使用）
* 作用于工作内存的变量
* 将工作内存的一个变量值传递给执行引擎
* 每当虚拟机遇到一个需要使用变量值的字节码指令：执行该操作
assign（赋值）
* 作用于工作内存的变量
* 将一个从执行引擎（Java Execution）接收到的值赋值给工作内存的变量
* 每当虚拟机遇到一个给变量赋值的字节码指令：执行该操作
store（存储）
* 作用于工作内存的变量
* 将工作内存中一个变量值传送回主内存，以便随后的 write 操作
write（写入）
* 作用于工作内存的变量
* 将 store 操作从工作内存中一个变量的值传送回主内存变量

同步规则：
* 如要将一个变量从主内存复制到工作内存：需按序执行 read 和 load 操作
* 如要将变量从工作内存同步回主内存：需按序执行 store 和 write 操作
    * JMM 只要求上述操作必须按顺序执行，没有保证必须连续执行
* 不允许 read 和 load、store 和 write 操作之一单独出现
* 不允许一个线程丢弃它最近的 assign 操作
    * 即：变量在工作内存中改变了之后必须同步回主内存
* 不允许一个线程无理由地（没发生任何 assign 操作）将数据从工作内存同步回主内存
* 一个新变量只能在主内存诞生
    * 不允许在工作内存直接使用一个未被初始化（load 或 assign）的变量
    * 即：对一个变量实施 use 和 store 操作之前，必须先执行过了 load 和 assign 操作
* 一个变量在同一时刻只允许一条线程对其进行 lock 操作
    * lock 操作可被同一线程重复执行多次
    * 多次执行 lock 后，只有再执行相同次数的 unlock 操作才会解锁变量
    * 即：lock 和 unlock 需成对出现
* 如对一个变量执行 lock 操作：清空工作内存中此变量的值
    * 执行引擎（Java Execution）使用该变量前需重新执行 load 或 assign 操作来初始化变量的值
* 如一个变量事先没被 lock 锁定：不允许执行 unlock 操作
    * 不允许 unlock 一个被其他线程锁定的变量
* 对一个变量 unlock 前：需将此变量同步到主内存中（执行 store 和 write 操作）


JMM 解决的问题

问题概述：
1. 线程缓存导致的可见性问题
* 多个线程没有在正确使用 volatile 声明或同步时共享一个对象
* 一个线程更新该共享变量可能对其他线程不可见
    * 共享对象被初始化在主内存
    * 跑在 CPU 上的一个线程将该共享对象读到 CPU 缓存，然后修改
    * 只要 CPU 缓存没被刷新回主内存，对象修改后的状态对于跑在其它 CPU 上的线程均不可见
* 导致每个线程拥有该共享对象的私有拷贝，每份拷贝停留在不同 CPU 缓存中
