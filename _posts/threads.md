---
title: 操作系统线程管理
date: 2021-08-03 22:24:37
tags:
- 操作系统
---

今天在学习整理系统并发的知识点的时候，发现自己对操作系统调度的某些概念有些模糊了，特别是线程这一块。今天就另开一个帖子记一下。

<!-- more -->

# 概念

首先来区分两个概念：**进程**与**线程**

进程，是操作系统的资源调度实体
* 内存中运行的一个应用程序，就会对应地启动一个（或多个）进程
    * 如：Windows 系统中，一个运行的 .exe 为一个进程
* 每个进程都有自己独立的一块内存地址空间和运行环境
* 一个进程可以包含一个或多个线程，但至少要包含一个线程

进程被启动之后，操作系统会为进程分配资源，最主要的是内存空间
* 进程中有些程序流程块是乱序的，且可同时被多次执行
* 代码块——线程体

而线程，是对程序中单独顺序控制流程的封装，即一个执行流程
* 进程**调度的最小单元**
* 线程本身依靠程序的进行而运行（总是属于某个进程），只能使用分配给它所依靠的进程的资源和环境
* 主要由线程ID、当前指令指针（PC）、寄存器集合（Registers）和堆栈（Heap & Stack）等组成
* 一个进程可运行多个线程，多个线程共享进程的内存
    * 包括内存空间和打开的文件
* 线程也叫“**轻量级进程**（**Light-Weight Process**, **LWP**）”

处理器在线程之间高速地切换，让使用者感觉线程在同时执行。

刚刚说到，一个进程可以包含不止一个线程。  
单线程，指的是程序中只存在一个线程；实际上，程序的主方法就是一个主线程。  
多线程，指的是在一个程序中运行多个任务，目的是更好的使用CPU资源。一个程序中多个线程如果同时执行的时候，我们称之为**并发**。

![](threads/threads-and-processes.png)

<br/>

# 线程状态

**就绪**
* 线程被分配了除 CPU 以外的全部资源，等待获得 CPU 调度

**运行**（Running）
* 就绪状态的线程获得了 CPU，开始执行程序代码
* 一个正在运行的线程仍然处于可运行状态
* 线程一旦运行了，就不必始终保持运行；有的时候，运行中的线程被中断，以便让其他的线程获得运行机会
* 如线程数目多于处理器数目，调度器会采用时间片机制

**阻塞**
* 线程因发生 I/O 或其他操作导致无法继续执行
* 此时线程会放弃处理机（CPU 使用权），转入线程就绪队列

**挂起**
* 由于终端请求，或操作系统的要求等原因，导致挂起

那进程状态是怎样定义的？由于进程不是调度单位，不必划分成过细的状态，如 Windows 操作系统中仅把进程分成可运行和不可运行态，挂起状态属于不可运行态。

<br/>

# 线程同步

当使用多个线程来访问同一个数据时，非常容易出现线程安全问题。  
比如，多个线程都在操作同一数据（竞争条件 race condition），导致数据不一致。

此时需要使用同步机制解决：只能让一个线程将所有操作都执行完，且在它执行过程中，其他线程不参与执行。

线程同步前提：
* 必须有两个或两个以上线程运行
* 必须多个线程使用同一个锁
* 优点：解决多线程安全问题
* 缺点：多个线程需要判定锁，耗费资源

线程同步不是永远高枕无忧的，处理不当的话，很容易导致**死锁**问题：
* 两个线程互相等待竞争资源，导致两边都无法得到资源，使自己无法执行
* 或：两个线程均无法达到执行所需条件

此时可以引入**生产者与消费者模型**来解决问题：
1. 生产者仅在仓储未满时生产，仓满则停止生产；
2. 消费者仅在仓储有产品时才能消费，仓空则等待；
3. 当消费者发现仓储无产品可消费，则通知生产者生产；
4. 生产者生产出可消费产品时，应通知等待的消费者消费

<br/>

# 多线程就一定快吗？

<big>**不一定。**</big>

起更多的线程，并不能保证程序最大程度上并发执行；若想要通过多线程让程序执行得更快，则需要面临很多的问题和挑战。  
最大的问题，便是**上下文切换**和线程**创建/销毁**的开销。

支持多线程执行程序的单核 CPU 通过给每个线程分配 CPU 时间片，并且在不同的时间片之间高速切换，以执行不同线程的任务。  
因为切换速度飞快且频繁，让人感觉多个线程好像在同时执行。

但是，多线程编程的**优势**在于：
* 进程间不能共享内存，但线程之间共享内存很容易
* 系统创建线程所分配的资源相对创建进程而言，代价小
