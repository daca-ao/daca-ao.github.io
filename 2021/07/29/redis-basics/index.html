<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在非关系型数据库（NoSQL）中，Redis 绝对是 C 位的存在。今天就开一个帖来专门唠唠 Redis。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 入门">
<meta property="og:url" content="http://example.com/2021/07/29/redis-basics/index.html">
<meta property="og:site_name" content="Raymond&#39;s Cabin">
<meta property="og:description" content="在非关系型数据库（NoSQL）中，Redis 绝对是 C 位的存在。今天就开一个帖来专门唠唠 Redis。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/redis-encoding-embstr.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/redis-encoding-raw.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/redisobj.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/redis-encoding-int.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/hash-encoding-ziplist.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/hash-encoding-hashtable.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/list-encoding-ziplist.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/list-encoding-linkedlist.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/set-encoding-intset.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/set-encoding-hashtable.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/zset-encoding-ziplist.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/zset-encoding-skiplist.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/redis-type-encoding-mapping.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/list-message-queue.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/list-message-queue-model.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/distributed-lock.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/rdb.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/aof.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/write-sync.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/aof-rewrite.png">
<meta property="og:image" content="http://example.com/2021/07/29/redis-basics/redis-cluster.png">
<meta property="article:published_time" content="2021-07-28T16:35:16.000Z">
<meta property="article:modified_time" content="2023-06-20T09:13:34.000Z">
<meta property="article:author" content="敖惠竣｜Ao Huijun, Raymond">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/07/29/redis-basics/redis-encoding-embstr.png">

<link rel="canonical" href="http://example.com/2021/07/29/redis-basics/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Redis 入门 | Raymond's Cabin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Raymond's Cabin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">for sharing thoughts</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/daca-ao" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/29/redis-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="敖惠竣｜Ao Huijun, Raymond">
      <meta itemprop="description" content="Storing blogs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Raymond's Cabin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-29 00:35:16" itemprop="dateCreated datePublished" datetime="2021-07-29T00:35:16+08:00">2021-07-29</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/07/29/redis-basics/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/29/redis-basics/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在非关系型数据库（NoSQL）中，Redis 绝对是 C 位的存在。今天就开一个帖来专门唠唠 Redis。</p>
<span id="more"></span>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis，全称 <strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver。官方解释是“BSD 开源许可的，使用 ANSI C 语言开发的，部署于内存的数据结构（in-memory data structure store）”。<br>Redis 不仅可以用来做内存数据库，还可以做缓存和消息代理。</p>
<p>Redis 支持多种数据结构：</p>
<ul>
<li>字符串 string</li>
<li>列表 list</li>
<li>hash</li>
<li>集合 set</li>
<li>带范围查询的有序集合 sorted set (zset)</li>
<li>位图 bitmap</li>
<li>hyperloglog</li>
</ul>
<p>前五种为基本数据类型，后两种为高级对象。</p>
<p>Redis 具有内置的复制，Lua 脚本，LRU 淘汰策略，事务和不同级别的磁盘持久性，并通过 Redis Sentinel 和 Redis Cluster 的自动分区提供高可用性。</p>
<p>Redis 所有的单个操作都是原子性的（Lua 脚本保证），多个操作支持事务。</p>
<p><br></p>
<h1 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h1><p>先来说说 Redis 里面基本对象的源码：</p>
<h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a><strong>redisObject</strong></h2><ul>
<li>Redis 的对象类型、内部编码、内存回收、共享对象等功能均需其支持</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> {</span></span><br><span class="line">    <span class="comment">// 对象的类型，占 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的内部编码，占 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构（即 val 对应的 SDS）的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">2</span>;  <span class="comment">/* Not used */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="comment">// REDIS_LRU_BITS 在不同版本中的 Redis 的长度也有所不同</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录该对象被引用的次数</span></span><br><span class="line">    <span class="keyword">int</span> refcount; </span><br><span class="line">} robj;</span><br></pre></td></tr></table></figure>
<p>一个 redisObject 占用 <strong>16</strong> 字节的空间。</p>
<p><strong><big>1. type</big></strong></p>
<p>redisObject 一共有 5 种数据类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure></p>
<p>4 位 type 字段最多能排出 15 种组合，记录 5 种数据类型足够。</p>
<p><strong><big>2. encoding</big></strong></p>
<p>redisObject 一共有 10 种编码类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0      <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1      <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2       <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3   <span class="comment">/* Encoded as zipmap, deprecated after v 3.2.5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4  <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5  <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6   <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8    <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_QUICKLIST 9  <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>encoding 常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>SDS</td>
</tr>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型（8 字节长，64 位）的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPMAP</td>
<td>zipmap，3.2.5 后弃用</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双向链表，非循环</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表，访问速度较快</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳表 + 字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的 SDS</td>
</tr>
<tr>
<td>REDIS_ENCODING_QUICKLIST</td>
<td>以压缩列表为元素的双向链表</td>
</tr>
</tbody>
</table>
</div>
<p>4 位 encoding 字段最多能排出 15 种组合，记录 10 种编码类型足够。</p>
<p><br></p>
<p><strong>注</strong>：这里比较一下 <code>REDIS_ENCODING_EMBSTR</code> 和 <code>REDIS_ENCODING_RAW</code>（下面简称 embstr 和 raw）：</p>
<ul>
<li>embstr 与 raw 都使用 redisObject 和 SDS 保存数据</li>
<li>从 Redis 3.0 开始引进 embstr，意为 “embedded string”，使用时只分配一次内存空间（因为 redisObject 和 SDS 空间上连续）<ul>
<li>专门用于存储<strong>短</strong>（不大于 44 字节的）字符串（Redis 3.2 之前是 39）</li>
<li>好处是：创建时少分配一次空间，删除时少释放一次空间；对象所有数据连在一起，创建快速，寻找方便</li>
<li>坏处是：字符串长度增加需要重新分配内存时，整个 redisObject 和 SDS 都需要重新分配空间</li>
<li>因此 embstr 实现是只读，并且没有提供修改值的函数</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/29/redis-basics/redis-encoding-embstr.png" alt></p>
<ul>
<li>raw 需要分别为 redisObject 和 SDS 分配内存空间（调用两次内存分配函数）<ul>
<li>存储大于 44 字节的字符串（Redis 3.2 之前是 39）</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/29/redis-basics/redis-encoding-raw.png" alt></p>
<p><strong><big>3. lru</big></strong></p>
<p>通过对比 lru 的值与当前时间，可计算某个对象的空转时间（object idletime）并打印出来。</p>
<p>lru 与 Redis 内存回收关系颇为密切。<br>如果 Redis 打开了 <code>maxmemory</code> 选项，且内存回收算法选择 <code>volatile-lru</code> 或 <code>allkeys-lru</code> 作为淘汰策略的话，当内存占用超过 maxmemory 阈值时，Redis 会优先选择 object idletime 最长的对象释放。</p>
<p><strong><big>4. refcount</big></strong>：主要用于对象引用计数和内存回收（计数法）</p>
<ul>
<li>创建新对象：refcount = 1</li>
<li>有新程序使用该对象：refcount + 1</li>
<li>对象不再被一个新程序使用：refcount - 1</li>
<li>refcount = 0：对象占用内存会被释放</li>
</ul>
<p>refcount &gt; 1，意味着该对象被多次使用，其被称为共享对象。<br>这就意味着当某些对象重复出现时，新程序不会创建新对象，而是仍然使用原来的对象；这样可以节省内存。</p>
<p>Redis 五种类型都可以使用共享对象，但仅支持整数值的字符串对象，因为这考虑到对内存和 CPU（时间）的平衡：</p>
<ul>
<li>共享对象虽然降低了内存消耗，但判断两个对象是否相等需消耗额外时间</li>
<li>整数值判断操作复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>；普通字符串为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>；列表等为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>Redis 服务器初始化时会创建 10000 个字符串对象：0 - 9999</p>
<ul>
<li>Redis 需要使用值为该范围其中的字符串对象时可直接使用。</li>
</ul>
<p>再说说刚刚提到的 SDS：</p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a><strong>SDS</strong></h2><p>全称 Simple Dynamic String，简单动态字符串，是 Redis 自己开发的字符串抽象类型。</p>
<p>所谓“动态”，意思是 Redis 能根据 redisObject 不同的值去对应上不同的编码，且进行自动扩展。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sds.h（Redis 3.2 之前）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;  <span class="comment">// buf 已使用的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">// buf 未使用长度</span></span><br><span class="line">    <span class="keyword">char</span> buf[];  <span class="comment">// 字节数组，len(buf)=len+free+1</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sds.h（Redis 3.2 之后，关于 SDS 有了多种结构：sdshdr5，sdshdr8，sdshdr16，sdshdr32，sdshdr64）</span></span><br><span class="line"><span class="comment">// sdshdr8：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;  <span class="comment">// 字符数组长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;  <span class="comment">// 字符数组总共分配内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;  <span class="comment">// 标记字符数组属性</span></span><br><span class="line">    <span class="keyword">char</span> buf[];  <span class="comment">// 字符数组，字符串真正的值</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// 相比于 Redis 3.2 之前的 sdshdr 优化了 5 个字节的空间，使 embstr 数据空间多了 5 字节</span></span><br></pre></td></tr></table></figure>
<p>SDS 在 C 字符串基础上加入了 <code>len</code> 和 <code>free</code>（<code>alloc</code>） 字段，是为了杜绝缓冲区溢出（C 字符串在没有进行足够的内存分配时，会存在缓冲区溢出的情况），并且能存储二进制数据；</p>
<p>同时 <code>len</code> 字段降低了原本 C 字符串读取字符长度的复杂度（从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 降为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>）；</p>
<p>另外，SDS 通过<strong>空间预分配</strong>和<strong>惰性空间释放</strong>来解决内存重新分配带来的性能问题：</p>
<ul>
<li>对 SDS 的值进行修改之后，如 SDS 的长度小于 1 M，此时分配的 len = free</li>
<li>如 &gt;= 1 M，就按照 1 M 分配</li>
<li>修改删除部分元素时，不及时释放，还保留空间（len 减少掉的数量加到 free 里）</li>
</ul>
<p>针对 C 字符串只能通过 ‘\0’ 判断字符串结束，且不能存储空字符串的特性，SDS 通过 len 字段判定结尾，且能够存储任意数据。</p>
<p>这也是 Redis 使用自己开发的字符串的原因。</p>
<p><br></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis 作为 NoSQL 类型的内存数据库，在内存中主要以键值对（key-value）的方式存储内容：</p>
<p><img src="/2021/07/29/redis-basics/redisobj.png" alt></p>
<p>其中“值”（value）的类型有：</p>
<p><strong><big>String</big></strong></p>
<ul>
<li>Redis 最基本的数据类型，扩展性非常高</li>
<li>上面已经提到过了：底层为字符数组，长度不超过 512 MB</li>
<li>Redis K-V 中的 key 只能为 String 类型</li>
<li>该类型二进制安全，可以包含任何数据，如 jpg 图像或者序列化的对象</li>
</ul>
<p>String 最简单的编码：</p>
<p><img src="/2021/07/29/redis-basics/redis-encoding-int.png" alt></p>
<p>String 编码转换：</p>
<ul>
<li>当 int 数据不再是整数，或大小超过 long 范围时，String 自动转为 raw 编码方式</li>
<li>因 embstr 的实现是只读：修改 String 的值时，要先将 embstr 转化为 raw，再进行修改</li>
</ul>
<p>String 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>set key value</td>
<td>将对应 key 赋值为 value</td>
</tr>
<tr>
<td>get key</td>
<td>获取 key 对应的 value 值</td>
</tr>
<tr>
<td>del key</td>
<td>删除 key</td>
</tr>
<tr>
<td>expire key seconds</td>
<td>设置 key 在 seconds 秒后过期</td>
</tr>
<tr>
<td>expireat key timestamp</td>
<td>设置 key 的超时时间至某个时间戳</td>
</tr>
<tr>
<td>setex key timeout value</td>
<td>如果 key 存在，则将值更新为 value，过期时间为 timeout 秒</td>
</tr>
<tr>
<td>ttl key</td>
<td>查看 key 还有多久过期</td>
</tr>
<tr>
<td>setnx key value</td>
<td>如果 key 不存在，就新增 key 和 value</td>
</tr>
<tr>
<td>strlen key</td>
<td>计算 key 对应 value 的长度</td>
</tr>
<tr>
<td>incr key</td>
<td>如果 key 对应的 value 值为 int 类型，则自增 1；否则报错</td>
</tr>
<tr>
<td>incrby key numbers</td>
<td>如果 key 对应的 value 值为 int 类型，则增加对应的值；否则报错</td>
</tr>
<tr>
<td>mset key1 value1 key2 value2 …</td>
<td>批量添加</td>
</tr>
<tr>
<td>mget key1 key2 key3 …</td>
<td>批量获取</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong><big>Hash</big></strong></p>
<ul>
<li>键值对（key-value）集合</li>
<li>本质为 String 类型的 field 和 value 的映射表</li>
<li>指令以 h 开头</li>
</ul>
<p>Hash 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset key name value</td>
<td>添加键值对 name、value 到 key 中</td>
</tr>
<tr>
<td>hget key name</td>
<td>查看键为 name 的 value 值</td>
</tr>
<tr>
<td>hmset key name1 value1 name2 value2</td>
<td>往 key 批量添加键值对</td>
</tr>
<tr>
<td>hmget key name1 name2</td>
<td>从 key 中批量获取值</td>
</tr>
<tr>
<td>hlen key</td>
<td>获取 key 的键值对数目</td>
</tr>
<tr>
<td>hgetall key</td>
<td>获取 key 中所有元素，包括键和值</td>
</tr>
</tbody>
</table>
</div>
<p>Hash 的编码：</p>
<p><img src="/2021/07/29/redis-basics/hash-encoding-ziplist.png" alt></p>
<p>ziplist 编码特点：如上，所有数据内存上连续，以实现快速访问。</p>
<p><img src="/2021/07/29/redis-basics/hash-encoding-hashtable.png" alt></p>
<p>当 hash 中键值对数量少于 512 个，且 key 和 value 的长度都小于某个字节长度阈值时，hash 采用 ziplist 编码，否则采用 hashtable 编码。</p>
<p><br></p>
<p><strong><big>List</big></strong></p>
<ul>
<li>简单的 String 列表，按照插入顺序排序</li>
<li>可添加至列表头（左）或尾（右）</li>
<li>相关操作指令以 l 开头</li>
</ul>
<p>List 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>lpush key value1 value2</td>
<td>往 key 的左侧插入 value1、value2 …</td>
</tr>
<tr>
<td>rpush key value1 value2</td>
<td>往 key 的右侧插入 value1、value2 …</td>
</tr>
<tr>
<td>lpop key</td>
<td>从 key 的左侧弹出元素</td>
</tr>
<tr>
<td>rpop key</td>
<td>从 key 的右侧弹出元素</td>
</tr>
<tr>
<td>llen key</td>
<td>查看 key 的长度（元素个数）</td>
</tr>
<tr>
<td>lindex key index</td>
<td>查看列表 key 中某个 index 对应的值</td>
</tr>
<tr>
<td>lrange key startIndex endIndex</td>
<td>查看指定范围内元素，下标从 0 开始</td>
</tr>
<tr>
<td>ltrim key startIndex endIndex</td>
<td>保留指定范围内元素，删除其他元素；下标从 0 开始</td>
</tr>
</tbody>
</table>
</div>
<p>List 的编码：</p>
<p><img src="/2021/07/29/redis-basics/list-encoding-ziplist.png" alt></p>
<p>在 Redis 3.2 之后，List 使用 quicklist 替换了原来的 ziplist；quicklist 的底层使用的还是 ziplist 的实现。</p>
<p><img src="/2021/07/29/redis-basics/list-encoding-linkedlist.png" alt></p>
<p><br></p>
<p><strong><big>Set</big></strong></p>
<ul>
<li>元素为 String 的无序不重复集合，通过哈希表实现</li>
<li>保存数字的时候是有序的</li>
<li>相关操作指令以 s 开头</li>
</ul>
<p>Set 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd key value1 value2</td>
<td>往集合 key 中添加元素 value1、value2 …</td>
</tr>
<tr>
<td>smembers key</td>
<td>查看集合 key 中的所有元素</td>
</tr>
<tr>
<td>sismember key value</td>
<td>查看 value 是否在集合 key 中</td>
</tr>
<tr>
<td>scard key</td>
<td>查询集合 key 的长度</td>
</tr>
<tr>
<td>spop key</td>
<td>取出集合 key 的一个元素</td>
</tr>
<tr>
<td>del key</td>
<td>删除集合 key</td>
</tr>
</tbody>
</table>
</div>
<p>Set 的编码：</p>
<p><img src="/2021/07/29/redis-basics/set-encoding-intset.png" alt></p>
<p>存入不多于 512 个纯整数时，Set 采用 intset 编码；否则均采用 hashtable 编码。</p>
<p><img src="/2021/07/29/redis-basics/set-encoding-hashtable.png" alt></p>
<p>Set 中的每个元素为 dictEntry 的 key，value 值为空。</p>
<p><br></p>
<p><strong><big>zset</big></strong>（Sorted Set）</p>
<ul>
<li>String 有序不重复集合，与 Set 类似</li>
<li>每个元素关联一个 double 类型的权重（score），Redis 根据权重从小到大排序</li>
<li>相关操作指令以 z 开头</li>
</ul>
<p>zset 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>zadd key score1 value1 score2 value2</td>
<td>添加元素至集合 key 中；如果 value 相同，后输入的 score 会覆盖前面的 score</td>
</tr>
<tr>
<td>zscore key value</td>
<td>查看 value 的 score 值，输出 -∞ &lt; score &lt; +∞ 的所有元素</td>
</tr>
<tr>
<td>zrange key 0 -1</td>
<td>正序输出</td>
</tr>
<tr>
<td>zrangebyscore key -inf +inf</td>
<td>正序输出</td>
</tr>
<tr>
<td>zrevrange key 0 -1</td>
<td>倒序输出</td>
</tr>
<tr>
<td>zcard key</td>
<td>查看集合 key 的元素个数</td>
</tr>
<tr>
<td>zrangebyscore key indexStart indexEnd</td>
<td>输出集合 key 中 indexStart &lt;= score &lt;= indexEnd 的元素，正序排列</td>
</tr>
<tr>
<td>zrevrangebyscore key indexStart indexEnd</td>
<td>输出集合 key 中 indexStart &lt;= score &lt;= indexEnd 的元素，倒序排列</td>
</tr>
<tr>
<td>zrem key value</td>
<td>删除集合 key 中的 value</td>
</tr>
</tbody>
</table>
</div>
<p>zset 的编码：</p>
<p><img src="/2021/07/29/redis-basics/zset-encoding-ziplist.png" alt></p>
<p>ZIPLIST 会按照 score 的大小排序。</p>
<p>当数据量增大时，zset 会调整到跳表（skiplist）的编码模式：</p>
<p><img src="/2021/07/29/redis-basics/zset-encoding-skiplist.png" alt></p>
<p>为啥每种对象类型都有至少两种编码？</p>
<ol>
<li>接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响</li>
<li>可根据不同应用场景切换内部编码，提高效率</li>
</ol>
<p><img src="/2021/07/29/redis-basics/redis-type-encoding-mapping.png" alt></p>
<p>小结：</p>
<table>
    <tr>
        <th>类型</th>
        <th>编码（Redis 3.0）</th>
        <th>简介</th>
        <th>应用场景</th>
    </tr>
    <tr>
        <th rowspan="3">String (REDIS_STRING)</th>
        <td>REDIS_ENCODING_INT</td>
        <td>使用整数值实现的字符串对象</td>
        <td rowspan="3"></td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_EMBSTR</td>
        <td>使用 embstr 编码的 SDS 实现的字符串对象</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_RAW</td>
        <td>使用 SDS 实现的字符串对象</td>
    </tr>
    <tr>
        <th rowspan="2">Hash (REDIS_HASH)</th>
        <td>REDIS_ENCODING_ZIPLIST</td>
        <td>使用压缩列表实现的 hash 对象</td>
        <td rowspan="2">存储、读取、修改用户属性</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_HT</td>
        <td>使用字典实现的 hash 对象</td>
    </tr>
    <tr>
        <th rowspan="2">List (REDIS_LIST)</th>
        <td>REDIS_ENCODING_ZIPLIST</td>
        <td>使用压缩列表实现的列表对象</td>
        <td rowspan="2">最新消息排行；消息队列等功能</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_LINKEDLIST</td>
        <td>使用双向链表实现的列表对象</td>
    </tr>
    <tr>
        <th rowspan="2">Set (REDIS_SET)</th>
        <td>REDIS_ENCODING_INTSET</td>
        <td>使用整数集合实现的集合对象</td>
        <td rowspan="2">共同好友<br>点赞系统（不能重复点赞）<br>利用唯一性统计访问网站的所有独立 IP<br>好友推荐：根据 tag 求交集</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_HT</td>
        <td>使用字典实现的集合对象</td>
    </tr>
    <tr>
        <th rowspan="2">Sorted Set (REDIS_ZSET)</th>
        <td>REDIS_ENCODING_ZIPLIST</td>
        <td>使用压缩列表实现的有序集合对象</td>
        <td rowspan="2">排行榜<br>带权重的消息队列</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_SKIPLIST</td>
        <td>使用跳表和字典实现的有序集合对象</td>
    </tr>
</table>

<p>编码转换在 Redis 写入数据时完成，而且转换过程是不可逆的，只能从小内存编码向大内存编码转换。</p>
<p><br></p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>通过 <code>info memory</code> 来看 Redis 的内存统计：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; info memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:199960008</span><br><span class="line">used_memory_human:190.70M</span><br><span class="line">used_memory_rss:213798912</span><br><span class="line">used_memory_peak:201290832</span><br><span class="line">used_memory_peak_human:191.97M</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">mem_fragmentation_ratio:1.07</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br></pre></td></tr></table></figure>
<p>内存统计中各字段的含义：</p>
<p><code>used_memory</code>：Redis 内存分配器分配的内存总量（Byte），包括使用的虚拟内存（swap）。</p>
<p><code>used_memory_human</code>：used_memory 更友好的显示方式。</p>
<p><code>used_memory_rss</code>：Redis 进程占据操作系统的内存（Byte），与 top 和 ps 命令看到的值是一样的，包括：</p>
<ul>
<li>Redis 内存分配器分配的内存</li>
<li>Redis 进程运行本身需要的内存</li>
<li>内存碎片</li>
<li>…</li>
</ul>
<p>但并不包括虚拟内存。</p>
<p>注：<code>used_memory</code> 是从 Redis 得到的数量，而 <code>used_memory_rss</code> 则是从操作系统角度得到的量。两者的值不一样，是因为：</p>
<ol>
<li>Redis 进程运行需要占用内存，且存在着内存碎片的时候：前者会比后者小</li>
<li>当存在虚拟内存：前者会比后者大</li>
</ol>
<p><code>mem_fragmentation_ratio</code>：内存碎片比率，等于 used_memory_rss / used_memory。</p>
<ul>
<li>数值一般大于 1，1.03 为比较健康的状态；比率越大，内存碎片的占比就越大</li>
<li>数值小于 1，说明 Redis 使用了虚拟内存：要及时排查</li>
<li>在实际应用中，当 Redis 的数据量比较大时，进程运行所占用的内存与 Redis 数据量和内存碎片相比会小很多。</li>
</ul>
<p><code>mem_allocator</code>：定义 Redis 使用的内存分配器，在编译时指定</p>
<ul>
<li>可以是 libc, jemalloc 或 tcmalloc，默认使用 jemalloc</li>
</ul>
<p>以 jemalloc 为例：将内存空间划分为小、大、巨大三个范围，每个范围内划分许多小的内存块单位：</p>
<table>
    <tr>
        <th>Category</th>
        <th>Spacing</th>
        <th>Size</th>
    </tr>
    <tr>
        <th rowspan="7">Small</th>
        <td>8</td>
        <td>[8]</td>
    </tr>
    <tr>
        <td>16</td>
        <td>[16, 32, 48, ..., 128]</td>
    </tr>
    <tr>
        <td>32</td>
        <td>[160, 192, 224, 256]</td>
    </tr>
    <tr>
        <td>64</td>
        <td>[320, 384, 448, 512]</td>
    </tr>
    <tr>
        <td>128</td>
        <td>[640, 768, 896, 1024]</td>
    </tr>
    <tr>
        <td>256</td>
        <td>[1280, 1536, 1792, 2048]</td>
    </tr>
    <tr>
        <td>512</td>
        <td>[2560, 3072, 3584]</td>
    </tr>
    <tr>
        <th>Large</th>
        <td>4 KiB</td>
        <td>[4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB]</td>
    </tr>
    <tr>
        <th>Huge</th>
        <td>4 MiB</td>
        <td>[4 MiB, 8 MiB, 12 MiB, ...]</td>
    </tr>
</table>

<p><br></p>
<p>综上，Redis 的内存占用主要有以下部分：</p>
<p><strong>1. 数据</strong></p>
<ul>
<li>最主要的部分，其占用的内存被统计在 used_memory 中</li>
<li>每种数据类型可能有两种或更多的内部编码实现</li>
<li>存储数据对象时，并不是直接将数据扔进内存，而是对对象进行各种包装：如 redisObject、SDS 等</li>
</ul>
<p><strong>2. 进程本身运行需要的内存</strong></p>
<ul>
<li>包括代码、常量池等内容，不由 jemalloc 去分配，因此不会统计在 used_memory 中</li>
<li>在大多数场景中，这部分的内存占用可忽略</li>
<li>除主进程外，Redis 创建的子进程（如执行 AOF、RDB 重写时创建的子进程）也会占用内存：<ul>
<li>这部分内存并不属于 Redis 进程，因此不会统计在 used_memory 和 used_memory_rss 中</li>
</ul>
</li>
</ul>
<p><strong>3. 缓冲内存</strong>，包括：</p>
<ul>
<li>客户端缓冲区：存储客户端连接的输入输出缓冲</li>
<li>复制积压缓冲区：用于部分复制功能</li>
<li>AOF 缓冲区：在进行 AOF 重写时，保存最近的写入命令</li>
<li>…</li>
</ul>
<p><strong>4. 内存碎片</strong>：Redis 分配、回收物理内存过程中产生的。</p>
<p>产生的原因：<br>比如：对内存中的数据更改频繁，且数据之间的大小相差很大，会导致 Redis 释放的空间在物理内存中并没有释放，但 Redis 又无法有效利用这些物理内存。由此便会产生内存碎片。</p>
<p>内存碎片的产生，和对数据进行的操作、数据的特点等有关；也和使用的内存分配器有关。</p>
<ul>
<li>如内存分配器设计合理，可以尽可能减少内存碎片产生</li>
<li>如内存碎片很大，可以通过安全重启减小内存碎片：重启后 Redis 重新从备份文件中读取数据，在内存中进行重排</li>
</ul>
<p>内存碎片不会被统计在 used_memory 中。</p>
<h2 id="数据存储的细节"><a href="#数据存储的细节" class="headerlink" title="数据存储的细节"></a>数据存储的细节</h2><p><code>dictEntry</code> 对应的是 Redis 的每个键值对，存储着指向 key 和 val 的指针；<br>其中 val 的数据结构是一个联合体（union）。<br>另外，每一个 dictEntry 都有一个 next 指针指向下一个 dictEntry。</p>
<p>例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> hello world</span><br></pre></td></tr></table></figure></p>
<ul>
<li>key 为 “hello”：存储于 SDS 中</li>
<li>val 为 “world”：存储于 redisObject 中<ul>
<li>字符串对象 “world” 存储于 SDS</li>
<li><code>type</code>：指明 val 对象的类型；因为指令是 set，所以对应类型为 REDIS_STRING</li>
<li><code>ptr</code>：指向字符串对象所在地址</li>
</ul>
</li>
<li>Redis 的内存分配器分配内存：dictEntry 有三个指针，占用 24 字节，分配器就会分配 32 字节。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>当 Redis 内存不足的时候，服务有可能限制缓存写入，且淘汰策略开始起作用，可能导致 key 频繁被逐出、响应时间上升、QPS 不稳定等问题，影响业务的运行。</p>
<p>Redis 的 <code>MEMORY DOCTER</code> 指令会提供内存诊断提议。</p>
<p>同时可以优化内存的使用率：</p>
<ol>
<li>查询现有 key 是否符合业务预期，及时清理无用的 key；</li>
<li>分析大 key 分布和 TTL 过期策略；</li>
<li>从业务方向对大 key 进行拆分；</li>
<li>根据业务，设置合理的数据驱逐策略和过期 key 的删除频率；</li>
<li>升级内存</li>
</ol>
<p><br></p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>最大的优点：<big><strong>快</strong></big></p>
<p>Redis 是单进程单线程的模型，对于数据的操作完全基于内存，因此 CPU 不是瓶颈；而且单线程容易实现。</p>
<p>为何 Redis 是单线程模型，处理起来还仍然这么快？</p>
<ul>
<li>数据结构简单，对数据的操作也简单</li>
<li>数据存储类似于 HashMap：查找和操作的时间复杂度是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
<li>采用单线程，避免不必要的上下文切换和竞争条件</li>
<li>使用非阻塞 IO</li>
</ul>
<p><br></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Redis 最大的用途就是缓存系统。而缓存系统需要关注以下三个问题：</p>
<ul>
<li>缓存击穿（失效）</li>
<li>缓存穿透</li>
<li>缓存雪崩</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>指的是流量访问数据的地点应该是缓存系统，然而缓存系统中的<strong>某些缓存数据失效</strong>（过期），导致缓存系统被“击穿”，流量直接打到数据库访问数据。</p>
<p>此时数据库可能因为高并发导致反应缓慢，甚至不可用。</p>
<p>解决方案：</p>
<ul>
<li>对于某些缓存数据，如热点数据，不设置过期时间，或者给过期时间添加随机值，避免大量缓存数据集中在一个时间点过期，给数据库造成压力；</li>
<li>预热：预先将重要缓存数据保存到 Redis 中；</li>
<li>锁：缓存失效时先获取分布式锁，获取成功后才执行数据库操作</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>比击穿还彻底：请求缓存和数据库<strong>均不存在</strong>的数据。这样的并发请求会很大程度上影响数据库运行。</p>
<p>解决方案：</p>
<ul>
<li>缓存空值</li>
<li>BloomFilter 布隆过滤器：在数据写入数据库的同时，将 id 同步到布隆过滤器中；当请求的 id 不存在于布隆过滤器里面，则说明该请求查询的数据一定没有在数据库中保存，就不要去数据库查询了。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是大量的请求无法在缓存系统中处理，从而请求全部打到数据库，导致数据库压力激增，甚至宕机。</p>
<p>原因主要有两种：</p>
<ul>
<li>大量缓存同时过期，导致大量请求需要查询数据库并写到缓存；</li>
<li>缓存服务出现异常导致故障宕机。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>对于某些缓存数据，如热点数据，不设置过期时间，或者给过期时间添加随机值，避免大量缓存数据集中在一个时间点过期，给数据库造成压力；</li>
<li>接口限流：在业务系统的请求入口控制单位时间请求数，避免过多的请求被发送到数据库；</li>
<li>对缓存服务采取服务熔断和接口限流措施；有必要时构建高可用缓存集群系统</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>可以使用 list 实现消息队列。基本操作与模型的对应如下：</p>
<p><img src="/2021/07/29/redis-basics/list-message-queue.png" alt></p>
<p>基于主流配置，结合生产者与消费者的模型如下：</p>
<p><img src="/2021/07/29/redis-basics/list-message-queue-model.png" alt></p>
<p>可以使用 <code>blpop</code> 或 <code>brpop</code> （<code>b</code> 表示阻塞 blocking）实现“拉”的消息获取。</p>
<ul>
<li>不过，因为操作会一直阻塞 list，Redis 监测到一段时间 list 没有消息，会抛出异常，令 MQ 终止。</li>
<li>因此实现消息队列时需要捕获这种异常并加以处理（重建队列，…）</li>
</ul>
<p>如果要实现延时队列的话，需要将模型改为 <code>zset</code>，给某一个时段进入的消息赋予一定的 score，然后通过对应操作（如 <code>zrangebyscore</code>）获取消息。</p>
<p>因为市面上成熟的 AMQP 产品很多，同时 MySQL 也有消息队列功能提供，一般不会使用 Redis 来做消息队列。</p>
<p><br></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>应用中如有多个服务对同一数据进行操作，JVM 的锁机制并不能满足，只能通过分布式锁解决。<br>如下图中的场景，服务 A 和服务 B 中的 JVM 锁就不能相互对对方起约束作用：</p>
<p><img src="/2021/07/29/redis-basics/distributed-lock.png" alt></p>
<p>概述：</p>
<ul>
<li>加锁操作：<code>setnx</code> + 过期时间 -&gt; <code>set key value ex timeout nx</code></li>
<li>解锁：<code>del key</code>，原子性操作</li>
</ul>
<p>实现要点：</p>
<ol>
<li>加锁和解锁的 key 一定要一致，要不然无法解锁，再多的 <code>setnx</code> 指令都是白费。</li>
<li>不能永久加锁，一定要加上过期时间；越来越多永久的锁存在于内存中，系统会受不了的。</li>
<li>一定要保证加锁和设置过期时间的<strong>原子性</strong>。</li>
</ol>
<p>有必要的话，分布式锁要支持过期<strong>续租</strong>（协程实现 watchdog） / <strong>可重入</strong>分布式锁（Redisson 客户端，原理与 ReentrantLock 类似）。</p>
<h3 id="雷区"><a href="#雷区" class="headerlink" title="雷区"></a>雷区</h3><p><strong>1. 锁过期</strong>：获得锁的线程因为各种原因还没操作完，锁就过期释放了。</p>
<p>解决方法：根据业务设定合适的加锁时间。</p>
<p><strong>2. 重叠解锁</strong>：基于锁过期引发的另一个严重问题</p>
<ul>
<li>甲线程在获得锁之后，在未执行完任务的情况下锁就过期了；</li>
<li>此时乙线程拿到锁并执行任务，在其未执行完毕的时候，甲执行完毕，并进行解锁操作；</li>
<li>因为甲线程所加的锁早已过期，此时甲线程的解锁操作解掉的是<strong>乙线程获得的锁</strong>，此时锁又被释放；</li>
<li>以此类推，当丙线程进来了，获得锁但未执行完任务，乙线程执行完毕并解锁的时候，解掉的是丙线程加的锁；以此反复，就会出现很大的问题。</li>
</ul>
<p>解决方法：加锁（set 操作）的时候，value 带上<strong>唯一标识</strong>（如线程 ID），就会避免解错锁的情况。</p>
<p><strong>3. 单点问题</strong></p>
<p>在 Redis <strong>集群环境</strong>中，甲线程获得锁之后，将信息保存到主节点；<br>在信息同步至从节点的过程中，主节点挂掉了（……）；从节点会升级为主节点，但是它并没有保存到甲线程获取到锁的信息，导致锁会被其它线程获取到。</p>
<p>解决方法：<strong>Redlock</strong> 算法</p>
<p><br></p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 最大的弊端在于其是内存数据库，万一宕机，数据就没有了。因此 Redis 需要持久化，以便服务重新启动时能恢复数据。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>全称 <strong>R</strong>edis <strong>D</strong>ata<strong>B</strong>ase，将当前进程数据生成快照保存到硬盘。支持手工执行和服务器定时执行。</p>
<p>分两种命令：</p>
<p>SAVE：阻塞当前 Redis 服务器，直到 RDB 过程完成。</p>
<ul>
<li>对于内存比较大的实例会造成长时间的阻塞</li>
<li>已被逐渐废弃，线上环境不建议使用</li>
</ul>
<p>BGSAVE (<strong>B</strong>ack<strong>G</strong>round <strong>SAVE</strong>)</p>
<ul>
<li>Redis 进程执行 fork 操作创建子进程，由该子进程负责 RDB 的持久化，完成后自动结束</li>
<li>由此可知，定时执行初始化使用的就是 BGSAVE</li>
<li>阻塞只发生在 fork 阶段，只占很短的一段时间</li>
<li>系统的条件检测器 Server Cron 每 <strong>100ms</strong> 进行一次条件检测，满足备份条件才会创建子进程执行持久化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
<p>相关的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> {</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// save point 数组，下面会介绍</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span>  <span class="comment">/* Save points array for RDB */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计数器。记录上一次成功执行 SAVE 或 BGSAVE 后，数据进行了多少次修改（写入、删除、更新等）</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> dirty;  <span class="comment">/* Changes to DB from the last save */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 例：</span></span><br><span class="line">	<span class="comment">// set key "value": dirty 计数器加 1</span></span><br><span class="line">	<span class="comment">// sadd key "value1" "value2" "value3": dirty 计数器加 3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录上一次成功执行 SAVE 或 BGSAVE 的时间</span></span><br><span class="line">	<span class="keyword">time_t</span> lastsave;  <span class="comment">/* Unix time of last successful save */</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> {</span>  <span class="comment">// 能否执行定时操作的标准</span></span><br><span class="line">	<span class="comment">// 执行时长</span></span><br><span class="line">	<span class="keyword">time_t</span> seconds;</span><br><span class="line">	<span class="comment">// 修改次数</span></span><br><span class="line">	<span class="keyword">int</span> changes;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>saveparam</code> 相当于 redisServer 的配置项。意思是：在 seconds 时间内执行了 changes 次修改之后，服务器会定时执行 BGSAVE 操作进行持久化。</p>
<p>以当前时间戳减去 lastsave，结果如果大于 seconds，即满足持久化条件；以 dirty 值与 changes 比较，如果比 changes 大即满足持久化条件。</p>
<p><img src="/2021/07/29/redis-basics/rdb.png" alt></p>
<p>当 RDB 文件比较大时，Redis 服务启动的时候需要耗费较多的时间。</p>
<p><br></p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>全称 <strong>A</strong>ppend <strong>O</strong>nly <strong>F</strong>ile。通过记录<strong>所有执行过的 redis 命令</strong>来记录数据库的变更。<br>命令被执行之后并没有马上结束，而是继续由 Redis 服务器将命令保存至 AOF 文件中。</p>
<p>AOF 频率比 RDB 高；如果开启了 AOF 开关，服务器启动时会先执行 AOF 加载 AOF 文件，否则会执行 RDB。</p>
<p>相关的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> {</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲区，以请求协议格式保存每一个被执行完的写命令的地方</span></span><br><span class="line">	sds aof_buf  <span class="comment">/* AOF buffer, written before entering the event loop */</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/29/redis-basics/aof.png" alt></p>
<p>多提一嘴：其实真正的写入文件，是包括写入和同步的：</p>
<p><img src="/2021/07/29/redis-basics/write-sync.png" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 开关</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span>  <span class="comment"># 文件名</span></span><br></pre></td></tr></table></figure>
<p>比较一下这三种写入策略：</p>
<p><code>appendfsync always</code>：将 aof_buf 的内容写入并同步到 AOF 文件中，真正地将指令写入了磁盘</p>
<ul>
<li>优点：能够保证基本数据不丢失</li>
<li>缺点：效率低，给磁盘带来的压力很大</li>
</ul>
<p><code>appendfsync everysec</code>：将 aof_buf 的内容先行写入 AOF 文件中；若上次同步时间距今超过 1 秒，则进行 AOF 同步</p>
<ul>
<li>默认设置</li>
</ul>
<p><code>appendfsync no</code>：将 aof_buf 的内容先行写入 AOF 文件中，但不同步 AOF 文件；何时同步由操作系统决定。</p>
<p>由此显而易见，AOF 的<strong>缺陷</strong>是：文件会增长。<br>不仅会占用大量的空间，还会拖慢 Redis 服务启动时数据的加载速度。</p>
<p>打个比方，一顿操作之后，最后的数据结构里只有两个元素，AOF 却可能记录了上百条执行过的命令，当中有大部分大概率是浪费的。</p>
<h3 id="改进：AOF-重写"><a href="#改进：AOF-重写" class="headerlink" title="改进：AOF 重写"></a>改进：AOF 重写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  <span class="comment"># 比上一次 AOF 重写后体量超过了 100%</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb  <span class="comment"># AOF 文件超过 64 MB</span></span><br><span class="line"><span class="comment"># 两个指令是 且 的关系，同时满足才触发 AOF</span></span><br></pre></td></tr></table></figure>
<p>每执行一次重写，会有大量的写入操作，如果让主线程去干这个事的话，主线程会被长时间阻塞；<br>因此解决的办法是：Redis fork 一个子进程去做这个事情。</p>
<p>但是这又会带来另一个问题：主进程一直在接收新指令，子进程发起重写时，重写数据会与数据库数据不一致。<br>针对数据不一致的情况，Redis 服务器设置了一个 AOF 缓冲区：</p>
<ul>
<li>Redis 接收一个指令的时候，除了执行处理之外，还会将它放在 AOF 缓冲区和 AOF <strong>重写缓冲区</strong>；</li>
<li>子进程重写完毕后，会通知回主进程，随后主进程阻塞，将 AOF 重写缓冲区的内容 append 到 AOF 文件中。</li>
</ul>
<p><img src="/2021/07/29/redis-basics/aof-rewrite.png" alt></p>
<p>由上图可知，基于重写的 AOF，每次重写的<strong>不是旧的 AOF 文件</strong>，而是基于 DB 数据创建新的文件。</p>
<p><br></p>
<h1 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h1><p>我们可以将数据分隔到多个 Redis 实例，每个实例只保存所有 key 的一个子集。</p>
<p>优势：</p>
<ul>
<li>通过利用多台计算机内存构造更大数据库，扩展计算能力</li>
</ul>
<p>不足：</p>
<ul>
<li>涉及多个 key 的操作通常不被支持</li>
<li>处理多个持久化文件</li>
</ul>
<p>分区策略：</p>
<ul>
<li>按照范围分区</li>
<li>按照 hash 分区</li>
</ul>
<p><br></p>
<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p><img src="/2021/07/29/redis-basics/redis-cluster.png" alt></p>
<p>master 支持数据的更新和修改，slave 只支持数据的查看。</p>
<p>同时，Redis 的主从切换，需要 Redis Sentinel 的支持。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/28/db-index/" rel="prev" title="数据库索引">
      <i class="fa fa-chevron-left"></i> 数据库索引
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/31/rpc/" rel="next" title="远程过程调用 RPC">
      远程过程调用 RPC <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">基本对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redisObject"><span class="nav-number">2.1.</span> <span class="nav-text">redisObject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDS"><span class="nav-number">2.2.</span> <span class="nav-text">SDS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">4.1.</span> <span class="nav-text">数据存储的细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">内存管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">6.1.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">6.1.1.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">6.1.2.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">6.1.3.</span> <span class="nav-text">缓存雪崩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">6.2.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">6.3.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B7%E5%8C%BA"><span class="nav-number">6.3.1.</span> <span class="nav-text">雷区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">7.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB"><span class="nav-number">7.1.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF"><span class="nav-number">7.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%EF%BC%9AAOF-%E9%87%8D%E5%86%99"><span class="nav-number">7.2.1.</span> <span class="nav-text">改进：AOF 重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="nav-number">8.</span> <span class="nav-text">数据分区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="nav-number">9.</span> <span class="nav-text">集群搭建</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">敖惠竣｜Ao Huijun, Raymond</p>
  <div class="site-description" itemprop="description">Storing blogs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/daca-ao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;daca-ao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/realkaije" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;realkaije" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/daca.aohuijun" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;daca.aohuijun" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/kaijesugardaddy" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;kaijesugardaddy" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">敖惠竣｜Ao Huijun, Raymond</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '9n2JksXJIAbLuQLoQsidfSPv-gzGzoHsz',
      appKey     : '3SHtsSspw7BYJU2g0uU1SASG',
      placeholder: "请在此输入您的留言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
