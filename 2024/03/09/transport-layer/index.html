<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="传输层负责在会话进程之间建立和维护端到端的连接，实现网络环境中分布式进程通信。">
<meta property="og:type" content="article">
<meta property="og:title" content="传输层">
<meta property="og:url" content="http://example.com/2024/03/09/transport-layer/index.html">
<meta property="og:site_name" content="Raymond&#39;s Cabin">
<meta property="og:description" content="传输层负责在会话进程之间建立和维护端到端的连接，实现网络环境中分布式进程通信。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/transport-layer.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/transport-entity.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/tpdu.jpg">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/tpdu-transmit.gif">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/udp-structure.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/udp-transmit.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/udp-header.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/pseudo-header.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/tcp-header.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/3-shake-hands.png">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/tcp-state-diagram.jpg">
<meta property="og:image" content="http://example.com/2024/03/09/transport-layer/sliding-window.png">
<meta property="article:published_time" content="2024-03-09T15:53:04.000Z">
<meta property="article:modified_time" content="2024-05-07T14:05:37.223Z">
<meta property="article:author" content="敖惠竣｜Ao Huijun, Raymond">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="UDP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/03/09/transport-layer/transport-layer.png">

<link rel="canonical" href="http://example.com/2024/03/09/transport-layer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>传输层 | Raymond's Cabin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Raymond's Cabin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">for sharing thoughts</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/daca-ao" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/09/transport-layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="敖惠竣｜Ao Huijun, Raymond">
      <meta itemprop="description" content="Storing blogs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Raymond's Cabin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          传输层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-03-09 23:53:04" itemprop="dateCreated datePublished" datetime="2024-03-09T23:53:04+08:00">2024-03-09</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>传输层负责在会话进程之间建立和维护端到端的连接，实现网络环境中分布式进程通信。</p>
<span id="more"></span>
<h1 id="传输层与传输层协议"><a href="#传输层与传输层协议" class="headerlink" title="传输层与传输层协议"></a>传输层与传输层协议</h1><p>计算机网络的本质，就是要<strong>实现分布在不同地理位置的主机之间的进程（应用程序）通信，并以此为基础，实现应用层的各种网络服务功能</strong>。</p>
<p><img src="/2024/03/09/transport-layer/transport-layer.png" alt></p>
<p>而 OSI（或者是 TCP/IP）协议模型中的<strong>传输层</strong>实现了<strong>分布式</strong>进程通信，是实现各种网络应用的基础：</p>
<ul>
<li>传输层利用网络层所提供的服务（IP 分组数据传输 + “点 - 点”链路传输路径），在源主机的应用进程与目的主机的应用进程之间建立“端 - 端”连接，实现分布式进程通信；</li>
<li>同时传输层会对 IP 分组丢失、线路故障进行检测；并采取相应的差错控制措施，满足分布式进程通信对服务质量（QoS）的要求；</li>
<li>另外，传输层能够屏蔽传输网实现技术的差异性，弥补网络层提供服务的不足。</li>
</ul>
<h2 id="传输实体"><a href="#传输实体" class="headerlink" title="传输实体"></a>传输实体</h2><p>传输层中实现传输层协议的实体如下：</p>
<p><img src="/2024/03/09/transport-layer/transport-entity.png" alt></p>
<p>图中的<strong>传输协议数据单元</strong>（Transport Protocol Data Unit, <strong>TPDU</strong>），就是传输层之间（不同传输实体）所传输的报文：</p>
<p><img src="/2024/03/09/transport-layer/tpdu.jpg" alt></p>
<p>如上：</p>
<ul>
<li>TPDU 的有效载荷（<strong>payload</strong>）是来自于应用层的数据；</li>
<li>传输层在 TPDU payload 前加上 TPDU 头，便组成了 TPDU；</li>
<li>TPDU 在往下传递过程中，加上 IP 分组头组成 IP 分组，加上帧头、帧尾组成帧，等</li>
</ul>
<p><img src="/2024/03/09/transport-layer/tpdu-transmit.gif" alt></p>
<p>传输层的协议一般有两个，也是最常用的两个：<strong>UDP</strong> 和 <strong>TCP</strong>。</p>
<p><br></p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP 全称 User Diagram Protocol，数据报协议。在 1980 年协议面世的时候，标准文件只有 3 页，这也说明它设计的主要原则，就是<strong>协议简洁，运行快捷</strong>。</p>
<p>UDP 协议只提供端口形式的传输层寻址与一种可选的校验和功能，主要特点主打一个<strong>尽力而为</strong>。</p>
<p>首先，UDP 是面向报文（Segment）的传输层协议：</p>
<p><img src="/2024/03/09/transport-layer/udp-structure.png" alt></p>
<p>对于应用层提交过来的报文，UDP 协议会添加 UDP 报头构成 TPDU，再向下提交至 IP 层。</p>
<p>要注意的是，UDP 协议对应用层提交过来的报文<strong>既不合并，也不拆分</strong>：而是保留原报文的长度和格式，接收端将发送端提交传送的报文<strong>原封不动</strong>地提交至接收端应用程序。</p>
<p><img src="/2024/03/09/transport-layer/udp-transmit.png" alt></p>
<p>⚠️ 注：使用 UDP 协议时应选择合适长度的报文，报文太短会导致协议开销相对较大；太长，则 UDP 协议向 IP 层提交的 TPDU 可能在 IP 层被分片，降低协议效率。</p>
<p>其次，UDP 是无连接，不可靠的传输层协议：</p>
<ol>
<li>通信双方不需要提前建立好连接，这减少了协议开销与传输延迟；</li>
<li>作为补偿机制，UDP 为报文提供了可选的<strong>校验总和</strong>，用以检验数据完整性，而且为数据包的传输提供端口号</li>
</ol>
<p>UDP 熟知的端口号如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口号</th>
<th>服务进程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>53</td>
<td>DNS</td>
<td>域名服务</td>
</tr>
<tr>
<td>67/68</td>
<td>DHCP</td>
<td>动态主机配置协议</td>
</tr>
<tr>
<td>69</td>
<td>TFTP</td>
<td>简单文件传输协议</td>
</tr>
<tr>
<td>161/162</td>
<td>SNMP</td>
<td>简单网络管理协议</td>
</tr>
<tr>
<td>520</td>
<td>RIP</td>
<td>路由信息协议</td>
</tr>
</tbody>
</table>
</div>
<p>UDP 服务与端口号映射表会<strong>定期</strong>在 RFC768 等文件中公布，并可在大多数 UNIX 主机的 <code>/etc/services</code> 文件中得到。</p>
<p>注：与 DNS 不同的是，DHCP、SNMP 的客户端和服务器端在通信时都要使用熟知端口号。</p>
<p>不过除了可选的校验和，UDP 几乎没有其他任何可以保证数据传输可靠性的措施；也就是说，不一定能提供可靠的数据传输，也并不能保证数据准确无误地到达目的地。</p>
<p>如收到的分组校验出错，则<strong>丢弃该分组</strong>，既不确认，也不通知发送端和要求重传。</p>
<h2 id="UDP-头结构"><a href="#UDP-头结构" class="headerlink" title="UDP 头结构"></a>UDP 头结构</h2><p>UDP 的头长度固定为 8 个字节。结构如下：</p>
<p><img src="/2024/03/09/transport-layer/udp-header.png" alt></p>
<p><strong>源端口号</strong>（<strong>Source Port</strong>，16 位）：表示发送端进程端口号</p>
<p><strong>目的端口号</strong>（<strong>Destination Port</strong>，16 位）：表示接收端进程端口号</p>
<p>如源进程为客户端，则源端口号为 UDP 软件分配的临时端口号，目的端口号为服务器的熟知端口号。</p>
<p><strong>长度</strong>（<strong>Length</strong>，16 位）：定义了包括报头在内的用户数据报总长度</p>
<ul>
<li>最大为 65535 字节，最短为 8 字节（即 UDP 头自身长度）</li>
<li>实际数据长度最大为 65535 - 8 = 65527 字节</li>
</ul>
<p><strong>校验和</strong>（<strong>Checksum</strong>，16 位）用于检验整个用户数据报、UDP 报头与伪报头在传输中是否出现差错（效率优先），可选；如应用程序对通信效率要求高于可靠性，应用程序可选择不使用校验和。</p>
<p>校验和包括伪报头（pseudo header）、UDP 报头与数据。</p>
<p>伪报头包括以下内容：</p>
<ul>
<li>IP 分组头的源 IP 地址（16 位）</li>
<li>目的 IP 地址（16 位）</li>
<li>协议字段（8 位）：17，表示 UDP 报文（取 IP 分组头的一部分，其中填充域字段要补 0）</li>
<li>UDP 长度（16 位）</li>
</ul>
<p><img src="/2024/03/09/transport-layer/pseudo-header.png" alt></p>
<p>UDP 的长度不包括伪报头的长度；伪报头并不是 UDP 的真实头部，只是在计算时临时加上去起作用的，它既不向低层传输，也不向高层传送。</p>
<p>如果没有伪报头，那校验的对象只是 UDP 报文，也能判断 UDP 报文传输是否出错；但是如果 IP 分组头出错，那么分组就有可能会传送到错误的主机。因此在 UDP 校验和中习惯增加伪报头。</p>
<h2 id="适用的应用场景"><a href="#适用的应用场景" class="headerlink" title="适用的应用场景"></a>适用的应用场景</h2><ol>
<li>对数据交付实时性要求高，对数据交付可靠性要求相对较低<ul>
<li>对时间敏感的应用适用 UDP 协议：相比于等待响应，数据包丢失在某程度上是可以接受的；</li>
<li>适用于简单的响应协议，如 DNS 和 NTP</li>
</ul>
</li>
<li>视频播放应用<ul>
<li>用户关注的是视频流能尽快和不间断播放，丢失个别数据报文对视频节目的播放效果不会产生严重影响</li>
<li>采用 TCP 会因为重传个别丢失的报文而加大传输延迟，反而不利</li>
</ul>
</li>
<li>简短的交互式应用<ul>
<li>只需要进行简单的请求与应答报文的交互</li>
<li>可设置“定时器/重传机制”去处理由于 IP 数据分组丢失的问题，不需要确认/重传机制，提高工作效率</li>
</ul>
</li>
<li>多播和广播应用<ul>
<li>UDP 支持一对一、一对多和多对多的交互式通信，TCP 不支持</li>
<li>UDP 没有拥塞控制，在网络拥塞时不要求源主机降低报文发送速率，而只会丢弃个别的报文</li>
</ul>
</li>
</ol>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 全称 Transmission Control Protocol，传输控制协议。相比于 UDP，TCP 的特点如下：</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>1</strong>. TCP 是支持面向连接（Connection）的传输服务。</p>
<p>应用程序在使用 TCP 协议传送数据时，必须在源进程端口与目的进程端口之间建立一条 TCP <strong>传输连接</strong>，每个连接用双方<strong>端口号</strong>标识，为双方的<strong>一次</strong>进程通信提供服务。</p>
<p><strong>2</strong>. TCP 支持字节流（Stream）传输</p>
<p>流相当于管道：从一端放入什么，就可从另一端取出什么，以此来描述不丢失、不重复和不乱序的数据传输过程。</p>
<p>TCP 将应用程序提交的数据看成一连串、无结构的字节流；为支持字节流传输，发送端 &amp; 接收端都需要使用缓存，发送端使用缓存是因为要存储从应用程序送来的数据。</p>
<p>TCP 不可能为发送的每个写操作创建一个报文段，而是会选择将几个写操作组合成一个报文段，再提交至 IP 层。随后：</p>
<ul>
<li>IP 协议将数据封装成 IP 分组之后传送到接收端，接收端的 TCP 协议再将接收到的字节存储在接收缓存中；</li>
<li>应用程序随后使用读操作将接收数据从接收缓存中读出；</li>
<li>接收端应用程序数据字节的起始与终结位置需由应用程序自行确定</li>
</ul>
<p><strong>3</strong>. TCP 支持全双工通信，允许通信双方在任意时候发送数据。</p>
<p><strong>4</strong>. TCP 支持同时建立多个并发的 TCP 连接</p>
<p>有的时候根据应用程序需要，比如一个 Web 服务器必须要同时处理多个客户端的访问，那么 TCP 协议应该支持一个服务器与多个客户端同时建立多个 TCP 连接，也支持一个客户端与多个服务器同时建立多个 TCP 连接。</p>
<p><strong>5</strong>. TCP 支持<strong>可靠</strong>的传输服务</p>
<p>因为 TCP 建立在不可靠的网络层 IP 协议之上，因此想要保证可靠的传输服务，TCP 需要自行解决：</p>
<ul>
<li>使用<strong>确认机制</strong>对发送和接收的数据进行跟踪、确认和重传，检查数据是否安全和完整地到达；</li>
<li>提供<strong>拥塞控制</strong>功能，该功能是 TCP 的核心；</li>
<li>在相互进行通信的设备和服务之间保持一个虚拟连接；</li>
<li>TCP 为发送的每一个数据包提供一个序号，以此保证在接收<strong>无序、丢失</strong>或在数据传输期间<strong>被破坏</strong>的时候能完成数据恢复；</li>
<li>一旦 IP 或以下协议层出现传输错误，需要能不断进行重传</li>
</ul>
<p>这一点是 TCP 协议存在的目的。</p>
<p>![]</p>
<h2 id="TCP-头结构"><a href="#TCP-头结构" class="headerlink" title="TCP 头结构"></a>TCP 头结构</h2><p>TCP 头的长度为 20 - 60 字节（固定长度 20 字节，TCP 选项字段最长 40 字节）：</p>
<p><img src="/2024/03/09/transport-layer/tcp-header.png" alt></p>
<p><strong>源端口号</strong>（<strong>Source Port</strong>，16 位，2 字节）：表示发送某个报文段的应用进程的源端口号</p>
<p><strong>目的端口号</strong>（<strong>Destination Port</strong>，16 位，2 字节）：表示接收某个报文段的接收进程的目的端口号</p>
<p><strong>序号</strong>（<strong>Sequence Number</strong>, seq，32 位，4 字节）：TCP 给将要发送的字节流（Stream）中每个字节按照顺序编号，以此解决包乱序的问题</p>
<ul>
<li>范围从 0 至 4,284,967,295（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>）</li>
<li>在 TCP 建立连接时，通信双方需要使用随机数产生器产生一个初始序号（Initial Sequence Number, <strong>ISN</strong>）；</li>
<li>并且，双方各自随机产生初始序号：因此在一个 TCP 连接中，通信双方序号可以不同</li>
</ul>
<p><strong>确认号</strong>（<strong>Acknowledgment Number</strong>, ack，32 位，4 字节）</p>
<ul>
<li>表示一个进程已经正确接收到序号为 N 的字节，要求发送端接下来应该发送序号为 N+1 的字节</li>
<li>如主机 B 接收到主机 A 序号为 500 的字节，则 B 发送至 A 的确认号应该为 501</li>
<li>确认号发送时会捎带上确认方法</li>
</ul>
<p><strong>报头长度</strong>（<strong>Offset</strong>，4 位）：TCP 报头长度以 4 字节为一个单位计算，即该字段的值为 5（5 <em> 4 = 20, <code>0101</code>） 至 15（15 </em> 4 = 60, <code>1111</code>）之间</p>
<p><strong>保留字段</strong>（<strong>Reserved</strong>，6 位）</p>
<p><strong>控制字段</strong>（TCP Flags）</p>
<p>用于 TCP 的连接建立和终止、流量控制，以及数据传输过程，使用时在同一时间可设置一位或多位。包括如下标记位：</p>
<ol>
<li><p><strong>紧急</strong>（<strong>Urgent</strong>, URG, <strong>U</strong>）位</p>
<ul>
<li>URG = 1：该报文优先级高，需插到报文段最前面，尽快发送</li>
<li>需要与紧急指针字段（Urgent Pointer）一起使用</li>
</ul>
</li>
<li><p><strong>确认</strong>（<strong>Acknowledge</strong>, <strong>ACK</strong>, A）位：TCP 规定，在 TCP 建立连接之后发送的所有报文段的 ACK 位都要置 1</p>
</li>
<li><p><strong>推送</strong>（Push, <strong>PSH</strong>）位：应用于交互式通信</p>
<ul>
<li>如果一端应用程序希望输入一个指令后能够立即得到响应，则应置 PSH 为 1</li>
<li>设置后会立即创建一个报文段发送给对方</li>
<li>对方接收到 PSH 为 1 的报文段后，会尽快提交至应用进程，请求尽快应答</li>
</ul>
</li>
<li><p><strong>复位</strong>（Reset, <strong>RST</strong>）位</p>
<ul>
<li>RST = 1时：因主机崩溃等原因造成 TCP 连接出错，需立即释放连接，然后重新连接</li>
<li>TCP 拒绝一个非法 TCP 报文或拒绝释放一个连接</li>
</ul>
</li>
<li><p><strong>同步</strong>（<strong>SYN</strong>）位</p>
<ul>
<li>在连接建立的时候用来同步序号</li>
<li>SYN = 1 &amp; ACK = 0：标记一个连接建立请求报文</li>
<li>SYN = 1 &amp; ACK = 1：标记同意建立连接的响应报文</li>
</ul>
</li>
<li><p><strong>终止</strong>（Final, <strong>FIN</strong>）</p>
<ul>
<li>用来释放一个 TCP 连接</li>
<li>FIN = 1：表示发送端的报文段发送完毕，请求释放 TCP 连接</li>
</ul>
</li>
</ol>
<p><strong>窗口</strong>（<strong>Window</strong>，16 位）：0 至 65535 (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>) 之间</p>
<ul>
<li>因为接收端的接收缓冲区存在限制，所以在接收下一个 TCP 报文段之前，接收端会通知发送端，这次最多可发送多少字节的报文段</li>
<li>发送端根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</li>
<li>同时，发送端会根据接收端通知的窗口值去动态调整自己的发送窗口值大小</li>
</ul>
<p><strong>校验和</strong>（<strong>Checksum</strong>）</p>
<ul>
<li>必填字段，且同样需要伪报头</li>
<li>协议字段值为 6</li>
</ul>
<p><strong>紧急指针</strong>（<strong>Urgent Pointer</strong>，16 位）</p>
<ul>
<li>只有当紧急标志 URG = 1 时才有效；此时报文段中包括紧急数据</li>
<li>TCP 协议软件要在优先处理完紧急数据之后才能恢复正常工作</li>
</ul>
<p><strong>选项字段</strong>（<strong>Options</strong>），包括：</p>
<ul>
<li>单字节选项<ul>
<li>0: 选项结束（Ends of Options List）</li>
<li>1: 无操作（No Operation, NOP, Pad）</li>
</ul>
</li>
<li>多字节选项<ul>
<li>2: 最大报文段长度（Maximum Segment Size, MSS）：规定 TCP 报文数据的最大值，不包括报头长度</li>
<li>3: 窗口扩大因子（Window Scale）</li>
<li>8: 时间戳（Timestamp）</li>
</ul>
</li>
</ul>
<p>注：MSS 的值与每次传输的窗口大小无关</p>
<ul>
<li>窗口字段值指的是接收端通知发送端下一次可以连续传输的字节数</li>
<li>MSS 规定的是一个 TCP segment 最多能放的数据的字节数</li>
</ul>
<p>MSS 值的选择应考虑下列因素：</p>
<ol>
<li>协议开销<ul>
<li>例：报头和 MSS 值均为 40 字节时 -&gt; 报文段 50% 用来传输数据</li>
<li>MSS 值太小会增加协议开销</li>
</ul>
</li>
<li>IP 分片<ul>
<li>MSS 值选得太大：受到 IP 分组长度的限制，较长报文段在 IP 层会被分片传输 -&gt; 增加网络层开销和传输出错概率</li>
</ul>
</li>
<li>发送和接收缓冲区的限制：直接影响到发送和接收缓冲区设置的大小和使用效率</li>
</ol>
<p>MSS 的默认值：536 字节</p>
<ul>
<li>对于某些应用未必适用：在建立 TCP 连接时使用 SYN 报文中最大段长度选项来协商</li>
<li>TCP 允许双方选择使用不同的 MSS 值</li>
</ul>
<h2 id="TCP-连接建立和释放：三次握手与四次挥手"><a href="#TCP-连接建立和释放：三次握手与四次挥手" class="headerlink" title="TCP 连接建立和释放：三次握手与四次挥手"></a>TCP 连接建立和释放：三次握手与四次挥手</h2><p><img src="/2024/03/09/transport-layer/3-shake-hands.png" alt></p>
<p>连接建立的过程俗称“<strong>三次握手</strong>”：</p>
<ol>
<li>在开始连接之前，客户端的 TCP 进程处于 <code>CLOSED</code>（关闭）状态；</li>
<li>开始连接：客户端调用 <code>connect()</code> 准备发起 TCP 连接，进入 <code>SYN_SENT</code>（准备发送）状态；<ul>
<li>服务端 TCP 进程需为 <code>LISTEN</code>（收听）状态；</li>
<li>客户端发送 <strong>SYN = 1</strong> 的<strong>连接建立请求报文</strong>到服务端；</li>
<li>连接建立请求报文不携带数据字段，这次传输的报文序号 <code>seq = x</code>；</li>
<li>x 值随机产生，但不能为 0：避免因 TCP 连接非正常断开而可能引起的混乱</li>
</ul>
</li>
<li>如果连接突然中断：可能有一两个进程同时等待双方确认应答<ol>
<li>此时有一个新连接的序号也从 0 开始；</li>
<li>则接收进程有可能认为是对方重传的报文：可能造成连接错误</li>
</ol>
</li>
<li>服务端收到连接建立请求报文后：<ol>
<li>如果同意建立连接，则向客户端返回<strong>连接建立请求确认报文</strong>；</li>
<li>报文的标识位 SYN = 1, ACK = 1；</li>
<li>不携带数据字段，序号 <code>seq = y</code>；</li>
<li>报文的确认号 <code>ack = x + 1</code>，意为对上一个连接建立请求报文序号 <code>seq = x</code> 的确认</li>
</ol>
</li>
<li>服务器端从 LISTEN 进入 <code>SYN_RCVD</code>（准备接收）状态</li>
<li>客户端收到服务端的连接建立请求确认报文，再向服务端发送又一个<strong>连接建立请求确认报文</strong>：<ol>
<li>报文标识位 ACK = 1；</li>
<li>不携带数据字段，序号 <code>seq = x + 1</code>，意为承接客户端发送到同一服务端的上一报文的序号，即之前的连接建立请求报文；且响应上一个连接建立请求报文的确认号 <code>ack = x + 1</code>；</li>
<li>报文确认号 <code>ack = y + 1</code>，为对前一个连接建立请求确认报文序号 <code>seq = y</code> 的确认</li>
</ol>
</li>
<li>客户端发出该确认报文后进入 <code>ESTABLISHED</code>（连接建立）状态</li>
<li>服务器端接收到该报文之后也进入 <code>ESTABLISHED</code> 状态</li>
</ol>
<p>总的来说，全过程相当于试探一下对方是否遵循 TCP/IP 协议，协商完成之后就可以进行通信了。</p>
<p><strong>报文传输</strong></p>
<p>TCP 传输连接建立后，客户端便可与服务端进行全双工字节流传输。</p>
<p>为保证 TCP 工作正常、有序进行，TCP 会为某一次会话设置保持计时器（keep timer），防止 TCP 连接处于长时间空闲状态。</p>
<ul>
<li>如果服务端接收到了客户端的报文，服务端则将保持计时器复位；</li>
<li>如果服务端超过了计时器设定的时间没有收到客户端信息，则发送探测报文；</li>
<li>如发送了 10 个探测报文（每个相隔 75 秒）还没有响应，服务端会认为客户端故障，从而终止连接。</li>
</ul>
<p>连接释放的过程俗称“<strong>四次挥手</strong>”，客户端和服务端都可以主动提出连接释放请求。</p>
<p>以客户端提出释放 TCP 连接的“四次挥手”为例：</p>
<ol>
<li>客户端调用 <code>close()</code> 执行“主动关闭”（active close），随后进入 <code>FIN-WAIT-1</code>（释放等待 - 1）状态：<ol>
<li>客户端会向服务端发送<strong>连接释放请求报文</strong>，并停止发送数据；</li>
<li>报文的标识位 FIN = 1, ACK = 1；</li>
<li>报文不携带数据字段,序号 <code>seq = u</code>（客户端发送的最后一个字节序号 + 1）</li>
</ol>
</li>
<li>服务端接收到连接释放请求报文后，执行“被动关闭”（passive close），进入 <code>CLOSE-WAIT</code>（等待关闭）状态：<ol>
<li>服务端向客户端响应<strong>连接释放请求确认报文</strong>，为对接收到第一个连接释放请求报文的确认；</li>
<li>报文序号 <code>seq = v</code>，为服务端发送的最后一个字节序号 + 1；</li>
<li>确认号 <code>ack = u + 1</code></li>
<li>⚠️ 此时客户端到服务端的 TCP 连接已经断开，但服务端到客户端的 TCP 连接依然保持连接，服务器可继续发送未发送的数据报文；此时为“<strong>半关闭</strong>（half-close）”状态</li>
</ol>
</li>
<li>客户端收到服务端的连接释放请求确认报文后，进入 <code>FIN-WAIT-2</code>（释放等待 - 2）状态</li>
<li>服务端将所有要发送的报文发送完毕后，向客户端发送<strong>连接释放请求报文</strong><ol>
<li>服务端进入 <code>LAST-ACK</code>（最终确认）状态，通知 TCP 可以释放连接；</li>
<li>报文的标识位 FIN = 1, ACK = 1；</li>
<li>报文序号假定为 seq = w（取决于从半关闭到最终确认状态之间，服务端是否发送过报文；如没有则 <code>seq = v</code>）；</li>
<li>确认号 <code>ack = u + 1</code></li>
</ol>
</li>
<li>此时客户端早无数据传输，因此服务端的确认号不变</li>
<li>服务端转回 <code>LISTEN</code> 或 <code>CLOSED</code> 状态</li>
<li>客户端收到服务端的连接释放请求报文后，向服务器端返回<strong>连接释放请求确认报文</strong><ol>
<li>报文的标识位 ACK = 1；</li>
<li>seq = u + 1, ack = w + 1；</li>
<li>随后：客户端进入 TIME-WAIT 状态</li>
</ol>
</li>
</ol>
<p>客户端进入 TIME-WAIT 状态的背景是：TCP 关闭一个连接时，并不认为该连接马上得到真正的关闭。</p>
<p>为了保证 TCP 连接释放过程能正常运行，协议还设置了时间等待计时器（TIME-WAIT timer）：</p>
<ul>
<li>此时再等待两个最长报文寿命（Maximum Segment Lifetime, MSL）后，客户端才进入 CLOSED 状态；</li>
<li>这种设计是为了确保服务端在最后阶段发送给客户端的数据，以及客户端发送给服务端的最后一个请求确认报文都能被正确接收，防止因个别报文传输错误导致连接释放失败。</li>
</ul>
<p>综上，TCP 每个阶段的状态图如下：</p>
<p><img src="/2024/03/09/transport-layer/tcp-state-diagram.jpg" alt></p>
<h2 id="TCP-协议滑动窗口与确认重传机制"><a href="#TCP-协议滑动窗口与确认重传机制" class="headerlink" title="TCP 协议滑动窗口与确认重传机制"></a>TCP 协议滑动窗口与确认重传机制</h2><p>TCP 协议的设计思想，是让应用进程传输给协议的数据作为一个字节流而存在，而不是从协议本身去限制应用层数据的长度。</p>
<p>也就是说，在数据交换的过程中，应用进程无需考虑发送数据的长度；数据交由 TCP 协议负责将字节分段打包，发送端利用已建立的 TCP 连接，将字节流传送到接收端的应用进程。</p>
<p>然而，传输层往下一层的网络层里面，IP 分组在传输过程中不可避免会出错；因此需要 TCP 协议提供差错控制、确认和重传功能，保证接收的字节流正确。</p>
<p>TCP 采用以字节为单位的<strong>滑动窗口协议</strong>（Sliding-Windows Protocol）来跟踪和记录字节流的发送、接收、确认与重传，实现差错控制：</p>
<ul>
<li>发送端对缓存设置发送窗口：窗口不为 0 即可发送报文段</li>
<li>接收端设置接收窗口：窗口值等于接收缓存可以继续接收的字节流大小</li>
<li>接收端窗口大小由接收端决定</li>
<li>根据接收缓存剩余空间大小</li>
<li>根据应用进程读取数据的速度</li>
<li>TCP 不可能对每一个字节进行确认</li>
<li>将字节流分成段，一个段多个字节打包成一个 TCP 报文段来传送</li>
<li>TCP 通过报头序号标识发送的字节，通过确认号表示已被正确接收的字节</li>
</ul>
<h3 id="传输字节流状态分类"><a href="#传输字节流状态分类" class="headerlink" title="传输字节流状态分类"></a>传输字节流状态分类</h3><p><img src="/2024/03/09/transport-layer/sliding-window.png" alt></p>
<p>以上为滑动窗口的示意图，图中对传输字节流的状态分成了四个阶段：</p>
<ul>
<li>第一类：已发送，且已得到确认的字节（图中 <code>#31</code> 字节及之前的数据）；</li>
<li>第二类：已发送，但并未得到确认的字节（<code>#32</code> - <code>#45</code> 字节）；</li>
<li>第三类：未发送，但接收端表示准备接收的字节（#46 - #51 字节）</li>
<li>接收缓冲区已准备好接收该字节<br>第四类：未发送，且接收端未准备接收的字节（#51 字节之后）</li>
</ul>
<ol>
<li>发送窗口与可用窗口</li>
</ol>
<ul>
<li>发送窗口：决定发送端在每一次发送过程中能连续发送的字节数</li>
<li>等于第二类与第三类字节数之和</li>
<li>如上图的发送窗口大小为 14 + 6 = 20</li>
<li>可用窗口：表示可随时发送的字节数</li>
<li>等于第三类字节数</li>
<li>如上图的可用窗口大小为 6</li>
<li>可用窗口字节发送完毕之后</li>
<li>第三类字节变成第二类字节（即 #32 - 51 为第二类）</li>
<li>处理确认 &amp; 滑动发送窗口</li>
<li>如：接收端发送 ACK 确认 #32 - 36 的字节，并保持发送窗口大小不变（20）</li>
<li>窗口开始滑动，第一类字节序号为 #37 之前</li>
<li>第二类字节为 #37 - 51，第三类字节为 #52 - 57，第四类字节为 #57 之后</li>
</ul>
<p>特点：</p>
<ul>
<li>TCP 使用发送和接收缓冲区，以及滑动窗口机制来控制 TCP 连接上的字节流传输</li>
<li>TCP 滑动窗口面向字节流，起到差错控制的作用</li>
<li>接收端可在任何时候发送确认，窗口大小可由接收端来根据需要增大或减小</li>
<li>发送窗口值可小于接收窗口值，不能超过接收窗口值；发送端可根据自身需要决定</li>
</ul>
<p>选择重传策略</p>
<ul>
<li>出现接收字节流序号不连续的情况</li>
</ul>
<p>处理方法：</p>
<ol>
<li>拉回方式</li>
</ol>
<ul>
<li>在丢失第 2 个报文段时：</li>
<li>不管之后的报文段接收是否正确，都要求从第 2 个报文段开始，重传所有后面的报文段</li>
<li>效率低</li>
</ul>
<ol>
<li>选择重传方式（Selective ACK, SACK）</li>
</ol>
<ul>
<li>如所有字节的序号都在接收窗口内，则首先完成接收窗口内字节接收，然后将丢失的字节序号通知发送端</li>
<li>发送端只需要重传丢失的报文段，不需要重传已经接收的报文段</li>
</ul>
<p>重传计时器（Retransmission Timer）：控制报文确认与等待重传的时间<br>发送端 TCP 发送报文：</p>
<ul>
<li>将它的一个报文的副本放入重传队列，同时启动一个重传计时器</li>
<li>重传计时器设定一个值：如 400 ms，然后开始倒计时</li>
<li>计时到 0 之前收到确认：报文传输成功</li>
<li>到 0 时仍未收到确认：传输失败，准备重传</li>
</ul>
<p>影响超时重传时间的因素：</p>
<ul>
<li>数值过低：已被接收端正确接收的报文被重传，造成报文重复</li>
<li>数值过高：报文已经丢失但发送端等待时间过长，降低通信效率</li>
</ul>
<ol>
<li>如一个主机同时与其他两个主机建立两条 TCP 连接</li>
</ol>
<ul>
<li>需要分别为每个 TCP 连接启动一个重传计时器</li>
<li>如：其中一个 TCP 连接用于在本地局域网中传输文本文件；另一个则通过 Internet 访问远端 Web 服务器视频文件</li>
<li>两个 TCP 连接的报文发送和确认信息返回的往返时间（Rout-Trip Time, RTT）相差很大</li>
<li>须分别设定不同的重传时间</li>
</ul>
<ol>
<li>在不同的时间段，Internet 用户数量变化很大，流量与传输延迟变化也很大</li>
</ol>
<ul>
<li>即便是相同的两个主机在不同时间建立的 TCP 连接，且完成同样的 Web 访问操作，客户端与服务器端之间的报文传输延迟也不会相同</li>
</ul>
<ol>
<li>传输层本就建立在“尽力而为”的 IP 协议之上：</li>
</ol>
<ul>
<li>报文往返时间在数值上离散较大很自然</li>
</ul>
<p>超时重传时间的选择：只能采用动态的自适应的方法</p>
<ul>
<li>根据对端-端报文往返时间的连续测量，来不断调整重传定时器的超时重传时间</li>
</ul>
<ol>
<li>当前最佳返回时间 RTT 值的估算</li>
</ol>
<ul>
<li>一个 TCP 连接维护一个当前最佳往返时间 RTT 估算值</li>
<li>发送一个报文段便启动一个重传计时器</li>
<li>测量该报文段从发送到被确认的往返时间</li>
<li>如果出现超时，启动重传</li>
<li>某次测量的往返时间为 M，则更新的当前最佳返回时间 RTT 估算值为 ${RTT = α × RTT + M}</li>
<li>α 为常数加权因子（0 ≦ α ＜ 1），决定 RTT 对延迟变化的反应速度</li>
<li>当 α 接近 0 时，短暂的延迟变化对 RTT 影响不大；</li>
<li>当 α 接近 1 时，RTT 将紧紧跟随往返时间变化，影响很大</li>
<li>RFC2988 建议 α 的参考值为 0.125</li>
<li>例：最初往返时间 RTTS 估算值为 30 ms</li>
<li>已知收到 3 个确认报文段，测量的往返时间 M 分别为 26ms，32ms，24ms</li>
<li>RTTS0 = 30ms</li>
<li>RTTS1 = 0.125 × 30 + 26 = 29.75ms</li>
<li>RTTS2 = 0.125 × 29.75 + 32 ≈ 35.72ms</li>
<li>RTTS3 = 0.125 × 35.72 + 24 ≈ 28.47ms</li>
<li>以上为每次更新的 RTTS 估算值</li>
</ul>
<ol>
<li>超时重传时间（Retransmission Time-Out, RTO）</li>
</ol>
<ul>
<li>略大于加权计算出来的 RTTS 估计值</li>
<li>建议计算公式：RTO = RTTS + 4 × RTTD</li>
<li>RTTD 为 RTT 的偏差加权平均值，和 RTTS 与测量值 M 之差相关</li>
<li>第一次测量：RTTD1 = M1 / 2</li>
<li>以后：RTTD = (1 - β) × (旧的 RTTS) + β × | RTTS - M |</li>
<li>β 为常数加权因子，建议取 0.25</li>
<li>接近 1 ：TCP 能迅速检测报文丢失，及时重传，减少等待时间，但可能引起更多的重传报文</li>
<li>太大：重传报文减少，等待时间太长</li>
<li>例：β = 0.25，旧的 RTTS = 30ms，新的 RTTS = 35ms，M = 32ms</li>
<li>RTTD = (1 - 0.25) × 30 + 0.25 × |35 - 32| = 23.25 ms</li>
<li>RTO = 35 + 4 × 23.25 = 128ms</li>
</ul>
<h2 id="TCP-协议滑动窗口与流量控制、拥塞机制"><a href="#TCP-协议滑动窗口与流量控制、拥塞机制" class="headerlink" title="TCP 协议滑动窗口与流量控制、拥塞机制"></a>TCP 协议滑动窗口与流量控制、拥塞机制</h2><ol>
<li>TCP 窗口与流量控制（flow control）</li>
</ol>
<ul>
<li>研究流量控制算法目的：控制发送端发送速率，使之不超过接收端的接收速率</li>
<li>防止由于接收端来不及接收送达的字节流，而出现报文段丢失的现象</li>
<li>滑动窗口协议利用报头中窗口字段实现流量控制</li>
</ul>
<p>控制过程：</p>
<ul>
<li>在此过程中，接收窗口又称为“通知窗口（Advertised Windows）”</li>
<li>接收端根据接收能力选择合适的接收窗口（rwnd, receiving window）值，将其写入 TCP 报头</li>
<li>将当前接收端的接收状态通知发送端</li>
<li>发送端的发送窗口不能超过接收窗口的数值<br>rwnd 数值单位为字节，而不是报文段</li>
<li>接收端应用进程从缓存中读取字节的速度 ≧ 字节到达速度：接收端需要在每个确认（ACK）中发送“非零窗口”通告（rwnd &gt; 0）</li>
<li>发送端发送速度 &gt; 接收端消费速度：缓冲区被全部占用，后到达字节因缓冲区溢出而丢弃</li>
<li>接收端必须发出“零窗口”通知（rwnd = 0）</li>
<li>发送端接收到“零窗口”通知后：停止发送，直至下一次接收到接收端的“非零窗口”为止</li>
</ul>
<p>如上图，接收方确定的 rwnd = 400，假设每次发送方每次发送报文段的长度为 100 字节</p>
<p>坚持计时器（Persistence Timer）<br>如果下一个非零窗口通告丢失：发送端无休止等待接收端通知——陷入死锁</p>
<ul>
<li>当发送端 TCP 接收到一个零窗口通知时：启动坚持计时器</li>
<li>当计时器时间到：发送端 TCP 发送一个零窗口探测报文</li>
<li>提示接收端：非零窗口通知丢失，需要重传</li>
<li>其值设置为重传时间的数值，最大为 60 秒</li>
<li>如发出的第一个零窗口探测报文没收到应答：继续发送，直到收到非零窗口为止</li>
</ul>
<p>流量控制的传输效率问题</p>
<ul>
<li>发送端应用进程将数据传送到 TCP 协议的发送缓存后：控制全传输任务就由 TCP 协议承担</li>
<li>TCP 协议必须注意解决好“何时”发送“多长报文段”</li>
<li>问题复杂：受到应用进程产生数据的速度与接收端发送能力限制</li>
</ul>
<p>极端情况：每次只发送一个字节</p>
<ul>
<li>IP 分组共 41 字节——1 + 20字节 TCP 报头 + 20 字节 IP 报头</li>
<li>接收端接收后没有数据发送，也要立即返回一个 40 字节的确认分组（20字节 TCP 报头 + 20 字节 IP 报头）</li>
<li>接收端向发送端发出窗口更新报文，通知将窗口前移 1 个字节（40 字节）</li>
<li>发送端发送一个字节的数据（41 字节）</li>
<li>则：输入一个字符需要发送 162 字节的 4 个报文段——资源浪费</li>
</ul>
<p>采用 Nagle 算法提高效率：</p>
<ul>
<li>当数据以每次 1 字节进入发送端：第一次只发送 1 字节，其它字节存入缓存区</li>
<li>第一个报文段符合时，再将缓存中的数据（不止 1 字节）放在第二个报文段中发出去</li>
<li>一边发送等待应答；一边缓存待发送数据</li>
<li>当缓存的数据字节数达到发送窗口的 1/2 或接近最大报文段长度 MSS 时：立即发送</li>
</ul>
<p>另一种情况：糊涂窗口综合征（Silly Windows Syndrome）</p>
<ul>
<li>假设 TCP 接收缓存已满，应用进程每次只从接收缓存读取 1 字节</li>
<li>接收端缓存腾空 1 字节，并向发送端发出确认报文，且将接收窗口设为 1</li>
<li>发送端发送的确认报文长度为 40 字节</li>
<li>随后发送端发送一个字节的数据（41 字节）</li>
<li>解决方法：禁止接收端发送只有 1 字节的窗口更新报文</li>
<li>让接收端等待一段时间至接收缓存有足够空间接收一个最大长度的报文段，或缓冲区空出一半，再发送窗口更新报文<br>即：发送端不要发送太小的报文段，接收端的 rwnd 不能太小</li>
</ul>
<ol>
<li>TCP 窗口与拥塞控制<br>拥塞控制：用于防止过多报文进入网络而造成的路由器与链路过载<br>注意：</li>
</ol>
<ul>
<li>流量控制：重点在点-点链路的通信量的局部控制上</li>
<li>拥塞控制：重点在进入网络报文总量的全局控制上<br>流量控制可以很好地解决发送端与接收端之间的端-端报文发送和处理速度的协调，但无法控制进入网络的总体流量。<br>随着网络流量增加，网络通信负荷过重，引起报文传输延时增大或丢弃，报文的差错确认又会加剧网络拥塞</li>
</ul>
<p>网络出现拥塞的条件：对网络资源的需求总和 &gt; 网络可用资源<br>例：某段时间用户对某类资源要求过高——造成拥塞</p>
<ul>
<li>链路带宽 100 M，连接在该链路上的 100 台计算机要求以 10 M 的速度发送数据</li>
<li>解决：升级链路带宽至 1 G</li>
<li>某节点缓存容量过小 / 处理速度太慢，造成进入节点的大量报文不能及时被处理，不得不丢弃报文</li>
<li>解决：升级主机，更换大容量缓存、高速处理器<br>——以上均不能根本上解决网络拥塞问题</li>
</ul>
<p>拥塞处理(congestion handling)</p>
<p>负载（load）：单位时间进入网络的字节数<br>吞吐量（throughput）：单位时间内通过网络输出的字节数</p>
<ol>
<li>未采取拥塞控制方法时：</li>
</ol>
<ul>
<li>开始阶段：吞吐量随网络负载增加呈线性增长</li>
<li>轻度拥塞：吞吐量增长小于负载增加量</li>
<li>网络负载继续增加而吞吐量不变：饱和状态</li>
<li>饱和状态后吞吐量随网络负载增加而减少</li>
<li>增加到一定程度：吞吐量为 0 ，系统出现死锁（deadlock）</li>
</ul>
<ol>
<li>理想拥塞控制：</li>
</ol>
<ul>
<li>网络负载达到饱和点之前，网络吞吐量一直保持线性增长的关系</li>
<li>到达饱和点后：网络吞吐量维持不变</li>
</ul>
<ol>
<li>实际拥塞控制：</li>
</ol>
<ul>
<li>网络负载增长初期：由于要在拥塞控制过程消耗一定资源——吞吐量小于无拥塞控制状态</li>
<li>在负载增加过程中：限制进入网络的报文或丢弃部分报文，是吞吐量逐渐增长，不出现下降和死锁现象</li>
</ul>
<p>拥塞控制前提：网络能承受现有的网络负荷<br>实现拥塞控制最基本手段：TCP 协议滑动窗口</p>
<ul>
<li>拥塞窗口（Congestion Window）：发送端根据网络拥塞情况确定的窗口值</li>
<li>发送端真正确定发送窗口时，应取“通知窗口”与“拥塞窗口”中的较小值</li>
<li>接收端需要根据自己的接收能力给出一个合适的接收窗口 rwnd</li>
<li>从流量控制角度：发送窗口一定不能超过接收窗口</li>
<li>发送窗口上限值 = Min(rwnd, cwnd)</li>
<li>rwnd &gt; cwnd：拥塞窗口限制发送窗口的最大值</li>
<li>rwnd &lt; cwnd：接收端接收能力限制发送窗口的最大值</li>
<li>没有发生拥塞：接收端的通知窗口和拥塞窗口一致</li>
</ul>
<p>使用到的参数：</p>
<ul>
<li>拥塞窗口（cwnd）:拥塞控制的关键参数，它描述源端在拥塞控制情况下一次最多能发送的数据包的数量</li>
<li>通告窗口（awin）:接收端给源端预设的发送窗口大小，它只在 TCP 连接建立的初始阶段发挥作用</li>
<li>发送窗口（win）:源端每次实际发送数据的窗口大小</li>
<li>慢启动阈值（ssthresh）:拥塞控制中慢启动阶段和拥塞避免阶段的分界点。初始值通常设为 65535byte</li>
<li>回路响应时间（RTT）:一个 TCP 数据包从源端发送到接收端，源端收到接收端确认的时间间隔</li>
<li>超时重传计数器（RTO）:描述数据包从发送到失效的时间间隔，是判断数据包丢失与否及网络是否拥塞的重要参数。通常设为2RTT或5RTT</li>
<li>快速重传阈值(tcprexmtthresh):：能触发快速重传的源端收到重复确认包 ACK 的个数。当此个数超过 tcprexmtthresh 时，网络就进入快速重传阶段。tcprexmtthresh 缺省值为3。</li>
</ul>
<p>拥塞控制算法通过动态调节用户对网络资源的需求来保证网络系统的稳定运行</p>
<ul>
<li>1999 年 RFC 2581 对 TCP 协议规定了四种拥塞控制方法</li>
</ul>
<ol>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ol>
<ul>
<li>发送端确定拥塞窗口大小时可采用 慢启动 和 拥塞避免 算法</li>
</ul>
<ol>
<li>算法<br>TCP 连接中，发送端还需要维持一个拥塞窗口（cwnd, congestion window）的状态参数</li>
</ol>
<ul>
<li>拥塞窗口的大小根据网络的拥塞情况动态调整</li>
<li>网络无拥塞：发送端逐步增大拥塞窗口</li>
<li>出现拥塞：拥塞窗口立即减小</li>
<li>网络是否出现拥塞：取决于路由器是否丢弃分组</li>
<li>基于的假设：线路质量好，丢弃分组原因不是因为物理层传输出错，而是因为网络中分组传输总量大，超过了路由器的接收能力，造成路由器过载</li>
</ul>
<p>慢启动（Slow-Start）</p>
<ul>
<li>场景：主机开始发送数据</li>
<li>对网络负载状态不了解——试探着从小到大逐步增加拥塞窗口</li>
<li>预定义：一个往返——第一个 从发送端发送报文（MSS）到接收端，接收端在规定时间内返回了确认报文 的动作</li>
<li>此时：主机在建立一个 TCP 连接的初始化时，将慢启动的初始值设为 1</li>
<li>第一个往返首先将拥塞窗口（cwnd）设为 2，然后向接收端发送两个最大报文段</li>
<li>如：接收端在定时器允许的往返时间内返回确认——网络不拥塞，拥塞窗口按二进制指数增长</li>
<li>即：第二个往返 cwnd = 4</li>
<li>如报文正确传输：第三个往返 cwnd = 8</li>
<li>如再正确：第四个往返 cwnd = 16，如此类推</li>
<li>若在规定时间没有收到确认报文：表明网络开始出现拥塞</li>
</ul>
<p>注意：</p>
<ol>
<li>每一次发送的往返时间 RTT 是不同的：取决于连续发送报文段的多少</li>
</ol>
<ul>
<li>每个过程的往返时间应从连续发送多个报文段，到接收到所有发送报文段确认消息需要的时间</li>
<li>如第一个往返过程中 cwnd = 2：该次可连续发送两个报文段</li>
<li>发送端必须都收到这两个报文段的确认，才能判断网络没有出现拥塞</li>
</ul>
<ol>
<li>“慢启动”的“慢”：不是指 cwnd 从 1 开始，然后按照二进制指数增长的速度</li>
</ol>
<ul>
<li>而是指：试探着将 cwnd 逐步增大，比突然将很多报文发送到网络的情况要“慢”</li>
<li>意味着发送报文段的多少存在着逐步加快的过程</li>
</ul>
<ol>
<li>定义“慢启动阀值（slow-start threshold, ssthresh）”：避免 cwnd 增长过快引起网络拥塞</li>
</ol>
<ul>
<li>cwnd &lt; ssthresh：使用慢启动算法</li>
<li>cwnd &gt; ssthresh：使用拥塞控制算法</li>
<li>cwnd = ssthresh：两种算法均可使用</li>
<li>如 cwnd = 32 时出现超时：发送端可将 ssthresh 设置为：ssthresh = cwnd / 2 = 16</li>
</ul>
<p>拥塞避免（Congestion Avoidance）</p>
<ul>
<li>（每增加一个往返就将 cwnd 加倍）改成每增加一个往返就将 cwnd 加一</li>
<li>cwnd 呈线性增加，缓慢增长</li>
<li>只要发现接收端没有按时返回确认：网络拥塞，将 ssthresh 值设为 cwnd / 2，并重新进入下一轮慢启动，即此时 cwnd = 1</li>
</ul>
<p>慢启动 + 拥塞避免</p>
<ul>
<li>连接初始化时 cwnd = 1，慢启动初始阀值 ssthresh = 16（单位为 MSS）</li>
<li>4 个往返后 cwnd 增长至 16，TCP 传输进入拥塞避免控制阶段</li>
<li>假设：cwnd = 24 时发送端检测出现超时—— cwnd 被重新设成 1，ssthresh 被设成 24 / 2 = 12</li>
<li>1 - 4 往返的 cwnd 分别为 2, 4, 8, 16，5 - 12 往返的 cwnd 分别为 17 - 24</li>
<li>之后重新开始慢启动 + 拥塞避免</li>
<li>13 - 17 往返的 cwnd 分别为 1, 2, 4, 8, 12，18 之后的往返就分别加一</li>
</ul>
<p>注：</p>
<ul>
<li>只要出现超时就将 ssthresh 减半——“乘法减小（Multiplicative Decrease）”算法</li>
<li>开始执行拥塞避免，缓慢加一——“加法增大（Additive Increase）”算法</li>
<li>合称 AIMD（Additive Increase Multiplicative Decrease）算法——加性增窗，乘性减窗<br>缺点：举例说明</li>
<li>当发送端连续发送报文 M1 - M7，只有 M3 在传输过程中丢失，M4 - M7 都能正确接收</li>
<li>此时不能根据一个 M3 的超时而简单判断网络出现拥塞</li>
<li>替代方法：快重传 和 快恢复</li>
</ul>
<p>快重传（Fast Retransmit）<br>例：</p>
<ul>
<li>如接收端在正确接收 M1、M2 报文并返回确认，没有接收到 M3 报文，而是接收到 M4：<ul>
<li>接收端不能对 M4 进行确认（M4 为乱序报文）</li>
</ul>
</li>
<li>根据“快重传”算法规定：</li>
<li>接收端应及时向发送端连续三次发出对 M2 的“重复确认”，要求发送端尽早重传未被确认的报文</li>
</ul>
<p>快恢复（Fast Recovery）：与快恢复算法配合<br>规定：</p>
<ol>
<li>接收端收到第一个对 M2 的“重复确认”时：发送端立即将拥塞窗口 cwnd 设置为最大拥塞窗口值的 1/2 <ol>
<li>执行“拥塞避免”算法，cwnd 按照线性方式增长</li>
</ol>
</li>
<li>接收端收到第二个对 M2 的“重复确认”时：发送端立即减小 cwnd<ol>
<li>执行“拥塞避免”算法，cwnd 按照线性方式增长</li>
</ol>
</li>
<li>接收端收到第三个对 M2 的“重复确认”时：发送端立即减小 cwnd<ol>
<li>执行“拥塞避免”算法，cwnd 按照线性方式增长</li>
</ol>
</li>
</ol>
<h1 id="通信单元-Socket"><a href="#通信单元-Socket" class="headerlink" title="通信单元 Socket"></a>通信单元 Socket</h1><p>应用进程、传输层接口与套接字（socket）</p>
<ul>
<li>Handler in the communication chain. </li>
<li>应用程序（进程）与传输层的 TCP 或 UDP 都是在主机操作系统控制下工作</li>
<li>在一台计算机中，不同进程需要使用进程号（process ID）被唯一地标识</li>
<li>进程号也被称为端口号（port number）</li>
<li>可用于计算机之间通信，也可用于同一计算机进程之间的通信</li>
<li>在计算机网络中，只有知道 IP 地址与端口号，才能唯一地找到准备通信的进程</li>
<li>RFC793 定义的 套接字（socket）由 IP 地址与对应的端口号组成<ul>
<li>IP 地址: 端口号</li>
<li>如 10.116.53.141:7070</li>
</ul>
</li>
<li>网络中两个应用程序通过一个双向的通信连接实现数据交换</li>
</ul>
<p>Socket 的不同含义：</p>
<ol>
<li>网络原理：RFC793 规定 socket = IP 地址: 端口号</li>
<li>网络软件编程：Socket 指网络程序的 API<ul>
<li>Socket 是 TCP/IP 协议十分流行的 PI</li>
<li>Socket 所支持的协议种类不光 TCP/IP 一种</li>
</ul>
</li>
<li>详见 Socket（套接字）</li>
</ol>
<ul>
<li>API 中的一个函数名也可称为 Socket</li>
<li>操作系统中也有关于 Socket 的讨论</li>
</ul>
<h1 id="进程标识方法：端口号"><a href="#进程标识方法：端口号" class="headerlink" title="进程标识方法：端口号"></a>进程标识方法：端口号</h1><p>TCP/IP 传输层的寻址通过 TCP 与 UDP 的端口号实现</p>
<ul>
<li>应用层程序分别选择 TCP 或 UDP 作为传输层协议</li>
<li>为了区分不同网络程序：TCP 和 UDP 规定用不同端口号表示不同的应用程序</li>
</ul>
<p>端口号分配方法</p>
<ul>
<li>数值范围：0 ~ 65535</li>
<li>类型（端口号范围从小到大）：</li>
<li>熟知端口号、注册端口号、临时端口号</li>
</ul>
<p>临时端口号：49152 ~ 65535</p>
<ul>
<li>由 TCP/UDP 软件随机选取，只对一次进程通信有效</li>
</ul>
<p>注册端口号：1024 ~ 49151</p>
<ul>
<li>用户开发一种新的网络应用程序时，为防止应用在 Internet 使用出现冲突而在 IANA 登记的端口号</li>
</ul>
<p>熟知端口号（Well-Known Port Number，公认端口号）：0 ~ 1023（系统端口）</p>
<ul>
<li>TCP / UDP 为每种标准的 Internet 服务器进程分配一个确定的全局端口号</li>
<li>每个客户进程都知道响应的服务器进程的熟知端口号</li>
<li>由 IANA 统一分配。查询：<a target="_blank" rel="noopener" href="http://www.iana.org/">http://www.iana.org/</a></li>
</ul>
<p>TCP 的熟知端口号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口号</th>
<th>服务进程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>20</td>
<td>FTP</td>
<td>文件传输协议（数据连接）</td>
</tr>
<tr>
<td>21</td>
<td>FTP</td>
<td>文件传输协议（控制连接）</td>
</tr>
<tr>
<td>23</td>
<td>TELNET</td>
<td>网络虚拟终端协议</td>
</tr>
<tr>
<td>25</td>
<td>SMTP</td>
<td>简单邮件传输协议</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>超文本传输协议</td>
</tr>
<tr>
<td>179</td>
<td>BGP</td>
<td>边界路由协议</td>
</tr>
</tbody>
</table>
</div>
<p>进程标识方法示意图：</p>
<h1 id="多重协议的识别"><a href="#多重协议的识别" class="headerlink" title="多重协议的识别"></a>多重协议的识别</h1><ul>
<li>网络中进行通信（使用同一种应用程序）的两台主机，必须在通信前确定都采用 TCP，还是都采用 UDP</li>
<li>如考虑到进程标识和多重协议的识别，网络环境中一个进程的全网唯一标识应该使用三元组</li>
<li>在 UNIX 中称为“半相关”（half-association）：<ul>
<li>协议（TCP）</li>
<li>本地地址（10.116.50.5）</li>
<li>本地端口号（8080）</li>
</ul>
</li>
<li>完整的进程通信标识（一个完整的 Socket）——使用五元组（“相关”）表示：<ul>
<li>协议（TCP）</li>
<li>本地地址（202.1.2.5）</li>
<li>本地端口号（30022）</li>
<li>远程地址（121.5.21.2）</li>
<li>远程端口号（22）</li>
</ul>
</li>
</ul>
<p>传输层多路复用（multiplexing）与多路分解（demultiplexing）</p>
<ul>
<li>一台运行 TCP/IP 协议的主机可能同时运行不同的应用程序</li>
<li>TCP/IP 协议允许多个不同的应用程序的数据同时使用 IP 地址和一个物理连接来发送和接收数据<ul>
<li>发送端：IP 协议将 TCP 或 UDP 的传输协议数据单元 TPDU 都封装成一个 IP 分组发送出去</li>
<li>接收端：IP 协议将从 IP 分组拆开的 TPDU 传送到传输层，由传输层根据不同 TPDU 端口号区分不同 TPDU 属性，分别传送至对应的应用程序</li>
</ul>
</li>
</ul>
<p>TCP、UDP 与应用层关系：<br>应用层协议中：</p>
<ul>
<li>一种依赖 TCP（主要是需要大量传输交互式报文的协议）</li>
<li>一种依赖 UDP（如 P2P 会话类应用）</li>
<li>一些两种都依赖（如 DNS）</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
              <a href="/tags/TCP/" rel="tag"># TCP</a>
              <a href="/tags/UDP/" rel="tag"># UDP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/17/ipv4/" rel="prev" title="网络层与 IPv4">
      <i class="fa fa-chevron-left"></i> 网络层与 IPv4
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.</span> <span class="nav-text">传输层与传输层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%AE%9E%E4%BD%93"><span class="nav-number">1.1.</span> <span class="nav-text">传输实体</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDP"><span class="nav-number">2.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E5%A4%B4%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">UDP 头结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.2.</span> <span class="nav-text">适用的应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP"><span class="nav-number">3.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%A4%B4%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">TCP 头结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%87%8A%E6%94%BE%EF%BC%9A%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.3.</span> <span class="nav-text">TCP 连接建立和释放：三次握手与四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E7%A1%AE%E8%AE%A4%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">TCP 协议滑动窗口与确认重传机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%AD%97%E8%8A%82%E6%B5%81%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB"><span class="nav-number">3.4.1.</span> <span class="nav-text">传输字节流状态分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.</span> <span class="nav-text">TCP 协议滑动窗口与流量控制、拥塞机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%95%E5%85%83-Socket"><span class="nav-number">4.</span> <span class="nav-text">通信单元 Socket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E6%96%B9%E6%B3%95%EF%BC%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">5.</span> <span class="nav-text">进程标识方法：端口号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AF%86%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">多重协议的识别</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">敖惠竣｜Ao Huijun, Raymond</p>
  <div class="site-description" itemprop="description">Storing blogs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/daca-ao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;daca-ao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/realkaije" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;realkaije" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/daca.aohuijun" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;daca.aohuijun" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/kaijesugardaddy" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;kaijesugardaddy" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">敖惠竣｜Ao Huijun, Raymond</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
