<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>适配器模式（Adapter）</title>
    <url>/2021/06/22/adapter/</url>
    <content><![CDATA[<p>适配器模式属于结构型模式，具体有对于类或对象的不同形态。</p>
<span id="more"></span>
<p>有的时候，我们需要实现两个不同接口的类之间的通信。基于不修改这两个类的前提，我们需要某个<strong>中间件</strong>（适配器）完成衔接的过程，此时我们可以使用适配器模式。</p>
<p>《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“将一个类的接口转换为客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作”
</code></pre><p>可让两个原本不兼容的接口完成无缝对接。</p>
<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><strong>类适配器</strong>模式：</p>
<p><img src="/2021/06/22/adapter/class-adapter.gif" alt></p>
<p><br></p>
<p><strong>对象适配器</strong>模式：</p>
<p><img src="/2021/06/22/adapter/instance-adapter.gif" alt></p>
<p><br></p>
<p>以上，可见适配器模式包括：</p>
<p><code>Target</code></p>
<ul>
<li>目标抽象类</li>
</ul>
<p><code>Adapter</code></p>
<ul>
<li>适配器类</li>
<li>通过在内部包装一个 Adaptee，将源接口转换成目标接口</li>
</ul>
<p><code>Adaptee</code></p>
<ul>
<li>适配者类</li>
<li>需要适配的类</li>
</ul>
<p><code>Client</code></p>
<ul>
<li>客户类</li>
</ul>
<p><br></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>继承或依赖（推荐）</p>
<p>以类适配器实现为例：</p>
<p><img src="/2021/06/22/adapter/adapter-example.png" alt></p>
<p>说明：</p>
<ul>
<li>想让 AudioPlayer 播放其它格式的音频文件</li>
<li>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>Adaptee 适配者类接口及其实现类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实体类： </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing vlc file. Name: &quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing mp4 file. Name: &quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器类接口及其实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>) ) &#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>)) &#123;</span><br><span class="line">            advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">            advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>封装对适配器类的调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MediaAdapter mediaAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 播放 mp3 音乐文件的内置支持</span></span><br><span class="line">        <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;mp3&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Playing mp3 file. Name: &quot;</span>+ fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 适配器 mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>) || audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">            mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">            mediaAdapter.play(audioType, fileName);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Invalid medium. &quot;</span>+ audioType + <span class="string">&quot; format not supported&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户类的调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">audioPlayer.play(<span class="string">&quot;mp3&quot;</span>, <span class="string">&quot;beyond the horizon.mp3&quot;</span>);</span><br><span class="line">audioPlayer.play(<span class="string">&quot;mp4&quot;</span>, <span class="string">&quot;alone.mp4&quot;</span>);</span><br><span class="line">audioPlayer.play(<span class="string">&quot;vlc&quot;</span>, <span class="string">&quot;far far away.vlc&quot;</span>);</span><br><span class="line">audioPlayer.play(<span class="string">&quot;avi&quot;</span>, <span class="string">&quot;mind me.avi&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><ol>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。</li>
<li>通过接口转换，将一个类插入另一个类系中。<ul>
<li>比如：轿车和皮卡，现在多了一个 SUV</li>
<li>在不增加实体的需求下，增加一个适配器，在里面包容一个皮卡，实现轿车的接口</li>
</ul>
</li>
</ol>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p>
<ol>
<li>可以让任何两个没有关联的类一起运行。</li>
<li>提高了类的复用。</li>
<li>增加了类的透明度。</li>
<li>灵活性好。</li>
</ol>
<p>缺点</p>
<ol>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。<ul>
<li>如：明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现</li>
<li>一个系统如果太多出现这种情况，无异于一场灾难。</li>
<li>因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li>
</ul>
</li>
<li>由于 Java 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解（Annotation）</title>
    <url>/2021/07/22/annotation/</url>
    <content><![CDATA[<p>从 Java 5 开始，官方开始引入注释机制，程序员们也可以通过自定义注解实现各种需求。</p>
<span id="more"></span>
<p>Java 注解是通过<strong>反射</strong>获取注解内容的；在编译器生成类文件时，注解可被嵌入到字节码中。</p>
<ul>
<li>JVM 可保留注解的内容，运行时会获得注解内容</li>
<li>类、方法、变量、参数、包都可被标注</li>
<li>支持自定义注解</li>
</ul>
<h1 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  <span class="comment">// 检查该方法是否为重写方法</span></span><br><span class="line"><span class="meta">@Deprecated</span>  <span class="comment">// 标记过时方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>  <span class="comment">// 指示编译器忽略注解声明的警告</span></span><br><span class="line"><span class="meta">@Retention</span>  <span class="comment">// 标记该注解如何保存（RetentionPolicy），是只存在代码中，还是编入 class 文件中，或是在运行时通过反射访问</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">// 标记注解是否包含在用户文档中</span></span><br><span class="line"><span class="meta">@Target</span>  <span class="comment">// 注解使用的目标范围（ElementType，包括类、方法、字段等），标记注解是哪种 Java 成员</span></span><br><span class="line"><span class="meta">@Inherited</span>  <span class="comment">// 标记这个注解继承自哪个注解类（默认 注解并没有继承任何子类）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SafeVarargs</span>  <span class="comment">// since Java 7，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告</span></span><br></pre></td></tr></table></figure>
<p>Since Java 8:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Native</span>  <span class="comment">// 指定字段是一个常量</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span>  <span class="comment">// 标记一个匿名函数或函数式接口</span></span><br><span class="line"><span class="meta">@Repeatable</span>  <span class="comment">// 标记某注解可在同一声明使用多次</span></span><br></pre></td></tr></table></figure></p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/2021/07/22/annotation/annotation.jpg" alt></p>
<p>如上图，1 个 Annotation 和 1 个 RetentionPolicy 关联，和 1 到 n 个 ElementType 关联（图左），有很多实现类（图右）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 每个实现 Annotation 的对象都会有唯一的 RetentionPolicy 属性，有一到多个 ElementType 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,       <span class="comment">// Annotation 信息仅存在于编译器处理期间，编译器处理完之后就没有该 Annotation 信息了</span></span><br><span class="line"></span><br><span class="line">    CLASS,        <span class="comment">// 编译器将 Annotation 存储于类对应的 .class 文件中。默认行为</span></span><br><span class="line"></span><br><span class="line">    RUNTIME       <span class="comment">// 编译器将 Annotation 存储于 class 文件中，且可由 JVM 读入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    TYPE,               <span class="comment">// 类、接口（包括注释类型）或枚举声明</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">// 字段声明（包括枚举常量）</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">// 方法声明</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">// 参数声明</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">// 构造方法声明</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">// 局部变量声明</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">// 注释类型声明</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">// 包声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// @interface 定义注解</span></span><br><span class="line">    <span class="comment">// @Target 指定 Annotation 的类型属性</span></span><br><span class="line">    <span class="comment">// @Retention </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 源码浅析</title>
    <url>/2021/06/07/arraylist/</url>
    <content><![CDATA[<p>ArrayList 是 List 接口最常用的通用实现。</p>
<span id="more"></span>
<p>概述：</p>
<ul>
<li>底层由一个 Object 数组维护</li>
<li>构造时会设置一个初始的容量，元素增加时会自动扩容</li>
<li>必要时如元素为大对象，可手动缩容</li>
<li>线程不安全</li>
</ul>
<p><br></p>
<h1 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList 默认的容量为 10 个 Object 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层数据结构</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;  <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录集合被修改的次数，每次 add 或者 remove 它的值都会加 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ArrayList 非线程安全，在使用迭代器遍历时，该变量用来检查列表中的元素是否发生结构性变化（列表元素数量发生改变）</span></span><br><span class="line"><span class="comment"> * 主要在多线程环境下需要使用，防止一个线程正在迭代遍历，另一个线程修改了这个列表的结构。</span></span><br><span class="line"><span class="comment"> * 不一致时会抛出异常 ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;   <span class="comment">// modified count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment"> * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment"> * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment"> * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要分配的数组的最大大小。一些 vm 在数组中保留一些头字。</span></span><br><span class="line"><span class="comment"> * 尝试分配较大的数组可能会导致 OOM：请求的数组大小超过了虚拟机限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// MAX_ARRAY_SIZE=2147483639=01111111 11111111 11111111 11110111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 调用 Arrays.copyOf() 方法进行复制</span></span><br><span class="line"><span class="comment"> 对于空的源集合：创建一个空的 ArrayList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> JDK 1.7-: 直接调用 ArrayList(DEFAULT_CAPACITY)，即 ArrayList(10)</span></span><br><span class="line"><span class="comment"> JDK 1.8: 直接将 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 赋给数组，实际上是一个空的 Object 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; <span class="comment">// Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> JDK 1.7-: 直接通过参数的正负创建指定大小的数组，或抛出异常</span></span><br><span class="line"><span class="comment"> JDK 1.8: </span></span><br><span class="line"><span class="comment">    参数为正：创建指定大小的数组</span></span><br><span class="line"><span class="comment">    参数为零：将一个 EMPTY_ELEMENTDATA 空数组赋值给数组</span></span><br><span class="line"><span class="comment">    参数为负：抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span> +</span><br><span class="line">                    initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="添加元素-amp-动态扩容"><a href="#添加元素-amp-动态扩容" class="headerlink" title="添加元素 &amp; 动态扩容"></a>添加元素 &amp; 动态扩容</h1><p>ArrayList 添加元素前会确保容量足够，如不足则会进行扩容，初始容量 <code>DEFAULT_CAPACITY = 10</code>。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：第一次新增元素 e = &quot;a1&quot;，list.add(&quot;a1&quot;);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 确定是否需要扩容，如果需要，则进行扩容操作 */</span></span><br><span class="line">   ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">   <span class="comment">// 动态扩容的重点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// eg1：size = 0，elementData[0] = &quot;a1&quot;，然后 size 自增为 1</span></span><br><span class="line">   elementData[size++] = e;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：第一次新增元素：size = 0，minCapacity = size + 1 = 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// eg1：第一次新增元素，calculateCapacity 方法返回 DEFAULT_CAPACITY = 10</span></span><br><span class="line">   ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算 ArrayList 当前的容量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 elementData 数组中没有已存储的元素，则返回默认值 10</span></span><br><span class="line"><span class="comment"> * 否则返回 minCapacity。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elementData  底层存储 ArrayList 元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity  ArrayList 中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：第一次新增元素，elementData = &#123;&#125;, minCapacity = 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      <span class="comment">// eg1：满足 if 判断，DEFAULT_CAPACITY = 10</span></span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);  <span class="comment">// 即：数组元素少于 10 的，容量都设定为 10</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保明确的 ArrayList 的容量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity  ArrayList 所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：第一次新增元素，minCapacity = 10</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// eg1: modCount++ 后，modCount = 1</span></span><br><span class="line">   modCount++;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 如果所需的最小容量大于 elementData 数组容量，则进行扩容操作 */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) &#123; <span class="comment">// eg1：10 - 0 = 10，满足扩容需求</span></span><br><span class="line">      <span class="comment">// eg1：minCapacity = 10</span></span><br><span class="line">      <span class="comment">// 如果所需最小容量大于 elementData 容量，则 ArrayList 目前容量不满足最小容量</span></span><br><span class="line">      grow(minCapacity);  <span class="comment">// 扩容</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity  所需要的最小扩容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：第一次新增元素，minCapacity = 10，即：需要将 elementData 长度从 0 扩容为 10。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 1. 确定原有数组 elementData 的长度 */</span></span><br><span class="line">   <span class="keyword">int</span> oldCapacity = elementData.length;  <span class="comment">// eg1：oldCapacity = 0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A &gt;&gt; 1 右移，等于 A/2</span></span><br><span class="line"><span class="comment">    * eg: 3 &gt;&gt; 1 = 3/2 = 1</span></span><br><span class="line"><span class="comment">    *     4 &gt;&gt; 1 = 4/2 = 2</span></span><br><span class="line"><span class="comment">    * ------------------------</span></span><br><span class="line"><span class="comment">    * A &lt;&lt; 1 左移，等于 A*2</span></span><br><span class="line"><span class="comment">    * eg: 3 &lt;&lt; 1 = 3*2 = 6</span></span><br><span class="line"><span class="comment">    *     4 &lt;&lt; 1 = 4*2 = 8</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 000100 &gt;&gt; 1 = 000010</span></span><br><span class="line"><span class="comment">    * 000100 &lt;&lt; 1 = 001000</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">/* 2. 新增 oldCapacity 的一半整数长度作为 newCapacity 的额外增长长度，即扩容为原来 1.5 倍 */</span></span><br><span class="line">   <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// eg1：newCapacity = 0 + (0 &gt;&gt; 1) = 0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 3. 增加之后，新的长度 newCapacity 依然无法满足所需最小扩容量 minCapacity，则新的扩容长度为 minCapacity */</span></span><br><span class="line">   <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// eg1：newCapacity=10</span></span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 4. 新的扩容长度 newCapacity 若超出了最大的数组长度 MAX_ARRAY_SIZE： */</span></span><br><span class="line">   <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 对于溢出情况的限制逻辑</span></span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 扩展数组长度为 newCapacity，并且将旧数组中的元素赋值到新的数组中 */</span></span><br><span class="line">   <span class="comment">// eg1：newCapacity = 10， 扩容 elementData 的 length = 10</span></span><br><span class="line">   elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，扩容关键语句是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7+</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>容量不足时，新容量为旧的 1.5 倍</li>
<li>位运算容量计算效率更高</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 1.6-</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>新容量为旧的 1.5 倍加 1</li>
</ul>
<p>可以看到的是，扩容方法是通过将<strong>整个数组拷贝</strong>的方式完成的。<br>因此要注意的是，对于大对象数组需考虑性能问题，提前规划容量，降低扩容频率。</p>
<p>总结如下：</p>
<p><img src="/2021/06/07/arraylist/arraylist-add.png" alt></p>
<p><br></p>
<h1 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   rangeCheck(index);  <span class="comment">// 检查下标：如大于 size 则抛出 IndexOutOfBoundsException 异常</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：elementData 保存了 &#123;&quot;a1&quot;,&quot;a2&quot;,&quot;a3&quot;,&quot;a4&quot;&#125;，删除第一个元素，即：index = 0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 校验传入的参数 index 是否超出了数组下标，如果超出，则抛出 IndexOutOfBoundsException 异常 */</span></span><br><span class="line">   rangeCheck(index);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 集合的修改次数加 1 */</span></span><br><span class="line">   modCount++;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// eg1：String oldValue = &quot;a1&quot;</span></span><br><span class="line">   <span class="comment">/* 获得index下标对应的旧值 oldValue */</span></span><br><span class="line">   E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// eg1：numMoved = 4 - 0 - 1 = 3</span></span><br><span class="line">   <span class="comment">/* 获得需要移动元素的个数 */</span></span><br><span class="line">   <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 从需要删除的 index 后一位开始到末尾的这部分数据，整体向前移动一个元素位置。</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 方法：将 elementData 从 index+1 开始，</span></span><br><span class="line"><span class="comment">       * 移动 numMoved 个元素，覆盖 elementData 从 index 开始的数据</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * eg1：删除 a1，index = 0, numMoved = 3</span></span><br><span class="line"><span class="comment">       * 则从 index+1 = 1 开始移动 3 个元素</span></span><br><span class="line"><span class="comment">       * 则从 &#123;a1, a2, a3, a4&#125; 移动成 &#123;a2, a3, a4, a4&#125;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 所谓的移动，其实是复制</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 通知 jvm 将之前的最后一位元素进行垃圾回收 */</span></span><br><span class="line">   <span class="comment">// eg1：回收最后一个 a4</span></span><br><span class="line">   elementData[--size] = <span class="keyword">null</span>;  <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 返回已被删除的元素 */</span></span><br><span class="line">   <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除节点的<strong>关键</strong>在于：删除某元素后，索引后<strong>元素的整体移动</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br></pre></td></tr></table></figure>
<p>因此 ArrayList 的删除性能需要考虑进元素<strong>移动</strong>的时间复杂度。</p>
<h1 id="与其它集合的比较"><a href="#与其它集合的比较" class="headerlink" title="与其它集合的比较"></a>与其它集合的比较</h1><h2 id="ArrayList-v-s-Array"><a href="#ArrayList-v-s-Array" class="headerlink" title="ArrayList v.s. Array"></a>ArrayList v.s. Array</h2><ul>
<li>Array 可容纳基本类型和对象；ArrayList 只能容纳对象</li>
<li>Array 指定大小，ArrayList 大小固定</li>
<li>Array 的接口较少，但使用多维数组更方便</li>
</ul>
<h2 id="ArrayList-v-s-Vector"><a href="#ArrayList-v-s-Vector" class="headerlink" title="ArrayList v.s. Vector"></a>ArrayList v.s. Vector</h2><ul>
<li>两者均使用<strong>数组</strong>方式存储数据（基于索引），数组元素数大于实际存储的数据以便增加和插入元素</li>
<li>两者均维护插入的顺序，都允许直接按照序号索引元素<ul>
<li>但插入元素要涉及数组元素移动等内存操作：索引数据快，但插入数据慢</li>
</ul>
</li>
<li>迭代器实现都是 fail-fast 的</li>
<li>Vector 由于使用 synchronized 方法（同步，线程安全），通常性能上较 ArrayList 差<ul>
<li>寻求迭代时对列表进行改变：使用 <code>CopyOnWriteArrayList</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合类</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2022/07/19/binary-search-tree/</url>
    <content><![CDATA[<p>Binary search tree，也叫二叉查找树、有序二叉树。</p>
<span id="more"></span>
<h1 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h1><p>先来说说搜索树。</p>
<p>提出搜索树的背景，是使用散列描述字典时遇到了瓶颈。</p>
<p>先是按关键字的升序输出字典元素：</p>
<ol>
<li>使用除数为 D 的链表，需要 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.483ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4191.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g><g data-mml-node="mo" transform="translate(2202.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3202.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3802.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时间内取出元素，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时间内排序，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时间内输出：因此一共需要 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.691ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6051.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g><g data-mml-node="mo" transform="translate(2202.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3202.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3802.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(4100.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(4585.4,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(5062.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5662.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 单位的时间；</li>
<li>对散列使用线性开型寻址：需要 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="12.788ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5652.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(1803.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2803.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3403.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(3701.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(4186.4,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(4663.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5263.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，其中取出元素需要 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.457ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1970 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(1581,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 429 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g></g></svg></mjx-container> 是桶的个数。</li>
</ol>
<p>随后，是按升序找到第 k 个元素 / 删除第 k 个元素。</p>
<ol>
<li>以上两个场景，如果使用链表来描述，需要在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.483ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4191.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g><g data-mml-node="mo" transform="translate(2202.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3202.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3802.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时间内完成</li>
<li>如果使用线性开型寻址，则时间复杂度是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.457ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1970 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(1581,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
<li>必须采用线性时间确定 n 元素集合中第 k 个元素</li>
</ol>
<p>因此搜索树，尤其是二叉搜索树适合描述<strong>字典</strong>，即：使用搜索树描述 n 个元素的字典：</p>
<ul>
<li>搜索、插入或删除所需的平均时间和最坏时间均为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> </li>
<li>按关键字升序输出元素：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
<li>按元素排名查找和删除操作耗时 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> </li>
<li>所有字典元素能在线性时间内按升序输出</li>
<li>无论是平衡还是非平衡的搜索树，顺序访问某个元素平均所需时间为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>搜索树是<strong>基础性数据结构</strong>（ADT），用于构建更为抽象的数据结构，如集合、multiset、关联数组等。</p>
<p>相比于其他数据结构，二叉搜索树的优势在于查找、插入、删除的时间复杂度较低，最坏时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>常见的搜索树有：</p>
<ul>
<li>自平衡二叉树，包括 <strong><a href="/2023/05/26/avl">AVL 树</a></strong>、<strong><a href="/2023/05/27/red-black">红-黑树</a></strong></li>
<li><strong><a href="/2023/06/04/b-tree">B 树</a></strong>：对读写操作进行优化的自平衡 N 叉搜索树，非叶子节点里拥有<strong>多于两个子节点</strong></li>
</ul>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p>二叉搜索树满足以下特征：</p>
<ul>
<li>若任意节点左子树非空，则左子树上所有节点的值均 &lt;（小于）其根节点的值</li>
<li>若任意节点右子树非空，则右子树上所有节点的值均 &gt;（大于）其根节点的值</li>
<li>任意节点的左、右子树也分别为二叉查找树</li>
<li>每个节点有一个关键值（key），<strong>没有键值相等</strong>的节点（no duplicate nodes）</li>
</ul>
<p>注：如将“小于”换成“小于等于”，“大于”换成“大于等于”，则会得到一棵有重复值的二叉搜索树</p>
<p>延伸：带索引的（indexed）二叉搜索树</p>
<ul>
<li>在每个节点中添加一个 LeftSize 域</li>
<li>该域值为该节点左子树的元素个数加一</li>
<li>该值同时给出了一个元素在子树中的排名</li>
<li>调用中序输出 InOrderOutput 将二叉搜索树按照升序输出：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
<li>搜索：按照索引查找</li>
<li>插入：需要更新插入沿途所有节点的 LeftSize 值：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.79ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2117 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(1728,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p><img src="/2022/07/19/binary-search-tree/binary-search-tree.png" alt></p>
<h1 id="操作与实现"><a href="#操作与实现" class="headerlink" title="操作与实现"></a>操作与实现</h1><p>先定义二叉搜索树的节点类 BinaryTreeNode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode leftChild = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode rightChild = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// 构造函数、getters &amp; setters</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>跟普通二叉树的节点没区别。</p>
<p>二叉搜索树除了拥有普通二叉树的方法（前中后序遍历、层级遍历、比较、复制等），其基本操作方法会有所区分，比如最基本的几个：</p>
<p><br></p>
<h2 id="搜索节点"><a href="#搜索节点" class="headerlink" title="搜索节点"></a><a href="https://github.com/daca-ao/Algos/blob/master/com/raymond/structures/AbstractBinarySearchTree.java#L4">搜索节点</a></h2><p>指导思想：比根节点大的，往右子树找；比根节点小的，往左子树找；否则，当前节点就是你要的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode&lt;T&gt; <span class="title">search</span><span class="params">(T value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        System.err.println(<span class="string">"Tree null."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">        System.err.println(<span class="string">"No operation for null value."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode&lt;T&gt; curr = root;</span><br><span class="line">    <span class="keyword">while</span> (value != curr.getValue()) {  <span class="comment">// 值不相等的时候</span></span><br><span class="line">        <span class="comment">// 比当前节点大的，进入右子树，否则进入左子树</span></span><br><span class="line">        curr = value.compareTo(curr.getValue()) &gt; <span class="number">0</span> ? </span><br><span class="line">                curr.getRightChild() : curr.getLeftChild();</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 不存在相等的节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> curr;  <span class="comment">// 否则返回当前节点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.79ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2117 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(1728,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，其中 h 为树的高度。</p>
<h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a><a href="https://github.com/daca-ao/Algos/blob/master/com/raymond/structures/BinarySearchTree.java#L7">添加节点</a></h2><p>指导思想：比根节点大的，往右子树插入；比根节点小的，往左子树插入；不接受已存在的节点值的添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(T value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">        System.err.println(<span class="string">"Please do not insert a null value."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        root = <span class="keyword">new</span> BinaryTreeNode&lt;&gt;(value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    BinaryTreeNode&lt;T&gt; node = <span class="keyword">new</span> BinaryTreeNode&lt;&gt;(value);</span><br><span class="line">    BinaryTreeNode&lt;T&gt; curr = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        BinaryTreeNode&lt;T&gt; parent = curr;</span><br><span class="line">        <span class="keyword">if</span> (value.compareTo(curr.getValue()) &gt; <span class="number">0</span>) {  <span class="comment">// 比根节点大的，往右子树插入</span></span><br><span class="line">            curr = curr.getRightChild();</span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="keyword">null</span>) {</span><br><span class="line">                parent.setRightChild(node);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (value.compareTo(curr.getValue()) &lt; <span class="number">0</span>) {  <span class="comment">// 比根节点小的，往左子树插入</span></span><br><span class="line">            curr = curr.getLeftChild();</span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="keyword">null</span>) {</span><br><span class="line">                parent.setLeftChild(node);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.err.println(<span class="string">"Node "</span> + value + <span class="string">" already there."</span>);</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 不接受重复节点添加</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><a href="https://github.com/daca-ao/Algos/blob/master/com/raymond/structures/BinarySearchTree.java#L40">删除节点</a></h2><p>二叉搜索树删除节点 p，分三种情况：</p>
<ol>
<li>p 是树叶：直接删除</li>
<li>p 只有一棵非空子树<ul>
<li>p 没有父节点（即 p 为根节点）：将 p 丢弃，p 的唯一子树的根节点成为新的搜索树根节点</li>
<li>p 存在父节点 pp：修改 pp 指针，令其指向 p 的唯一子树</li>
</ul>
</li>
<li>p 有两棵非空子树<ul>
<li>将 p 替换为其<strong>左子树的最大值</strong>（<strong>前驱</strong>节点），或者<strong>右子树的最小值</strong>（<strong>后驱</strong>节点）</li>
<li>寻找左子树最大元素：沿着子树各节点的右孩子指针移动，直到右孩子指针为 <code>null</code></li>
<li>寻找右子树最小元素：沿着子树各节点的左孩子指针移动，直到左孩子指针为 <code>null</code></li>
</ul>
</li>
</ol>
<p>注意：如果节点 p 的左子树为空，则 p 的前驱节点为 p 的第一个有右孩子且左子树没有 p 节点的祖先。</p>
<p>举个例子：</p>
<p><img src="/2022/07/19/binary-search-tree/delete.png" alt></p>
<p>如上图，当我们要删除 <code>a)</code> 中值为 40 的元素的时候：</p>
<ul>
<li>可以选择其右子树的最小值（60）为新的父节点，如 <code>b)</code> 所示</li>
<li>也可选择其左子树的最大值（35）为新的父节点，如 <code>c)</code> 所示</li>
<li>节点选择完毕并删除后，搜索树需要<strong>重新构建</strong>。</li>
</ul>
<p>再比如：删除 <code>c)</code> 中值为 30 的元素，如选择其左子树的最大值（5）为新的父节点，便如 <code>d)</code> 所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteNode</span><span class="params">(T value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        System.err.println(<span class="string">"Tree null. Deletion failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"No operation for null value."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search out the node</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; curr = root;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; parent = root;</span><br><span class="line">    <span class="keyword">boolean</span> isInLeft = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (value != curr.getValue()) {</span><br><span class="line">        isInLeft = value.compareTo(curr.getValue()) &lt; <span class="number">0</span>;  <span class="comment">// 要删除的节点是左子树还是右子树</span></span><br><span class="line">        parent = curr;</span><br><span class="line">        curr = isInLeft ? curr.getLeftChild() : curr.getRightChild();</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="keyword">null</span>) {  <span class="comment">// 找不到要删除的元素</span></span><br><span class="line">            System.err.println(<span class="string">"Element not found."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 找到了要删除的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建二叉搜索树</span></span><br><span class="line">    <span class="keyword">if</span> (curr.getLeftChild() == <span class="keyword">null</span> &amp;&amp; curr.getRightChild() == <span class="keyword">null</span>) {  <span class="comment">// 叶子结点：直接删除</span></span><br><span class="line">        System.out.println(<span class="string">"Deleting leaf "</span> + value + <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (isInLeft) {</span><br><span class="line">            parent.setLeftChild(<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.setRightChild(<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 有且只有一棵非空子树</span></span><br><span class="line">    <span class="keyword">if</span> (curr.getLeftChild() == <span class="keyword">null</span> || curr.getRightChild() == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">boolean</span> isLeftExist = curr.getLeftChild() != <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"Deleting node "</span> + value + <span class="string">" with "</span> + </span><br><span class="line">                (isLeftExist ? <span class="string">"left"</span> : <span class="string">"right"</span>) + <span class="string">" child."</span>);</span><br><span class="line">        <span class="keyword">if</span> (isInLeft) {</span><br><span class="line">            parent.setLeftChild(isLeftExist ? curr.getLeftChild() : curr.getRightChild());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.setRightChild(isLeftExist ? curr.getLeftChild() : curr.getRightChild());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 有左右两棵非空子树</span></span><br><span class="line">    System.out.println(<span class="string">"Deleting node "</span> + value + <span class="string">" with children."</span>);</span><br><span class="line">    BinaryTreeNode&lt;T&gt; predecessor = getPredecessorTree(curr);  <span class="comment">// 以前驱节点替换</span></span><br><span class="line">    <span class="keyword">if</span> (root == curr) {</span><br><span class="line">        root = predecessor;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (isInLeft) {</span><br><span class="line">        parent.setLeftChild(predecessor);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        parent.setRightChild(predecessor);</span><br><span class="line">    }</span><br><span class="line">    predecessor.setRightChild(curr.getRightChild());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前驱节点，并以此节点为根节点重建子树</span></span><br><span class="line"><span class="function">BinaryTreeNode&lt;T&gt; <span class="title">getPredecessorTree</span><span class="params">(BinaryTreeNode&lt;T&gt; node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    BinaryTreeNode&lt;T&gt; predParent = node;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; predecessor = node;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; curr = node.getLeftChild();</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) {</span><br><span class="line">        predParent = predecessor;</span><br><span class="line">        predecessor = curr;</span><br><span class="line">        curr = curr.getRightChild();  <span class="comment">// 获取到前驱节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果前驱节点不是刚好是 node 的左子树，而是在 node 左子树的右子树中：</span></span><br><span class="line">    <span class="keyword">if</span> (predecessor != node.getLeftChild()) {</span><br><span class="line">        predParent.setRightChild(predecessor.getLeftChild());</span><br><span class="line">        predecessor.setLeftChild(node.getLeftChild());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> predecessor;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.79ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2117 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(1728,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，其中 h 为树的高度。</p>
<ul>
<li>n 个元素的二叉搜索树高度可以为 n，但其平均时间为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/06/23/binary-tree/</url>
    <content><![CDATA[<p>二叉树可能不是计算机世界中最基本的数据结构，但是将它誉为计算机应用中的基石，这个赞誉并不为过。</p>
<span id="more"></span>
<p>了解二叉树之前，我们先来理一下“树”的概念。</p>
<h1 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h1><p>在计算机科学中，线性数据结构和表数据结构一般不适合描述具有<strong>层次结构</strong>的数据，比如祖先 - 后代、上级 - 下属、整体 - 部分之类的数据。</p>
<p>由此我们引入了一个新类型的非空有限元素的集合：<strong>树</strong>（<strong>tree</strong>）</p>
<ul>
<li>树的最高层元素称为根（root）</li>
<li>余下的非空元素组成该树的子树（subtree）</li>
<li>根在上，树在下</li>
<li>每棵树的末端为树的叶子（leaf node）</li>
</ul>
<p>一般的树的结构：</p>
<p><img src="/2022/06/23/binary-tree/tree.png" alt></p>
<p>树属于<strong>抽象数据类型</strong>（Abstract Data Type, <strong>ADT</strong>）。</p>
<h1 id="树的各个概念"><a href="#树的各个概念" class="headerlink" title="树的各个概念"></a>树的各个概念</h1><p>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。</p>
<p>子节点：一个节点如含有子树，则该子树的根节点称为该节点的子节点。</p>
<p>由此衍生的概念有：</p>
<ul>
<li>节点的祖先：从根到该节点所经过的分支上的所有节点</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点</li>
<li>堂兄弟节点：父节点在同一层的节点互为堂兄弟</li>
</ul>
<p>节点层次（level）：从根开始定义，根为第一层，根的子节点为第二层……以此类推。</p>
<p>树的高度/深度：树中节点的最大层次。</p>
<p>节点的<strong>度</strong>（<strong>degree</strong> of a node）：一个节点含有的子树的棵数</p>
<ul>
<li>树的度：一棵树中节点的度的最大值</li>
<li>叶节点/终端节点：度为 0 的节点</li>
<li>非终端节点/分支节点：度不为 0 的节点</li>
</ul>
<p>森林：没有回路的图，也可以看成由 m（m &gt; 0）棵互不相交的树的集合称为森林。</p>
<h1 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h1><p>按照节点次序可以分为：</p>
<ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，也称为自由树</li>
<li>有序树：树中任意节点的子节点之间有顺序关系</li>
</ul>
<p>有序树中，按照度的数量，可以分为：</p>
<ul>
<li>二叉树</li>
<li>N 叉树</li>
</ul>
<p><br></p>
<p>本帖主要介绍二叉树，这也是计算机科学中最常用的树型数据结构。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>与树不同的是，二叉树可以为空。当二叉树非空时，包括：</p>
<ul>
<li>根元素</li>
<li>两棵子二叉树，分别叫左子树和右子树</li>
</ul>
<p>二叉树和树的<strong>根本区别</strong>：</p>
<ul>
<li>二叉树可以为空；而树不能为空</li>
<li>二叉树的每个元素恰好有两棵子树（以左、右区分次序，可以为空）；而树中每个元素可以有若干个且无序的子树</li>
</ul>
<h2 id="二叉树特性"><a href="#二叉树特性" class="headerlink" title="二叉树特性"></a>二叉树特性</h2><ol>
<li>包含 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.623ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3811.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1866.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mn" transform="translate(2922.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(3422.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 个元素的二叉树，它的边的数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>若二叉树的高度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.515ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3763.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(965,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(1818.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mn" transform="translate(2874.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(3374.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，则该二叉树最少有 h 个元素，最多有 2h - 1 个元素</li>
<li>包含 n 个元素的二叉树，其高度最大为 n，最小为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.006ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5748.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"/></g><g data-mml-node="mi" transform="translate(444,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(742,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1227,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mn" transform="translate(1704,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(2204,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2593,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3415.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4415.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4915.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(5304.4,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"/></g></g></g></svg></mjx-container> （上取整数）</li>
<li>任意一棵二叉树中，若有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.804ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1239.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(836,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container> 个叶节点，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.804ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1239.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(836,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container> 个度为 2 的节点，则有：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="12.523ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 5535.1 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(836,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1517.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2573.1,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(836,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(4034.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(5035.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>设完全二叉树中任一元素的序号为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5235.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(734,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1511.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(2567.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3190.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(4246.1,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4846.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，则：<ol>
<li>当 i = 1 时，该元素为二叉树的根。若 i &gt; 1，则该元素父节点的序号为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2233 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="230A" d="M174 734Q174 735 175 737T177 740T180 744T184 747T189 749T196 750Q206 748 214 735V-210H310H373Q401 -210 411 -213T422 -230T411 -247T369 -251Q362 -251 338 -251T298 -250H190Q178 -246 174 -234V734Z"/></g><g data-mml-node="mi" transform="translate(444,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(789,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(1289,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(1789,0)"><path data-c="230B" d="M229 734Q229 735 230 737T232 740T235 744T239 747T244 749T251 750Q262 748 269 735V-235Q266 -240 256 -249L147 -250H77Q43 -250 32 -247T21 -230T32 -213T72 -209Q79 -209 99 -209T133 -210H229V734Z"/></g></g></g></svg></mjx-container> （下取整数）。</li>
<li>若 2i &gt; n，该元素无左孩子；否则其左孩子的编号为 2i 。</li>
<li>若 2i + 1 &gt; n，该元素无右孩子；否则其右孩子的编号为 2i + 1 。</li>
</ol>
</li>
<li>完全二叉树中，度为 1 的节点的数目要不是 1，要不是 0</li>
</ol>
<h2 id="二叉树的不同形态"><a href="#二叉树的不同形态" class="headerlink" title="二叉树的不同形态"></a>二叉树的不同形态</h2><p><strong>完全二叉树</strong>（Complete Binary Tree）</p>
<p>对于一棵深度为 d（d &gt; 1）的二叉树，除了第 d 层（叶子节点那一层）外其他各层节点数目<strong>已满</strong>，且第 d 层所有节点<strong>从左向右</strong>连续紧密排列。</p>
<p>我们称这样的二叉树为完全二叉树。</p>
<p>完全二叉树的特性：</p>
<ul>
<li>左孩子节点位置 = 当前父节点位置 * 2 + 1（从 0 开始）</li>
<li>右孩子节点位置 = 当前父节点位置 * 2 + 2</li>
</ul>
<p><img src="/2022/06/23/binary-tree/complete-binary-tree.png" alt></p>
<p><br></p>
<p>由完全二叉树衍生出来的：</p>
<p><strong>满二叉树</strong>（Perfect Binary Tree）完全二叉树去掉第 d 层所有节点之后，所剩下的部分构成一棵满二叉树。</p>
<ul>
<li>一棵深度为 d - 1 的二叉树含有 2(d - 1) - 1 个元素</li>
</ul>
<p><img src="/2022/06/23/binary-tree/perfect-binary-tree.png" alt></p>
<p><strong>完满二叉树</strong>（Full Binary Tree）：除了叶子节点之外的每一个节点都有两个孩子节点。</p>
<p><img src="/2022/06/23/binary-tree/full-binary-tree.png" alt></p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>确定高度</li>
<li>确定元素数目</li>
<li>复制单个元素 / 整棵树</li>
<li>打印二叉树</li>
<li>比较两棵二叉树</li>
<li>删除整棵树</li>
<li>……</li>
</ul>
<p>这些常用操作都可通过遍历二叉树来完成。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>通常有两种描述二叉树的结构：</p>
<p><strong>1</strong>. <strong>公式化描述</strong>：利用二叉树的特性 5</p>
<ol>
<li>可以将一棵二叉树与其对应的<strong>完全二叉树</strong>作为比较，逻辑上补全缺少的部分元素</li>
<li>将二叉树从上到下，从左到右编号后，再存储到数组中</li>
</ol>
<p><img src="/2022/06/23/binary-tree/incomplete-binary-tree.png" alt></p>
<p>缺点：如果对应的完全二叉树缺少的元素数量很多，就会非常浪费时间和空间，以右斜（right-skewed）二叉树最甚：</p>
<p><img src="/2022/06/23/binary-tree/right-skewed-binary-tree.png" alt></p>
<p><strong>2</strong>. <strong>链表描述</strong>：这是最常用的方法</p>
<ul>
<li>每个元素使用一个有两个指针域（leftChild, rightChild）和数据域 data 的节点表示</li>
<li>边可以用从父节点指向子节点的指针描述，指针存放于父节点指针域中</li>
<li>拥有 n 个元素的二叉树，会有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="20.54ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 9078.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1322.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(2322.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2711.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3533.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4533.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(5033.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(5700.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(6756.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7578.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(8578.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 个指针域没有值</li>
</ul>
<p><img src="/2022/06/23/binary-tree/chain-binary-tree.png" alt></p>
<p><br></p>
<p>本文我们用<strong>链表</strong>描述方式来实现二叉树的数据结构。</p>
<h3 id="节点类-BinaryTreeNode"><a href="#节点类-BinaryTreeNode" class="headerlink" title="节点类 BinaryTreeNode"></a>节点类 BinaryTreeNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode leftChild = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode rightChild = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(String data)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String data)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeftChild</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> leftChild;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftChild</span><span class="params">(BinaryTreeNode leftChild)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRightChild</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> rightChild;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightChild</span><span class="params">(BinaryTreeNode rightChild)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node data: "</span> + getData();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="二叉树类-BinaryTree"><a href="#二叉树类-BinaryTree" class="headerlink" title="二叉树类 BinaryTree"></a>二叉树类 BinaryTree</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(BinaryTreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRoot</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(BinaryTreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">visit</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.getData() == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"NULL node"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="comment">// 空间复杂度为 Ο(n)，时间复杂度为 Θ(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        visit(node);</span><br><span class="line">        preOrder(node.getLeftChild());</span><br><span class="line">        preOrder(node.getRightChild());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNonRecur</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Deque&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            visit(node);</span><br><span class="line">            <span class="comment">// 利用栈的 FILO 原理，右子树先入栈，后出栈</span></span><br><span class="line">            <span class="keyword">if</span> (node.getRightChild() != <span class="keyword">null</span>) {</span><br><span class="line">                stack.push(node.getRightChild());</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 左子树后入栈，先出栈</span></span><br><span class="line">            <span class="keyword">if</span> (node.getLeftChild() != <span class="keyword">null</span>) {</span><br><span class="line">                stack.push(node.getLeftChild());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="comment">// 空间复杂度为 Ο(n)，时间复杂度为 Θ(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        inOrder(node.getLeftChild());</span><br><span class="line">        visit(node);</span><br><span class="line">        inOrder(node.getRightChild());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderNonRecur</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Deque&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) {</span><br><span class="line">            <span class="comment">// 一直将左子树的左节点推进栈</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) {</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.getLeftChild();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 左节点操作完毕</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                visit(node);</span><br><span class="line">                node = node.getRightChild();  <span class="comment">// 再推右子树</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="comment">// 空间复杂度为 Ο(n)，时间复杂度为 Θ(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        postOrder(node.getLeftChild());</span><br><span class="line">        postOrder(node.getRightChild());</span><br><span class="line">        visit(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderNonRecur</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Deque&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        BinaryTreeNode prev = <span class="keyword">null</span>;  <span class="comment">// 避免重复遍历节点 -&gt; 右子树再添加的死循环</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) {</span><br><span class="line">            <span class="comment">// 先一直遍历到最左端子树左叶子</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) {</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.getLeftChild();</span><br><span class="line">            }</span><br><span class="line">            node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.getRightChild() == <span class="keyword">null</span> || node.getRightChild() == prev) {</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                visit(node);</span><br><span class="line">                prev = node;</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                node = node.getRightChild();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上的顺序遍历都是 DFS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐层遍历（BFS）</span></span><br><span class="line">    <span class="comment">// 时间复杂度为 Θ(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            BinaryTreeNode removed = queue.poll();</span><br><span class="line">            visit(removed);</span><br><span class="line">            <span class="keyword">if</span> (removed.getLeftChild() != <span class="keyword">null</span>) {</span><br><span class="line">                queue.add(removed.getLeftChild());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (removed.getRightChild() != <span class="keyword">null</span>) {</span><br><span class="line">                queue.add(removed.getRightChild());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述操作，对于满二叉树所需的空间为 Θ(n)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二叉树高度</span></span><br><span class="line">    <span class="comment">// 时间复杂度为 Θ(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="number">0</span> :</span><br><span class="line">            <span class="number">1</span> + Math.max(height(node.getLeftChild()), height(node.getRightChild()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定二叉树元素数目</span></span><br><span class="line">    <span class="comment">// 此处实现基于前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="number">0</span> :</span><br><span class="line">            <span class="number">1</span> + Math.addExtract(count(node.getLeftChild()), count(node.getRightChild()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(BinaryTreeNode p, BinaryTreeNode q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!p.getData().equals(q.getData())) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> compare(p.getLeftChild(), q.getLeftChild())</span><br><span class="line">                &amp;&amp; compare(p.getRightChild(), q.getRightChild());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制二叉树</span></span><br><span class="line">    <span class="comment">// 此处实现基于前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">copy</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">        BinaryTreeNode copied = <span class="keyword">new</span> BinaryTreeNode(node.getData());</span><br><span class="line">        copied.setLeftChild(copy(node.getLeftChild()));</span><br><span class="line">        copied.setRightChild(copy(node.getRightChild()));</span><br><span class="line">        <span class="keyword">return</span> copied;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(BinaryTreeNode node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        clear(node.getLeftChild());</span><br><span class="line">        clear(node.getRightChild());</span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">        clear(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="应用：数学表达树"><a href="#应用：数学表达树" class="headerlink" title="应用：数学表达树"></a>应用：数学表达树</h2><ul>
<li>前序遍历：前缀（prefix）表达式</li>
<li>中序遍历：中缀（infix）表达式</li>
<li>后序遍历：后缀（postfix）表达式</li>
</ul>
<p>例子：</p>
<p><img src="/2022/06/23/binary-tree/expression-tree.png" alt></p>
<p>遍历结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>树</th>
<th>a)</th>
<th>b)</th>
<th>c)</th>
</tr>
</thead>
<tbody>
<tr>
<td>前序</td>
<td>+*ab/cd</td>
<td>+++abcd</td>
<td>/+-a+xy<em>+b</em>ca</td>
</tr>
<tr>
<td>中序</td>
<td>a*b+c/d</td>
<td>a+b+c+d</td>
<td>-a+x+y/+b<em>c</em>a</td>
</tr>
<tr>
<td>后序</td>
<td>ab*cd/+</td>
<td>ab+c+d+</td>
<td>a-xy++b+ca**/</td>
</tr>
</tbody>
</table>
</div>
<h2 id="应用：二叉搜索树（Binary-Search-Tree）"><a href="#应用：二叉搜索树（Binary-Search-Tree）" class="headerlink" title="应用：二叉搜索树（Binary Search Tree）"></a>应用：<a href="/2022/07/19/binary-search-tree">二叉搜索树（Binary Search Tree）</a></h2>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL 树</title>
    <url>/2023/05/26/avl/</url>
    <content><![CDATA[<p>AVL 树是最先被发明的自平衡二叉查找树。</p>
<span id="more"></span>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>AVL 树是由 <strong>A</strong>delson-<strong>V</strong>elskii 和 <strong>L</strong>andis 共同提出的一种数据结构，因此得名。</p>
<p>所谓的“平衡”，指的是：</p>
<ol>
<li>左右子树的高度差小于等于 1；</li>
<li>其每一个子树均为平衡二叉树。</li>
</ol>
<p>为了保证二叉树的平衡，AVL 树引入了监督和自调节机制：在树的某一部分的不平衡度超过一个阈值时，会触发相应的平衡操作，保证其平衡度在可以接受的范围内。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>空的二叉树是 AVL 树。</p>
<p>对于非空二叉树，满足以下条件时为 AVL 树：</p>
<ul>
<li>其左子树和右子树都是 AVL 树</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="13.458ex" height="2.268ex" role="img" focusable="false" viewbox="0 -753 5948.2 1002.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="msub" transform="translate(278,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(609,-150) scale(0.707)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g><g data-mml-node="mo" transform="translate(1640.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(2641,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(609,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g><g data-mml-node="mo" transform="translate(3836.7,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mo" transform="translate(4392.5,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(5448.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.58ex" height="1.91ex" role="img" focusable="false" viewbox="0 -694 1140.5 844"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(609,-150) scale(0.707)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g></g></svg></mjx-container> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="2.705ex" height="1.943ex" role="img" focusable="false" viewbox="0 -694 1195.7 858.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(609,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></svg></mjx-container> 分别是左子树和右子树的高度<ul>
<li>即：在 AVL 树中任何节点的两个子树高度差<strong>不大于 1</strong></li>
<li>这种以高度为平衡条件的树也叫<strong>高度平衡树</strong></li>
</ul>
</li>
</ul>
<h2 id="衍生定义"><a href="#衍生定义" class="headerlink" title="衍生定义"></a>衍生定义</h2><p><strong>AVL 搜索树</strong>：既是二叉搜索树，也是 AVL 树的一种数据结构。</p>
<p><strong>带索引的 AVL 搜索树</strong>：顾名思义。</p>
<ul>
<li>图 1 <code>a)</code> <code>b)</code> 和 图 2 是 AVL 树，<code>c)</code> 不是</li>
<li>图 1 <code>a)</code> 不是 AVL 搜索树</li>
<li>图 2 是带索引的 AVL 搜索树</li>
</ul>
<p><img src="/2023/05/26/avl/avl-example.png" alt></p>
<p>另外，使用 AVL 树描述字典须具备：</p>
<ol>
<li>n 个元素（节点）的 AVL 树的高度是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> </li>
<li>对于每一个 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.623ex" height="2.269ex" role="img" focusable="false" viewbox="0 -753 3811.6 1003"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1866.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(2922.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(3422.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，都存在一棵 AVL 树结构与之对应<ul>
<li>否则完成插入后，一棵 AVL 树将不再是 AVL 树：因为对当前元素数量来说不存在对应的 AVL 树</li>
</ul>
</li>
<li>一棵 n 个元素的 AVL 搜索树能在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.723ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8275.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">高</text></g><g data-mml-node="mi" transform="translate(2152,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">度</text></g><g data-mml-node="mo" transform="translate(3152,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3818.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(4874.6,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(5637.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6026.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(6324.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(6809.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(7286.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7886.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 的时间内完成搜索</li>
<li>往一棵 n 元素的 AVL 搜索树中插入一个新元素，可得到一棵 n+1 元素的 AVL 树，该插入过程可在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 完成</li>
<li>从一棵 n 元素的 AVL 搜索树中删除一个元素，可得到一棵 n-1 元素的 AVL 树，该删除过程可在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 完成</li>
</ol>
<p>注：4. 包含了 2. </p>
<p>由此可得：</p>
<ul>
<li>AVL 树的查找、插入和删除操作在平均和最坏情况下都是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li>
</ul>
<h1 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h1><p>我们一般使用链表去描述 AVL 树。</p>
<p>为描述插入和删除操作给树带来的影响，我们为每个节点增加一个平衡因子 <code>bf</code> 的描述：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.161ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8469.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1940,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2606.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(3662.6,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="TeXAtom" transform="translate(605,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mi" transform="translate(681,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(5649.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(6649.5,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="TeXAtom" transform="translate(605,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g></g></g></svg></mjx-container> （x 左子树高度 - x 右子树高度，有时相反）</p>
<p>结合 AVL 树的定义我们可知：</p>
<ul>
<li>平衡因子 1、0、-1 的节点会被认为是平衡的，而 2 或者 -2 被认为是不平衡的，需要重新平衡；</li>
<li>因此增加或删除节点，可能需通过一次或者多次树旋转来重新平衡这个树。</li>
</ul>
<p><img src="/2023/05/26/avl/avl-bf.png" alt></p>
<h1 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h1><p>设 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.926ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 1293.3 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mi" transform="translate(836,-150) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></g></svg></mjx-container> 为一棵高度为 h 的 AVL 树最小节点数。</p>
<ul>
<li>最坏情况：根节点两棵子树一棵高度是 h-1，另一棵是 h-2，都是 AVL 树<ul>
<li>满足：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex;" xmlns="http://www.w3.org/2000/svg" width="38.464ex" height="2.016ex" role="img" focusable="false" viewbox="0 -683 17001.2 891"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mi" transform="translate(836,-150) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1571.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2626.8,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(836,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mo" transform="translate(5046,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(6046.3,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="TeXAtom" transform="translate(836,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g><g data-mml-node="mo" transform="translate(8465.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(9465.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(9965.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(10410.4,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(836,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(11927.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(12983.5,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(13483.5,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(13928.1,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(836,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(15445.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(16501.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> （与斐波那契数列相似）</li>
<li>也可：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex;" xmlns="http://www.w3.org/2000/svg" width="20.906ex" height="2.174ex" role="img" focusable="false" viewbox="0 -753 9240.5 961"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mi" transform="translate(836,-150) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1571.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2626.8,0)"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="TeXAtom" transform="translate(676,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g><g data-mml-node="mo" transform="translate(4886,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(5886.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6386.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(6830.9,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(7684.7,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(8740.5,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container></li>
<li>由斐波那契定理：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.334ex;" xmlns="http://www.w3.org/2000/svg" width="8.741ex" height="3.591ex" role="img" focusable="false" viewbox="0 -997.7 3863.6 1587.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mi" transform="translate(676,-150) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1411.1,0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"/></g><g data-mml-node="mfrac" transform="translate(2466.8,0)"><g data-mml-node="msup" transform="translate(289.2,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D6F7" d="M356 624Q356 637 267 637H243Q237 642 237 645T239 664Q243 677 249 683H264Q342 681 429 681Q565 681 571 683H583Q589 677 589 674T587 656Q582 641 578 637H540Q516 637 504 637T479 633T463 630T454 623T448 613T443 597T438 576Q436 566 434 556T430 539L428 533Q442 533 472 526T543 502T613 451T642 373Q642 301 567 241T386 158L336 150Q332 150 331 146Q310 66 310 60Q310 46 399 46H424Q430 40 430 39T428 19Q424 6 418 0H401Q360 2 247 2Q207 2 173 2T119 2T95 1Q87 1 84 1T79 4T77 10Q77 11 79 23Q80 25 81 30T82 36T84 40T86 43T88 44T93 46T99 46T108 46H115Q170 46 189 49T216 62Q220 74 228 107L239 150L223 152Q139 164 82 205T24 311Q24 396 125 462Q207 517 335 533L346 578Q356 619 356 624ZM130 291Q130 203 241 188H249Q249 190 287 342L325 495H324Q313 495 291 491T229 466T168 414Q130 357 130 291ZM536 393Q536 440 507 463T418 496L341 187L351 189Q443 201 487 255Q536 314 536 393Z"/></g><g data-mml-node="mi" transform="translate(700,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="msqrt" transform="translate(220,-511.4) scale(0.707)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g></g><g data-mml-node="mo" transform="translate(0,71.9)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="500" height="42.4" x="853" y="829.5"/></g><rect width="1156.7" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，其中  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="9.731ex" height="3.246ex" role="img" focusable="false" viewbox="0 -1089.5 4301 1434.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6F7" d="M356 624Q356 637 267 637H243Q237 642 237 645T239 664Q243 677 249 683H264Q342 681 429 681Q565 681 571 683H583Q589 677 589 674T587 656Q582 641 578 637H540Q516 637 504 637T479 633T463 630T454 623T448 613T443 597T438 576Q436 566 434 556T430 539L428 533Q442 533 472 526T543 502T613 451T642 373Q642 301 567 241T386 158L336 150Q332 150 331 146Q310 66 310 60Q310 46 399 46H424Q430 40 430 39T428 19Q424 6 418 0H401Q360 2 247 2Q207 2 173 2T119 2T95 1Q87 1 84 1T79 4T77 10Q77 11 79 23Q80 25 81 30T82 36T84 40T86 43T88 44T93 46T99 46T108 46H115Q170 46 189 49T216 62Q220 74 228 107L239 150L223 152Q139 164 82 205T24 311Q24 396 125 462Q207 517 335 533L346 578Q356 619 356 624ZM130 291Q130 203 241 188H249Q249 190 287 342L325 495H324Q313 495 291 491T229 466T168 414Q130 357 130 291ZM536 393Q536 440 507 463T418 496L341 187L351 189Q443 201 487 255Q536 314 536 393Z"/></g><g data-mml-node="mo" transform="translate(944.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2000.6,0)"><g data-mml-node="mrow" transform="translate(220,418.1) scale(0.707)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(500,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msqrt" transform="translate(1278,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g></g><g data-mml-node="mo" transform="translate(0,71.9)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="500" height="42.4" x="853" y="829.5"/></g></g><g data-mml-node="mn" transform="translate(973.4,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="2060.4" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，可得：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.334ex;" xmlns="http://www.w3.org/2000/svg" width="14.133ex" height="3.591ex" role="img" focusable="false" viewbox="0 -997.7 6246.6 1587.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mi" transform="translate(836,-150) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1571.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2626.8,0)"><g data-mml-node="msup" transform="translate(220,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D6F7" d="M356 624Q356 637 267 637H243Q237 642 237 645T239 664Q243 677 249 683H264Q342 681 429 681Q565 681 571 683H583Q589 677 589 674T587 656Q582 641 578 637H540Q516 637 504 637T479 633T463 630T454 623T448 613T443 597T438 576Q436 566 434 556T430 539L428 533Q442 533 472 526T543 502T613 451T642 373Q642 301 567 241T386 158L336 150Q332 150 331 146Q310 66 310 60Q310 46 399 46H424Q430 40 430 39T428 19Q424 6 418 0H401Q360 2 247 2Q207 2 173 2T119 2T95 1Q87 1 84 1T79 4T77 10Q77 11 79 23Q80 25 81 30T82 36T84 40T86 43T88 44T93 46T99 46T108 46H115Q170 46 189 49T216 62Q220 74 228 107L239 150L223 152Q139 164 82 205T24 311Q24 396 125 462Q207 517 335 533L346 578Q356 619 356 624ZM130 291Q130 203 241 188H249Q249 190 287 342L325 495H324Q313 495 291 491T229 466T168 414Q130 357 130 291ZM536 393Q536 440 507 463T418 496L341 187L351 189Q443 201 487 255Q536 314 536 393Z"/></g><g data-mml-node="TeXAtom" transform="translate(700,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g><g data-mml-node="msqrt" transform="translate(470.3,-511.4) scale(0.707)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g></g><g data-mml-node="mo" transform="translate(0,71.9)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="500" height="42.4" x="853" y="829.5"/></g><rect width="1657.3" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(4746.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(5746.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li><p>如果树中有 n 个节点，那么树的最大高度是：</p>
<p>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="50.579ex" height="2.714ex" role="img" focusable="false" viewbox="0 -949.5 22356.1 1199.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,-150) scale(0.707)"><path data-c="1D6F7" d="M356 624Q356 637 267 637H243Q237 642 237 645T239 664Q243 677 249 683H264Q342 681 429 681Q565 681 571 683H583Q589 677 589 674T587 656Q582 641 578 637H540Q516 637 504 637T479 633T463 630T454 623T448 613T443 597T438 576Q436 566 434 556T430 539L428 533Q442 533 472 526T543 502T613 451T642 373Q642 301 567 241T386 158L336 150Q332 150 331 146Q310 66 310 60Q310 46 399 46H424Q430 40 430 39T428 19Q424 6 418 0H401Q360 2 247 2Q207 2 173 2T119 2T95 1Q87 1 84 1T79 4T77 10Q77 11 79 23Q80 25 81 30T82 36T84 40T86 43T88 44T93 46T99 46T108 46H115Q170 46 189 49T216 62Q220 74 228 107L239 150L223 152Q139 164 82 205T24 311Q24 396 125 462Q207 517 335 533L346 578Q356 619 356 624ZM130 291Q130 203 241 188H249Q249 190 287 342L325 495H324Q313 495 291 491T229 466T168 414Q130 357 130 291ZM536 393Q536 440 507 463T418 496L341 187L351 189Q443 201 487 255Q536 314 536 393Z"/></g></g><g data-mml-node="mo" transform="translate(1814.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msqrt" transform="translate(2203.6,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g></g><g data-mml-node="mo" transform="translate(0,89.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="500" height="60" x="853" y="829.5"/></g><g data-mml-node="mo" transform="translate(3556.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(3945.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4767.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(5768.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6268.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6657.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(7268.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(8268.5,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(9046.3,0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"/></g><g data-mml-node="mn" transform="translate(10102.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(778,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1278,0)"/></g><g data-mml-node="mo" transform="translate(12102.3,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="mi" transform="translate(12824.5,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(13122.5,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(13607.5,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(14521.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(14910.1,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(15732.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(16732.5,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(17232.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(17899.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(18955.1,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(19718.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(20107.1,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(20405.1,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(20890.1,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(21367.1,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(21967.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p>
</li>
</ul>
<p>确定搜索树的高度总为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时，能保证每棵搜索树操作所占用的时间为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>可以参照<a href="/2022/07/19/binary-search-tree/#搜索节点">二叉搜索树</a>的搜索算法，时间为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a><a href="https://github.com/daca-ao/Algos/blob/master/com/raymond/structures/AVLTree.java#L4">插入</a></h1><p>直接使用<a href="/2022/07/19/binary-search-tree/#添加节点">二叉搜索树</a>的插入算法，得到的可能不是 AVL 树。</p>
<p>存在以下情况：</p>
<ol>
<li>不平衡树中的平衡因子的值限于 -2，-1，0，1，2；</li>
<li>平衡因子为 2 的节点在插入前的平衡因子为 1；与此类似，平衡因子为 -2 的，插入前为 -1；</li>
<li>从根到新插入节点的路径上，只有途径的节点的平衡因子在插入后会被改变；</li>
<li>设 A 是新插入节点最近的祖先，平衡因子为 -2 或 2，那插入前在从 A 到新插入节点的路径上，所有节点的平衡因子为 0。</li>
</ol>
<p><img src="/2023/05/26/avl/avl-insert.png" alt></p>
<p>如上图所示：往图 3 <code>b)</code> 插入节点 32 得到图 4 <code>a)</code> 。观察节点 40，其平衡因子 <code>bf</code> 在插入前为 1，插入后为 2，即 A 为值为 40 的节点。</p>
<p>如往图 3 <code>a)</code> 插入节点 26、28、50 或 72，则 A 为值为 25 的节点；<br>如往图 3 <code>a)</code> 插入节点 10、14、16 或 19，则不存在这样的 A。</p>
<p>如果存在上述的节点 A，说明 AVL 树处于<strong>不平衡</strong>状态。</p>
<p>不平衡状态分为 <strong>L 型不平衡</strong>（新插入节点在 A 左子树）或 <strong>R 型不平衡</strong>（新插入节点在 A 右子树）两个类别，细分则有：</p>
<ul>
<li>LL 型不平衡（新插入节点在 A 左子树的左子树中）</li>
<li>LR 型不平衡（新插入节点在 A 左子树的右子树中）</li>
<li>RL 型不平衡（新插入节点在 A 右子树的左子树中）</li>
<li>RR 型不平衡（新插入节点在 A 右子树的右子树中）</li>
</ul>
<p>当 A 的 bf 值为 -2 或 2，说明 A 保存新插入节点的子树高度至少为 2，也就是说，A 肯定拥有孙节点。</p>
<h2 id="处理插入后失衡：旋转子树"><a href="#处理插入后失衡：旋转子树" class="headerlink" title="处理插入后失衡：旋转子树"></a>处理插入后失衡：旋转子树</h2><h3 id="调整-LL-型不平衡：LL-旋转"><a href="#调整-LL-型不平衡：LL-旋转" class="headerlink" title="调整 LL 型不平衡：LL 旋转"></a>调整 LL 型不平衡：<a href="https://github.com/daca-ao/Algos/blob/master/com/raymond/structures/AVLTree.java#L140">LL 旋转</a></h3><p><img src="/2023/05/26/avl/LL-rotate.png" alt></p>
<p>旋转前：</p>
<ul>
<li>A 为根节点，B 为左子树根节点</li>
<li>新元素比 B 的值小，最终插入到 B 的左子树</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.82ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4340.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2784.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3840.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.841ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4349.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3849.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>插入元素后 B 的左子树比右子树高（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="14.628ex" height="1.943ex" role="img" focusable="false" viewbox="0 -694 6465.6 858.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1899.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(2899.7,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(4909.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(5965.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>）。</li>
</ul>
<p>旋转后：</p>
<ul>
<li>B 为根节点，A 变成 B 右子树的根节点</li>
<li>B’L 仍为 B 的左子树，B’R 为 A 的左子树（B &lt; B’R &lt; A），A 的右子树不变</li>
<li>从 B 到新插入节点途中的 B’ 的左右节点的平衡因子都将<strong>改变</strong>，其他节点平衡因子与旋转前<strong>一致</strong>。</li>
</ul>
<p>证明其仍为二叉搜索树：</p>
<ul>
<li>BR 子树上所有元素原本就比 A 要小：旋转后 B’R 成为 A 左子树，符合要求。</li>
</ul>
<h3 id="调整-LR-型不平衡：LR-旋转"><a href="#调整-LR-型不平衡：LR-旋转" class="headerlink" title="调整 LR 型不平衡：LR 旋转"></a>调整 LR 型不平衡：<a href="https://github.com/daca-ao/Algos/blob/master/com/raymond/structures/AVLTree.java#L169">LR 旋转</a></h3><p><img src="/2023/05/26/avl/LR-rotate.png" alt></p>
<p>针对于树产生了 LR 不平衡，说明 A 的左子树（记为 B）的右子树（记为 C）肯定存在。</p>
<ul>
<li>此时 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.82ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4340.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2784.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3840.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.601ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5127.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3849.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4627.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>注：C 的左右子树（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.895ex" height="1.934ex" role="img" focusable="false" viewbox="0 -705 1279.5 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="3.02ex" height="1.968ex" role="img" focusable="false" viewbox="0 -705 1334.7 869.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></svg></mjx-container>）有可能为空。</li>
</ul>
<p>旋转后，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.692ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2516 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.672ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2507 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 的值取决于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2517 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mo" transform="translate(2128,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 在插入之后、重新整理之前的平衡因子 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 429 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g></g></svg></mjx-container>：</p>
<ol>
<li>若 b = 0：即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="10.734ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 4744.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(3011.5,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></g></svg></mjx-container><ul>
<li>因整理前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.601ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5127.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3849.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4627.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，可知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="15.055ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 6654.1 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(3011.5,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(5022.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(6078.1,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container></li>
<li>因此整理后 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.53ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8190.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3849.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(4278.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(4828.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(5217.6,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(5967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6634.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(7690.1,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>若 b = 1：即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="14.631ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 6467 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1900.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(2900.4,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(4911.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(5967,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container><ul>
<li>因整理前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.601ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5127.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3849.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4627.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，可知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="8.117ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 3587.5 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3011.5,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="12.138ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 5365.1 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(2010.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3066.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(3864.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4865.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>整理后 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.841ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4349.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3849.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.58ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5118.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2784.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3840.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4618.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>若 b = -1：即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="16.391ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 7245 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1900.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(2900.4,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(4911.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(5967,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(6745,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container><ul>
<li>因整理前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.601ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5127.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3849.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4627.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，可知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="12.013ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 5309.9 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3011.5,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(3809.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4809.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="8.241ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 3642.7 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(2010.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3066.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container></li>
<li>整理后 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.841ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4349.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3849.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.82ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4340.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2784.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3840.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
</ol>
<p>证明其仍为二叉搜索树：</p>
<ul>
<li>旋转前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.719ex" height="1.645ex" role="img" focusable="false" viewbox="0 -705 760 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g></g></g></svg></mjx-container> 肯定比节点 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.717ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 759 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g></g></g></svg></mjx-container> 大，比 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.697ex" height="1.62ex" role="img" focusable="false" viewbox="0 -716 750 716"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g></g></g></svg></mjx-container> 小，因此旋转后形成的根节点和根节点下一层的排列，符合要求</li>
<li>旋转前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.895ex" height="1.934ex" role="img" focusable="false" viewbox="0 -705 1279.5 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g></g></svg></mjx-container> 根节点肯定比 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.717ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 759 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g></g></g></svg></mjx-container> 大，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="3.02ex" height="1.968ex" role="img" focusable="false" viewbox="0 -705 1334.7 869.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></svg></mjx-container> 根节点肯定比 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.697ex" height="1.62ex" role="img" focusable="false" viewbox="0 -716 750 716"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g></g></g></svg></mjx-container> 小，符合要求。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过观察上述的旋转过程，我们可以得出：</p>
<ul>
<li>LL 和 RR 只需旋转一次，我们称之为<strong>单旋转</strong></li>
<li>LR 和 RL 需要旋转两次，我们称之为<strong>双旋转</strong></li>
<li>可将 LR 看作是 RR 旋转后的 LL 旋转。</li>
</ul>
<p><img src="/2023/05/26/avl/rotate-sum.png" alt></p>
<h2 id="插入算法思路"><a href="#插入算法思路" class="headerlink" title="插入算法思路"></a>插入算法思路</h2><ol>
<li>沿着从根节点开始的路径对具有相同键值的元素进行搜索，以找到插入新元素的位置。在此过程中寻找最近的，且平衡因子为 -1 或 1 的节点，令其为 A 节点。如找到相同关键值的元素，则插入失败，以下步骤无需执行；</li>
<li>如没有这样的 A 节点：从根节点开始再遍历一次，并修改平衡因子，然后终止；</li>
<li>如 bf(A) = 1 并且新节点插入到 A 的右子树中，或 bf(A) = -1 且插入在左子树进行：A 新的平衡因子为 0。此时修改从 A 到新节点途中的平衡因子，然后终止；</li>
<li>确定 A 的不平衡类型并执行相应的旋转，在从新子树根节点至新插入节点途中，根据旋转需要修改相应的平衡因子。</li>
</ol>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a><a href="https://github.com/daca-ao/Algos/blob/master/com/raymond/structures/AVLTree.java#L13">删除</a></h1><p>同理：直接使用<a href="/2022/07/19/binary-search-tree/#删除节点">二叉搜索树</a>的删除算法，得到的可能不是 AVL 树。</p>
<p>设被删除的节点的父节点为 q</p>
<ul>
<li>如删除发生在左子树，则 bf(q) 减 1 或者不变；</li>
<li>如删除发生在右子树，则 bf(q) 加 1 或者不变。</li>
</ul>
<p>删除节点之后，如果：</p>
<ul>
<li>q 的新的平衡因子是 0，说明 q 子树的高度已减 1，且需要改变它的父节点（如有）和其他某些祖先节点的平衡因子</li>
<li>q 的新的平衡因子是 -1 或 1：高度与删除前相同，无需改变其祖先的平衡因子值</li>
<li>q 的新的平衡因子是 -2 或 2：树在 q 节点不平衡</li>
</ul>
<p>设从 q 到根节点的路径中平衡因子第一个发生改变的节点为 A，此时 A 的平衡因子是 2 或者 -2。</p>
<ul>
<li>如删除在 A 的左子树：L 型不平衡</li>
<li>如删除在 A 的右子树：R 型不平衡<ul>
<li>删除前 bf(A) = 1，删除后 bf(A) = 2，即 A 的右子树高度减 1，属于 R 型不平衡</li>
</ul>
</li>
</ul>
<p>当删除 A 右子树的节点时，我们将 A 的左子树的根节点记为 B。<br>如果删除导致 bf(B) = -1，我们将其定义为 <strong>R-1 型不平衡</strong>。</p>
<p>由此会有以下的不平衡状态定义：</p>
<ul>
<li><strong>R-1</strong>：A 的左节点 B 的平衡系数为 -1</li>
<li><strong>R0</strong>：A 的左节点 B 的平衡系数为 0</li>
<li><strong>R1</strong>：A 的左节点 B 的平衡系数为 1</li>
<li><strong>L-1</strong>：A 的右节点 B 的平衡系数为 -1</li>
<li><strong>L0</strong>：A 的右节点 B 的平衡系数为 0</li>
<li><strong>L1</strong>：A 的右节点 B 的平衡系数为 1</li>
</ul>
<h2 id="处理删除后失衡：旋转子树"><a href="#处理删除后失衡：旋转子树" class="headerlink" title="处理删除后失衡：旋转子树"></a>处理删除后失衡：旋转子树</h2><p>删除了右子树的节点，左子树平衡因子被改变，左子树需要变化；<br>对于左子树节点的删除，也是同样的道理。我们这里只介绍 R 型不平衡，对于 L 型不平衡，作镜像处理。</p>
<p>R0 旋转：与插入时的单旋转类似</p>
<p><img src="/2023/05/26/avl/r0.png" alt></p>
<p>R1 旋转：与插入时的单旋转类似</p>
<p><img src="/2023/05/26/avl/r1.png" alt></p>
<p>R-1 旋转：与双旋转类似</p>
<p><img src="/2023/05/26/avl/r-1.png" alt></p>
<p>旋转后，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.692ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2516 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.672ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2507 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 的值取决于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2517 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mo" transform="translate(2128,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 在插入之后、重新整理之前的平衡因子 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 429 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g></g></svg></mjx-container>：</p>
<ol>
<li>若 b = 0：即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="10.734ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 4744.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(3011.5,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></g></svg></mjx-container><ul>
<li>因整理前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.601ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5127.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3849.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4627.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，可知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="18.952ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 8376.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(3011.5,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(5022.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(6078.1,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(6876.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(7876.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>因此整理后 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.53ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8190.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3849.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(4278.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(4828.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(5217.6,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(5967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6634.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(7690.1,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>若 b = 1：即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="14.631ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 6467 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1900.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(2900.4,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(4911.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(5967,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container><ul>
<li>因整理前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.601ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5127.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3849.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4627.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，可知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="12.013ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 5309.9 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3011.5,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(3809.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4809.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="12.138ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 5365.1 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(2010.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3066.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(3864.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4865.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container></li>
<li>整理后 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.841ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4349.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3849.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.58ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5118.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2784.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3840.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4618.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>若 b = -1：即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="16.391ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 7245 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1900.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msub" transform="translate(2900.4,0)"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(4911.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(5967,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(6745,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container><ul>
<li>因整理前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.601ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5127.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3849.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4627.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，可知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="12.013ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 5309.9 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g><g data-mml-node="mo" transform="translate(1955.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3011.5,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(3809.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4809.9,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="12.138ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 5365.1 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g><g data-mml-node="mo" transform="translate(2010.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3066.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(3864.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4865.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>整理后 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.841ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4349.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2127,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2793.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3849.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.82ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4340.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(979,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1368,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(2118,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2784.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3840.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
</ol>
<h2 id="删除具体思路"><a href="#删除具体思路" class="headerlink" title="删除具体思路"></a>删除具体思路</h2><p>把要删除的节点向下旋转成一个叶节点，接着直接移除该叶节点；<br>旋转期间最多有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="4.208ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 1860 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1260,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个节点被旋转：整体上的时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树- 维基百科，自由的百科全书</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2022/11/08/bubble-sort/</url>
    <content><![CDATA[<p>学习数据结构的时候最早接触到的排序算法。</p>
<span id="more"></span>
<p><a href="https://zh.wikipedia.org/wiki/冒泡排序">冒泡排序</a>属于<strong>比较排序</strong>。比较过程中的“冒泡”，指的是：<strong>重复</strong>地访问要排序的数列，对相邻的元素进行比较，如果次序不符合要求，再将元素<strong>交换顺序</strong>。</p>
<ul>
<li>升序排列：如果左元素 &gt; 右元素，则进行交换</li>
<li>降序排列：如果左元素 &lt; 右元素，则进行交换</li>
</ul>
<p>名称由来：越小（大）的元素经过交换后会逐渐“浮”到数列的顶端。</p>
<p>在一次冒泡过程结束后，最大（小）的元素肯定在最后的位置上。</p>
<p>时间复杂度最好是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，最坏是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort</span>(<span class="params">array, length</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">from</span> <span class="number">0</span> to length-<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">from</span> <span class="number">0</span> to length-<span class="number">1</span>-i) {</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">                swap(array[j], array[j+<span class="number">1</span>])</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">} </span><br></pre></td></tr></table></figure>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) {  <span class="comment">// ascending order</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> temp = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>改进 1：引入提前中断位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最好情况：序列本身有序，比较次数 n-1，无数据交换，时间复杂度为 O(n)</span></span><br><span class="line"><span class="comment"> * 最坏情况：序列本身逆序，需要比较以及交换 n(n-1)/2 次，时间复杂度为 O(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortE</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">boolean</span> needSwap = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> &amp;&amp; needSwap; i++) {</span><br><span class="line">        needSwap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) {  <span class="comment">// 从待排序元素开始遍历</span></span><br><span class="line">        <span class="comment">// 如果跑完一轮 needSwap 仍是 false，证明已经有序，就不再继续冒泡了。</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) {</span><br><span class="line">                swap(a, j, j + <span class="number">1</span>);  <span class="comment">// 交换</span></span><br><span class="line">                needSwap = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>另一种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span> &amp;&amp; bubble(a, i); i--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> swapped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) {</span><br><span class="line">            swap(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">            swapped = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> swapped;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>改进 2：举一个极端的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果有 100 个数的数组，仅前面 10 个无序，后面 90 个都已经排好序且都大于前面 10 个数字</span></span><br><span class="line"><span class="comment"> * 那么第一遍遍历之后，最后发生交换的位置必小于 10，而且这个位置之后的数据必然有序</span></span><br><span class="line"><span class="comment"> * 记录下这个位置，第二次只要从数组头部遍历到这个位置就好了</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> flag = a.length;</span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>) {</span><br><span class="line">        k = flag;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &gt; k; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) {</span><br><span class="line">                swap(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">                flag = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM Class Loader 类加载器</title>
    <url>/2021/07/08/class-loader/</url>
    <content><![CDATA[<p>Java 程序的基本单元，就是一个个的类（Class）及类实例（Class Instance）。在使用类之前，必须先将类加载进 JVM 的内存中。</p>
<span id="more"></span>
<p>类加载器（Class Loader）作用：将类加载到 Java 虚拟机，并且检查类的完整性。</p>
<p>类加载机制：</p>
<ol>
<li>将描述类的数据从 <code>.class</code> 文件（cafe babe 0000 0034 0022 0800 ….）加载到内存；</li>
<li>对数据进行校验、转换解析和初始化；</li>
<li>最终构造成可被虚拟机直接使用的 Java 类型。</li>
</ol>
<p>好处：</p>
<ul>
<li>类的加载、连接和初始化过程都在程序的运行时完成，令 Java 具备高度的灵活性；<ul>
<li>其他语言是在编译时进行链接的</li>
</ul>
</li>
<li>避免类被重复加载：即每个 JVM 中，<strong>只会有一个</strong>拥有<strong>同样全路径</strong>的 .class 文件；</li>
<li>沙箱安全机制：防止核心类库的核心类被篡改。</li>
</ul>
<p>.class 文件被加载后，对应在 JVM 形成一份描述该类结构的元信息对象；通过该元信息对象可以获知 Class 的结构信息，如构造函数、属性、方法等。<br>Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能，这就是我们经常能见到的 Class 类。</p>
<p>JVM 只会加载程序执行时所需要的 .class 文件，<strong>暂时不使用的类则不会被加载</strong>。</p>
<p><br></p>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>三大类，五步：<strong>加载</strong> -&gt; <strong>验证</strong> -&gt; <strong>准备</strong> -&gt; <strong>解析</strong> -&gt; <strong>初始化</strong>。</p>
<p><strong>1. 加载 Load</strong>：加载类数据到内存，在堆区建立一个 Class 对象</p>
<ol>
<li>通过类的全限定名（com.xxx.xxxx.xxxx）获取该类的二进制字节流（.class 文件）<ul>
<li>可从磁盘上读取文件，或者根据链接请求网络文件，等</li>
</ul>
</li>
<li>解析流，将该字节流代表的<strong>静态存储结构</strong>转换为<a href="/2021/07/07/jvm-basics#2-%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area">方法区</a>的运行时数据结构，将类的信息存放到方法区中</li>
<li>在静态区（内存）创建代表这个类的 <code>java.lang.Class</code> 实例，作为方法区该类的各种数据结构的访问入口<ul>
<li>没有规定这个对象一定要在堆中：比较特殊，虽是对象，但是在方法区</li>
<li>注意：这里创建的应该是<strong>实例</strong>，而不是对象。</li>
</ul>
</li>
</ol>
<p><strong>2. 链接 Link</strong>：把 Class 的二进制数据合并到 JRE，具体包括<strong>验证</strong>、<strong>准备</strong>和<strong>解析</strong>三步：</p>
<ol>
<li><strong>验证 Verification</strong>：此时类加载器会验证 .class 文件中类结构、语义、操作等的合法性，确保不会危害虚拟机安全。包括：<ol>
<li>文件格式验证</li>
<li>元数据验证（语义分析，类与类的继承关系等）</li>
<li>字节码验证（数据流和控制流分析）</li>
<li>符号引用验证（对类自身以外的信息进行匹配校验）</li>
</ol>
</li>
<li><strong>准备 Preparation</strong>：为类的静态变量在方法区分配内存<ul>
<li>final 的静态变量（也就是常量）在这个阶段赋值为其指定值</li>
<li>非 final 的静态变量赋初始化默认值（0 值或 null）<ul>
<li>如有 <code>static int a = 1;</code> 静态变量 a 在准备阶段被赋值为 0，在初始化阶段被赋值为 1</li>
</ul>
</li>
<li>然后，一般的成员变量是在实例化的时候，随对象一起被分配到堆内存中</li>
</ul>
</li>
<li><strong>解析 Resolution</strong>：将 .class 二进制数据中常量池（即：静态常量池）中的符号引用替换成直接引用<ul>
<li><strong>符号引用</strong>：类名、方法名、字段名，具有人类可读性，类似于 OS 中的逻辑地址（<code>javap -verbose xxx.class</code> 的输出）；</li>
<li><strong>直接引用</strong>：内存偏移量，指示内存真实地址，类似于 OS 中的物理地址；</li>
<li>符号引用只是编译的结果，其指向的目标不一定加载到了内存中，而直接引用的目标一定已经加载到了内存中</li>
</ul>
</li>
</ol>
<p><strong>3. 初始化 Initialization</strong>：赋予静态变量以程序原本指定的值，如上面说的 <code>static int a = 1;</code>，并初始化静态代码块</p>
<ul>
<li>到了这个阶段，说明类已经顺利地被加载到了系统中</li>
<li>此时真正执行类中定义的 Java 程序代码</li>
<li>不是必然发生的</li>
</ul>
<h2 id="初始化的场景"><a href="#初始化的场景" class="headerlink" title="初始化的场景"></a>初始化的场景</h2><p>JVM 规范中，严格规定了<strong>有且只有</strong> <strong><code>5</code></strong> 种情况<strong>必须对类进行初始化</strong>，这些行为称为对一个类进行“主动引用”：</p>
<p><big><strong>一</strong></big>、遇到 <code>new</code>, <code>getstatic</code>, <code>putstatic</code>, <code>invokestatic</code> 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发类的初始化。<br>常见代码场景：</p>
<ul>
<li><code>new</code> 关键字实例化对象时</li>
<li>调用一个类的静态方法时</li>
<li>读取一个类的非 final 静态域或给它设值时<ul>
<li>不包括已经在编译期就将结果放入常量池的静态域，包括 final 静态域</li>
</ul>
</li>
</ul>
<p>注：访问类的 final 静态变量，即常量时不会触发该类的初始化</p>
<ul>
<li>因为：常量在被写进类的字节码之前，会被编译器优化为 value 而不是 field；</li>
<li>所以编译器并不会对应生成字节码来从实例中载入 field 的值，而是直接把这个 value 插入到字节码中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>	String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);  <span class="comment">// 调用类常量：只会输出 &quot;hello world&quot;，不会输出 &quot;ConstClass init&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><big><strong>二</strong></big>、使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发类的初始化。</p>
<ul>
<li>如：<code>Class.forName()</code></li>
</ul>
<p><big><strong>三</strong></big>、初始化一个类时，若其父类还没进行过初始化，则先初始化其父类。</p>
<ul>
<li>这种情形会递归加载所有之前未被加载的父类</li>
</ul>
<p>所以：通过子类来引用父类的静态字段（包括域和静态块），只会触发父类的初始化，不会触发子类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>	String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.HELLOWORLD);  <span class="comment">// 只输出 &quot;SuperClass init&quot;，不会输出 &quot;SubClass init&quot;。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化</li>
</ul>
<p><big><strong>四</strong></big>、JVM 启动时，用户需要指定一个主类（包含 <code>main</code> 方法的类），JVM 先初始化这个类。</p>
<p><big><strong>五</strong></big>、JDK 1.7 动态语言支持：如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果 <code>REF_getStatic</code>, <code>REF_putStatic</code>, <code>REF_invokeStatic</code> 的方法 handle，且这个方法 handle 所对应的类没进行过初始化，则需要先触发类的初始化。</p>
<p><br></p>
<p>例：程序从 <code>HelloWorld.class</code> 开始运行——</p>
<ol>
<li>虚拟机从磁盘读取文件或请求 Web 上的文件等方法，加载 HelloWorld 类文件（<code>.class</code> 文件）的内容；</li>
<li>如 HelloWorld 类拥有来自另一个类的域，或拥有超类，那么这些类文件也会被加载（类的解析）；</li>
<li>虚拟机执行 HelloWorld 中 <code>main()</code> 方法；</li>
<li>如 <code>main()</code> 或 <code>main()</code> 调用的方法需要用到更多的类：就加载这些类。</li>
</ol>
<p><br></p>
<h2 id="类的唯一性"><a href="#类的唯一性" class="headerlink" title="类的唯一性"></a>类的唯一性</h2><p>JVM 并不是一次性将所有文件都加载进来的，而是按需加载，通过不同的类加载器（后面小节会说到）加载不同的类。<br>当程序到了某一段逻辑需要额外的类时，再通过类加载机制去加载到 JVM 中；而且会存放一段时间，便于频繁使用。</p>
<p>JVM 判断两个类是否相同：不仅要判定类的全限定名是否相同（同一个 .class 文件），而且要判断是否由同一个类加载器实例加载（<code>isAssingnableFrom()</code>）。<br>也就是：任何一个类，需要这个类自身和加载它的类加载器来确定它在 JVM 的唯一性。</p>
<p><br></p>
<h1 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h1><p>每个 Java 程序至少拥有三类加载器。</p>
<p><strong>1. 引导（启动，Bootstrap）类加载器</strong></p>
<p>最顶层的类加载器，随 JVM 启动而启动，是 JVM 不可分割的一部分</p>
<ul>
<li>负责加载 JVM 运行所需要的：JDK 的<strong>核心类库</strong>，包括：<ul>
<li><code>$JAVA_HOME/lib</code> 路径下的核心类库</li>
<li>JVM <code>-Xbootclasspath</code> 参数指定路径下的 jar 包</li>
<li>如 <code>rt.jar</code>, <code>resources.jar</code>, <code>charsets.jar</code> 等</li>
</ul>
</li>
<li>负责加载 C++ native code 编写，没有父类，也没有对应的 ClassLoader 对象<ul>
<li>这些类库的对象无法被 Java 程序直接引用</li>
</ul>
</li>
</ul>
<p>在构造 Bootstrap 类加载器的时候会同时构造 <code>ExtClassLoader</code>，即下面要提到的扩展类加载器。</p>
<p>出于安全性考虑，虚拟机是<strong>按照文件名</strong>识别并加载 jar 包的，而且 Bootstrap 类加载器只加载包名以 <code>java</code>, <code>javax</code>, <code>sun</code> 等开头的类。<br>如果文件名不被 JVM 识别，即使将再多 jar 包丢到 /lib 目录下面也没用。<br>而且，即使是自己重新打了一个 <code>rt.jar</code>，也是过不了虚拟机的安全机制，加载不了的。</p>
<p><br></p>
<p><strong>2. 扩展（Extension）类加载器</strong></p>
<p>由 Sun 实现的 <strong><code>sun.misc.Launcher$ExtClassLoader</code></strong> 类，通过 Java 实现。</p>
<ul>
<li>继承自 <code>URLClassLoader</code>，是 Launcher 的静态内部类</li>
<li>默认从 <code>$JAVA_HOME/lib/ext</code> 目录加载“标准的扩展”</li>
<li>还包括 java.ext.dirs 系统变量（<code>-Djava.ext.dirs</code>）所指定的路径中的所有类库</li>
<li>开发者可以直接使用该加载器</li>
</ul>
<p>在构造 Extension 类加载器的时候同时构造 <code>AppClassLoader</code>，即下面要提到的应用类加载器。</p>
<p><br></p>
<p><strong>3. 应用（Application）类加载器</strong></p>
<p>由 Sun 实现的 <strong><code>sun.misc.Launcher$AppClassLoader</code></strong> 类，通过 Java 实现，同样继承自 <code>URLClassLoader</code>。<br>因为 <code>AppClassLoader</code> 又是 <code>ClassLoader.getSystemClassLoader()</code> 的返回值，所以又称之为<strong>系统类加载器 System ClassLoader</strong>）</p>
<ul>
<li>用于加载<strong>应用程序</strong>的类路径 classpath 目录（<code>java -classpath</code> / <code>-Djava.class.path</code>）下所有 jar 和 .class 文件</li>
<li>开发者可以直接使用该加载器（<code>ClassLoader.getSystemClassLoader()</code>）</li>
<li>如应用没有自定义类加载器，那：它就是程序中<strong>默认</strong>的类加载器。</li>
</ul>
<p>另：还可从 <code>/jre/lib/endorsed</code> 目录加载 —— 将某个标准 Java 类库替换为更新的版本。</p>
<p><br></p>
<p>除了上述三类必备的类加载器之外，用户还可以自定义类加载器： </p>
<p><strong>4. Custom Class Loader</strong></p>
<ul>
<li>用户自定义的类加载器，父类为 <code>AppClassLoader</code></li>
</ul>
<p>自定义类加载器的原因：像刚刚所说的，JVM 比较认生，只识别指定文件名和路径下的资源文件，因此 Java 提供的默认 ClassLoader 只会加载指定目录下的 jar 和 .class。</p>
<h2 id="基类源码浅析"><a href="#基类源码浅析" class="headerlink" title="基类源码浅析"></a>基类源码浅析</h2><p>除了 Bootstrap 类加载器，所有的类加载器，包括自定义的类加载器，均需继承 <code>ClassLoader</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="function">ClassLoader <span class="title">getParent</span><span class="params">()</span>    <span class="comment">// 返回父类加载器，如为 Bootstrap ClassLoader 则返回 null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span>  <span class="comment">// 获取系统的类加载器，即返回应用类加载器</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span>  <span class="comment">// 类加载器应覆盖此方法，以查找类的字节码</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">protected</span> Class&lt;?&gt; <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> resolve)</span>  <span class="comment">// 加载某个类</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    Class <span class="title">defineClass</span><span class="params">(String name, <span class="keyword">byte</span>[] byteCodeData, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将新的类添加到虚拟机中，其字节码在给定的数据范围（offset, length）中</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="类加载层次：双亲委派模型"><a href="#类加载层次：双亲委派模型" class="headerlink" title="类加载层次：双亲委派模型"></a>类加载层次：双亲委派模型</h1><p>类加载器有一种“父/子关系”，它们是<strong>组合</strong>而非继承关系：</p>
<ul>
<li>子类保存对父类的引用；</li>
<li>当某个类加载器收到类加载请求，首先将请求递归地委派给“父类”；</li>
<li>父类在自己的加载路径中搜索目标类；当父类找不到，无法完成加载时，加载工作才交还子类，由子类自身完成</li>
<li>除了 Bootstrap 引导类加载器外，每个类加载器都有一个父类加载器</li>
</ul>
<p>以上即为“<strong>双亲委派模型</strong>（<strong>Parents Delegation Model</strong>, since Java 2）”</p>
<p>好处：</p>
<ul>
<li>安全：避免用户自己编写的类动态替换了 Java 的一些核心类，如 <code>String</code> 等</li>
<li>加载分层次，避免重复加载某个类带来的混乱</li>
</ul>
<p>举个例子：某自定义 ClassLoader 在亲自搜索需要加载的某个类之前，首先不会自己尝试去加载，而是将加载任务<strong>委托</strong>至父类加载器</p>
<ul>
<li>检查这个类是否已被加载，没有则委派 <code>AppClassLoader</code> 加载</li>
<li>检查这个类是否已被加载，没有则委派 <code>ExtClassLoader</code> 加载</li>
<li>检查这个类是否已被加载，没有则委派 Bootstrap ClassLoader 加载</li>
<li>从 Bootstrap ClassLoader 开始，在它的搜索范围内找需要的类，试图加载</li>
<li>如没加载到：任务转交给 <code>ExtClassLoader</code></li>
<li>如没加载到：任务再转交给 <code>AppClassLoader</code> </li>
<li>如没加载到：任务再转交给该 ClassLoader 自身，或到网络或指定文件系统 URL 加载该类</li>
<li>如没加载到：抛出 <code>ClassNotFoundException</code></li>
</ul>
<p><img src="/2021/07/08/class-loader/classloader.png" alt></p>
<p>再举个例子：</p>
<p>自定义类加载器通过 defineClass() 加载一个 “java.lang.” 开头的类并不会成功；虚拟机将会抛出 <code>java.lang.SecurityException: Prohibited package name: java lang</code> 异常。<br>因为类的加载早就分配好了是由引导类加载器加载 “java.lang.” 开头的类。</p>
<p><br></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>类图关系：</p>
<p><img src="/2021/07/08/class-loader/classloader-class-diagram.png" alt></p>
<p>如图，<code>ExtClassLoader</code> 和 <code>AppClassLoader</code> 都继承于 <code>URLClassLoader</code>。</p>
<p><br></p>
<p><code>ClassLoader</code> 中的四个方法：</p>
<p><strong>1.</strong> <code>loadClass()</code> ：由 <code>ClassLoader</code> 实现，逻辑就是<strong>双亲委派模型</strong>的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 先从缓存查找该 class 对象，找到了就不用再重新加载了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  <span class="comment">// 没找到</span></span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  <span class="comment">// 委托父类加载器加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 没有父类加载器：委托引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// 父类都找不到：调用自己类定义的 findClass() 去找</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this	is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">// 是否需要在加载时进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong> <code>findClass()</code>：定义类加载器的类加载逻辑，在 <code>loadClass()</code> 被调用。</p>
<ul>
<li>父类加载器加载失败后，就会调用自己的 <code>findClass()</code> 方法加载类。</li>
<li><code>ClassLoader</code> 的该方法为空方法；</li>
<li>一般来说，自定义类加载器会复写 <code>findClass()</code> 方法，定义自己的加载规则，将取得的字节码转换成流，再调用 <code>defineClass()</code> 生成 Class 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码：</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取类的字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 defineClass() 生成 class 对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);  <span class="comment">// 此处还没有对 class 文件进行解析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.</strong> <code>defineClass()</code>：通常与 <code>findClass()</code> 一起使用。</p>
<p><strong>4.</strong> <code>resolveClass()</code>：创建并解析 Class 对象，符号引用替换成直接引用。</p>
<p><br></p>
<p><code>SecureClassLoader</code>：新增几个与使用相关的代码源验证（代码源位置和证书验证），和权限定义类验证（主要是对 class 源码的访问权限）的方法。</p>
<p><br></p>
<p><code>URLClassLoader</code>：一般和这个类打交道，包括扩展类加载器。</p>
<ul>
<li>为父抽象类提供了实现</li>
<li>新增 <code>URLClassPath</code> 类协助取得 class 字节码流等功能</li>
<li>避免重写 <code>findClass()</code> 的时间消耗</li>
</ul>
<p><br></p>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>应用场景：</p>
<ol>
<li>常用于代码的加解密：想要让自己的 Java 不那么容易被反编译，可以先将编译后的代码使用某种算法加密；<ul>
<li>加密之后的代码就不能用 Java 的 ClassLoader 加载了，需要自定义类加载器在加载类时先解密，再加载；</li>
</ul>
</li>
<li>加载非标准来源的代码：自定义加载来自数据库、云端等地方的类，如开放式云平台；</li>
<li>以上两种情况的综合运用：加密网络传输过来的 Java 类字节码</li>
</ol>
<p>如何自定义：</p>
<ul>
<li>如不想打破双亲委派模型：重写 <code>findClass()</code></li>
<li>如想打破双亲委派模型：重写 <code>loadClass()</code></li>
</ul>
<p><br></p>
<h1 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h1><p>这是除了重写 <code>ClassLoader</code> 的 <code>loadClass()</code> 方法之外，另外一种破坏双亲委派的做法。</p>
<p><strong>背景 1</strong>：Java 应用存在很多的服务提供者接口（Service Provider Interface, <strong>SPI</strong>），允许第三方提供实现。</p>
<ul>
<li>JDBC、JNDI 等都是常见的 SPI</li>
</ul>
<p><strong>背景 2</strong>：SPI 的接口和实现是分离的：</p>
<ul>
<li>SPI 的接口属于 Java 核心类库，一般保存在 <code>rt.jar</code> 中 -&gt; 由引导类加载器加载；</li>
<li>SPI 的第三方实现代码则是作为 Java 应用所依赖的 jar 包，被存放在了 <code>classpath</code> 中</li>
</ul>
<p>综上，因为 SPI 如果要实现，就需要经常加载具体的第三方实现类并调用其相关的方法：</p>
<ul>
<li>首先，Bootstrap 类加载器加载不了这些类：因为它只能通过加载核心类库导入 SPI 接口类，<strong>无法直接加载</strong>这些实现类；</li>
<li>其次，虽然这看起来像是<strong>应用类加载器</strong>将要干的活，但是由于双亲委派模式的存在，Bootstrap 类加载器<strong>无法反向委托</strong>应用类加载器去加载实现类</li>
</ul>
<p>那怎么办呢？</p>
<p><br></p>
<p>可以利用<strong>线程上下文加载器</strong>（ContextClassLoader, since Java 2）解决问题。</p>
<ul>
<li>可通过 <code>java.lang.Thread</code> 中的 <code>getContextClassLoader()</code> 和 <code>setContextClassLoader()</code> 获取和设置线程的上下文加载器</li>
<li>如果没有手动设置，线程就会继承其父线程的上下文加载器；初始线程的上下文加载器，就是<strong>应用类加载器</strong>（<code>AppClassLoader</code>）</li>
</ul>
<p>以 JDBC 实现为例：</p>
<p><img src="/2021/07/08/class-loader/context-classloader.png" alt></p>
<p>以上加载方式显然破坏了双亲委派模型：抛弃了原本的委托链，使程序逆向使用类加载器。</p>
<p>示例：可参考 <code>DriverManager</code> (from <code>rt.jar</code>)，通过读取配置文件获取需要加载的类的全限定名。</p>
<p>ContextClassLoader 默认存放了 AppClassLoader 的引用。<br>无论当前程序在何处（Bootstrap ClassLoader 或者 ExtClassLoader 等），有需要时都可以调用 <code>Thread.getCurrentThread().getContextClassLoader()</code> 获得应用类加载器。</p>
<p><br></p>
<h2 id="应用：Tomcat-的类加载器结构"><a href="#应用：Tomcat-的类加载器结构" class="headerlink" title="应用：Tomcat 的类加载器结构"></a>应用：Tomcat 的类加载器结构</h2><p>应用场景：</p>
<p><strong>1</strong>. 最基本需求：部署在同一个 Web 容器的两个 Web 程序，它们所使用的 Java 类库可以相互隔离。</p>
<ul>
<li>两个不同的应用程序，它们可能会依赖到<strong>同一个</strong>第三方类库的<strong>不同版本</strong>；</li>
<li>所以不能要求一个类库在一个 Web 容器中只有一份，容器应保证每个应用程序的类库可以独立使用。</li>
</ul>
<p>用双亲委派模型能做到吗？做不到。<br>双亲委派模型是根据包名+类名加载类的，不以版本作区分。因此如果不同应用的依赖类库不能相互隔离的话，容器一旦加载了其中一个版本的类库，另一个版本的就不能用了。</p>
<p><br></p>
<p><strong>2</strong>. 常见需求：部署在同一个 Web 容器上的两个 Web 应用程序，它们所使用的 Java 类库可以共享。</p>
<ul>
<li>其实就是第一个需求的相对：比如有 10 个使用 Spring Framework 的应用程序部署于同一个容器中，如果每个应用隔离一份 Spring，将会造成巨大的资源浪费。</li>
<li>类库不能共享，则多组同质化类库加载到 Web 容器内存后，很容易造成虚拟机的方法区过度膨胀。</li>
</ul>
<p>用双亲委派模型能做到吗？做不到。<br>双亲委派模型根据不同的程序运行时，去给程序加载所需的类库，有多少个应用在跑，就无脑加载多少次，不会去管“如果某几个应用用了同样的类库，我就加载一次”的情况。</p>
<p><br></p>
<p><strong>3</strong>. Web 容器需要尽可能保证自身的安全，不受部署的 Web 应用程序影响</p>
<ul>
<li>特别是某些使用 Java 实现的 Web 容器，其自身的库依赖问题也要重视；</li>
<li>基于安全考虑，容器所使用的类库应该与应用程序的类库相互独立。</li>
</ul>
<p><br></p>
<p>又要隔离，又要共享，还要和容器类库相互独立，Tomcat 的类加载器结构只能<strong>打破双亲委派模型</strong>去做这些事。</p>
<p><img src="/2021/07/08/class-loader/tomcat-classloader.png" alt></p>
<p>每次新启动一个 Web 应用，其类加载器默认的加载顺序是：</p>
<ol>
<li>先从缓存中加载</li>
<li>如果没有找到，就从 JVM 的 Bootstrap 类加载器加载</li>
<li>如果还没有找到，则 Bootstrap 类加载器<strong>反向委托</strong>回当前的类加载器，去加载所需要的类（按照 <code>WEB-INF/classes</code>, <code>WEB-INF/lib</code> 的顺序）</li>
<li>如果还没找到，则委托其父类加载器加载，顺序是：<code>AppClassLoader</code> -&gt; <code>Common ClassLoader</code> -&gt; <code>Shared ClassLoader</code>。</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合体系（JCF）概述</title>
    <url>/2021/05/26/collections-java/</url>
    <content><![CDATA[<p>JCF，Java Collections Framework 的简称。<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/">官方文档</a>解释其为“统一化的表示和操作集合的架构”。</p>
<span id="more"></span>
<p>通常来说，一个集合类的实例，如链表、队列、映射表等，都是若干个对象的集合，是数据结构类型的实例化结果。<br>由于复杂的类结构，所有 Java 集合相关的接口以及其实现类被统称为“集合框架”（JCF）。<br>其实理解为“<strong>体系</strong>”更为恰当。</p>
<p>优势：</p>
<ul>
<li>降低代码量和复杂度：不需要由开发者再进行基础数据结构的设计，提高代码复用性，降低编码难度，增强可操作性</li>
<li>提升代码性能：被 JDK 收录的集合类库是一系列数据结构类型的具体实现，其质量和性能较高，降低底层代码的性能风险和维护成本</li>
</ul>
<p><br></p>
<h1 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h1><p>Java 最初版本：只为最常用的数据结构提供很少的一组类：</p>
<ul>
<li><code>Vector</code></li>
<li><code>Stack</code></li>
<li><code>Hashtable</code></li>
<li><code>BitSet</code></li>
<li><code>Enumeration</code>：“枚举”，提供访问任意容器中各元素的抽象机制</li>
</ul>
<h2 id="改进想法"><a href="#改进想法" class="headerlink" title="改进想法"></a>改进想法</h2><h3 id="全新框架"><a href="#全新框架" class="headerlink" title="全新框架"></a>全新框架</h3><ul>
<li>将传统的类融入到新框架中</li>
<li>让类库规模小且易于学习，不希望像 C++ 的 STL 那样复杂</li>
<li>能得到 STL 的泛型算法具有的优点</li>
</ul>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用<strong>泛型</strong></h3><p>为集合提供并规定一个可以容纳的对象类型</p>
<ul>
<li>如添加其它类型任何元素，将抛出编译错误</li>
<li>可使代码变得整洁</li>
</ul>
<h3 id="实施：接口（interface）与实现（implementation）分离"><a href="#实施：接口（interface）与实现（implementation）分离" class="headerlink" title="实施：接口（interface）与实现（implementation）分离"></a>实施：<strong>接口（interface）与实现（implementation）分离</strong></h3><p>比如要实现一个队列，我们有不同的实现方法：</p>
<ul>
<li>若需要实现循环数组队列，可使用 <code>ArrayDeque</code> 类</li>
<li>若需要链表队列，可使用 <code>LinkedList</code> 类：实现了 Queue 接口<ul>
<li>循环数组为有界集合，高效；链表没有上限</li>
</ul>
</li>
<li>使用 <code>ArrayList</code> 实现可以从 0 开始添加索引并迭代</li>
<li>使用 <code>HashSet</code> 实现，则无法预知元素被访问的顺序</li>
</ul>
<p>即：构建集合时，只有使用具体的实现类才有意义。</p>
<p>如：使用接口类型存放集合的引用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> CircularArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure></p>
<p>如要改为另一种实现方式，直接更改它的实现类即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="集合“体系”下的集合框架（Collections-Framework）"><a href="#集合“体系”下的集合框架（Collections-Framework）" class="headerlink" title="集合“体系”下的集合框架（Collections Framework）"></a>集合“体系”下的集合框架（Collections Framework）</h1><p>集合框架的构成：</p>
<ul>
<li>提供一系列的集合接口：如 <code>Set</code>，<code>List</code>，<code>Map</code> 等</li>
<li>针对集合接口的基础支持，如 <code>Iterator</code></li>
<li>针对集合接口的抽象类实现：允许更多定制，类名通常以 <code>Abstract-</code> 开头</li>
<li>针对集合接口的通用实现：实现了接口的基本功能：<code>ArrayList</code>，<code>HashMap</code>，<code>LinkedList</code>，…</li>
<li>针对集合接口的包装类（<code>-Wrapper</code>）实现，比如让接口只读</li>
<li>针对集合接口的高性能且方便的功能性实现，如数组转换成 List</li>
<li>为早期的集合类添加集合接口的实现，如 <code>Vector</code>，<code>Hashtable</code> 等</li>
<li>针对集合接口的某些特殊实现，如特殊的 List</li>
<li>针对集合接口的同步实现：通常以 <code>Concurrent-</code> 开头，为线程安全类</li>
<li>提供了针对集合的算法，如 <code>Collections</code> 类提供的 List 排序算法</li>
<li>针对数组的工具类，但严格来说不算 JCF 的一部分</li>
</ul>
<p>学习框架是为了：</p>
<ul>
<li>想要实现用于多种集合类型的泛型算法</li>
<li>想要增加新的集合类型</li>
</ul>
<p>小结：</p>
<ul>
<li>该框架是一个类的集，奠定了创建高级功能的基础</li>
<li>框架使用者创建的子类可以扩展超类的功能，不必重新创建基本机制</li>
<li>Java 集合类库为集合实现者定义并描述大量接口和抽象类</li>
</ul>
<p><br></p>
<h1 id="基本接口"><a href="#基本接口" class="headerlink" title="基本接口"></a>基本接口</h1><p>接口类图如下：</p>
<p><img src="/2021/05/26/collections-java/interface-diagram.png" alt></p>
<big>包括：</big>

<h2 id="Collection-java-util-Collection"><a href="#Collection-java-util-Collection" class="headerlink" title="Collection (java.util.Collection)"></a><small><a href="/2022/04/30/java-collection">Collection</a> (<code>java.util.Collection</code>)</small></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为子接口</span></span><br><span class="line">java.util.Set</span><br><span class="line">java.util.SortedSet</span><br><span class="line">java.util.NavigableSet</span><br><span class="line">java.util.Queue</span><br><span class="line">java.util.concurrent.BlockingQueue</span><br><span class="line">java.util.concurrent.TransferQueue</span><br><span class="line">java.util.Deque</span><br><span class="line">java.util.concurrent.BlockingQueue</span><br></pre></td></tr></table></figure>
<h2 id="Map-java-util-Map"><a href="#Map-java-util-Map" class="headerlink" title="Map (java.util.Map)"></a><small><a href="/2022/05/06/java-map">Map</a> (<code>java.util.Map</code>)</small></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为子接口</span></span><br><span class="line">java.util.SortedMap</span><br><span class="line">java.util.NavigableMap</span><br><span class="line">java.util.concurrent.ConcurrentMap</span><br><span class="line">java.util.concurrent.ConcurrentNavigableMap</span><br></pre></td></tr></table></figure>
<big>和基础功能，如：</big>

<p><br></p>
<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><p>迭代器 <code>Iterator</code>：在实现了 Enumeration 接口的基础上，还能删除元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;  <span class="comment">// 返回下一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>  <span class="comment">// 循环调用遍历元素</span></span></span><br><span class="line"><span class="function"><span class="comment">// 到达队列末尾时，next() 抛出 NoSuchElementException</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/** </span></span></span><br><span class="line"><span class="comment"><span class="function"> * next() 和 remove() 的调用具有依赖性</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 调用 remove() 之前不调用 next()：抛出 IllegalStateException 异常</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span>  <span class="comment">// 删除上次调用 next() 时返回的元素    </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">()</span>  <span class="comment">// 编译器将其翻译为带有迭代器的循环</span></span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : c) &#123;</span><br><span class="line">    doSomething(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for each 对于标准类库任何集合都可使用</span></span><br></pre></td></tr></table></figure>
<p>应用：以 Map 为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">    <span class="comment">// 差劲的遍历方法，迭代 key，每次根据 key 再 get</span></span><br><span class="line">    <span class="comment">// Sonar 已不再建议这种迭代方式</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        Integer key = iterator.next();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般遍历方法，entrySet 是一个 Set 实现类，返回一个 Iterator 对象</span></span><br><span class="line">    Iterator&lt;?&gt; iterator2 = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator2.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator2.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般遍历方法，在 JDK 1.7- 最常见</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer, Object&gt; entry: map.entrySet()) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JDK 1.8 中的遍历方法，利用 lambda 表达式简化了语句</span></span><br><span class="line">    <span class="comment">// forEach 内部实现其实仍是一般方法</span></span><br><span class="line">    map.forEach((k, v)-&gt;&#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;=&quot;</span> + v);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 进一步简化</span></span><br><span class="line">    map.forEach((k, v)-&gt;System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">    <span class="comment">// 这里用到的是 Iterable 的 forEach() 接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器迭代，更加线程安全</span></span><br></pre></td></tr></table></figure>
<p>子接口 <code>ListIterator</code>：</p>
<ul>
<li>支持 Iterator 的功能</li>
<li>将一个元素添加到迭代器所处位置的前面：<code>void add(E element)</code></li>
<li>要想获取和删除给定位置的元素，只需调用 Iterator 接口中的 <code>next()</code> 和 <code>remove()</code> 方法即可</li>
<li>针对 List 的迭代器，支持双向迭代，元素替换，元素插入以及索引获取。</li>
</ul>
<p>注：<code>iterator.next()</code> 和 <code>iterator.hasNext()</code>，与 <code>Enumeration.nextElement()</code> 和 <code>Enumeration.hasMoreElements()</code> 一样</p>
<ul>
<li>仅仅是因为 iterator 接口的名字较短，导致更多人愿意使用</li>
</ul>
<h3 id="与-Enumeration-的区别"><a href="#与-Enumeration-的区别" class="headerlink" title="与 Enumeration 的区别"></a>与 <code>Enumeration</code> 的区别</h3><ul>
<li>Enumeration 出自 JDK 1.0，更基础，能满足基础需要；Iterator 出自 JDK 1.2；</li>
<li>Iterator 天生 <code>fail-fast</code>，面对集合编辑的时候更加安全；而 Enumeration 天然 <code>fail-safe</code>；</li>
<li>Iterator 允许调用者从集合中移除元素，Enumeration 则没有相关接口，其只能遍历元素。</li>
</ul>
<h3 id="fail-fast-属性"><a href="#fail-fast-属性" class="headerlink" title="fail-fast 属性"></a><code>fail-fast</code> 属性</h3><ul>
<li>每次尝试获取下一个元素时：该属性会检查当前集合的 <code>modCount</code> 变量</li>
<li>如发现 <code>modCount</code> 与当前不一致：抛出 <code>ConcurrentModificationException</code> <ul>
<li>如果存在多个线程对同一个集合内容进行操作，很容易会抛出此异常；</li>
<li>在调用 <code>iterator.hasNext()</code> 的过程中调用 <code>iterator.remove()</code>，不会抛出异常；而调用 <code>collection.remove()</code> 则会抛出异常</li>
</ul>
</li>
<li>Collection 中所有非线程安全的 Iterator 实现均按照 fail-fast 设计</li>
</ul>
<p>与之相对的就是：<code>fail-safe</code></p>
<ul>
<li>不抛出 ConcurrentModificationException</li>
<li>线程安全的集合的 iterator 就是 <code>fail-safe</code> 的</li>
<li>遍历时不直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历</li>
</ul>
<p>其实 fail-safe 的 iterator 由于自身的 weakly consistent，<strong>并不强保证遍历得到的元素一定正确</strong>。</p>
<big>注：</big>

<p>Java 集合类库中的迭代器不同于其他类库的迭代器</p>
<ul>
<li>传统集合类库迭代器使用数组索引建模：不需执行查找操作便可使迭代器移动</li>
<li>Java 迭代器只能调用 <code>next()</code>，执行查找操作时，迭代器随之移动</li>
</ul>
<p>因此 Java 迭代器应位于两元素之间：调用 <code>next()</code> 时跳至下一元素，返回前一元素。</p>
<p><img src="/2021/05/26/collections-java/next.png" alt></p>
<p>即：可将 <code>Iterator.next()</code> 和 <code>InputStream.read()</code> 等效</p>
<ul>
<li>从数据流中读取一个字节，自动“消耗掉”该字节</li>
<li>下次调用 <code>read()</code> 将会消耗并返回输入的下一个字节</li>
<li>同样方式，反复调用 <code>next()</code> 可读取集合中所有元素</li>
</ul>
<big>说到 Iterator，就不可避免地提到 Collection 的父接口：</big>

<h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a><small><code>Iterable</code></small></h2><ul>
<li>实现 Iterable 接口的类<strong>需要实现</strong> <code>iterator.iterator()</code>，用于生成一个 Iterator 迭代器；</li>
<li>实现了 Iterable 接口的类，可以使用 <code>for(:)</code> 循环遍历<ul>
<li>Since JDK 1.8：新的 <code>forEach()</code>，提供了默认实现，用于使用 lambda 表达式进行遍历（详情可参照<a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/Iterable.java">源码</a>）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;World!&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda 表达式遍历</span></span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda 表达式遍历简化版</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><strong>Iterable 和 Iterator 接口的区别</strong></p>
<ul>
<li>Iterable 描述的是一组可以迭代的元素，而每个元素在 Iterable 接口的实现里是无状态的；</li>
<li>而 Iterator 对象对于每一个元素是有状态描述的：因为 <code>next</code> 指针的存在，调用 <code>next()</code> <code>hasNext()</code> 方法会改变 next 的引用；</li>
<li>Iterable 实现了 iterator() 方法来获取 Iterator；</li>
<li>Iterable 遍历时不允许删除；而 Iterator 遍历时允许删除</li>
</ul>
<p>正因此，Iterable 的 forEach() 在无状态的情况下，每一次调用都遍历集合里面的<strong>所有元素</strong>；<br>而 Iterator.forEachRemaining() 同样有个 “forEach”，返回的则是所有<strong>未被遍历过的元素</strong>。 </p>
<h2 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h2><p><code>Comparable</code></p>
<ul>
<li>其实现类要求各个元素可以自然排序，从而可以对整个集合排序</li>
<li>元素之间的顺序由 equals() 的返回值得到</li>
</ul>
<p><code>Comparator</code></p>
<ul>
<li>如类本身不支持排序（没有实现 Comparable 接口）：手动创建一个类的 Comparator，重写排序方法</li>
<li>如实现了 Comparable 接口：仍可利用 Comparator 重定义排序方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">        ... <span class="comment">// 提供对象的自然排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Runtime-exceptions"><a href="#Runtime-exceptions" class="headerlink" title="Runtime exceptions"></a>Runtime exceptions</h2><ul>
<li><code>UnsupportedOperationException</code><ul>
<li>集合进行不被支持的操作时抛出</li>
</ul>
</li>
<li><code>ConcurrentModificationException</code><ul>
<li>迭代进行的时候集合被意外地修改，由迭代器抛出异常</li>
<li>当 List 的视图正在进行操作，而 List 被意外修改了，同样抛出该异常</li>
</ul>
</li>
</ul>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p><code>RandomAccess</code></p>
<ul>
<li>为避免执行成本较高的随机访问操作而引入的标记接口</li>
<li>该接口无任何方法，但可用来检测一个特定集合是否支持高效的随机访问</li>
<li>实现该接口的类需支持快速随机访问（random access）：随意访问 List 的任意索引的元素</li>
<li>实现了该接口的集合类：<ul>
<li><code>ArrayList</code></li>
<li><code>Vector</code></li>
<li><code>HashMap</code></li>
<li><code>TreeMap</code></li>
<li><code>Hashtable</code></li>
</ul>
</li>
</ul>
<p><br></p>
<h1 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h1><p>实现接口的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line">java.util.AbstractCollection</span><br><span class="line">java.util.AbstractList</span><br><span class="line">java.util.AbstractSequentialList</span><br><span class="line">java.util.AbstractSet</span><br><span class="line">java.util.AbstractQueue</span><br><span class="line"></span><br><span class="line">java.util.AbstractMap</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体类</span></span><br><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayList</span><br><span class="line">java.util.HashSet</span><br><span class="line">java.util.TreeSet</span><br><span class="line">java.util.PriorityQueue</span><br><span class="line">java.util.ArrayDeque</span><br><span class="line">java.util.concurrent.ConcurrentLinkedDeque</span><br><span class="line"></span><br><span class="line">java.util.HashMap</span><br><span class="line">java.util.TreeMap</span><br><span class="line">java.util.EnumMap</span><br><span class="line">java.util.concurrent.ConcurrentHashMap</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/26/collections-java/class-diagram.png" alt></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Interface</th>
<th style="text-align:center">哈希表</th>
<th style="text-align:center">可变数组</th>
<th style="text-align:center">平衡树</th>
<th style="text-align:center">链表</th>
<th style="text-align:center">哈希表+链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">List</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ArrayList</td>
<td style="text-align:center">-</td>
<td style="text-align:center">LinkedList</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">Deque</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ArrayDeque</td>
<td style="text-align:center">-</td>
<td style="text-align:center">LinkedDeque</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">Map</td>
<td style="text-align:center">HashMap</td>
<td style="text-align:center">-</td>
<td style="text-align:center">TreeMap</td>
<td style="text-align:center">-</td>
<td style="text-align:center">LinkedHashMap</td>
</tr>
<tr>
<td style="text-align:center">Set</td>
<td style="text-align:center">HashSet</td>
<td style="text-align:center">-</td>
<td style="text-align:center">TreeSet</td>
<td style="text-align:center">-</td>
<td style="text-align:center">LinkedHashSet</td>
</tr>
</tbody>
</table>
</div>
<table>
    <tr>
        <th></th>
        <th></th>
        <th>元素有序</th>
        <th>允许元素重复</th>  
    </tr>
    <tr>
        <td colspan="2">List</td>
        <td>是</td>
        <td>是</td>
    </tr>
    <tr>
        <td rowspan="3">Set</td>
        <td>AbstractSet</td>
        <td rowspan="2">否</td>
        <td rowspan="3">否</td>
    </tr>
    <tr>
        <td>HashSet</td>
    </tr>
    <tr>
        <td>TreeSet</td>
        <td>是（用二叉树排序）</td>
    </tr>
    <tr>
        <td rowspan="3">Map</td>
        <td>AbstractMap</td>
        <td rowspan="2">否</td>
        <td rowspan="3">key 值必须唯一，value 可重复</td>
    </tr>
    <tr>
        <td>HashMap</td>
    </tr>
    <tr>
        <td>TreeMap</td>
        <td>是（用二叉树排序）</td>
    </tr>
</table>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遗留类：JCF 针对较旧的集合类为其添加了集合接口实现</span></span><br><span class="line">java.util.Vector</span><br><span class="line">java.util.Stack</span><br><span class="line">java.util.Hashtable</span><br><span class="line">java.util.Properties</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/26/collections-java/legacy-class-diagram.png" alt></p>
<p><code>Hashtable</code>：与 HashMap 作用一样</p>
<ul>
<li>实现 Map 接口</li>
<li>与 HashMap <a href="/2022/05/08/java-hashmap/#HashMap%20v.s.%20Hashtable">有区别</a></li>
</ul>
<p><code>Enumeration</code>：枚举类</p>
<ul>
<li>类似于 Iterator 的 hasNext() 和 next()，其也有 <code>hasMoreElements()</code> 和 <code>nextElement()</code></li>
</ul>
<p>属性映射表（property map）</p>
<ul>
<li>键和值都是字符串</li>
<li>表可保存到一个文件中，也可从文件中加载</li>
<li>使用默认辅助表</li>
</ul>
<p>实现属性映射表的 Java 平台类称为 <code>Properties</code>，为线程安全类。</p>
<p><code>Vector</code></p>
<ul>
<li>实现 <code>AbstractList</code> 接口</li>
<li>加了同步锁，同步的可变数组（线程安全），同时也包含了其自身的较旧的方法</li>
<li>读写方法都只是简单加上 <code>synchronized</code>，性能较差</li>
</ul>
<p>Vector 扩容：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span>  <span class="comment">// 增量为正整数：按指定增量扩容</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span>  <span class="comment">// 每次扩容将容量扩大一倍</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span>  <span class="comment">// 等同于 public Vector(10)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Stack</code>：栈，扩展自 Vector 类</p>
<p><code>BitSet</code>：位集，存放位序列</p>
<p><br></p>
<h1 id="JCF-类图"><a href="#JCF-类图" class="headerlink" title="JCF 类图"></a>JCF 类图</h1><p><img src="/2021/05/26/collections-java/jcf-1.png" alt></p>
<p><img src="/2021/05/26/collections-java/jcf-2.png" alt></p>
<p>在使用时的最佳实践，应该是<strong>根据业务的需要</strong>去选择正确的集合类型。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合类</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式（Command）</title>
    <url>/2021/06/19/command/</url>
    <content><![CDATA[<p>命令模式别名为动机（Action）、事务（Transaction），属于对象行为型模式。</p>
<span id="more"></span>
<p>在《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“将一个请求封装为一个对象，从而可以用不同的请求对客户进行参数化、对请求排队或者记录请求日志，以及支持可取消的操作”
</code></pre><p>即：方便于使用不同的请求、队列或日志来参数化其它对象，同时支持可撤销操作。</p>
<p><br></p>
<h1 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h1><p>有时候需要向某个对象发送一个请求，但：</p>
<ul>
<li>不知道接收该请求的具体对象（接收者）是谁；</li>
<li>不知道具体处理过程，被请求到的操作是哪（几）个。</li>
</ul>
<p>在命令模式中，设计好的一堆命令会放到一个“编排器”中，“编排器”规定了命令的执行顺序。<br>按照命令模式的开发流程，只需要知道程序运行中指定的具体请求接收者即可。</p>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul>
<li>可使得请求的发送者和接收者之间实现完全的解耦；</li>
<li>发送者和接收者之间没有直接联系：发送者只需要知道如何发送请求命令即可，其它一概不管。</li>
</ul>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2021/06/19/command/commanduml.jpeg" alt></p>
<p>以上，可见命令模式包括以下角色：</p>
<p><code>Command</code></p>
<ul>
<li>抽象命令类</li>
<li>声明执行操作的接口（execute()）</li>
</ul>
<p><code>ConcreteCommand</code></p>
<ul>
<li>具体命令类</li>
<li>将一个接收者 Receiver 对象绑定于一个动作，调用 Receiver 相应的操作，以实现 execute()</li>
<li>如没有绑定 Receiver 对象：则操作的逻辑在该具体命令类中定义</li>
</ul>
<p><code>Invoker</code></p>
<ul>
<li>调用者</li>
<li>定义某一个请求过来的时候，对应有一个命令执行该请求</li>
</ul>
<p><code>Receiver</code></p>
<ul>
<li>接收者</li>
<li>定义了多个实际的与不同的请求相关的操作</li>
<li>任何类都可能成为一个接收者</li>
<li><strong>可有可无</strong>：视乎业务逻辑；如不定义接收者类：将操作逻辑上提到具体命令类</li>
</ul>
<p><code>Client</code></p>
<ul>
<li>客户类</li>
<li>通过调用调用者 Invoker 执行命令</li>
</ul>
<p><br></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul>
<li>Client 和 Receiver 需要同时开发</li>
<li>在开发过程中，随着具体命令 ConcreteCommand 的变化，Client 和 Receiver 分别需要不停地重构、改名</li>
<li>Receiver 是实际的执行类，执行与请求相关的操作<ul>
<li>concreteCommand.execute() 调用 Receiver 对应的操作，然后 Client 通过调用 Involker 实例，执行 concreteCommand.execute()</li>
</ul>
</li>
<li>Invoker 对象一般由一个或多个具体命令类构造而成</li>
<li>如要实现可撤销功能（redo &amp; undo），需要命令不按照调用执行，而是按照执行时的情况排序并执行</li>
</ul>
<p><br></p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>调用者：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command commandOne;</span><br><span class="line">    <span class="keyword">private</span> Command commandTwo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该调用者仅接收两个命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command commandOne, Command commandTwo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commandOne = commandOne;</span><br><span class="line">        <span class="keyword">this</span>.commandTwo = commandTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commandOne.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commandTwo.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接收者：具体做事情的类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActionOne has been taken.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActionTwo has been taken.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>命令类：间接或直接做事情的类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommandOne</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommandOne</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.actionOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommandTwo</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommandTwo</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.actionTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        Command commandOne = <span class="keyword">new</span> ConcreteCommandOne(receiver);</span><br><span class="line">        Command commandTwo = <span class="keyword">new</span> ConcreteCommandTwo(receiver);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(commandOne, commandTwo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户完全不需要管执行到的具体命令和顺序</span></span><br><span class="line">        invoker.actionOne();</span><br><span class="line">        invoker.actionTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Redo &amp; Undo：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommandOne</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="keyword">private</span> Receiver lastReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommandOne</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        record();</span><br><span class="line">        receiver.actionOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lastReceiver.actionOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>具体可用 List，Queue，图等实现方式。</p>
<p><br></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：</p>
<ul>
<li>降低系统的耦合度</li>
<li>新的命令可以很容易地加入到系统中</li>
<li>可以比较容易地设计一个命令队列和宏命令（组合命令），即解决好一系列命令的安排</li>
<li>可以方便地实现对请求的 Undo 和 Redo</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能会导致某些系统有过多的具体命令类：因为针对每一个命令都需要设计一个具体命令类</li>
<li>因此某些系统可能需要大量具体命令类，这将影响命令模式的使用</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的常量池们</title>
    <url>/2021/07/18/constant-pool/</url>
    <content><![CDATA[<p>本来想在 <a href="/2021/07/07/jvm-basics">JVM 初探</a>里面将 JVM 共享数据区里面的常量池讲清楚的，发现篇幅不够，因此另开了一个帖来唠唠。</p>
<span id="more"></span>
<p>常量池的实现是为了避免频繁的创建和销毁对象而影响系统的性能，实现了对象的共享。</p>
<p>平时会提及的 Java 中的常量池 Constant Pool 包括：</p>
<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>在编译期间就把所有字符串文字放入一个常量池中：</p>
<ol>
<li>对于 <code>String s = &quot;hello&quot;;</code> 直接生成放入常量池</li>
<li>对于 <code>String s = new String(&quot;hello&quot;);</code> 常量池生成 “hello” 常量，new 的实例会在运行时在堆中创建</li>
</ol>
<p>实现：<code>StringTable</code> 类，类似于一个 Hash 表</p>
<ol>
<li>Java 6 及之前版本：长度固定为 1009</li>
<li>Java 7 及之后版本：长度可以通过参数设定</li>
</ol>
<p>好处：</p>
<ul>
<li>节省内存空间：在常量池中，所有相同的字符串常量会被合并，最终只占一个空间。</li>
<li>节省运行时间：比较字符串时 <code>==</code> 比 <code>equals()</code> 快；对于两个引用变量，只用 <code>==</code> 判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<p><strong>小问题</strong>：两个线程共享字符串常量池同一个字符串，其中一个线程改变它会如何？<br>答：线程安全，因为 String 是 <code>final</code> 类</p>
<p><br></p>
<h1 id="静态常量池"><a href="#静态常量池" class="headerlink" title="静态常量池"></a>静态常量池</h1><ul>
<li>位于方法区中</li>
<li>在编译期为某个类生成某个 .class 文件的时候，会生成一个常量池<ul>
<li>即：.class 文件中的常量池</li>
</ul>
</li>
<li>用于存放编译期生成的：<ul>
<li>各种字符串（数字）字面量（文本字符串、final 常量值等）</li>
<li>符号引用量（类和接口的全限定名，字段名称和描述符，方法名称和描述符）</li>
<li>类、方法的信息</li>
<li>以上占用了 .class 文件绝大部分空间。</li>
</ul>
</li>
<li>池里面的数据项和数组项类似，使用索引访问。</li>
</ul>
<p><br></p>
<h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><ul>
<li>位于方法区中，存储元数据（类的版本、接口、域、方法等）</li>
<li>在类加载完成后，将 .class 文件中的常量池（静态常量池）加载到内存中，并保持到对应的区域</li>
<li>我们最常提及的常量池，就是这个运行时常量池，在程序运行的时候，常量也会产生，这些新的常量也会加入池中。</li>
</ul>
<p>静态常量池和运行时常量池的区别主要如下图：</p>
<p><img src="/2021/07/18/constant-pool/method-area.png" alt></p>
<p><br></p>
<p>如果按照内容类别分，有以下两大类：</p>
<p><img src="/2021/07/18/constant-pool/constant-pool.png" alt></p>
<p>其他信息：</p>
<ol>
<li>Java 6 及之前，常量池位于方法区，从 Java 7 之后移到了堆中</li>
<li>类加载期间就把常量加载进了常量池</li>
<li>部分原子类型的包装类也有自己的常量池<ul>
<li><code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Character</code>, <code>Boolean</code> 类型的常量池范围：除 <code>Boolean</code> (<code>true</code>/<code>false</code>)、<code>Character</code> [0 - 127] 外全部为 [-128, 127]</li>
<li><code>Float</code> 和 <code>Double</code> 类型没有常量池：与精度有关</li>
</ul>
</li>
<li>原始数据类型的包装类和 <code>String</code> 作为方法参数时，是值传递。</li>
</ol>
<p>测试代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String hel = <span class="string">&quot;hel&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lo = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// i1 != i2, 位于堆中非常量池的不同内存</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> int3 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// i1 == int3, i2 == int3，比较时会自动拆箱</span></span><br><span class="line"></span><br><span class="line">        Integer i3 = -<span class="number">128</span>;</span><br><span class="line">        Integer i4 = -<span class="number">128</span>;</span><br><span class="line">        <span class="comment">// i3 == i4, 指向常量池中同一内存(-128~127)：since Java 5 的机制</span></span><br><span class="line">        <span class="comment">// 自动装箱，Integer i3 = Integer.valueOf(-128);</span></span><br><span class="line">        <span class="comment">// valueOf 会返回常量池中的对象或新生成堆中对象，此处返回常量池对象</span></span><br><span class="line">        <span class="comment">// 注：算术计算（加减乘除）时也会自动拆箱</span></span><br><span class="line"></span><br><span class="line">        Integer i5 = <span class="number">128</span>;</span><br><span class="line">        Integer i6 = <span class="number">128</span>;</span><br><span class="line">        <span class="comment">// i5 != i6, 指向不在常量池中</span></span><br><span class="line">        <span class="comment">// 自动装箱，Integer i5 = Integer.valueOf(128);</span></span><br><span class="line">        <span class="comment">// valueOf 会返回常量池中的对象或新生成堆中对象，此处返回堆中对象</span></span><br><span class="line"></span><br><span class="line">        Boolean b1 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean b2 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// b1 == b2, 常量池</span></span><br><span class="line"></span><br><span class="line">        Double d1 = <span class="number">1.0</span>;</span><br><span class="line">        Double d2 = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// d1 != d2, double/float 未实现常量池</span></span><br><span class="line"></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// s1 != s2, 位于堆中非常量池的不同内存</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// s3 == s4, 调用 String.valueOf()，指向常量池中同一内存</span></span><br><span class="line"></span><br><span class="line">        String hello = <span class="string">&quot;hello&quot;</span>, hel = <span class="string">&quot;hel&quot;</span>, lo = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * hello == &quot;hello&quot;, 指向常量池中同一内存</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * hello == &quot;hel&quot; + &quot;lo&quot;, 编译器自动对操作符右边的常量拼接进行优化：编译阶段就进行拼接</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * hello != &quot;hel&quot; + lo, 编译器不会优化变量，过程相当于：</span></span><br><span class="line"><span class="comment">         *   - new StringBuilder().append(&quot;hel&quot;).append(lo).toString();</span></span><br><span class="line"><span class="comment">         *   - 通过 StringBuilder::toString 返回 new String()，所以是指向堆中的变量</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * hello != hel + lo, 变量拼接不可预料，无法优化</span></span><br><span class="line"><span class="comment">         * hello == Test.hel + Test.lo, 静态常量指向常量池中的常量</span></span><br><span class="line"><span class="comment">         * hello == (hel + lo).intern()，手动载入常量池</span></span><br><span class="line"><span class="comment">         *     true，因执行 intern() 后返回的是 &quot;hello&quot; 在常量池中的对象</span></span><br><span class="line"><span class="comment">         * Test.hel + Test.lo == (hel + lo).intern()，手动载入常量池</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        hello.intern();</span><br><span class="line">        <span class="comment">// 手动将字符串载入常量池，并将对应的符号常量作特殊处理</span></span><br><span class="line">        <span class="comment">// Java 6 及之前：字符串如已存在于常量池，则直接返回该常量；否则将其加入到常量池</span></span><br><span class="line">        <span class="comment">// Java 7 及以后：字符串如已存在于常量池，则直接返回该常量；否则说明字符串在堆中，将对在堆中的该字符串的引用（引用指向堆中的字符串）添加至常量池</span></span><br><span class="line">        <span class="comment">//   - 以后拿到的是该字符串的引用，实际则存在于堆中</span></span><br><span class="line"></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行前：在常量池创建 &quot;1&quot;</span></span><br><span class="line">        <span class="comment">// 执行时：new 一个 &quot;1&quot; 的对象存放到堆，然后 str1 指向堆中的变量</span></span><br><span class="line">        str1.intern();  <span class="comment">// 查看 &quot;1&quot; 是否在常量池中，存在则直接返回该常量</span></span><br><span class="line">        String str2 = <span class="string">&quot;1&quot;</span>;  <span class="comment">// 此时 &quot;1&quot; 已存在于常量池，str2 指向常量池的对象</span></span><br><span class="line">        System.out.println(str1 == str2);  <span class="comment">// false，因指向不同的位置</span></span><br><span class="line"></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">&quot;2&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">// 底层调用 StringBuilder::append 拼接 &quot;2&quot; 和 &quot;2&quot;，再调用 toString() 去 new 一个 String 对象 &quot;22&quot;</span></span><br><span class="line">        <span class="comment">// 因此 &quot;22&quot; 是在堆里创建的</span></span><br><span class="line">        str3.intern();  <span class="comment">// 此时堆中有 &quot;22&quot;，但常量池还没有 &quot;22&quot;</span></span><br><span class="line">        <span class="comment">// Java 6-：在常量池创建 &quot;22&quot;</span></span><br><span class="line">        <span class="comment">// Java 7+：将堆中对 &quot;22&quot; 的引用放入常量池</span></span><br><span class="line">        String str4 = <span class="string">&quot;22&quot;</span>;</span><br><span class="line">        <span class="comment">// Java 6- 指向常量池中的 &quot;22&quot;</span></span><br><span class="line">        <span class="comment">// Java 7+ 指向常量池中的引用，即 str3，最终指向堆中的变量</span></span><br><span class="line">        System.out.println(str3 == str4);</span><br><span class="line">        <span class="comment">// Java 6- 为 false（同 str1 与 str2 的比较）</span></span><br><span class="line">        <span class="comment">// Java 7+ 为 true</span></span><br><span class="line"></span><br><span class="line">        String str5 = <span class="keyword">new</span> String(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        String str6 = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        str5.intern();  <span class="comment">// &quot;3&quot; 已经存在于常量池中</span></span><br><span class="line">        System.out.println(str5 == str6);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        String str7 = <span class="keyword">new</span> String(<span class="string">&quot;4&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;4&quot;</span>);  <span class="comment">// 该 &quot;44&quot; 在堆里创建</span></span><br><span class="line">        String str8 = <span class="string">&quot;44&quot;</span>;  <span class="comment">// 该 &quot;44&quot; 在常量池中创建</span></span><br><span class="line">        str7.intern();  <span class="comment">// &quot;44&quot; 已经存在于常量池中，此时无论是 Java 6- 还是 Java 7+ 都直接返回常量值 &quot;44&quot;</span></span><br><span class="line">        System.out.println(str7 == str8);  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础</title>
    <url>/2021/07/24/database-basics/</url>
    <content><![CDATA[<p>我们平日里说得很多的数据库，指的是能够以一定方式（数据结构）去组织、储存在一起，能为多个用户共享，具有尽可能小的冗余度，并且能够与应用程序彼此独立的数据集合。</p>
<span id="more"></span>
<p>每个数据库都有一个或多个不同的 API 用于创建、访问、管理、搜索和复制所保存的数据。</p>
<h1 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h1><p>一个数据库通常包含有一个或者多个<strong>表</strong></p>
<ul>
<li>表是一种数据结构，是相关数据项的集合，由<strong>列</strong>和<strong>行</strong>组成</li>
<li>每一个表由一个名字标识（如“客户”、“订单”）</li>
<li>表中包含若干带有数据的记录（也称为<strong>行</strong>）<ul>
<li>数据库每一列都有列名</li>
<li>每一行包含一个相关的<strong>数据集</strong></li>
</ul>
</li>
</ul>
<h1 id="数据库相关的基本概念"><a href="#数据库相关的基本概念" class="headerlink" title="数据库相关的基本概念"></a>数据库相关的基本概念</h1><p><strong>实体</strong></p>
<ul>
<li>在现实世界中客观存在的，并且可以相互区分的对象或事物</li>
<li>如：“公司”、“项目”、“员工”</li>
</ul>
<p><strong>属性</strong></p>
<ul>
<li>实体所具有的某一属性</li>
<li>如：“公司名”、“地址”等都是实体“公司”的属性</li>
</ul>
<p><strong>主键</strong>，也称<strong>码</strong></p>
<ul>
<li>表中可以唯一确定一行数据的某个属性（或属性组）</li>
<li>如 [员工号]、[员工号, 绩效评定月份]</li>
<li>不同的表结构，对应的码不同</li>
</ul>
<p><strong>主属性</strong></p>
<ul>
<li>包含在任何一个码中的属性都是主属性</li>
<li>如上例的“员工号”“绩效评定月份”便是主属性</li>
</ul>
<p><strong>非主属性</strong></p>
<ul>
<li>与主属性相反</li>
<li>没有在任何候选码中出现过的属性便是非主属性</li>
</ul>
<p>另：</p>
<ul>
<li>数据表：数据的矩阵，表面上看是一张电子表格</li>
<li>列：一列（数据元素）包含相同类型的数据</li>
<li>行：一条记录，即一组相关的数据</li>
<li>冗余：存储两倍数据，可使系统速度更快</li>
<li>外键：关联两张表的标识</li>
<li>复合键：将多个列作为一个索引</li>
<li><strong><a href="/2021/07/28/db-index">索引</a></strong>：对数据表中一列或多列的值进行排序的结构，类似于目录</li>
<li>参照完整性：要求关系中不允许引用不存在的实体；与实体完整性时关系模型必须满足的完整性约束条件</li>
</ul>
<h1 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h1><p>指的是采用了关系模型（二维表格模型）来组织数据的数据库。</p>
<p>优点：</p>
<ol>
<li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>
<li>使用方便：通用的 SQL 语言使得操作关系型数据库非常方便</li>
<li>易于维护：丰富的完整性（实体完整性、参照完整性和用户定义的完整性）定义大大减低了数据冗余和数据不一致的概率</li>
</ol>
<p><strong>关系型数据库管理系统</strong>（Relational Database Management System,  <strong>RDBMS</strong>），是 SQL 的基础，也是所有现代数据库系统的基础。<br>市面上流行的所有数据库系统，包括 MS Access, SQL Server, IBM DB2, MySQL 等等，都是基于 RDBMS 来开发的。</p>
<h2 id="关系型数据库中数据表的关系"><a href="#关系型数据库中数据表的关系" class="headerlink" title="关系型数据库中数据表的关系"></a>关系型数据库中数据表的关系</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a><strong>函数依赖</strong></h3><p>在一张表中，如果在属性（或属性组）X 完全确定时，必定能确定属性 Y 的值</p>
<ul>
<li>那么在该数据表中，不会存在任意两条记录，它们在 X 属性（或属性组）上的值相同，而在 Y 属性上的值不同</li>
<li>即 Y 函数依赖于 X，X → Y，X 与 Y 一一对应</li>
</ul>
<h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a><strong>完全函数依赖</strong></h3><p>如存在 X → Y，且：</p>
<ul>
<li>对 X 任意一个真子集 X’，都不存在 X‘ → Y，则 X → Y 是一个完全函数依赖</li>
<li>非正式记法：X &gt;&gt; Y</li>
</ul>
<h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a><strong>部分函数依赖</strong></h3><p>如存在 X → Y，且：</p>
<ul>
<li>在 X 中存在一个真子集 X’，使 X‘ → Y，则 X → Y 是一个部分函数依赖</li>
<li>非正式记法：X &gt; Y</li>
</ul>
<h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a><strong>传递函数依赖</strong></h3><ul>
<li>如果 X → Y，Y → Z，且 Y 不属于 X，Y → X 不成立<ul>
<li>称 Z 传递函数依赖于 X</li>
<li>非正式记法：X &gt;&gt;&gt; Z</li>
</ul>
</li>
<li>如 Y 属于 X，则 Z 部分传递函数依赖于 X</li>
</ul>
<h2 id="范式（normalization）"><a href="#范式（normalization）" class="headerlink" title="范式（normalization）"></a>范式（normalization）</h2><p>范式（normal form, NF）：符合某一种级别的关系模式的集合，表达一个关系内部个属性之间的联系的合理化程度。</p>
<p>关系型数据库范式：</p>
<p>第一范式（<strong>1NF</strong>，1971）</p>
<ul>
<li>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值<ul>
<li>即：实体中某个属性不能有多个值或不能有重复属性</li>
<li>对属性的原子性约束，具有原子性，不可再分解</li>
<li>不能是集合、数组、记录等非原子数据项</li>
<li>简而言之：没有重复的列</li>
</ul>
</li>
<li>所有关系型数据库的最基本要求</li>
<li>符合 1NF 的关系中的每个属性都不可再分（属性的原子性）</li>
</ul>
<p>第二范式（<strong>2NF</strong>，1971）：消除了非主属性对于主键（码）的部分函数依赖</p>
<ul>
<li>在满足 1NF 的基础上，表中非 key 属性完全依赖于主键<ul>
<li>对记录的唯一性约束，要求记录（实体）有唯一性</li>
<li>指不能存在仅依赖 key 一部分的属性</li>
<li>如存在：这个属性和 key 的这一部分应该分离出来形成新的实体</li>
<li>新实体和原实体是一对多的关系</li>
</ul>
</li>
<li>数据库表中每个实例或记录必须可以被唯一地拆分<ul>
<li>选出一个能区分每个实体的属性或属性组，作为实体的唯一标识</li>
</ul>
</li>
</ul>
<p>2NF 的例子：</p>
<ul>
<li>某一表中的字段：学号、课程号、姓名、学分</li>
<li>学分依赖于课程号，姓名依赖于学号：不符合第二范式</li>
<li>可根据{课程号, 学分}分成一张表，{学号, 姓名}分成另一张表<ul>
<li>由此便中断了原表中数据的联系</li>
<li>解决方法：{学号, 课程号}分一张表</li>
</ul>
</li>
</ul>
<p>第三范式（<strong>3NF</strong>，1971）：消除了非主属性对于主键的传递函数依赖（间接相关）</p>
<ul>
<li>对字段冗余性的约束</li>
<li>确保表中各列与主键列直接相关（直接依赖关系），而不是间接相关<ul>
<li>任何字段不能由其他字段派生出来，要求字段没有冗余</li>
</ul>
</li>
</ul>
<p>此外还有 4NF，5NF（完美范式），6NF 等，但是对于绝大多数场景的数据库设计来说，能做到 3NF 已经基本足够。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>范式的优点：</p>
<ul>
<li>范式化的数据库更新起来更快</li>
<li>范式化之后，只有很少的重复数据，只需要修改更少的数据</li>
<li>范式化的表更小，可在内存中执行</li>
<li>很少的冗余数据，在查询时需要更少的 distinct 或 group by 语句</li>
</ul>
<p>范式的缺点：</p>
<ul>
<li>范式化的表在查询时经常需要很多关联：因为单独一个表内不存在冗余数据和重复数据<ul>
<li>导致稍微复杂一些的查询语句在查询范式的 schema 上可能需要多次关联</li>
<li>增加查询的代价，可能使一些索引策略无效</li>
</ul>
</li>
</ul>
<h2 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h2><p>没有冗余的数据库未必是最好的数据库；有时为了提高运行效率，必须降低范式标准，适当保留冗余数据。</p>
<p>我们可以通过在表中增加冗余或重复的数据提高数据库读写性能：</p>
<ul>
<li>概念数据模型设计时：遵守第三范式</li>
<li>物理数据模型设计时：降低范式标准<ul>
<li>增加字段，减少查询时的关联，提高效率</li>
</ul>
</li>
</ul>
<p>反范式的优点：</p>
<ul>
<li>避免关联：因为所有的数据几乎都可在一张表上显示</li>
<li>可设计有效的索引</li>
</ul>
<p>反范式的缺点：</p>
<ul>
<li>表格内冗余较多，删除数据时会造成表有些有用的信息丢失；</li>
<li>因此反范式<strong>一定要适度</strong></li>
</ul>
<p>实际的应用往往是混用范式和反范式。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引</title>
    <url>/2021/07/28/db-index/</url>
    <content><![CDATA[<p>数据库索引的本质是一种数据结构。</p>
<span id="more"></span>
<p>索引是定义在<strong>数据表</strong>的基础之上的，包括某个表中一列或若干列值，以及<strong>指向相对应数据页</strong>的逻辑指针。</p>
<p>建立索引的意义，在于能够通过缩小一张表中需要查询的记录/行的数目，来加快搜索所需数据的速度。<br>相当于图书的目录，可根据目录的页码快速找到所需内容。</p>
<p>一个好的数据库表设计，从一开始就应考虑添加索引。<br>因为索引数据的存储是有序的，通过查询索引数据去找东西，不需要遍历所有记录；最极端情况也就是：索引查询的效率等于二分法查询，趋近于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.62ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2926 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(1260,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1649,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2537,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>索引最大的优点，是能够大大加快数据的检索速度。这是创建索引的最主要原因。</p>
<ul>
<li>通过创建唯一性索引，可保证数据库表中每一行数据的唯一性</li>
<li>可加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li>
</ul>
<p>对应的，索引的缺点也不少：</p>
<ul>
<li>每创建出来一个索引，就是一个具体的数据结构，占用磁盘的固定的物理空间，聚簇索引的空间就更大了</li>
<li>创建索引和维护索引需要耗费时间，随着数据量增加而增加</li>
<li>对表中的数据进行增加、删除和修改时，索引也要动态维护：由此会降低维护速度</li>
</ul>
<p>因此建立索引需要遵循以下原则：</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>对于经常查询的字段，建议创建索引</li>
<li>索引不是越多越好：大量索引不仅会占用磁盘空间，而且影响对数据表 insert，delete，update 等语句的性能<ul>
<li>所以：<strong>避免对经常增删改的表进行过多的索引</strong>，因为表中数据被更改的同时，索引也会进行调整和更新，十分消耗系统资源</li>
</ul>
</li>
<li>数据量小的表建议不要创建索引：少于万级、十万级别的就不需要建立索引了，此时索引不仅起不到明显的优化效果，对于索引结构的维护反而消耗系统资源</li>
<li>不要在区分度低（表的数据重复，分布平均）的字段建立索引：如性别字段，只有“男”“女”，建索引完全起不到优化效果</li>
<li>当唯一性是某字段本身的特征时，指定唯一索引能提高查询字段</li>
<li>在频繁进行排列分组（group by / order by）的列上建立索引，如待排序有多个，可在这些列上建立<strong>联合索引</strong>。</li>
</ul>
<h2 id="联合索引为什么香"><a href="#联合索引为什么香" class="headerlink" title="联合索引为什么香"></a>联合索引为什么香</h2><p>对列 col1、col2 和 col3 建立联合索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">KEY test_col1_col2_col3 <span class="keyword">on</span> test(col1,col2,col3);</span><br></pre></td></tr></table></figure>
<p>如上，联合索引 <code>test_col1_col2_col3</code> 实际上建立了 <code>(col1)</code> <code>(col1,col2)</code> 和 <code>(col1,col2,col3)</code> 三个索引，对于大量数据的表，使用联合索引会大大减少开销；</p>
<p>同时就联合索引对数据进行搜索时，数据库可以直接遍历索引获取数据，<strong>无需回表</strong>，减少了很多 IO 操作；</p>
<p>另外，索引列越多，通过索引筛选出来的数据就越少，大大提升效率；但这并不意味着索引多就一定好，毕竟索引越多，占据的硬盘空间就越大，过多索引反而会影响 IO 性能。</p>
<p>一般联合索引不超过 <strong>3 列</strong>，否则虽然减少回表操作，但是索引块过多，查询时遍历的开销也会加大。</p>
<h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>指的是最左优先，在搜索数据的时候从联合索引的最左边开始匹配。</p>
<p>再比如，就联合索引 <code>test_col1_col2_col3</code>，执行下面这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> col1<span class="operator">=</span>"1" <span class="keyword">AND</span> col2<span class="operator">=</span>"2" <span class="keyword">AND</span> col4<span class="operator">=</span>"4";</span><br></pre></td></tr></table></figure>
<p>执行搜索的时候会根据<strong>最左前缀匹配原则</strong>（col1 在最左，col2 次之，col3 在最右），使用索引 <code>(col1,col2)</code> 进行数据匹配。</p>
<p>如果 SQL 语句只按照 col2 或 col3 进行查询，那么查询不会使用这个联合索引。</p>
<p>这是因为数据库在建立索引时会将索引按照列的顺序进行排序，而查询时必须按照索引声明时<strong>列的顺序</strong>依次查询。因此，只有在查询中按照<strong>索引最左边的列</strong>开始进行查询时，才能利用到这个索引。如果查询中没有按照索引最左边的列开始查询，那么即使这个索引存在，也不会被使用。</p>
<p>如果查询时候使用的条件是 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col2<span class="operator">=</span>"1" <span class="keyword">AND</span> col1<span class="operator">=</span>"2"</span><br></pre></td></tr></table></figure>
<p>优化器会<strong>自动优化</strong>为匹配联合索引的顺序，此时同样能命中索引。</p>
<p>最左匹配原则的应用可以提高查询效率，特别是当数据库中有大量数据时，能减少数据库系统的负载。因此，在设计复合索引时，要考虑到查询中最常用的条件，将这些条件放在索引的最左边，可以使得查询效率更高。</p>
<p><strong>注</strong>：</p>
<p>联合索引的连接类型 <code>type</code> 值的不同，会对联合索引的最终搜索结果有影响：</p>
<ul>
<li><code>type = ref</code>：非唯一性索引扫描，返回匹配某个单独值的所有行；</li>
<li><code>type = index</code>：从索引第一个字段逐个查找，直到找到符合的某一个索引；连接类型为该值时，说明此时<strong>不符合最左前缀匹配原则</strong>，与其无关。</li>
</ul>
<p>因此在建立索引的时候，应该尽量将区分度高的字段放前面，尽量减少一条 SQL 语句的影响行数。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>一般采用 <a href="/2023/06/04/b-tree">B 树</a>作为索引的实现。</p>
<p>为什么不使用 Hash 搜索呢？</p>
<p>Hash 的查询、插入、修改、删除的平均时间为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，而树的对应复杂度则为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.455ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4179 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(2412,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2801,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3401,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3790,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。<br>对于单行查询的需求，Hash 索引更快；但 SQL 的应用场景多为排序（order by）、分组（group by）和比较大小等操作，如果仍然使用 Hash，时间会退化为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。<br>所以根据 SQL 的需求，索引一般设计为树的数据结构；而且因为数据库存储大量数据的关系，一般使用 m 叉（m &gt; 2，即 2-3 树）自平衡二叉搜索树的实现方式。</p>
<p>MySQL 采用 <strong>B+ 树</strong>作为 InnoDB 引擎的数据结构。<br>对于范围查询，B+ Tree 比 B-Tree 的优势更大：</p>
<ul>
<li>适合磁盘存储，能充分利用局部性原理和磁盘预读</li>
<li>很低的树高度（扁平化），能存储大量数据</li>
<li>索引本身占用内存小</li>
<li>能很好支持单点查询、范围查询（无需中序回溯）、有序性查询。</li>
</ul>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.xiaolincoding.com/mysql/index/index_lose.html">小林coding - 索引失效有哪些？</a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式（Decorator）</title>
    <url>/2021/06/22/decorator/</url>
    <content><![CDATA[<p>装饰器模式属于对象结构型模式。</p>
<span id="more"></span>
<p>《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“动态地给一个对象添加一些额外的职责，就增加功能来说，该模式比生成子类更加灵活”
</code></pre><p>即：允许向一个已有的对象添加新的功能，同时又不改变其结构。<br>其本质仍然是通过子类生成，但是比直接使用子类添加功能更加灵活。</p>
<p><br></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通过继承的方式去扩充职责会有以下缺点：</p>
<ul>
<li>如果对象之间关系复杂的话：造成系统复杂，不利于维护</li>
<li>容易产生“类爆炸”</li>
<li>静态功能</li>
</ul>
<p>通过装饰器模式，能够动态地将责任附加到对象上</p>
<ul>
<li>通过此模式扩展功能：能提供比继承更加有弹性的替代方案</li>
</ul>
<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/2021/06/22/decorator/decorator-diagram.png" alt></p>
<p>以上，可见装饰器模式包括：</p>
<p><code>Component</code></p>
<ul>
<li>抽象构件</li>
<li>定义一个对象接口，可以给这些对象动态添加职责</li>
<li>被装饰类和装饰类均需实现该接口</li>
</ul>
<p><code>ConcreteComponent</code></p>
<ul>
<li>具体构件</li>
<li>定义一个具体的对象，可以给该对象添加职责</li>
</ul>
<p><code>Decorator</code></p>
<ul>
<li>抽象装饰类</li>
<li>实现 Component 接口，从外类扩展实现 Component 接口的类的功能</li>
<li>对于 Component 类：无需知道 Decorator 存在</li>
</ul>
<p><code>ConcreteDecorator</code></p>
<ul>
<li>具体装饰类</li>
<li>给 Component 添加额外的职责</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>抽象构件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体构件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape: Circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象装饰类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体装饰类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">        setRedBorder(decoratedShape);  <span class="comment">// 所添加的额外的职责</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Border Color: Red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即：</p>
<ol>
<li>通过实现要被装饰类的接口，生成抽象装饰器；</li>
<li>基于接口编程，抽象装饰器的构造方法传入被装饰的类接口的实现类；</li>
<li>实现一个具体装饰类，在需要装饰的方法中添加额外的职责。</li>
</ol>
<p><br></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p>
<ul>
<li>装饰类和被装饰类可以独立发展，不会相互耦合</li>
<li>装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
</ul>
<p>缺点</p>
<ul>
<li>多层装饰比较复杂</li>
</ul>
<h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><ol>
<li>扩展一个类的功能</li>
<li>动态增加功能，动态撤销</li>
</ol>
<h1 id="与代理模式的区别"><a href="#与代理模式的区别" class="headerlink" title="与代理模式的区别"></a>与代理模式的区别</h1><ul>
<li>代理模式追求流程的完整性与扩展性，追求对完整流程的把控和辅助；</li>
<li>装饰器模式讲求功能的修饰性；</li>
<li>装饰器模式可以通过层层嵌套来扩展功能，而某些代理并不支持多重嵌套。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式概述</title>
    <url>/2021/06/14/design-patterns/</url>
    <content><![CDATA[<p>总结前人的程序设计和开发经验并加以概括、丰富，形成共识，这便是各种设计模式诞生的初衷。</p>
<span id="more"></span>
<p><br></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有经验的面向对象设计者往往能够做出良好的设计。<br>但新手面对众多选择无从下手，这个时候总会去求助于使用过的非面向对象技术。</p>
<ul>
<li>然而，并不是解决任何问题都需要从头做起的；</li>
<li>当找到一个好的解决方案时，我们可以一遍又一遍地使用，在节省研发开销的同时，对该解决方案也能更好地维护。</li>
</ul>
<p>因此总结设计经验的重要价值就体现出来了：</p>
<ul>
<li>解决一个问题，是在什么地方或者怎样解决的？ -&gt; 需要我们<strong>总结经验</strong></li>
</ul>
<p><br></p>
<p>在进行项目开发之前，我们需明确：</p>
<h2 id="程序设计的原则（SOLID-CD）"><a href="#程序设计的原则（SOLID-CD）" class="headerlink" title="程序设计的原则（SOLID + CD）"></a>程序设计的原则（SOLID + CD）</h2><h3 id="单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle, SRP）"></a><strong>单一职责原则</strong>（Single Responsibility Principle, <strong>SRP</strong>）</h3><ul>
<li>一个类应该只有一个职责，即只有一个引起它变化的原因</li>
<li>每个职责都是变化的一个轴线（如 setter）</li>
<li>如一个类有一个以上的职责：职责耦合，导致了脆弱的设计<ul>
<li>影响复用性</li>
<li>当一个职责发生变化时，可能影响其他的职责</li>
</ul>
</li>
</ul>
<h3 id="开闭原则（Open-Close-Principle-OCP）"><a href="#开闭原则（Open-Close-Principle-OCP）" class="headerlink" title="开闭原则（Open Close Principle, OCP）"></a><strong>开闭原则</strong>（Open Close Principle, <strong>OCP</strong>）</h3><ul>
<li>对扩展开放，对修改关闭<ul>
<li>程序需要拓展时，不能修改原有的代码，应实现“热插拔”的效果</li>
</ul>
</li>
<li>尽量使用接口和抽象类</li>
<li>提高扩展性，易于维护和升级</li>
</ul>
<h3 id="里氏代换原则（Liskov-Substitution-Principle-LSP）"><a href="#里氏代换原则（Liskov-Substitution-Principle-LSP）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle, LSP）"></a><strong>里氏代换原则</strong>（Liskov Substitution Principle, <strong>LSP</strong>）</h3><ul>
<li>背景：任何基类可以出现的地方，子类一定可以出现</li>
<li>因此：不要去破坏继承体系<ul>
<li>可以扩展，增加自己特有的方法</li>
<li>但不要覆盖父类的非抽象（已实现）方法</li>
<li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类的更严格</li>
</ul>
</li>
<li>否则：代码会很容易有问题</li>
<li>继承复用的基石，开闭原则的补充</li>
</ul>
<h3 id="接口隔离原则（Interface-Segregation-Principle-ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle-ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle, ISP）"></a><strong>接口隔离原则</strong>（Interface Segregation Principle, <strong>ISP</strong>）</h3><ul>
<li>使用多个隔离的接口，比使用单个接口要好</li>
<li>设计接口的时候要精简，要单一，细化，不要设计一个庞大的接口</li>
<li>即：类依赖的接口也要职责分明，从而降低一个类之间的耦合度</li>
</ul>
<h3 id="依赖反转原则（Dependency-Inversion-Principle-DI）"><a href="#依赖反转原则（Dependency-Inversion-Principle-DI）" class="headerlink" title="依赖反转原则（Dependency Inversion Principle, DI）"></a><strong>依赖反转原则</strong>（Dependency Inversion Principle, <strong>DI</strong>）</h3><ul>
<li>依赖于抽象（接口），不依赖于具体细节</li>
<li>面向抽象编程，不要对实现进行编程</li>
<li>降低了客户与实现模块之间的耦合</li>
</ul>
<h3 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a><strong>合成复用原则</strong>（Composite Reuse Principle）</h3><ul>
<li>在一个新的对象里通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分</li>
<li>新对象通过委派调用已有对象的方法，达到复用其已有功能目的</li>
<li>多组合，少继承</li>
</ul>
<h3 id="迪米特法则（Demeter-Principle，最少知道原则）"><a href="#迪米特法则（Demeter-Principle，最少知道原则）" class="headerlink" title="迪米特法则（Demeter Principle，最少知道原则）"></a><strong>迪米特法则</strong>（Demeter Principle，最少知道原则）</h3><ul>
<li>一个实体应尽量少地与其它实体之间发生相互作用<ul>
<li>即：每一个类要减少与其他对象产生的依赖</li>
</ul>
</li>
<li>使得系统功能模块相互独立</li>
<li>当一个模块修改时，就会尽量少地影响其它的模块，扩展会相对容易</li>
<li>优点：高内聚，低耦合</li>
<li>缺点：一旦过度应用，会导致系统 / 工程中存在大量功能小的类，使得系统比较纷乱</li>
</ul>
<p><big>总结</big>：<strong>用抽象去构建框架，用实现去扩展细节</strong>。<br>一个词：<big><strong>解耦</strong></big>（高可用，低耦合）</p>
<p><br></p>
<h1 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h1><p>在软件工程中：对软件设计普遍存在（<strong>反复出现</strong>）的各种问题所提出的解决方案</p>
<ul>
<li>被反复使用，且为多数人所知晓，并经过分类编目的、代码设计经验的<strong>总结</strong>；</li>
<li>“每一个模式描述一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。</li>
</ul>
<p><big>设计模式的来源：</big></p>
<ul>
<li>绝大部分以往并无文档记录</li>
<li>或是来源于面向对象设计者圈子里面的非正式交流</li>
<li>或来源于某些成功的面向对象系统的某部分</li>
</ul>
<p>设计模式并不直接用来完成代码的编写，而是用来描述：在各种不同情况下如何解决问题的一种<strong>方案</strong>。</p>
<p><big>设计模式提出的原因：<strong>为了代码复用，增加可维护性</strong></big></p>
<ul>
<li>面向对象设计的终极目标——<strong>开闭</strong>（Open Closed），即：模块应该对扩展开放（open to extension），对修改关闭（close to modification）；</li>
<li>使开发者可以更加简单方便复用成功的设计和体系结构。</li>
</ul>
<h2 id="设计模式四要素"><a href="#设计模式四要素" class="headerlink" title="设计模式四要素"></a><strong>设计模式四要素</strong></h2><p>每一个设计模式都确定了所包含的类和实例，它们的角色、协作方式以及职责分配，总结为“在特定场景下解决一般设计问题的类，和相互通信的对象的描述”。</p>
<h3 id="模式名称（pattern-name）"><a href="#模式名称（pattern-name）" class="headerlink" title="模式名称（pattern name）"></a>模式名称（pattern name）</h3><ul>
<li>助记名，使用一两个词描述模式的目标问题、解决方案和效果</li>
<li>注：找到适当的模式名也是设计模式编目工作的难点之一</li>
</ul>
<h3 id="问题（problem）"><a href="#问题（problem）" class="headerlink" title="问题（problem）"></a>问题（problem）</h3><ul>
<li>描述应在何时使用模式</li>
<li>解释了设计问题，和问题存在的前因后果<ul>
<li>包括使用模式必须满足的一系列先决条件</li>
</ul>
</li>
<li>描述的可能是特定的设计问题（怎样用对象表示算法）</li>
<li>也可能描述的是：导致不灵活设计的类或对象结构</li>
</ul>
<h3 id="解决方案（solution）"><a href="#解决方案（solution）" class="headerlink" title="解决方案（solution）"></a>解决方案（solution）</h3><ul>
<li>描述了设计的组成部分，各部分之间的相互关系以及各自的职责和协作方式</li>
<li>提供设计问题的抽象描述，怎样用一般意义的元素组合去解决问题<ul>
<li>而并不是描述一个特定的、具体的设计或实现</li>
</ul>
</li>
</ul>
<h3 id="效果（consequences）"><a href="#效果（consequences）" class="headerlink" title="效果（consequences）"></a>效果（consequences）</h3><ul>
<li>描述模式应用的效果，及使用模式应该权衡的问题</li>
<li>包括对系统的灵活性、扩充性或可移植性的影响</li>
</ul>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a><strong>设计模式分类</strong></h2><p>GOF 所著的《设计模式》中，常用的设计模式一共 <code>23</code> 种，粒度和抽象层次各有不同。<br>按照每个设计模式的目的（模式用来干嘛的），大致可分为三种类型：  </p>
<p><br></p>
<h3 id="创建型模式：与对象的创建有关"><a href="#创建型模式：与对象的创建有关" class="headerlink" title="创建型模式：与对象的创建有关"></a><strong>创建型模式</strong>：与对象的创建有关</h3><ol>
<li>系统演化成越来越依赖于<strong>对象组合</strong>，而不是类继承</li>
<li>重心转移：从对一组固定行为的硬编码（hard-coding） -&gt; 定义一个较小的基本行为集<ul>
<li>硬编码不够灵活：如想改变设计的一部分，需通过重写或重新实现</li>
<li>行为可被组合成任意数目的更复杂的行为：因此不仅仅是实例化一个类<ul>
<li>如：实例化一个房间，不仅仅只是实例化一扇窗，还有窗户、桌子……等</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>创建型模式抽象了实例化过程，帮助一个系统独立于如何创建、组合和表示其对象。其中：</p>
<ul>
<li><strong>类创建型模式</strong>：使用继承改变被实例化的类</li>
<li><strong>对象创建型模式</strong>：将实例化委托给另一个对象</li>
</ul>
<p>主旋律：</p>
<ul>
<li>将关于该系统使用哪些具体的类的信息封装起来</li>
<li>隐藏了这些类的实例如何被创建和放在一起的（隐藏创建细节）<ul>
<li>在创建什么、在什么时候被创建、谁创建它、怎样被创建等方面给予了很大的灵活性</li>
</ul>
</li>
<li>达到使整个系统独立的目的</li>
</ul>
<p>应用场景：</p>
<ul>
<li>一个系统需要和它的对象和产品的创建相互独立</li>
<li>一组相关的对象被设计为一起使用</li>
<li>隐藏一个类库的具体实现，仅暴露它们的接口</li>
<li>创建独立复杂对象的不同表示</li>
<li>一个类希望它的子类实现它所创建的对象</li>
<li>类的实例化在运行时才指定</li>
<li>一个类只能有一个实例，而且这个实例能在任何时候访问到</li>
<li>实例应该能在不修改的情况下具有可扩展性</li>
</ul>
<p><strong>1. 抽象工厂模式</strong>（<strong>Abstract Factory</strong>）</p>
<pre><code>“提供一个创建一系列相关或相互依赖的对象（产品族）的接口，而无需指定它们具体的类”
</code></pre><p><strong>2. 建造者模式</strong>（<strong>Builder</strong>）</p>
<pre><code>“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示”
</code></pre><p><strong>3. 工厂方法模式</strong>（<strong>Factory Method</strong>）</p>
<pre><code>“定义一个用于创建对象的接口，让子类决定将哪一个类实例化”
</code></pre><ul>
<li>将一个类的初始化下放到子类</li>
</ul>
<p><strong>4. 原型模式</strong>（<strong>Prototype</strong>）</p>
<pre><code>“用原型实例指定创建对象的种类，并且通过复制该原型来创建新的对象”
</code></pre><p><strong>5. <a href="/2021/06/19/singleton">单例模式</a></strong>（<strong>Singleton</strong>）</p>
<pre><code>“保证一个类仅有一个实例，并提供一个对该实例的全局访问点”
</code></pre><p><br></p>
<h3 id="结构型模式：处理类或对象的组合"><a href="#结构型模式：处理类或对象的组合" class="headerlink" title="结构型模式：处理类或对象的组合"></a><strong>结构型模式</strong>：处理类或对象的组合</h3><ul>
<li>处理类或者对象的组合，涉及到如何组合类和对象以获得更大的结构</li>
<li>从程序结构上解决模块之间的耦合问题</li>
</ul>
<p><strong>1. <a href="/2021/06/22/adapter">适配器模式</a></strong>（<strong>Adapter</strong>）</p>
<pre><code>“将一个类的接口转换为客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作”
</code></pre><ul>
<li>消除接口不匹配造成的类不兼容问题</li>
</ul>
<p><strong>2. 桥接模式</strong>（<strong>Bridge</strong>）</p>
<pre><code>“将抽象部分与它的实现部分分离，使它们都可以独立地变化”
</code></pre><p><strong>3. 组合模式</strong>（<strong>Composite</strong>）</p>
<pre><code>“将多个对象组合成树状结构以表示“部分－整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性”
</code></pre><ul>
<li>让客户可以同等对待单个对象和对象的组合（具有一致性）</li>
</ul>
<p><strong>4. <a href="/2021/06/22/decorator">装饰器模式</a></strong>（<strong>Decorator</strong>）</p>
<pre><code>“动态地给一个对象添加一些额外的职责，就增加功能来说，该模式比生成子类更加灵活”
</code></pre><ul>
<li>是除了类继承之外，另一种扩展功能的方法</li>
</ul>
<p><strong>5. 外观模式</strong>（<strong>Facade</strong>）</p>
<pre><code>“为子系统中的一组接口提供一个一致的界面。其定义的高层接口能让这个子系统更加容易使用”
</code></pre><p><strong>6. 享元模式</strong>（<strong>Flyweight</strong>）</p>
<pre><code>“运用共享技术，有效地支持大量细粒度的对象”
</code></pre><p><strong>7. <a href="/2021/06/19/proxy">代理模式</a></strong>（<strong>Proxy</strong>）</p>
<pre><code>“为其他对象提供一个代理，以控制对这个对象的访问”
</code></pre><p><br></p>
<h3 id="行为型模式：对类或对象怎样交互和怎样分配职责进行描述"><a href="#行为型模式：对类或对象怎样交互和怎样分配职责进行描述" class="headerlink" title="行为型模式：对类或对象怎样交互和怎样分配职责进行描述"></a><strong>行为型模式</strong>：对类或对象怎样交互和怎样分配职责进行描述</h3><p>描述类或对象怎样<strong>交互</strong>和<strong>分配职责</strong></p>
<ul>
<li>一个类的行为或其算法可以在运行时更改</li>
<li>涉及到算法和对象间的职责分配</li>
<li>不仅描述对象或者类的模式，还描述它们之间的通信方式</li>
<li>将注意力从控制流转移到<strong>对象关系</strong>上来</li>
</ul>
<p><strong>1. 职责链模式</strong>（<strong>Chain of Responsibility</strong>）</p>
<pre><code>“使多个对象都有机会处理这个请求，从而避免请求的发送者和接收者之间的耦合关系”
“将这些对象连成一个链，并沿着这条链传递该请求，直到有一个对象处理它为止”
</code></pre><p><strong>2. <a href="/2021/06/19/command">命令模式</a></strong>（<strong>Command</strong>）</p>
<pre><code>“将一个请求封装为一个对象，从而可以用不同的请求对客户进行参数化、对请求排队或者记录请求日志，以及支持可取消的操作”
</code></pre><p><strong>3. 解释器模式</strong>（<strong>Interpretor</strong>）</p>
<pre><code>“给定一个语言，定义它的文法的一种表示，并且定义一个解释器，该解释器使用该表示来解释语言中的句子”
</code></pre><p><strong>4. 迭代器模式</strong>（<strong>Iterator</strong>）</p>
<pre><code>“提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示”
</code></pre><p><strong>5. 中介者模式</strong>（<strong>Mediator</strong>）</p>
<pre><code>“用一个中介对象来封装一系列的对象交互”
“使各对象不需要显式地相互引用，从而使其耦合松散，且可以独立改变它们之间的交互”
</code></pre><ul>
<li>当某些对象之间的作用发生改变的时候，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立地变化</li>
</ul>
<p><strong>6. 备忘录模式</strong>（<strong>Memento</strong>）</p>
<pre><code>“在不破坏封装性的前提下，捕获一个对象的内部状态（快照），并在该对象之外（外部化）保存这个状态”
“这样以后就可以将该对象恢复到保存的状态”
</code></pre><p><strong>7. <a href="/2021/06/22/observer">观察者模式</a></strong>（<strong>Observer</strong>）</p>
<pre><code>“定义对象之间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新”
</code></pre><p><strong>8. 状态模式</strong>（<strong>State</strong>）</p>
<pre><code>“允许一个对象在其内部状态改变的时候改变他的行为”
“这让对象看起来似乎修改了他所属的类”
</code></pre><ul>
<li>需要对每一个系统可能获取的状态创立一个状态类的子类，系统状态变化时，系统改变所选的子类</li>
</ul>
<p><strong>9. <a href="/2021/06/19/strategy">策略模式</a></strong>（<strong>Strategy</strong>）</p>
<pre><code>“定义一系列算法，将他们一一封装，并使他们可以相互替换”
“本模式使得算法能独立于使用它的客户而变化”
</code></pre><p><strong>10. <a href="/2021/06/22/template-method">模板方法模式</a></strong>（<strong>Template Method</strong>）</p>
<pre><code>“定义一个操作中算法的骨架，而将一些步骤延迟到子类中”
“能使得子类能在不改变一个算法的结构的情况下，即可重定义该算法的某些特定步骤”
</code></pre><p><strong>11. 访问者模式</strong>（<strong>Visitor</strong>）</p>
<pre><code>“表示一个作用于某对象结构中的各元素的操作。使开发者可以在不改变各元素的类的前提下定义作用于这些元素的新操作”
</code></pre><ul>
<li>把数据结构和作用于结构上的操作之间的耦合解脱开</li>
</ul>
<p>按照适用范围（模式用于类还是对象），分为两种类型：</p>
<ul>
<li>适用于<strong>类</strong>：工厂模式、适配器模式（类）、解释器模式、模板方法模式<ul>
<li>处理类和子类之间的关系</li>
<li>关系通过继承确立，编译时候就确定下来了</li>
</ul>
</li>
<li>适用于<strong>对象</strong>：其他的设计模式<ul>
<li>处理对象间的关系，可以变化，更具动态性</li>
</ul>
</li>
</ul>
<p>如下表：</p>
<table>
    <tr>
        <th rowspan="2" colspan="2"></th>
        <th colspan="3">目的</th>  
    </tr>
    <tr>
        <th>创建型
        </th><th>结构型
        </th><th>行为型
    </th></tr>
    <tr>
        <th rowspan="11">范围</th>
        <th rowspan="2">类</th>
        <td rowspan="2">Factory Method</td>
        <td rowspan="2">Adapter(Class)</td>
        <td>Interpreter</td>
    </tr>
    <tr>
        <td>Template Method</td>
    </tr>
    <tr>
        <th rowspan="9">对象</th>
        <td>Abstract Factory</td>
        <td>Adapter(Object)</td>
        <td>Chain of Responsibility</td>
    </tr>
    <tr>
        <td>Builder</td>
        <td>Bridge</td>
        <td>Command</td>
    </tr>
    <tr>
        <td>Prototype</td>
        <td>Composite</td>
        <td>Iterator</td>
    </tr>
    <tr>
        <td>Singleton</td>
        <td>Decorator</td>
        <td>Mediator</td>
    </tr>
    <tr>
        <td></td>
        <td>Facade</td>
        <td>Memento</td>
    </tr>
    <tr>
        <td></td>
        <td>Flyweight</td>
        <td>Observer</td>
    </tr>
    <tr>
        <td></td>
        <td>Proxy</td>
        <td>State</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td>Strategy</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td>Visitor</td>
    </tr>
</table>

<p>表格注释：  </p>
<ul>
<li>类创建型模式：将对象部分创建工作延迟到<strong>子类</strong></li>
<li>对象创建型模式：将对象部分创建工作延迟到<strong>另一个对象</strong>中</li>
<li>类结构型模式：使用<strong>继承</strong>机制组合类</li>
<li>对象结构型模式：描述对象的<strong>组合</strong>方式</li>
<li>类行为型模式：使用<strong>继承</strong>描述算法和控制流</li>
<li>对象行为型模式：描述一组对象怎样<strong>协作</strong>完成单个对象所无法完成的任务</li>
</ul>
<p>关系如下：<br><img src="/2021/06/14/design-patterns/patterns.png" alt></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2021/07/25/db-transaction/</url>
    <content><![CDATA[<p>我们常说到的数据库<strong>事务</strong>（Transaction），指的是访问并可能更新数据库中各种数据项的一个程序执行单元。</p>
<span id="more"></span>
<p>事务包括一系列的数据库操作，管理着 INSERT, UPDATE, DELETE 等语句。它可以是一条或一组 SQL 语句，或者是整个程序。</p>
<p>按照作用域来看，数据库事务主要可分两种：</p>
<ul>
<li>局部事务<ul>
<li>特定于一个单一的事务资源，如一个 JDBC 连接</li>
<li>APP 组件与资源位于同一单元</li>
</ul>
</li>
<li>全局事务<ul>
<li>跨多个事务资源的事务，比如在一个分布式系统中的事务</li>
</ul>
</li>
</ul>
<p>特性：须具备 <strong>ACID</strong></p>
<p><strong>A</strong>: 原子性（<strong>A</strong>tomicity）</p>
<ul>
<li>一个事务中的操作，要么全部完成，要么全部不完成（不做）</li>
<li>不会结束在某个中间环节</li>
<li>如果事务执行发生了错误：回滚（<strong>rollback</strong>）到事务开始前的状态，就如事务从未被执行过一样</li>
</ul>
<p><strong>C</strong>: 一致性（<strong>C</strong>onsistency）</p>
<ul>
<li>事务开始前和开始后，数据库的完整性没有被破坏</li>
<li>表示写入的资料必须完全符合所有的预设规则</li>
<li>包含资料的精确度、串联性以及后续数据库可以自发性完成预定的工作</li>
</ul>
<p><strong>I</strong>: 隔离性（<strong>I</strong>solation)</p>
<ul>
<li>数据库应拥有允许多个并发事务同时对其数据进行读写和修改的能力</li>
<li>并发事务之间不能互相干扰</li>
<li>可防止多个事务并发执行时，由于交叉执行而导致数据的不一致</li>
</ul>
<p><strong>D</strong>: 持续性（<strong>D</strong>urability）</p>
<ul>
<li>事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失</li>
</ul>
<p><br></p>
<h1 id="并发对数据库事务隔离性的破坏"><a href="#并发对数据库事务隔离性的破坏" class="headerlink" title="并发对数据库事务隔离性的破坏"></a>并发对数据库事务隔离性的破坏</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">并发下的问题</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">脏写</td>
<td style="text-align:left">事务回滚了其它事务对数据项的已提交修改</td>
</tr>
<tr>
<td style="text-align:left">丢失更新</td>
<td style="text-align:left">事务覆盖了其它事务对数据的已提交修改</td>
</tr>
<tr>
<td style="text-align:left">(以下为最常见的并发问题)</td>
</tr>
<tr>
<td style="text-align:left">脏读 Dirty Read</td>
<td style="text-align:left">一个事务读取了另一个<strong>未提交</strong>的事务中的数据</td>
</tr>
<tr>
<td style="text-align:left">不可重复读 Non-repeatable Read</td>
<td style="text-align:left">对于数据库中某个数据，在同一个事务范围内多次查询却返回不同数据值<br>因为在查询间隔，该数据被另一个事务修改并提交了</td>
</tr>
<tr>
<td style="text-align:left">幻读（多行的不可重复读）Phantom</td>
<td style="text-align:left">一个事务多次查询之间的数据的条数不一致<br>针对<strong>一批数据整体</strong>出现的问题</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h2 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">脏写示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（比如此时读出来的是 mazda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left"></td>
<td style="text-align:left">update car set name=’honda’ where id = 1;</td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left"></td>
<td style="text-align:left">commit;（脏写）</td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td style="text-align:left">rollback;</td>
</tr>
</tbody>
</table>
</div>
<p>会话 A rollback 后，car 记录是 “mazda”，而不是已经被 B 会话提交的 “honda”，这就造成了脏写。</p>
<p><br></p>
<h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">丢失更新示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left"></td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（比如此时两个会话读出来的都是 mazda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left">update car set name=’honda’ where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td style="text-align:left"></td>
<td style="text-align:left">update car set name=’mitsubishi’ where id = 1;</td>
</tr>
<tr>
<td style="text-align:center">T7</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T8</td>
<td style="text-align:left"></td>
<td style="text-align:left">commit;</td>
</tr>
</tbody>
</table>
</div>
<p>会话 B 的 “mitsubishi” 更新会因为会话 A 的提交而丢失。</p>
<p><br></p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">脏读示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left"></td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">update car set name=’audi’ where id = 1;</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td style="text-align:left"></td>
<td style="text-align:left">rollback;</td>
</tr>
</tbody>
</table>
</div>
<p>T4 的时候读取到的结果如果是 “audi”，就出现了脏读，因为会话 B 将事务回退了。</p>
<p><br></p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">不可重复读示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（比如此时会话读出来的是 mazda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left"></td>
<td style="text-align:left">update car set name=’mitsubishi’ where id = 1;</td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left"></td>
<td style="text-align:left">commit;</td>
</tr>
<tr>
<td style="text-align:center"><strong>T6</strong></td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（此时会话读出来的是 mitsubishi）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T7</td>
<td style="text-align:left"></td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T8</td>
<td style="text-align:left"></td>
<td style="text-align:left">update car set name=’honda’ where id = 1;</td>
</tr>
<tr>
<td style="text-align:center">T9</td>
<td style="text-align:left"></td>
<td style="text-align:left">commit;</td>
</tr>
<tr>
<td style="text-align:center"><strong>T10</strong></td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
</tr>
</tbody>
</table>
</div>
<p>T6 和 T10 都是不可重复读。</p>
<p>脏读 v.s. 不可重复读</p>
<ul>
<li>脏读读取的是其它事务<strong>未提交</strong>的脏数据</li>
<li>不可重复读读取的是其它事务<strong>已经提交</strong>的数据</li>
</ul>
<p><br></p>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">幻读示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">select * from car where id &gt; 0;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（比如此时会话读出来的是 mazda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left"></td>
<td style="text-align:left">insert into car(name) values(‘audi’)</td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left">select * from car where id &gt; 0;</td>
</tr>
</tbody>
</table>
</div>
<p>如果 T5 读取出来的值是 (‘mazda’, ‘audi’)，就出现了幻读。</p>
<p>幻读 v.s. 不可重复读</p>
<ul>
<li>不可重复读针对确定的<strong>某一行</strong>数据</li>
<li>幻读针对的是不确定的<strong>多行</strong>数据（Result Set）</li>
</ul>
<p><br></p>
<p>因为以上原因，我们才设定了事务之间的：</p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>逐级提高：</p>
<p><strong><big>读未提交</big></strong>（<strong>Read Uncommitted</strong>）：所有事务都可看到其它事务修改过但未提交的内容数据。</p>
<ul>
<li>仍可能发生脏读、不可重复读和幻读问题</li>
<li>没有解决任何并发问题，不常用</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">读未提交示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T0</td>
<td style="text-align:left">（比如此时 id = 1 的是 honda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">update car set name=’mazda’ where id = 1;</td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（此时会话读出来的是 mazda）</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（此时会话读出来的是 mazda）</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong><big>读已提交</big></strong>（<strong>Read Committed</strong>）：一个事务只能读取其它事务已经提交的内容数据</p>
<ul>
<li>如：事务 B 只能在事务 A 修改过并且提交之后，才能读取到事务 B 修改的数据</li>
<li>解决了脏读问题，但没有解决不可重复读和幻读，也不常用</li>
<li>Oracle 的默认级别</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">读已提交示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T0</td>
<td style="text-align:left">（比如此时 id = 1 的是 honda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">update car set name=’mazda’ where id = 1;</td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（此时会话读出来的是 mazda）</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong><big>可重复读</big></strong>（<strong>Repeatable Read</strong>）：保证一个事务之间的多个实例在<strong>并发</strong>下能读取同一数据</p>
<ul>
<li>对同一字段的多次读取结果是一样的，除非数据被自身事务修改</li>
<li>MySQL InnoDB 的默认级别</li>
<li>能解决脏读和不可重复读的问题；在 MySQL InnoDB 的实现中，一定程度上能够解决幻读问题</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">可重复读示意</th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
<th style="text-align:left">Session C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T0</td>
<td style="text-align:left">（比如此时 id = 1 的是 honda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">update car set name=’mazda’ where id = 1;</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（此时会话读出来的是 mazda）</td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left"></td>
<td style="text-align:left">commit;</td>
<td style="text-align:left">commit;</td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（此时会话读出来的是 mazda）</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong><big>串行化</big></strong>（<strong>Serializable</strong>）：事务之间只能顺序执行，使之没有任何冲突</p>
<ul>
<li>最高级别</li>
<li>通过加锁实现（读锁和写锁）</li>
</ul>
<p>串行化规范对于不同的情景有不同的阻塞操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">事务 A 读操作</th>
<th style="text-align:left">事务 A 写操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">事务 B 读操作</td>
<td style="text-align:left">不阻塞</td>
<td style="text-align:left">阻塞</td>
</tr>
<tr>
<td style="text-align:center">事务 B 写操作</td>
<td style="text-align:left">阻塞</td>
<td style="text-align:left">阻塞</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong>读读操作不阻塞</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T0</td>
<td style="text-align:left">（比如此时 id = 1 的是 honda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
</tr>
</tbody>
</table>
</div>
<p>事务 A 的读操作不会阻塞事务 B 的读操作。</p>
<p><br></p>
<p><strong>读写操作阻塞</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">update car set name=’mazda’ where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（会话 B 修改操作被阻塞）</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left"></td>
<td style="text-align:left">此时写操作才会被执行</td>
</tr>
</tbody>
</table>
</div>
<p>事务 A 的读操作会阻塞事务 B 的写操作。</p>
<p><br></p>
<p><strong>写读操作阻塞</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T0</td>
<td style="text-align:left">（比如此时 id = 1 的是 honda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">update car set name=’mazda’ where id = 1;</td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（会话 B 读取操作被阻塞）</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left"></td>
<td style="text-align:left">此时读操作才会被执行，查到的是 mazda</td>
</tr>
</tbody>
</table>
</div>
<p>事务 A 的写操作会阻塞事务 B 的读操作。</p>
<p><br></p>
<p><strong>写写操作阻塞</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">Session A</th>
<th style="text-align:left">Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T0</td>
<td style="text-align:left">（比如此时 id = 1 的是 mitsubishi）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:left">begin;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:left">update car set name=’mazda’ where id = 1;</td>
<td style="text-align:left">begin;</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:left"></td>
<td style="text-align:left">update car set name=’honda’ where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（会话 B 修改操作被阻塞）</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:left">commit;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td style="text-align:left">select * from car where id = 1;</td>
<td style="text-align:left">此时写操作才会被执行</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">（此时会话读出来的是 mazda）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td style="text-align:left"></td>
<td style="text-align:left">select * from car where id = 1;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（此时会话读出来的是 honda）</td>
</tr>
<tr>
<td style="text-align:center">T7</td>
<td style="text-align:left"></td>
<td style="text-align:left">commit;</td>
</tr>
</tbody>
</table>
</div>
<p>事务 A 的写操作会阻塞事务 B 的写操作。</p>
<p><br></p>
<p>级别越高，越能保证数据完整性和一致性，对并发的效率也越低。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">对象状态</th>
<th style="text-align:left">脏读</th>
<th style="text-align:left">不可重复读</th>
<th style="text-align:left">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">读未提交</td>
<td style="text-align:left"><font color="red">可能</font></td>
<td style="text-align:left"><font color="red">可能</font></td>
<td style="text-align:left"><font color="red">可能</font></td>
</tr>
<tr>
<td style="text-align:left">读已提交</td>
<td style="text-align:left"><font color="green">不会</font></td>
<td style="text-align:left"><font color="red">可能</font></td>
<td style="text-align:left"><font color="red">可能</font></td>
</tr>
<tr>
<td style="text-align:left">可重复读</td>
<td style="text-align:left"><font color="green">不会</font></td>
<td style="text-align:left"><font color="green">不会</font></td>
<td style="text-align:left"><font color="red">可能</font></td>
</tr>
<tr>
<td style="text-align:left">串行化</td>
<td style="text-align:left"><font color="green">不会</font></td>
<td style="text-align:left"><font color="green">不会</font></td>
<td style="text-align:left"><font color="green">不会</font></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>B 树</title>
    <url>/2023/06/04/b-tree/</url>
    <content><![CDATA[<p><a href="/2023/05/26/avl">AVL 树</a>和<a href="/2023/05/27/red-black">红-黑树</a>在内存中能够保持很好的性能，但不适用于规模大的字典，如外部字典或文件等用途。</p>
<span id="more"></span>
<p>因此我们采用度数更高的搜索树改善性能。</p>
<h1 id="背景：ISAM"><a href="#背景：ISAM" class="headerlink" title="背景：ISAM"></a>背景：ISAM</h1><p><strong>I</strong>ndexed <strong>S</strong>equential <strong>A</strong>ccess <strong>M</strong>ethod，索引顺序访问方法，本质上是公式化描述。</p>
<ul>
<li>将可用的磁盘空间划分成多块（磁盘空间最小单位），每个块包含 m 个元素（m 通常较大）</li>
<li>字典元素以升序存储在块中</li>
<li>索引存储了每个块中关键值的最大值，即索引的关键值数量与块数相同<ul>
<li>因此访问关键值 k 的时候，可以通过二分法，在索引中寻找包含相应元素的块，再在相应的块中寻找。</li>
</ul>
</li>
</ul>
<h1 id="背景：m-叉搜索树"><a href="#背景：m-叉搜索树" class="headerlink" title="背景：m 叉搜索树"></a>背景：m 叉搜索树</h1><p>m-way search tree，可以是一棵空树。</p>
<p>如果树非空，则需要满足：</p>
<ol>
<li>在相应的扩充搜索树中（用外部节点替换零指针），每个内部节点最多有 m 个子女及 1 ~ <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.883ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2600.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1100.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2100.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 个元素（外部节点不含元素和子女）</li>
<li>每个包含 p 个元素的节点，有 p+1 个子女</li>
<li>对于含 p 个元素的任意节点<ol>
<li>设 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.166ex" height="1.91ex" role="img" focusable="false" viewbox="0 -694 957.6 844"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container>, …, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.65ex;" xmlns="http://www.w3.org/2000/svg" width="2.171ex" height="2.22ex" role="img" focusable="false" viewbox="0 -694 959.7 981.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(554,-150) scale(0.707)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g></g></g></g></svg></mjx-container> 为这些元素的关键值，且顺序排列</li>
<li>设 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.967ex" height="1.375ex" role="img" focusable="false" viewbox="0 -442 869.6 607.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mn" transform="translate(466,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="1.967ex" height="1.339ex" role="img" focusable="false" viewbox="0 -442 869.6 592"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mn" transform="translate(466,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container>, …, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.65ex;" xmlns="http://www.w3.org/2000/svg" width="1.972ex" height="1.65ex" role="img" focusable="false" viewbox="0 -442 871.7 729.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(466,-150) scale(0.707)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g></g></g></g></svg></mjx-container> 是该节点的 p+1 个孩子，则：</li>
<li>以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.967ex" height="1.375ex" role="img" focusable="false" viewbox="0 -442 869.6 607.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mn" transform="translate(466,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container> 为根的子树中的关键值<strong>小于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.166ex" height="1.91ex" role="img" focusable="false" viewbox="0 -694 957.6 844"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container></strong></li>
<li>以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.65ex;" xmlns="http://www.w3.org/2000/svg" width="1.972ex" height="1.65ex" role="img" focusable="false" viewbox="0 -442 871.7 729.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(466,-150) scale(0.707)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g></g></g></g></svg></mjx-container> 为根的子树中的关键值<strong>大于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.65ex;" xmlns="http://www.w3.org/2000/svg" width="2.171ex" height="2.22ex" role="img" focusable="false" viewbox="0 -694 959.7 981.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(554,-150) scale(0.707)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g></g></g></g></svg></mjx-container></strong></li>
<li>以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.719ex" height="1.357ex" role="img" focusable="false" viewbox="0 -442 760 599.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(466,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 为根的子树中的关键值大于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.918ex" height="1.927ex" role="img" focusable="false" viewbox="0 -694 848 851.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(554,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>，小于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex;" xmlns="http://www.w3.org/2000/svg" width="3.963ex" height="2.041ex" role="img" focusable="false" viewbox="0 -694 1751.6 902"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="TeXAtom" transform="translate(554,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container>（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="9.084ex" height="2.143ex" role="img" focusable="false" viewbox="0 -753 4015.1 947"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2456.3,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(3512.1,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g></g></g></svg></mjx-container>）</li>
</ol>
</li>
</ol>
<p>如下例图所示：</p>
<p><img src="/2023/06/04/b-tree/7-way-search-tree.png" alt></p>
<ul>
<li>查找、搜索按照正常的方法进行</li>
<li>删除需要从非空相邻子树挑选替换元素</li>
</ul>
<h2 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h2><p>对于一棵高度为 h 的 m 叉搜索树来说：</p>
<ul>
<li>最少有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 576 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container> 个元素：每层一个节点，每个节点一个元素</li>
<li>最多有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.993ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 3090.7 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(911,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1590.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2590.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 个元素<ul>
<li>从 1 到 h - 1 层每个节点都含有 m 个孩子，且第 h 层的节点没有孩子</li>
<li>共 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.777ex;" xmlns="http://www.w3.org/2000/svg" width="28.821ex" height="2.966ex" role="img" focusable="false" viewbox="0 -967.8 12739 1311.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/></g><g data-mml-node="mi" transform="translate(1089,477.1) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="msup" transform="translate(2453.3,0)"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(911,363) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(3936,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(4991.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(5380.8,0)"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(911,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(6971.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(7971.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(8471.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8860.5,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mo" transform="translate(9360.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(9749.5,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(10849.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(11850,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(12350,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 个节点</li>
<li>每个节点最多包含 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.883ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2600.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1100.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2100.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 个元素，因此最多一共 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.993ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 3090.7 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(911,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1590.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2590.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 个元素</li>
</ul>
</li>
</ul>
<p>即：一棵包含 n 个元素的 m 叉树高度在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.458ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5064.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,-150) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1963.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2352.8,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3175.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4175.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4675.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 之间。</p>
<h1 id="m-序-B-树"><a href="#m-序-B-树" class="headerlink" title="m 序 B 树"></a>m 序 B 树</h1><p>B-Tree of order m，是一棵 m 叉搜索树。</p>
<p>如果树非空，则相应的扩充搜索树应该满足：</p>
<ol>
<li>根节点至少有两个孩子</li>
<li>除根节点外，所有内部节点至少有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.258ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2766 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"/></g><g data-mml-node="mi" transform="translate(444,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1322,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(1822,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(2322,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"/></g></g></g></svg></mjx-container> 个孩子</li>
<li>每个节点元素从小到大排列，即<strong>左小右大</strong></li>
<li><strong>所有外部节点在同一层</strong>，即根节点到每个叶子节点的长度都相同。</li>
</ol>
<p><img src="/2023/06/04/b-tree/7-b-tree.png" alt></p>
<h2 id="三序-B-树（2-3-树）"><a href="#三序-B-树（2-3-树）" class="headerlink" title="三序 B 树（2-3 树）"></a>三序 B 树（2-3 树）</h2><p>即 m = 3 的 B 树，内部节点可以有两个子节点和 1 个数据元素、或 3 个孩子节点和两个数据元素，叶子节点有 1 到 2 个数据元素。</p>
<p><img src="/2023/06/04/b-tree/2-3-tree.png" alt></p>
<h2 id="高度-1"><a href="#高度-1" class="headerlink" title="高度"></a>高度</h2><p>定理：</p>
<p>设 T 是一棵高度为 h 的 m 序 B 树，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.451ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4619.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(797.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(1853.6,0)"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"/></g><g data-mml-node="mi" transform="translate(2297.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3175.6,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(3675.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4175.6,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"/></g></g></g></svg></mjx-container>，n 是 T 中的元素个数，则</p>
<ol>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="23.937ex" height="2.327ex" role="img" focusable="false" viewbox="0 -853.7 10580 1028.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="msup" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="TeXAtom" transform="translate(553,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mo" transform="translate(2636.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3636.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4414.2,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(5470,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(6347.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(7403.5,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(8281.5,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(9079.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(10080,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="37.097ex" height="2.269ex" role="img" focusable="false" viewbox="0 -753 16397 1003"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,-150) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1963.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2352.8,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3175.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4175.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4675.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(5342.1,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(6397.8,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(7251.6,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(8307.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(8605.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(9090.4,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,-150) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g><g data-mml-node="mo" transform="translate(10018.1,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mo" transform="translate(10296.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(10685.1,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(11507.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(12507.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(13007.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(13396.5,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(13896.5,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(14396.5,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(14896.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(15897,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
</ol>
<p>证明：</p>
<ul>
<li>n 的上限：已证明</li>
<li>n 的下限：<ul>
<li>相应的扩充 B 树的外部节点都在 h+1 层</li>
<li>1, 2, 3, 4, …, h+1 层的节点最小数目是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="2.308ex" height="1.593ex" role="img" focusable="false" viewbox="0 -694 1020 704"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="3.295ex" height="1.909ex" role="img" focusable="false" viewbox="0 -833.9 1456.6 843.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="msup" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mn" transform="translate(553,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>, …, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.314ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 3232.7 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="msup" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(553,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1732.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2732.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>B 树外部节点最小数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.314ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 3232.7 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="msup" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(553,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g><g data-mml-node="mo" transform="translate(1732.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2732.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>因外部节点比元素个数多 1：得出下限值</li>
</ul>
</li>
<li>由 1 可得 2</li>
</ul>
<p>因此即使元素数量再多，树的高度也可以很小。<br>在实际应用中，树的序可以做到很大。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>B 树的搜索算法与 m 叉搜索树的相同，磁盘访问次数最多是 h。</p>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><ul>
<li>首先检查具有相同关键值元素是否存在<ul>
<li>如已经存在：不允许重复值，插入失败</li>
</ul>
</li>
<li>否则便可将元素插入到树中</li>
</ul>
<p>当新元素需要插入到饱和节点（超过了规定的 m 值）中时，饱和节点需要被分开。</p>
<p>将饱和节点记为 P：</p>
<ul>
<li>将带有空指针的新元素 e 插入到 P 中，得到一个有 m 个元素和 m+1 个孩子的溢出节点</li>
<li><p>以序列表示如下：</p>
<p>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="25.767ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11389 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1322.7,0)"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mn" transform="translate(466,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2192.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2636.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(3025.9,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mn" transform="translate(499,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(3928.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(4373.1,0)"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mn" transform="translate(466,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(5242.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(5631.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(6076.3,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(7415,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(7859.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(8248.7,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(499,-150) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(9418.5,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(9863.2,0)"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(466,-150) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(11000,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>    （<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.794ex" height="1.357ex" role="img" focusable="false" viewbox="0 -442 793 599.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(499,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 是元素，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.719ex" height="1.357ex" role="img" focusable="false" viewbox="0 -442 760 599.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(466,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 是孩子指针）</p>
</li>
</ul>
<p>我们从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex;" xmlns="http://www.w3.org/2000/svg" width="2.074ex" height="1.355ex" role="img" focusable="false" viewbox="0 -442 916.7 599.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(499,-150) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></g></svg></mjx-container> 处分开节点（已知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.451ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4619.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(797.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(1853.6,0)"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"/></g><g data-mml-node="mi" transform="translate(2297.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3175.6,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(3675.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4175.6,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"/></g></g></g></svg></mjx-container>），将左边元素保留在 P 中，右边元素分到新的节点 Q 中：</p>
<script type="math/tex; mode=display">P: d-1, c_0, (e_1, c_1), ..., (e_{d-1}, c_{d-1})</script><script type="math/tex; mode=display">Q: m-d, c_d, (e_{d+1}, c_{d+1}), ..., (e_m, c_m)</script><p>与此同时：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.63ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2930.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(499,-150) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g><g data-mml-node="mo" transform="translate(1305.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1750.4,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g><g data-mml-node="mo" transform="translate(2541.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 被插入到 P 的父节点中</li>
<li>要保证 P 和 Q 的孩子数量至少为 d</li>
</ul>
<p>当操作引起 s 个节点分裂时：</p>
<ul>
<li>磁盘访问次数 = <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 576 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container>（读取搜索路径上的节点） <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="3.952ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 1747 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container>（回写两个分裂出的新节点）<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>（回写新的根节点或插入后没有导致分裂的节点）</li>
<li>最多可达 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.331ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2798.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(1298.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2298.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
</ul>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>分两种情况讨论：</p>
<p>当被删除的元素在叶节点时，其孩子均为外部节点的节点：</p>
<ul>
<li>被删除元素在一个包含多于最少数目元素（又是树叶又是根节点：1；不是：⌈m/2⌉-1）的节点：将修改后的节点写回</li>
<li>被删除元素在非根且元素数量为最小值的节点：用其最相邻的左或右兄弟的元素替换<ul>
<li>将该元素往上移至其父节点，父节点被牵涉到的元素往下移动</li>
</ul>
</li>
<li>最相邻的兄弟不含额外的元素：将两个兄弟（自己，不含额外元素的最相邻兄弟）和父节点中介于两兄弟之间的元素合并</li>
<li>合并会减少父节点个数：需要检查父节点是否满足要求，并检查父节点相邻的兄弟<ul>
<li>要么从中取一个元素，要么与它合并</li>
<li>…</li>
<li>由此类推，最坏情况是一直回溯到根节点：变成空节点被抛弃，高度减 1</li>
</ul>
</li>
</ul>
<p>当被删除的元素在非叶节点：</p>
<ul>
<li>转化为 1.：既可以用左相邻子树中最大元素，也可以用右相邻子树最小元素替换被删除元素</li>
</ul>
<p>最坏情况的磁盘被访问次数：3h</p>
<ol>
<li>找到包含被删除元素需要 h 次读访问</li>
<li>获得第 2 到 h 层的最相邻兄弟需要 h-1 次读访问</li>
<li>在第 3 至 h 层的合并需要 h-2 次写访问</li>
<li>对修改过的根节点和第 2 层的两个节点进行 3 次写访问</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>B 树：每个节点存储 M/2 到 M 个关键字，非叶子节点存储指向关键字范围的子节点<ul>
<li>所有关键字在整棵树出现，且只出现一次，没有冗余</li>
<li>因此非叶子节点可以命中搜索记录</li>
</ul>
</li>
<li>B+ 树：在 B 树基础上，为叶子节点增加<strong>链表指针</strong><ul>
<li>所有关键字（值）在叶子节点中完整出现</li>
<li>非叶子节点作为叶子节点的索引，与叶子节点<strong>是有冗余的</strong></li>
<li>搜索结果总是要到叶子节点才命中</li>
</ul>
</li>
<li>B* 树：在 B+ 树基础上，为非叶子节点也增加链表指针</li>
</ul>
<p>应用：直方图，关系型数据库存储</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 概述</title>
    <url>/2022/02/09/es/</url>
    <content><![CDATA[<p>Elasticsearch（ES）是用 Java 开发的，并在 Apache 许可条款下开放源码发布，是一款非常流行的分布式、多用户能力的全文搜索引擎。</p>
<span id="more"></span>
<p>ES 基于 <strong>Apache Lucene</strong> 库（由 Doug Cutting，Hadoop 之父开发）进行开发，对 Lucene 的接口进行了封装；而且提供了 RESTful web 的接口，开箱即用，非常适合二次开发。</p>
<p>ES 中的 Elastic 本质就是<strong>分布式数据库</strong></p>
<ul>
<li>分布式必然伴随着<strong>强扩展</strong></li>
<li>允许多台服务器协同工作</li>
<li>每台服务器可运行多个 Elastic 实例</li>
<li>直击关系型数据库因业务增长需要分页、分表带来潜在的数据迁移的痛点。</li>
</ul>
<p>因此 ES 应用于云计算中，能够实现实时搜索，稳定、可靠、快速、安装使用方便，比关系型数据库的 like 模糊查找效率更高。其官方客户端在 Java、.NET（C#）、PHP、Python、Groovy、Ruby 和许多其他语言中都是可用的。</p>
<p>根据 DB-Engines 的排名显示，Elasticsearch 已是最受欢迎的企业搜索引擎，并应用于多个大型网页应用中，如 Wikipedia, Stack Overflow, Github 等；<br>排行榜其次的是 Apache Solr，也是基于 Lucene。</p>
<h1 id="Elasticsearch-v-s-Solr"><a href="#Elasticsearch-v-s-Solr" class="headerlink" title="Elasticsearch v.s. Solr"></a>Elasticsearch v.s. Solr</h1><p>两者都是基于 Lucene 这个 Java 库开发的，各自的面向点有差异。</p>
<p>ES 的优点：</p>
<ul>
<li>Elasticsearch 是<strong>分布式</strong>搜索引擎，天生带有易扩展、高可用的特性，且不需要其它组件</li>
<li>Elasticsearch 的分发是实时的，被叫做“Push replication”；且完全支持 Lucene 的<strong>接近实时</strong>的搜索，新增到 ES 中的数据在 1 秒之后就可以被搜索到</li>
<li>Elasticsearch 采用 Gateway 的概念，使备份更加简单</li>
<li>各节点组成的网络结构是对等的，某些节点出现故障的时候，会自动分配其它节点代替其进行工作。</li>
</ul>
<p>ES 的缺点：</p>
<ul>
<li>非实时性搜索的速度比不上 Solr</li>
<li><strong>仅支持 JSON</strong> 文件格式</li>
<li>版本更新太频繁，如 6.x 和 7.x 在使用上有不少的区别：好事说明它活跃，坏事说明它版本差别大，会产生一定的学习成本。</li>
</ul>
<p>Solr 的优点：</p>
<ul>
<li>面世比 ES 早了 4 年，成熟、稳定，有一个更大、更成熟的用户、开发和贡献者社区</li>
<li>Solr 支持添加多种格式的索引，如 HTML、PDF、Office 文件（<code>.xls</code>, <code>.docx</code>, <code>.pptx</code> 等）以及 JSON、XML、<code>.csv</code> 等纯文本格式</li>
<li>在不考虑建索引的同时进行搜索，速度更快。</li>
</ul>
<p>Solr 的缺点：</p>
<ul>
<li>建立索引之后，搜索的效率会下降，实时索引的搜索效率不高。</li>
</ul>
<p>性能对比：</p>
<ul>
<li>单纯对已有数据进行搜索时，Solr 比 ES 快了大约 1.6 倍</li>
<li>建立了实时索引时，Solr 会产生 IO 阻塞，查询性能较差；ES 此时会快大约 4 倍，具有明显优势</li>
<li>随着数据量的增加，Solr 的搜索效率会变得很低，跟 ES 的差别甚至会达到 100 倍以上；而 ES 却没有明显变化</li>
<li>在实际生产环境的测试中，搜索引擎从 Solr 转到 ES 之后的平均 RT 大概会有 50 倍的提升。</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Node：节点，单个 Elastic 实例</p>
<p>Cluster：集群，一组 Elastic 实例</p>
<p><strong>Index</strong>：Elastic 数据管理的顶层单位</p>
<ul>
<li>索引是<strong>映射类型</strong>（mappings）的<strong>容器</strong>，是一个非常大的文档（Document）集合，相当于单个数据库</li>
<li>索引存储了所有映射类型的字段（field）和其它设置，Elastic 会索引所有字段，处理后写入一个反向索引（inverted index），存储到各个分片上</li>
<li>查找数据的时候直接查找该索引</li>
<li>与关系型数据库的“索引”不一样</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前节点所有 index：</span></span><br><span class="line">http://localhost:9200/_cat/indices?v</span><br><span class="line"></span><br><span class="line">health status index         uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">green  open   series_titles l5gnXXJlQUCsWwcrmcy9tg   1   0          0            0       261b           261b</span><br><span class="line">green  open   site_titles   HVUGVU5qROCIy3jHK3bVyA   6   0          0            0      1.5kb          1.5kb</span><br><span class="line">green  open   wfs           nxLo35j9Trqh3CzvotgLyw   5   0          0            0      1.2kb          1.2kb</span><br><span class="line">green  open   seasons       YsgvnPK2Qh2diMn8s00vtQ   1   0          0            0       261b           261b</span><br><span class="line">green  open   master_titles zMi-WlSMQ_Krqlvdnjp5pQ   3   0          0            0       779b           779b</span><br></pre></td></tr></table></figure>
<p><small>注：觉得 Elasticsearch 命令行不够直观的话，可以使用 <a href="https://github.com/mobz/elasticsearch-head">elasticsearch-head</a> 客户端进行管理，其底层调用的是 ES 的 API。</small></p>
<p><strong>Document</strong>：文档</p>
<ul>
<li>index 里面的单条记录，使用 JSON 格式</li>
<li>一条 document 同时包含字段和对应的值（映射类型，key:value），许多条 document 构成一个 index</li>
<li>同一 index 里的 document 最好保持相同的结构（schema）</li>
</ul>
<p>ES 是<strong>面向文档</strong>的，意味着索引和搜索数据的最小单位就是文档：</p>
<ul>
<li>文档的结构很灵活，不依赖预先定义的模式，避免需要修改 schema 时造成的性能损耗；</li>
<li>文档对于字段是非常灵活的，有时候可以忽略字段或者动态添加一个新字段。</li>
</ul>
<p><strong>Type</strong>（7.x 被标记过时，后续版本会被移除）</p>
<ul>
<li>document 的虚拟逻辑分组，用于过滤 document</li>
<li>（就像关系型数据库一样，表格是行的容器）</li>
<li>type 对于字段的定义称之为映射（mapping），如：字段 name 映射为字符串类型</li>
</ul>
<p>可以按照以下映射理解，但映射两端并不是同一类型的东西，对比并不正确：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关系型数据库</th>
<th>Elasticsearch</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>index</td>
<td>指向一个或多个物理分配的逻辑命名空间</td>
</tr>
<tr>
<td>table</td>
<td>type</td>
<td>用于区分同一个集合的不同细分</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>ES 是面向文档的，各种文本内容以文档形式存储到 ES 中，以 JSON 作为文档序列号格式</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>文档可以有很多字段，可以指定字段的数据格式</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Elasticsearch-支持的-field-类型"><a href="#Elasticsearch-支持的-field-类型" class="headerlink" title="Elasticsearch 支持的 field 类型"></a>Elasticsearch 支持的 field 类型</h2><p>在创建索引的时候，我们可以不去指定字段 field 的类型（mappings），由 Elasticsearch 自行决定字段类型；<br>我们也可以通过 mappings 的方式，指定索引中字段的类型。</p>
<table>
    <tr>
        <th>一级分类</th>  
        <th>二级分类</th>  
        <th>具体类型</th>  
    </tr>
    <tr>
        <th rowspan="7">核心类型</th>
        <td><b>字符串类型</b></td>
        <td>string, text, keyword</td>
    </tr>
    <tr>
        <td>整数类型</td>
        <td>integer, long, short, byte</td>
    </tr>
    <tr>
        <td>浮点类型</td>
        <td>double, float, half_float, scaled_float</td>
    </tr>
    <tr>
        <td>逻辑类型</td>
        <td>boolean</td>
    </tr>
    <tr>
        <td>日期类型</td>
        <td>date</td>
    </tr>
    <tr>
        <td>范围类型</td>
        <td>range</td>
    </tr>
    <tr>
        <td>二进制类型</td>
        <td>binary</td>
    </tr>
    <tr>
        <th rowspan="3">复合类型</th>
        <td>数组类型</td>
        <td>array</td>
    </tr>
    <tr>
        <td>对象类型</td>
        <td>object</td>
    </tr>
    <tr>
        <td>嵌套类型</td>
        <td>nested</td>
    </tr>
    <tr>
        <th rowspan="2">地理类型</th>
        <td>地理坐标类型</td>
        <td>geo point</td>
    </tr>
    <tr>
        <td>地理地图</td>
        <td>geo shape</td>
    </tr>
    <tr>
        <th rowspan="5">特殊类型</th>
        <td>IP 类型</td>
        <td>ip</td>
    </tr>
    <tr>
        <td>范围类型</td>
        <td>completion</td>
    </tr>
    <tr>
        <td>令牌计数类型</td>
        <td>token count</td>
    </tr>
    <tr>
        <td>附件类型</td>
        <td>attachment</td>
    </tr>
    <tr>
        <td>抽取类型</td>
        <td>percolator</td>
    </tr>
</table>

<p>text 和 keyword 有啥区别？</p>
<ul>
<li>text 可以分词，可利用分词后结果进行索引，用于全文搜索；</li>
<li>keyword 不可分词，其用来直接索引，用于关键词搜索。</li>
</ul>
<p>比如存在字段 foo1 的 type 为 text，分别有“大佬”“大佬的朋友”两个文档：当搜索“大佬”的时候，两个文档都会被搜索出来；<br>字段 foo2 的 type 为 keyword，分别有“大佬”“大佬的朋友”两个文档：当搜索“大佬”的时候，只有前一个文档会被搜索出来。</p>
<p><small>注：string 在老版本的 Elasticsearch 使用较多；从 Elasticsearch 5.x 开始不再支持 string，由 text 和 keyword 类型替代。</small></p>
<p>删除数据的时候是标记删除，数据从 buffer pool 里面同步到 segment 中，多个 segment 组合更新到磁盘。</p>
<p>在同步到 segment 的时候为了保证倒序索引能够被更新且降低维护成本，会创建一个全新的索引，且将所有的索引全部遍历一遍，将全部修改聚合并写回磁盘。</p>
<p><br></p>
<h1 id="正序索引和倒序索引"><a href="#正序索引和倒序索引" class="headerlink" title="正序索引和倒序索引"></a>正序索引和倒序索引</h1><p>比如说我们有三个文档：</p>
<p>ID1: 今天我们一起学习 Elasticsearch<br>ID2: Elasticsearch 学习起来真有趣<br>ID3: 今天下班大家一起打火锅怎么样</p>
<p>按照正序索引，我们将文档 ID 设置为 key，将文档设置为 value，包括关键词 N，出现次数，出现位置等：</p>
<p>ID1: 【今天】【我们】【一起】【学习】【Elasticsearch】<br>ID2: 【Elasticsearch】【学习】【起来】【真】【有趣】<br>ID3: 【今天】【下班】【大家】【一起】【打】【火锅】【怎么样】</p>
<p>按照倒序索引，我们将文档等设置为 key，文档 N 的 ID 设置为 value：</p>
<p>【今天】: ID1-位置1, ID3-位置1<br>【我们】: 1D1-位置2<br>【一起】: ID1-位置3, ID3-位置4<br>【学习】: ID1-位置4, ID2位置2<br>【Elasticsearch】: ID1-位置5, ID2-位置1<br>【起来】: ID2-位置3<br>【有趣】: ID2-位置5<br>……</p>
<p>有啥用？</p>
<p>比方说我们如果想要搜索关键词“一起”，根据正序索引，需要遍历文档 ID，再遍历所有文档去找“一起”出现的位置；<br>而使用倒序索引的话，我们通过遍历拆分过后的文档，便能迅速知道该关键词在文档 1 和文档 3 中存在。</p>
<p>如果搜索关键词“我们一起”，涉及到全文搜索，根据倒序索引的话很快就能找到文档 1 包含所有关键词，而文档 3 只包含“一起”，由此我们可以判定对于这个关键词，文档 1 的 <strong>score</strong> 值会比文档 3 要高。</p>
<p>score 越高的文档，在对应的搜索结果中就会排得越靠前。</p>
<p><br></p>
<h1 id="分片和副本"><a href="#分片和副本" class="headerlink" title="分片和副本"></a>分片和副本</h1><p>分片和副本是大数据中非常重要的概念。</p>
<p>当文档量非常庞大，而服务器物理内存有限的情况下，ES 基于自身<strong>分布式</strong>的特点，会采取“分而治之”的策略：</p>
<ul>
<li>将数据副本分为主分片（primary shard）和副分片（replica shard）；</li>
<li>主分片的数据作为权威数据；</li>
<li>写数据的时候，先写主分片（真正的业务写入），写入成功后再写副分片（数据同步）；</li>
<li>恢复数据的时候，以主分片上的数据为准</li>
</ul>
<p><img src="/2022/02/09/es/es-distribution.png" alt></p>
<p>如上图，数据被分成了 3 个副本，3 个分片中分别有一个副本。</p>
<ul>
<li>Master 存储数据和分片的 mapping，到 Slave 才存储具体的数据</li>
<li>请求数据的时候，请求发送至 Master，再根据 mapping 去对应的分片中查询数据</li>
<li>万一其中一台 Slave 宕机，其它的 Slave 也会有一样的副本数据，不会导致数据丢失或查询请求失败</li>
<li>数据副本会根据一定的策略存储到分片中，<strong>并不是每一个分片都要存储所有的副本</strong>；分布式系统中，只要保证数据副本有多于一份就好</li>
<li>写数据的时候，先往机器 B 写，随后同步其它的 Slave 机器</li>
</ul>
<p>在 ES 创建一个索引的时候，默认是 5 个分片，每个分片一个副本。</p>
<h2 id="集群状态"><a href="#集群状态" class="headerlink" title="集群状态"></a>集群状态</h2><p>例图：</p>
<p><img src="/2022/02/09/es/es-cluster.png" alt></p>
<p>上图说明有 5 个分片没有分配到副本。</p>
<ul>
<li><font color="green">绿色</font>：最健康的状态，代表所有的主分片和副本分片都可用</li>
<li><font color="#FFD700">黄色</font>：所有主分片可用，但部分副本分片不可用，即高可用未能实现</li>
<li><font color="red">红色</font>：部分主分片不可用；此时执行查询部分数据仍然可以查到，但是遇到这种情况还是尽快解决</li>
</ul>
<p>一些检查集群状态的 API：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">GET /_cluster/health</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分片状态</span></span><br><span class="line">GET _cat/shards?v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群中不同节点索引的状态</span></span><br><span class="line">GET _cat/shards?h=index,shard,prirep,state,unassigned.reason</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看unsigned的原因</span></span><br><span class="line">GET /_cluster/allocation/explain</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Analyzer：Elastic-的分词器"><a href="#Analyzer：Elastic-的分词器" class="headerlink" title="Analyzer：Elastic 的分词器"></a>Analyzer：Elastic 的分词器</h1><h2 id="Standard-Analyzer"><a href="#Standard-Analyzer" class="headerlink" title="Standard Analyzer"></a>Standard Analyzer</h2><p>ES 的默认分词器，提供了基于语法的标准化（Unicode 文本分割算法），适用于大多数语言。</p>
<p>Standard Analyzer 区分中英文分词。</p>
<ul>
<li>英文按照空格切分，同时大写字母会转为小写；</li>
<li>中文按照单个词分词</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;HONDA 本田&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;honda&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,  <span class="comment">// 字母</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;本&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">6</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,  <span class="comment">// 图形文字</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;田&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">8</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Simple-Analyzer"><a href="#Simple-Analyzer" class="headerlink" title="Simple Analyzer"></a>Simple Analyzer</h2><p>遇到只要不是字母的字符，就将文本解析成 term（最细粒度的词），而且所有的 term 都是小写的。<br>先按照空格分词，英文大写转小写，<strong>不是英文不分词</strong>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;simple&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;HONDA 本田&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;honda&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;本田&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">6</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">8</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Whitespace-Analyzer"><a href="#Whitespace-Analyzer" class="headerlink" title="Whitespace Analyzer"></a>Whitespace Analyzer</h2><p>顾名思义，严格按照空格分词；英文不区分大小写，中文不分词。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;whitespace&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;car brand brand HONDA 本田 汽车&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;car&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">9</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">10</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;HONDA&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">16</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">21</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;本田&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">22</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">24</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;汽车&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">25</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">27</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ik"><a href="#ik" class="headerlink" title="ik"></a>ik</h2><p>上面提到的分词器对于中文语境来说，其实并不是完美的，甚至大多数情况不适用。</p>
<p>开源社区中有一个 ik 系列分词器，对于中文相对友好，包括 ik_smart 和 ik_max_word 两种：</p>
<ul>
<li>ik_smart：按照最粗粒度划分，每个 term 没有重复的字符</li>
<li>ik_max_word：最细粒度划分，每个 term 有重复的字符</li>
</ul>
<p>演示例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;夏洛特烦恼&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;夏洛特&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,  <span class="comment">// 识别为中文字符</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;烦恼&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;夏洛特烦恼&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;夏洛特&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;特烦&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;烦恼&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在 IKAnalyzer.cfg.xml 配置文件中设定自定义的分词词汇。</p>
<p><br></p>
<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><p>ES 的指令主要分为两大部分，一是关于<strong>索引</strong>的操作，另外则是<strong>文档</strong>的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>method</th>
<th>URL</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUT / POST</td>
<td><a href="http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID">http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID</a>]</td>
<td>创建文档（指定 doc_id）</td>
</tr>
<tr>
<td>POST</td>
<td><a href="http://localhost:9200/[INDEX_NAME]/[TYPE_NAME">http://localhost:9200/[INDEX_NAME]/[TYPE_NAME</a>]</td>
<td>创建文档（随机 doc_id）</td>
</tr>
<tr>
<td>POST</td>
<td><a href="http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID]/_update">http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID]/_update</a></td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td><a href="http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID">http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID</a>]</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td><a href="http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID">http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/[DOC_ID</a>]</td>
<td>通过 doc_id 查询文档</td>
</tr>
<tr>
<td>POST</td>
<td><a href="http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/_search">http://localhost:9200/[INDEX_NAME]/[TYPE_NAME]/_search</a></td>
<td>根据条件查询数据</td>
</tr>
</tbody>
</table>
</div>
<p>可以看到，URL 的层级是按照“<strong>索引 index &lt;- 类型 type &lt;- 文档 doc</strong>”递进的。</p>
<p>注意的点：</p>
<ul>
<li>如果不指定 TYPE_NAME，默认使用 <code>_doc</code>；</li>
<li>如果在创建文档的时候索引 / 类型不存在，接口不会报错，而是会顺势将索引 / 类型创建出来；</li>
<li>使用创建文档的方法也能更新文档，但是请求中但凡少一个字段，更新后<strong>少掉的字段值会被置空</strong>；而使用修改文档的方法则不需要担心这一点</li>
</ul>
<p>举几个使用例子：</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p><strong>1</strong>. 创建索引时不指定 field 的类型映射：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line">PUT /car_no_mappings</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;shards_acknowledged&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引的 mappings 属性为空</span></span><br></pre></td></tr></table></figure>
<p>插入数据的时候，ES 会根据数据选择具体的类型：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文档</span></span><br><span class="line">PUT /car_no_mappings/type1/<span class="number">001</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;civic&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;ivtec&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;honda&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iteration&quot;</span> : <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;001&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时索引的 mappings：</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type1&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;engine&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,  <span class="comment">// 类型</span></span><br><span class="line">          <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>  <span class="comment">// 默认既有 type 属性，也有 keyword 属性（field type）</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;iteration&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;brand&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 创建索引时指定 field 的类型映射：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line">PUT /car_mappings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  <span class="comment">// 只想要 text，不想要 keyword 了</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;brand&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;iteration&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;shards_acknowledged&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;index&quot;</span> : <span class="string">&quot;car_mappings&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时索引的 mappings：</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;_doc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;iteration&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;brand&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><p><strong>1</strong>. 指定文档 ID</p>
<p>除了上述 PUT 方法之外，还可使用 POST：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文档</span></span><br><span class="line">POST /car_no_mappings/type1/<span class="number">002</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;fiesta&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;zy&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;ford&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iteration&quot;</span> : <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结束后索引数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>_index</th>
<th>_type</th>
<th>_id</th>
<th>_score</th>
<th>name</th>
<th>engine</th>
<th>brand</th>
<th>iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>001</td>
<td>1</td>
<td>civic</td>
<td>ivtec</td>
<td>honda</td>
<td>5</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>002</td>
<td>1</td>
<td>fiesta</td>
<td>zy</td>
<td>ford</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<p>上面的 _id 就是刚刚创建文档的时候指定的文档 ID。</p>
<p><strong>2</strong>. 随机文档 ID：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文档</span></span><br><span class="line">POST /car_no_mappings/type1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;golf&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;DLS&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;volkswagen&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iteration&quot;</span> : <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;f8NTDYABmekajPhuv7w_&quot;</span>,  <span class="comment">// 随机的 id</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结束后索引数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>_index</th>
<th>_type</th>
<th>_id</th>
<th>_score</th>
<th>name</th>
<th>engine</th>
<th>brand</th>
<th>iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>001</td>
<td>1</td>
<td>civic</td>
<td>ivtec</td>
<td>honda</td>
<td>5</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>002</td>
<td>1</td>
<td>fiesta</td>
<td>zy</td>
<td>ford</td>
<td>6</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>f8NTDYABmekajPhuv7w_</td>
<td>1</td>
<td>golf</td>
<td>DLS</td>
<td>volkswagen</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p><strong>1</strong>. 覆盖修改：PUT</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">PUT /car_no_mappings/type1/<span class="number">002</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;fiesta - rt&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;zy&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;ford&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iteration&quot;</span> : <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;updated&quot;</span>,  <span class="comment">// 更新成功</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结束后索引数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>_index</th>
<th>_type</th>
<th>_id</th>
<th>_score</th>
<th>name</th>
<th>engine</th>
<th>brand</th>
<th>iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>001</td>
<td>1</td>
<td>civic</td>
<td>ivtec</td>
<td>honda</td>
<td>5</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>f8NTDYABmekajPhuv7w_</td>
<td>1</td>
<td>golf</td>
<td>DLS</td>
<td>volkswagen</td>
<td>8</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>002</td>
<td>1</td>
<td>fiesta - rt</td>
<td>zy</td>
<td>ford</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>只有部分域：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">PUT /car_no_mappings/type1/<span class="number">002</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;fiesta - RT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结束后索引数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>_index</th>
<th>_type</th>
<th>_id</th>
<th>_score</th>
<th>name</th>
<th>engine</th>
<th>brand</th>
<th>iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>001</td>
<td>1</td>
<td>civic</td>
<td>ivtec</td>
<td>honda</td>
<td>5</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>f8NTDYABmekajPhuv7w_</td>
<td>1</td>
<td>golf</td>
<td>DLS</td>
<td>volkswagen</td>
<td>8</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>002</td>
<td>1</td>
<td>fiesta - RT</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>可以看到，PUT 方法如果没有提供所有域的话，其它值会被空值覆盖。</p>
<p><strong>2</strong>. 非覆盖修改：POST</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">POST /car_no_mappings/type1/<span class="number">001</span>/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;civic - typeR&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;001&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">6</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结束后索引数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>_index</th>
<th>_type</th>
<th>_id</th>
<th>_score</th>
<th>name</th>
<th>engine</th>
<th>brand</th>
<th>iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>f8NTDYABmekajPhuv7w_</td>
<td>1</td>
<td>golf</td>
<td>DLS</td>
<td>volkswagen</td>
<td>8</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>002</td>
<td>1</td>
<td>fiesta - RT</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>001</td>
<td>1</td>
<td>civic - typeR</td>
<td>ivtec</td>
<td>honda</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p>注意：调用 POST 更新数据时，URL 最后必须要带上 <code>_update</code>，消息体要用 <code>doc</code> 包着。</p>
<h2 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h2><p><strong>1</strong>. 查询索引信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;car_no_mappings&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;aliases&quot;</span> : &#123; &#125;,  <span class="comment">// 别名</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;brand&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;engine&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;iteration&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;routing&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;allocation&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;include&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;_tier_preference&quot;</span> : <span class="string">&quot;data_content&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;provided_name&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;creation_date&quot;</span> : <span class="string">&quot;1649432640257&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;uuid&quot;</span> : <span class="string">&quot;GligivYtRa-qEh9aUiG8Mg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;created&quot;</span> : <span class="string">&quot;7170099&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 查询文档信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/<span class="number">001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;001&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,  <span class="comment">// 找到了</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;civic&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;ivtec&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;honda&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;iteration&quot;</span> : <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/<span class="number">003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 根据查询三要素 _index _type _id 可以唯一标记一条文档</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;003&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3</strong>. 不同分词器下的条件搜索</p>
<p>假设索引 car_no_mappings 存有下面的文档：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>_index</th>
<th>_type</th>
<th>_id</th>
<th>_score</th>
<th>name</th>
<th>engine</th>
<th>brand</th>
<th>iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>f8NTDYABmekajPhuv7w_</td>
<td>1</td>
<td>golf001</td>
<td>DLS</td>
<td>volkswagen</td>
<td>8</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>002</td>
<td>1</td>
<td>fiesta - RT</td>
<td>zy</td>
<td>ford</td>
<td>6</td>
</tr>
<tr>
<td>car_no_mappings</td>
<td>type1</td>
<td>001</td>
<td>1</td>
<td>civic - typeR</td>
<td>ivtec</td>
<td>honda</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p>使用默认（standard）的分词器：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/_search?q=name:golf</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span>  <span class="comment">// 匹配方式</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ ]  <span class="comment">// 没找到</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 standard 分词器在分析文本的时候将 “golf001” 解析为一整个 ALPHANUM，没有进行内部分词：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;golf001&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 mappings 的 analyzer 为 ik_max_word 后，可以通过 <code>q=name:golf</code> 搜索到 golf001。</p>
<p><strong>4</strong>. 复杂条件搜索</p>
<p>上述的 <code>_search?q=name:golf</code> 等价于：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /car_no_mappings/type1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;golf&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行复杂条件搜索的时候，建议使用这种带消息体的请求。</p>
<p><small>注：除了 <code>match</code>，ES 还可以用 <code>term</code>（上面提到过的，最小粒度单位）来进行查询。搜索到的结果会有不一样。</small></p>
<p>给三条文档分别打上 tag：</p>
<ul>
<li>golf gti: [“street”, “a0”, “germany”]</li>
<li>fiesta st: [“street”, “a0”, “euro”]</li>
<li>civic - typeR: [“street”, “a”, “japan”]</li>
</ul>
<ol>
<li><p>指定显示的列：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;civic&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;brand&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.9808291</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;001&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.9808291</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;civic - typeR&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;honda&quot;</span></span><br><span class="line">        &#125;  <span class="comment">// 只显示了指定的两列</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个内容搜索：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: <span class="string">&quot;a0 germany&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.4508327</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;f8NTDYABmekajPhuv7w_&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.4508327</span>,  <span class="comment">// 匹配度高</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;golf gti&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;dls&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;volkswagen&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;iteration&quot;</span> : <span class="string">&quot;8&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;street&quot;</span>,</span><br><span class="line">            <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;germany&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.4700036</span>,  <span class="comment">// 匹配度没那么高</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;street&quot;</span>,</span><br><span class="line">            <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;euro&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;zy&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;fiesta st&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;iteration&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;ford&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对搜索结果进行排序：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: <span class="string">&quot;a0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;iteration&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span>  <span class="comment">// asc 或 desc</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">7</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;street&quot;</span>,</span><br><span class="line">            <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;euro&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;zy&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;fiesta st&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;iteration&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;ford&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;sort&quot;</span> : [  <span class="comment">// 排序信息</span></span><br><span class="line">          <span class="number">6</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;f8NTDYABmekajPhuv7w_&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;golf gti&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;dls&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;volkswagen&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;iteration&quot;</span> : <span class="string">&quot;8&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;street&quot;</span>,</span><br><span class="line">            <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;germany&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;sort&quot;</span> : [  <span class="comment">// 排序信息</span></span><br><span class="line">          <span class="number">8</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query</code> 的元素除了 <code>match</code>，还可以使用 <code>bool</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [&#123;<span class="attr">&quot;match&quot;</span>:&#123;...&#125;&#125;,...]  <span class="comment">// 与操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [&#123;<span class="attr">&quot;match&quot;</span>:&#123;...&#125;&#125;,...]  <span class="comment">// 或操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [&#123;<span class="attr">&quot;match&quot;</span>:&#123;...&#125;&#125;,...],  <span class="comment">// 非操作</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;<span class="attr">&quot;range&quot;</span>:&#123;...&#125;&#125;  <span class="comment">// 结果过滤（gte, lte, gt, lt）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分页显示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: <span class="string">&quot;a0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">1</span>,  <span class="comment">// 从第一个开始操作</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span>  <span class="comment">// 每页一个结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">6</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.4700036</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.4700036</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;doc&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">              <span class="string">&quot;street&quot;</span>,</span><br><span class="line">              <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">              <span class="string">&quot;euro&quot;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;street&quot;</span>,</span><br><span class="line">            <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;euro&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;zy&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;fiesta st&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;iteration&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;ford&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>5</strong>. 高亮查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET /car_no_mappings/type1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: <span class="string">&quot;a0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;blue&gt;&quot;</span>,  <span class="comment">// 默认是 &lt;em&gt;</span></span><br><span class="line">    <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/blue&gt;&quot;</span>,   <span class="comment">// 默认是 &lt;/em&gt;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">140</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.4700036</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;f8NTDYABmekajPhuv7w_&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.4700036</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;golf gti&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;dls&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;volkswagen&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;iteration&quot;</span> : <span class="string">&quot;8&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;street&quot;</span>,</span><br><span class="line">            <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;germany&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;highlight&quot;</span> : &#123;  <span class="comment">// 高亮处理</span></span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;&lt;blue&gt;a0&lt;/blue&gt;&quot;</span>  <span class="comment">// 高亮处理都是围绕着关键字来的</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_no_mappings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.4700036</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;street&quot;</span>,</span><br><span class="line">            <span class="string">&quot;a0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;euro&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;engine&quot;</span> : <span class="string">&quot;zy&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;fiesta st&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;iteration&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;ford&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;highlight&quot;</span> : &#123;  <span class="comment">// 高亮处理</span></span><br><span class="line">          <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;&lt;blue&gt;a0&lt;/blue&gt;&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>另外还可以通过 <code>_cat</code> 命令获取 ES 的相关信息。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">DELETE /car_mappings/_doc/<span class="number">002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;car_mappings&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;002&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;deleted&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除索引：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">DELETE /car</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端集成"><a href="#客户端集成" class="headerlink" title="客户端集成"></a>客户端集成</h1><p>ES 推出了基于很多语言的 <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">API</a>，这里就不赘述了。</p>
<h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a><a href="https://www.elastic.co/what-is/elk-stack">ELK</a></h1><p>ELK 是 <strong>E</strong>lasticsearch、<strong>L</strong>ogstash 和 <strong>K</strong>ibana 三个开源项目的首字母缩写，三者合称 ELK stack，提供“托管型”的 Elasticsearch Service。</p>
<p>我们已经知道 Elasticsearch 是干嘛的了，接下来看看另外两个：</p>
<p>Logstash 是服务器端数据（主要是日志）的处理管道，能够同时从多个来源采集数据，转换数据，随后将数据发送到 Elasticsearch 等进行存储；<br>Kibana 提供了对 Elasticsearch 数据进行图形图表的可视化功能。<br>（上述文字结合官网介绍而得。）</p>
<p>目前 ELK 加入了 Beats：一系列轻量型单一功能的数据采集器，并改称 <strong>Elastic Stack</strong>。</p>
<p><img src="/2022/02/09/es/elk-stack-elkb-diagram.svg" alt></p>
<p>包括 CCTV、民生银行、奥迪、牛津大学、沃尔玛、浦项制铁、联想、Netflix 等都是 Elastic Stack 的客户。</p>
<p>依托 Elastic Stack 所构建的解决方案完整列表：</p>
<p><img src="/2022/02/09/es/elastic-solutions.jpg" alt></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>分而治之算法 Divide and Conquer</title>
    <url>/2022/11/13/divide-and-conquer/</url>
    <content><![CDATA[<p>分而治之算法是 MapReduce 方法的基石，是数据挖掘的核心。</p>
<span id="more"></span>
<p>分而治之的本质是：</p>
<ol>
<li>将大的问题分成两个以上小的问题</li>
<li>分别解决每个小问题</li>
<li>将各小问题解答组合起来，得到原问题的解答</li>
</ol>
<p>拆分出来的小问题通常与大问题相似，因此可以通过<strong>递归</strong>解决。</p>
<p>非递归：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MinMax</span><span class="params">(T w[], <span class="keyword">int</span> n, T&amp; Min, T&amp; Max)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// Locate min and max of w[0:n-1].</span></span><br><span class="line"> <span class="comment">// Return false if fewer than one element.</span></span><br><span class="line"> <span class="comment">// special cases, n &lt;= 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        Min = Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize Min and Max</span></span><br><span class="line">    <span class="keyword">int</span> s;  <span class="comment">// start point for loop</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;  <span class="comment">// n is odd</span></span><br><span class="line">        Min = Max = <span class="number">0</span>;</span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// n is even, compare first pair</span></span><br><span class="line">        <span class="keyword">if</span> (w[<span class="number">0</span>] &gt; w[<span class="number">1</span>]) &#123;</span><br><span class="line">            Min = <span class="number">1</span>;</span><br><span class="line">            Max = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Min = <span class="number">0</span>;</span><br><span class="line">            Max = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare remaining pairs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find larger of w[i] and w[i+1]</span></span><br><span class="line">        <span class="comment">// then compare larger with w[Max]</span></span><br><span class="line">        <span class="comment">// and smaller with w[Min]</span></span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; w[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; w[Max]) &#123;</span><br><span class="line">                Max = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w[i+<span class="number">1</span>] &lt; w[Min]) &#123;</span><br><span class="line">                Min = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i+<span class="number">1</span>] &gt; w[Max]) &#123;</span><br><span class="line">                Max = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &lt; w[Min]) &#123;</span><br><span class="line">                Min = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>由分而治之算法衍生出来的算法，常用的有<a href="/2023/02/25/merge-sort">归并排序</a>和<a href="/2023/02/26/quick-sort">快速排序</a>两种。</p>
<p>解决线性代数的矩阵乘法，可以使用分而治之算法。</p>
<p>分而治之算法可以应用到很多生活场景，比如求解递归方程、找出伪币、找最轻和最重、得出距离最近的点对等。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论初探</title>
    <url>/2023/06/06/distributed-system-basics/</url>
    <content><![CDATA[<p>先给结论：能不用分布式事务就不用，但是 ——</p>
<span id="more"></span>
<p>随着互联网技术和社会业务需求的不断发展，系统日益复杂，分布式架构逐渐流行，因此分布式事务是避不开的话题。</p>
<p>在此先捋一下分布式事务的基础理论。</p>
<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>CAP 定理，或者叫 CAP 原则，指的是在一个分布式系统中，对于<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong>、<strong>分区容错性（Partition tolerance）</strong> 这三个基本需求，最多只能<strong>同时满足其中的两个</strong>。</p>
<p>CAP 是基于<strong>瞬态</strong>的描述性理论。</p>
<p>一致性（<strong>C</strong>）：在分布式系统中，不同的节点分别保存着数据副本，每个节点的数据副本之间能够保持一致。</p>
<p>可用性（<strong>A</strong>）：系统提供的服务一直处于可用的状态，每次请求都能获得正确的响应；即使集群中部分节点存在故障，整体服务还能响应客户端请求。</p>
<p>分区容错性（<strong>P</strong>）：对通信时限性存在要求。分布式系统在遇到任何网络分区故障的时候，仍然能够正常对外提供服务。</p>
<p><img src="/2023/06/06/distributed-system-basics/cap.png" alt></p>
<h2 id="为什么三者不可兼得"><a href="#为什么三者不可兼得" class="headerlink" title="为什么三者不可兼得"></a>为什么三者不可兼得</h2><p>首先分布式系统，是避免不了分区的。<br>何为分区？分布式系统的不同节点分布在不同子网中，这些相对孤立的子网络我们称之为分区。</p>
<p>分布式系统是避免不了分区的，因此分区容错性（P）一定要满足。<br>在此基础上，<strong>当网络故障或者其它原因，导致某个分区出现故障</strong>的时候，某个用户请求修改数据：</p>
<ul>
<li>如果允许其中一个副本更新，则分区故障副本无法被更新，导致数据不一致，即<strong>一致性（C）无法满足</strong>；</li>
<li>如果为了保证一致性，将分区故障副本设置为不可用，那么<strong>可用性（A）无法满足</strong>。</li>
</ul>
<p>举个例子：假设存在两个分区 P1 和 P2，P1 包括服务 S1 和数据 D1，P2 包括服务 S2 和数据 D2。<br>此时网络发生了故障，导致 D2 网络不通。</p>
<p>用户访问 S1 修改了 D1 的数据，再次访问时请求落在了 P2：此时 D1 和 D2 的数据是不一致的。</p>
<ul>
<li>如果要保证一致性（C）：D1 和 D2 的数据不一致，就不能返回，导致服务 S2 无法响应，<strong>可用性（A）无法满足</strong>；</li>
<li>如果要保证可用性（A）：S2 响应请求，返回了与 D1 不一致的数据，<strong>一致性（C）无法满足</strong>。</li>
</ul>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>三者不可兼得，在 CAP 的框架范围内，我们需要做一些权衡。<br>根据排列组合，我们有三种权衡方案（如上图）：</p>
<h3 id="CA-without-P"><a href="#CA-without-P" class="headerlink" title="CA without P"></a>CA without P</h3><p>单机系统的性质，节点之间通信网络一定会有问题，即放弃了系统的扩展性。<br>因此分布式系统理论上是不可选 CA 的。</p>
<p>应用于早期的单体服务，比如 MySQL 的 InnoDB 等传统关系型数据库，满足 ACID 的刚性事务。</p>
<h3 id="CP-without-A"><a href="#CP-without-A" class="headerlink" title="CP without A"></a>CP without A</h3><p>牺牲了可用性（A），相当于每个请求需要在服务之间强一致；由于分区的存在，会导致数据同步时间无限延长，影响用户体验。</p>
<p>分布式数据库采用的是 CP 方案。</p>
<h3 id="AP-without-C"><a href="#AP-without-C" class="headerlink" title="AP without C"></a>AP without C</h3><p>保证可用性的话，就不能保证数据一致性。因此每个节点只能用本地数据提供服务。</p>
<p>市面上很多 NoSQL都采用此方案；在业务应用中的高峰值订单、秒杀系统等都暂时放弃数据一致性。</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>在微服务的常用组件中：</p>
<ul>
<li>ZooKeeper 保证的是 CP：数据强一致性，但是不保证每次请求的可用性；选举过程中过半数机器不可用时，服务不可用</li>
<li>Eureka 保证的是 AP：每个节点都是平等的，这种设计方式就是为了先保证可用性，因此即使大部分节点挂掉也不会影响服务，只要一个节点可用就行</li>
<li>Nacos 既支持 CP 也支持 AP（注册临时节点）</li>
</ul>
<h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><p>BASE 理论包含的是 <strong>Basically Available</strong>（基本可用）, <strong>Soft state</strong>（软状态）, <strong>Eventually consistent</strong>（最终一致性）。</p>
<p>一句话概括：先保证系统的基本可用（保证核心功能的能力），各节点的数据允许出现软状态（中间状态），最终达到一致性。</p>
<p>BASE 理论是基于 CAP，综合了大规模分布式系统的实践，而得到的对 C 和 A 做权衡的结果。<br>其核心思想是：</p>
<pre><code>即使无法做到强一致性，但是每个应用可根据自身特点，采用适当方式使系统达到最终统一。
</code></pre><h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>分布式系统出现故障时，能够保证核心服务可用，<strong>允许损失部分可用性</strong>。</p>
<p>损失掉的部分可用性包括：</p>
<ul>
<li><strong>响应时间上的损失</strong>：响应时间会从毫秒级增加到秒级；</li>
<li><strong>功能上的缺失</strong>：部分用户会被引导到降级之后的服务；</li>
<li>…</li>
</ul>
<h2 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h2><p>允许系统出现中间状态，这样的中间状态不影响系统的整体可用性。<br>即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>系统中的所有数据副本，在经过一定时间的同步后，最终能够达到一致的状态。</p>
<p>与刚性事务 ACID 不同，基于分布式系统的 BASE 理论属于<strong>柔性事务</strong>。</p>
<p>如何保证最终一致性？</p>
<ul>
<li>读取数据时检测到数据不一致，进行修复</li>
<li>写入数据时检测到数据不一致，进行修复</li>
<li>异步修复</li>
</ul>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">小米信息部技术团队 - 分布式事务，这一篇就够了</a></p>
<p><a href="https://www.cnblogs.com/three-fighter/p/15293310.html">分布式必备理论基础：CAP和BASE</a></p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式汇总</title>
    <url>/2021/06/19/factory/</url>
    <content><![CDATA[<p>GOF 所著的《设计模式》中，与工厂相关的设计模式属于创建型模式的入门，也是最重要的模式。</p>
<span id="more"></span>
<p>工厂模式的意图，是通过定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p>其核心是要<strong>屏蔽掉所需对象的创建逻辑</strong>：</p>
<ul>
<li>创建对象时不会对客户端暴露创建逻辑，且通过使用共同的接口来指向新创建的对象</li>
<li><strong>解耦</strong>：降低程序耦合性，实现创建者和调用者的分离，维护便利</li>
<li>将实现类、创建对象纳入统一管理和控制</li>
</ul>
<p>总的来说，各工厂模式离不开三个角色：<br>1) 工厂类角色：模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品<br>2) 抽象产品角色：一般是具体产品继承的父类，或者是要实现的接口<br>3) 具体产品角色：工厂类所创建的对象就是该角色的实例，由一个具体类实现</p>
<p>《设计模式》中，与工厂有关的包括了<strong>工厂方法</strong>和<strong>抽象工厂</strong>两个模式；但是近段时间看资料，发现有一个名为“<strong>简单工厂</strong>”的设计模式经常被提到，但是没有被包含在 GOF 总结的 23 种设计模式里面。  </p>
<p>为了总结一下业界的经验，本帖将讨论包括简单工厂、工厂方法、抽象工厂三者在内的所有工厂相关的模式。</p>
<p><br><br><br></p>
<h1 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h1><p>该模式中，用于创建实例的方法通常为静态方法，因此又被称为<strong>静态工厂方法</strong>（Static Factory Method）模式。</p>
<ul>
<li>提供一个创建对象实例的功能，而无需关心其具体实现。</li>
<li>被创建实例的类型可以是接口、抽象类，也可以是具体的类。</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/2021/06/19/factory/simple-factory-diagram.png" alt></p>
<p>以上，可见简单工厂模式包括：</p>
<p><code>Factory</code></p>
<ul>
<li>负责实现创建所有产品的内部逻辑</li>
<li>工厂内部一般通过路由逻辑（switch-case）去判断创建哪些产品<ul>
<li>或通过接收参数，作为不同的具体产品对象的构造函数的入参</li>
</ul>
</li>
</ul>
<p><code>Product</code></p>
<ul>
<li>定义工厂方法所要创建的对象（产品）的接口</li>
</ul>
<p><code>ConcreteProduct</code></p>
<ul>
<li>要产生具体对象（产品）的类，实现 Product 接口</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>代入一个简单的具体开发场景，结构图如下：<br><img src="/2021/06/19/factory/simple-factory-diagram.jpeg" alt></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>定义一个工厂类，可根据参数的不同，返回不同的产品实例；被创建的产品实例通常都具有共同的产品父类（或实现同一个产品接口）；</li>
<li>实际调用的时候，我们需要一个客户类（Service 实例）调用工厂类的创建方法。</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p>
<ul>
<li>简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。</li>
<li>明确区分了各自的职责和权力，有利于整个软件体系结构的优化。</li>
</ul>
<p>缺点：</p>
<ul>
<li>很明显，工厂类集中了所有实例的创建逻辑，容易违反 GRASPR 的高内聚的责任分配原则</li>
</ul>
<p><br></p>
<h1 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h1><big>别名：虚构造器（Virtual Constructor），属于类创建型模式。</big>

<p>《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“定义一个用于创建对象的接口，让子类决定将哪一个类实例化”
</code></pre><p>又称<strong>多态性工厂模式</strong>。</p>
<p><strong>与简单工厂模式不同的是</strong>，工厂模式将具体创建产品的工作交给了子类 —— 具体的产品工厂，不再是所有产品都交给一个工厂生产。 </p>
<p><br></p>
<h2 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/2021/06/19/factory/factory-method-diagram.png" alt></p>
<p>以上，可见工厂方法模式包括：</p>
<p><code>Product</code></p>
<ul>
<li>定义工厂方法所要创建的对象（产品）的接口</li>
</ul>
<p><code>ConcreteProduct</code></p>
<ul>
<li>要产生具体对象（产品）的类，实现 Product 接口</li>
</ul>
<p><code>Creator</code></p>
<ul>
<li>声明一个工厂方法，且可调用该工厂方法创建一个 Product 类型的对象</li>
<li>也可定义一个工厂方法的默认实现，返回默认 ConcreteProduct 对象</li>
</ul>
<p><code>ConcreteCreator</code></p>
<ul>
<li>重定义 Creator 声明的工厂方法，返回一个 ConcreteProduct 实例</li>
</ul>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul>
<li>Creator 依赖于它的子类来定义工厂方法；子类返回一个适当的 ConcreteProduct 实例</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul>
<li><code>Creator</code> 为<strong>抽象类</strong>，不提供它所声明的工厂方法的实现<ul>
<li>需要子类去定义并实现</li>
<li>避免了不得不实例化那些不可预见类的问题</li>
</ul>
</li>
<li><code>ConcreteCreator</code> 为具体的类，为工厂方法提供默认的实现<ul>
<li>子类在必要时可以重定义实现</li>
</ul>
</li>
<li>该模式可采用一个标识，作为要被创建的对象种类的参数<ul>
<li>创建产品的方法可以设计为传参的方法，指定将要创建的产品种类</li>
<li>可简单而有选择性地扩展或改变一个 Creator 生产的产品</li>
</ul>
</li>
<li>可使用模版（泛型编程）以避免创建子类</li>
</ul>
<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ul>
<li>当一个类不知道它所必须创建的具体对象的类时</li>
<li>当一个类希望由它的子类来指定它所创建的对象时</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个，且希望将哪一个帮助子类是代理者这一信息局部化时</li>
</ul>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>工厂方法模式不会再将与特定应用有关的类绑定到代码中：</p>
<ul>
<li>代码仅处理 Product 接口：因此可与用户定义的任何 ConcreteProduct 类一起使用</li>
<li>潜在缺点：有可能仅仅为了创建一个特定 ConcreteProduct 对象，就不得不创建一个具体工厂 Creator 子类</li>
<li>为子类提供一个挂钩（hook）<ul>
<li>使用本模式在一个类的内部创建对象，通常比直接创建对象更灵活</li>
<li>给子类提供一个 hook 来扩展对象</li>
</ul>
</li>
<li>连接平行的类层次：一个类将其职责委托给一个独立的类</li>
</ul>
<h2 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h2><ul>
<li>Abstract Factory 经常使用本设计模式来实现</li>
<li>本设计模式通常还在 Template Methods 中被调用</li>
<li>Prototype 不需要创建 Creator 的子类，但通常要求一个针对 Product 类的 initialize 操作<ul>
<li>即：Prototype 需要 Creator 使用 initialize 初始化对象</li>
<li>本设计模式不需要该操作</li>
</ul>
</li>
</ul>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p>
<ul>
<li>灵活：当要生产新的产品时，只需按照抽象产品和抽象工厂的要求扩充即可，无需修改原有代码</li>
<li>屏蔽产品类：产品类的实现如何变化，调用者都不需要关心，只需关心产品的接口，只要接口保持不变，系统中的上层模块就不会发生变化</li>
<li>解耦：高层模块只需要知道产品的抽象类，其他的实现类都不需要关心，符合迪米特法则，依赖倒置原则，里氏替换原则</li>
<li>多态性：客户代码可以做到与特定应用无关，适用于任何实体类</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要 Creator 和相应的子类作为本模式的载体，类的层次相对会多一点</li>
</ul>
<p><br></p>
<h1 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h1><big>别名：Kit，属于对象创建型模式。</big>

<p>《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“提供一个创建一系列相关或相互依赖的对象（产品族）的接口，而无需指定它们具体的类”
</code></pre><h2 id="结构图-2"><a href="#结构图-2" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/2021/06/19/factory/abstract-factory-diagram.png" alt></p>
<p>以上，可见抽象工厂模式包括：</p>
<p><code>AbstractFactory</code></p>
<ul>
<li>抽象工厂，用来声明一组创建抽象产品对象的操作接口</li>
</ul>
<p><code>ConcreteFactory</code></p>
<ul>
<li>具体工厂，用来实现创建具体产品对象的操作</li>
<li>实现 AbstractFactory 接口</li>
</ul>
<p><code>AbstractProduct</code></p>
<ul>
<li>抽象产品，为一类产品对象声明一个接口</li>
</ul>
<p><code>ConcreteProduct</code></p>
<ul>
<li>具体产品，定义一个将被相应的具体工厂创建的产品对象</li>
<li>实现 AbstractProduct 接口</li>
</ul>
<p><code>Client</code></p>
<ul>
<li>仅能调用由 AbstractFactory 和 AbstractProduct 类声明的接口，不可直接触及实体类</li>
</ul>
<h2 id="协作-1"><a href="#协作-1" class="headerlink" title="协作"></a>协作</h2><ul>
<li>通常在运行时创建一个 <code>ConcreteFactory</code> 类实例<ul>
<li>该具体工厂创建具有特定实现的产品对象</li>
<li>为创建不同的产品对象，客户应使用不同的具体工厂</li>
</ul>
</li>
<li>AbstractFactory 将产品对象的创建延迟到对应的 ConcreteFactory 子类中</li>
</ul>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><ol>
<li>定义可扩展的工厂<ul>
<li><code>AbstractFactory</code> 通常为每一种可生产的产品定义一个操作<ul>
<li>产品种类被编码在操作构型中</li>
<li>每当增加一种新的产品，需要改变 AbstractFactory 的接口以及所有与其相关的类</li>
</ul>
</li>
<li>有一种灵活，但不安全的做法：定义 make() 并传参，指定要创建对象的种类</li>
<li>存在的问题：所有产品将返回类型所给定的相同接口返回给客户<ul>
<li>因此不能通过接口获得特定子类并进行操作</li>
</ul>
</li>
</ul>
</li>
<li>将具体工厂作为单例<ul>
<li>一个应用中，一般每个产品系列只需一个 <code>ConcreteFactory</code> 实例</li>
</ul>
</li>
<li>创建产品<ul>
<li><code>AbstractFactory</code> 仅声明创建产品的接口</li>
<li>真正创建产品由 <code>ConcreteProduct</code> 子类实现</li>
<li>最常用方法：为每一个产品定义一个工厂方法（Factory Method）<ul>
<li>一个具体的工厂将为每个产品重定义该工厂方法，以指定产品</li>
<li>虽然实现简单，产品区别小，但要求每个产品系列都要有一个新的具体工厂子类</li>
</ul>
</li>
<li>如有多个可能的产品系列：也可用 Prototype 实现</li>
</ul>
</li>
</ol>
<h2 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h2><ul>
<li>一个系统要独立于它的产品的创建、组合和表示时</li>
<li>一个系统需要由多个产品系列中的一个来配置时</li>
<li>需要强调一系列相关产品对象的设计以便进行联合使用时</li>
<li>当提供一个产品类库，而只想显示它们的接口而不是实现时</li>
</ul>
<h2 id="相关模式-1"><a href="#相关模式-1" class="headerlink" title="相关模式"></a>相关模式</h2><ul>
<li>AbstractFactory 类通常用工厂方法 Factory Method 实现，也可用 Prototype 实现</li>
<li>一个具体工厂通常为一个单例（Singleton）</li>
</ul>
<h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p>
<ul>
<li>分离具体的类<ul>
<li>工厂的职责：封装创建产品对象的责任和过程<ul>
<li>将客户与类的实现分离：客户只通过抽象接口操纵实例</li>
</ul>
</li>
<li>产品的类名也在具体工厂的实现中被分离</li>
</ul>
</li>
<li>易于交换产品系列<ul>
<li>一个具体工厂类在一个应用中仅出现一次：初始化的时候</li>
<li>一个抽象工厂创建了一个完整的产品系列</li>
<li>只需要改变具体的工厂即可使用不同的产品配置，整个产品系列随之改变</li>
</ul>
</li>
<li>有利于产品的一致性<ul>
<li>一个应用一次只能使用同一个系列中的对象</li>
</ul>
</li>
</ul>
<p>缺点：难以支持新种类的产品</p>
<ul>
<li>对于新增行为的处理会比较麻烦，违反开闭原则</li>
<li>AbstractFactory 接口已经确定了可被创建的产品集合<ul>
<li>如要支持新种类产品，就需要扩展该工厂接口，涉及 AbstractFactory 类及其所有子类的改变</li>
<li>因为继承的关系，难以扩展抽象工厂来建立新的具体工厂，生产新种类的产品</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h1 id="几个工厂模式的讨论"><a href="#几个工厂模式的讨论" class="headerlink" title="几个工厂模式的讨论"></a>几个工厂模式的讨论</h1><p>简单地给它们分一下类：</p>
<ul>
<li>简单工厂：用来生产同一等级结构中的任意产品（不支持拓展增加产品）</li>
<li>工厂方法：用来生产同一等级结构中的固定产品（支持拓展增加产品）</li>
<li>抽象工厂：用来生产不同产品族的全部产品（不支持拓展增加产品；支持增加产品族&lt;即工厂&gt;）<ul>
<li>即：抽象工厂是“工厂的工厂”</li>
</ul>
</li>
</ul>
<p><big>简单工厂：</big></p>
<ul>
<li>专门定义一个类用来负责创建其他类的实例，被创建的实例通常都具有共同的父类</li>
</ul>
<p><big>工厂方法：“<strong>一对一</strong>”关系</big></p>
<ul>
<li>定义一个创建对象的接口（抽象工厂类），让其子类（具体工厂类）决定实例化哪一个类（具体产品类）</li>
<li>一个工厂接口（或抽象类），实现（派生）出多个具体工厂类</li>
<li>一个产品接口（或抽象类），实现（派生）出多个具体产品类</li>
<li>每个具体工厂类只能创建<strong>一个</strong>具体产品类的实例</li>
</ul>
<p><big>抽象工厂：“<strong>一对多</strong>”关系</big></p>
<ul>
<li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体的类</li>
<li>一个工厂接口（或抽象类），实现（派生）出多个具体工厂类</li>
<li>多个产品接口（或抽象类），分别实现（派生）出多个具体产品类</li>
<li>每个具体工厂类可创建<strong>多个</strong>具体产品类的实例</li>
</ul>
<p>例：生产汽车动力总成</p>
<p>工厂方法模式</p>
<ul>
<li>以更具体的方式定义工厂接口（或抽象类），如发动机工厂，变速箱工厂<ul>
<li>发动机工厂由丰田发动机工厂、本田发动机工厂、日产发动机工厂等具体工厂实现</li>
<li>变速箱工厂由爱信工厂、本田变速箱工厂、捷特科工厂等具体工厂实现</li>
</ul>
</li>
<li>定义发动机和变速箱的接口或抽象类，以及他们的派生类<ul>
<li>丰田发动机工厂生产丰田发动机（<code>toyotaEnginesFactory.build()</code>），爱信工厂生产爱信变速箱（<code>aisinFactory.build()</code>）</li>
<li>本田发动机工厂生产本田发动机（<code>hondaEnginesFactory.build()</code>），本田变速箱工厂生产本田变速箱（<code>hondaTranmissionFactory.build()</code>）</li>
<li>日产发动机工厂生产日产发动机（<code>nissanEnginesFactory.build()</code>），捷特科工厂生产捷特科变速箱（<code>jatcoFactory.build()</code>）</li>
<li>……</li>
<li>即：每个具体工厂类只对应一个具体产品类的实例</li>
</ul>
</li>
</ul>
<p>抽象工厂模式：</p>
<ul>
<li>以更整体的方式定义工厂接口（或抽象类），如主机厂工厂<ul>
<li>主机厂工厂（接口）声明生产发动机和变速箱的方法</li>
<li>如：丰田工厂定义了生产发动机和变速箱的具体方法，本田、日产的工厂也如此</li>
</ul>
</li>
<li>定义发动机和变速箱的接口或抽象类，以及他们的派生类<ul>
<li>丰田工厂生产丰田发动机（<code>toyotaFactory.buildEngine()</code>），以及爱信变速箱（<code>toyotaFactory.buildTransmission()</code>）</li>
<li>本田工厂生产本田发动机（<code>hondaFactory.buildEngine()</code>），以及本田变速箱（<code>hondaFactory.buildTransmission()</code>）</li>
<li>日产工厂生产日产发动机（<code>nissanFactory.buildEngine()</code>），以及捷特科变速箱（<code>nissanFactory.buildTransmission()</code>）</li>
<li>……</li>
<li>即：每个具体工厂类对应多个具体产品类的实例</li>
</ul>
</li>
</ul>
<p>抽象工厂模式中：</p>
<ul>
<li>如果需要增加一个工厂：增加具体工厂类和具体产品类，分别继承抽象工厂类（实现工厂接口）和抽象产品类（产品接口）即可；</li>
<li>如果需要增加一个产品：增加抽象产品类（接口）及其具体产品，抽象工厂类（接口）声明新产品的工厂方法，所有具体工厂都要实现新产品的工厂方法。</li>
</ul>
<p>为什么不用简单工厂：</p>
<ul>
<li>简单工厂新增产品时会修改公共代码，一旦修改就容易出问题，影响其它业务；</li>
<li>工厂方法新增产品不会修改公共代码，就算出问题，也不会影响其他业务。</li>
</ul>
<p><br><br><br></p>
<h1 id="Spring-Framework-中的工厂设计模式"><a href="#Spring-Framework-中的工厂设计模式" class="headerlink" title="Spring Framework 中的工厂设计模式"></a>Spring Framework 中的工厂设计模式</h1><p>在 Spring IOC 容器创建 bean 的过程使用了工厂设计模式</p>
<ul>
<li>无论是通过 XML 配置，配置类还是注解，大部分均通过简单工厂模式创建</li>
<li>IOC 容器拿到 beanName 和 Class 类型后，通过反射创建具体对象，并维护这些对象</li>
</ul>
<p>使用工厂设计模式的原因：</p>
<ul>
<li>类与类之间，方法与方法之间的依赖都是耦合。实际开发中，如 A 调用 B，B 调用 C，C 调用 D，程序耦合性会提高</li>
<li>旧三层架构中，控制层调用业务层，业务层调用数据访问层时，都是直接 new 创建对象，耦合性大大提升，代码重复量很高</li>
<li>使用工厂模式编程，通过创建出来的工厂去创建 bean，当需要使用某个 bean 实例的时候就直接从工厂方面索取（依赖倒置原则）<ul>
<li>IOC 容器使用静态 Map 维护 bean 的单例，确保新建的 bean 实例不会重复影响程序效率</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 垃圾回收机制</title>
    <url>/2021/07/09/garbage-collection/</url>
    <content><![CDATA[<p>其实，很多 Java 初学者即使一点 GC 都不懂，也能写出一个能用甚至还不错的程序或系统，但并不代表 Java 的 GC 就不重要。</p>
<span id="more"></span>
<p>今天就来唠一唠这个 Java 的重要思想和 JVM 重要的组成部分 —— 垃圾回收。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>啥是内存垃圾？</p>
<p>当内存中的对象失去了所有的引用，变成了“孤魂野鬼”的时候，也就被称为“垃圾”。</p>
<p>这里展示一个垃圾对象的诞生过程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// &quot;abc&quot; 这个 String 对象有一个引用 str1 指向它</span></span><br><span class="line">String str2 = str1;               <span class="comment">// &quot;abc&quot; 现在有两个引用了：str1 和 str2 都指向它</span></span><br><span class="line">str1 = <span class="keyword">null</span>;  <span class="comment">// 失去引用 str1</span></span><br><span class="line">str2 = <span class="keyword">null</span>;  <span class="comment">// 失去引用 str2，失去全部引用，变成野对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由此，new String(&quot;abc&quot;); 产生的对象失去了所有指向它的引用，将无法再被程序访问 */</span></span><br></pre></td></tr></table></figure></p>
<p>有了垃圾，怎么清理呢？</p>
<p>就 C / C++ 语言来说，它们没有垃圾回收机制。<br>除非程序结束，否则在堆中申请后还没被释放，且没有任何指向的内存会一直处于“三无”状态：</p>
<ul>
<li>无法释放；</li>
<li>无法调用；</li>
<li>无法更改。</li>
</ul>
<p>当这样无法再被访问的内存越积越多的时候，可利用的内存越来越少，就会导致内存泄漏（Memory Leak）。</p>
<p>如下为一次内存泄漏过程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span> *) <span class="built_in">malloc</span> (<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 内存分配函数的参数没有问题，指针的转型也没有问题，但是并没有任何指针指向它……</span></span><br></pre></td></tr></table></figure></p>
<p>JVM 所提供的垃圾回收机制（Garbage Collection, <strong>GC</strong>）会不定时地去回收垃圾对象所占用的内存，大大地降低内存泄漏的隐患。</p>
<p><br></p>
<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>首先我们要明白，垃圾回收机制所要回收的，是已经<strong>没有任何引用的对象占据的内存空间</strong>，而不是内存本身。<br>JVM 通过自动检测对象是否超过作用域，从而达到自动回收内存的目的。<br>主要包括两步：</p>
<ul>
<li>在程序运行过程中<strong>标记</strong>垃圾对象</li>
<li>在 GC 过程中<strong>回收</strong>被标记的垃圾对象</li>
</ul>
<p>所以我们说的 Java 语言有垃圾回收特性，其实是 JVM 提供的机制，Java 语言本身并没有提供释放已分配内存的显式操作方法。<br>而 Java 的内存管理，实际上就是对象的管理，包括对象的分配和释放。</p>
<h2 id="如何标记垃圾"><a href="#如何标记垃圾" class="headerlink" title="如何标记垃圾"></a>如何标记垃圾</h2><p>主要有两种方法。</p>
<p><strong>1</strong>. <strong>计数法</strong>（引用计数法，Reference Counting）：</p>
<ul>
<li>所有算法的“祖宗”</li>
<li>当新建一个对象，或者有引用指向该对象时，该对象的引用计数器 + 1；</li>
<li>当一个对象引用超过了生存期限（失效）或指向新对象时，引用计数器 - 1；</li>
<li>当引用计数器对应的值变为 0 时，该对象不可能再被使用，虚拟机就会伺机回收该对象。</li>
</ul>
<p>计数法的好处就是快、简单，但无法检测循环引用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  <span class="comment">// 孤岛效应</span></span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    a.b = b;</span><br><span class="line">    b.a = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且每一次的引用产生和消除，需要伴随着一个加减法操作，对系统的性能有一定的影响。</p>
<p>基于以上问题，JVM 并没有选择此方法作为垃圾回收算法。</p>
<p><strong>2</strong>. 跟踪法 / <strong>根搜索算法</strong>：</p>
<p>该算法从图论引入，它将一个调用链中所有的对象引用关系看作是一张<strong>图</strong>，虚拟机会从根节点开始，寻找对应的引用节点。<br>这样的一些根节点被称为 <strong>GC roots</strong>；以每个 GC root 为起点能够形成作用链，链中的每个对象都是有向图的顶点。  </p>
<p>GC roots 包括：</p>
<ul>
<li><p>虚拟机栈中引用的对象：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态属性引用的对象：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量引用的对象：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地方法栈中引用的对象。</p>
</li>
</ul>
<p>从根结点开始去访问某些对象，如果能被访问到，就将这些对象是<strong>可触及的</strong>。从 GC roots 开始，不可触及（不可达）的对象将会被回收。</p>
<p><br></p>
<p><img src="/2021/07/09/garbage-collection/root-search.png" alt></p>
<p>如上：红色部分为某个 GC Root 不可达的节点，它们可被回收。</p>
<p><br></p>
<p>为了丰富的描述对象与对象之间的关系，更为了实现系统缓存的原因，Java 从 JDK 1.2 开始，建立了四种引用级别。</p>
<h2 id="引用级别"><a href="#引用级别" class="headerlink" title="引用级别"></a>引用级别</h2><p>4 种引用级别由高到低：</p>
<ol>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ol>
<p><strong>强引用</strong>（strong reference）</p>
<ul>
<li>最普遍的引用，GC 在普通情况下绝对不会回收</li>
<li>当内存空间不足时，JVM 宁可抛出 OutOfMemoryError 使程序异常终止，也不会随意回收具有强引用的对象来解决问题</li>
</ul>
<p>例：</p>
<ul>
<li>使用 <code>Object obj = new Object();</code> 将 obj 指向了 new Object() 在堆中创建的对象，则 obj 为强引用</li>
<li>obj = null; 时，new Object() 代表的对象不被任何引用所指向，该对象没有强引用。</li>
</ul>
<p><strong>软引用</strong>（<code>SoftReference</code>）</p>
<ul>
<li>GC 过程中，如果内存空间足够，则不回收只有软引用的对象</li>
<li>若堆空间不足时才会被回收</li>
<li>这种类型的对象是指某个对象没有被强引用所指向，而被软引用所指向<ul>
<li>如上例中 obj = null 之后的 new Object()</li>
</ul>
</li>
<li>可以和一个引用队列（<code>ReferenceQueue</code>）联合使用<ul>
<li>如软引用所引用的对象被垃圾回收器回收，JVM 会把该软引用加入到与之关联的引用队列中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();  <span class="comment">// 对象创建, 且有强引用</span></span><br><span class="line">        user.id = <span class="number">1</span>;</span><br><span class="line">        user.name = <span class="string">&quot;Ray&quot;</span>;</span><br><span class="line">        SoftReference&lt;User&gt; softRef = <span class="keyword">new</span> SoftReference&lt;&gt;(user);  <span class="comment">// 添加软引用</span></span><br><span class="line"></span><br><span class="line">        user = <span class="keyword">null</span>;  <span class="comment">// 移除强引用，现在 user 就只有软引用了</span></span><br><span class="line">        User sameUser;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != (sameUser = softRef.get())) &#123;</span><br><span class="line">            <span class="comment">// 只有软引用的对象未被垃圾回收</span></span><br><span class="line">            System.out.println(<span class="string">&quot;recovered &quot;</span> + sameUser.name + <span class="string">&quot;(&quot;</span> + sameUser.id + <span class="string">&quot;) from SoftReference!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 只有软引用的对象被垃圾回收，内存较为稀缺</span></span><br><span class="line">            System.out.println(<span class="string">&quot;user object GCed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>弱引用</strong>（<code>WeakReference</code>）</p>
<ul>
<li>与软引用类似</li>
<li>与软引用区别：只具有弱引用的对象拥有更短暂的生命周期<ul>
<li>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</li>
<li>即当 GC 发生时，无论内存是否充足，只有弱引用的对象都会被回收</li>
</ul>
</li>
<li>也可以和引用队列联合使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();  <span class="comment">// 对象创建, 且有强引用</span></span><br><span class="line">    user.id = <span class="number">2</span>;</span><br><span class="line">    user.name = <span class="string">&quot;Ray&quot;</span>;</span><br><span class="line">    WeakReference&lt;User&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;&gt;(user);  <span class="comment">// 添加软引用</span></span><br><span class="line"></span><br><span class="line">    user = <span class="keyword">null</span>;  <span class="comment">// 移除强引用，现在 user 就只有弱引用了</span></span><br><span class="line">    User sameUser;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != (sameUser = weakRef.get())) &#123;</span><br><span class="line">        <span class="comment">// 只有弱引用的对象未被垃圾回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;recovered &quot;</span> + sameUser.name + <span class="string">&quot;(&quot;</span> + sameUser.id + <span class="string">&quot;) from WeakReference!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 只有弱引用的对象被垃圾回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user object GCed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虚引用</strong>（<code>PhantomReference</code>）</p>
<ul>
<li>“形同虚设”，不会决定对象的生命周期<ul>
<li>即：对象有没有虚引用与对象会不会被 GC 没有关系</li>
</ul>
</li>
<li>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收</li>
<li>主要是用来跟踪对象被垃圾回收器回收的活动</li>
<li>与软引用、弱引用区别：虚引用必须和引用队列联合使用</li>
</ul>
<h2 id="槽位复用对垃圾回收的影响"><a href="#槽位复用对垃圾回收的影响" class="headerlink" title="槽位复用对垃圾回收的影响"></a>槽位复用对垃圾回收的影响</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">            System.out.println(a.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  <span class="comment">// b 复用了 a 的槽位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">            System.out.println(a.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 method1()，虽然 a 已经不在作用域中，但是 a 仍然占用一个槽位，并且存在引用，所以该数组还<strong>不能被回收</strong>。</p>
<p>对于 method2()，b 复用了 a 的槽位，此时数组已经不再占用栈帧的局部变量表中的槽位了，<strong>可以被回收</strong>。</p>
<p><br></p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>JVM 的垃圾回收算法，基本上是基于跟踪法发展而来。具体来说，主要有<strong>三种</strong>：</p>
<p><strong>1. 标记-清除算法 Mark-Sweep</strong></p>
<p>标记清除算法是现代垃圾回收算法的思想基础。顾名思义，算法会分为“标记”和“清除”两个阶段：</p>
<ul>
<li>从根集合扫描出存活的对象（遍历有向图），从存活（可达）的对象进行标记；</li>
<li>完了之后再扫描堆栈中未标记的对象，并进行回收。</li>
</ul>
<p><img src="/2021/07/09/garbage-collection/mark-sweep.jpg" alt></p>
<p>该算法（M-S）最大的问题是效率低，回收完成后会产生大量的不连续空间（空间碎片），插入新对象的时候不好操作。</p>
<p><strong>2. 标记-压缩算法 Mark-Compact</strong></p>
<ul>
<li>第一阶段的“标记”同标记-清除算法；</li>
<li>第二阶段：把被标记的对象移动到内存的一端，从而形成连续内存，并回收所有存活对象以外的内存。</li>
</ul>
<p><img src="/2021/07/09/garbage-collection/mark-compact.jpg" alt></p>
<p>该算法（M-C）不会产生内存碎片，因此提高了内存利用率，相当于“用时间换空间”。适用于触发次数不那么多的<strong>老年代</strong>的垃圾回收。</p>
<p><strong>3. 复制算法 Copying</strong></p>
<ul>
<li>将原有的内存分为大小相等的两块，每次只使用其中一块；</li>
<li>从根集合扫描出存活的对象后，将这些对象复制到一块完全未使用的空间（另一块）去；</li>
<li>复制完成之后，将前面一块内存回收。</li>
</ul>
<p>复制算法为了解决标记-清除算法效率低的问题而设计，简单高效；但是内存利用率较低（每次只能用一半内存）。</p>
<p><img src="/2021/07/09/garbage-collection/copying.jpg" alt></p>
<p>看完了介绍，联想一下 JVM 堆的结构，有没有想到什么？</p>
<p><br></p>
<p>没错，堆里面新生代的 <code>From Survivor</code> 和 <code>To Survivor</code> 之间，就是这么样操作的（不然怎么叫 “from” 和 “to”），这也算是对“只能使用 1/2 内存”的优化。<br>出于简单高效的优点，而且新生代大多数对象都“朝不保夕”，所以<strong>新生代</strong>的 GC 使用了复制算法。</p>
<p><br></p>
<p>结合以上算法，还根据堆的各个功能区产生了两种<strong>策略</strong>，以提升回收效率：</p>
<p><strong>4. 分代收集算法</strong></p>
<ul>
<li>复制算法用于新生代：以空间换时间</li>
<li>压缩或清除算法用于老年代：以时间换空间</li>
</ul>
<p><img src="/2021/07/09/garbage-collection/generation.jpg" alt></p>
<p><strong>5. 分区算法</strong>：将堆空间划分成连续不同的小区间，每个区间独立使用，独立回收。</p>
<p>当堆空间很大的时候，执行一次 GC 会非常耗时。</p>
<p><img src="/2021/07/09/garbage-collection/division.jpg" alt></p>
<p>分区算法的好处是：可以<strong>控制一次回收多少小空间，而不是整个堆</strong>，避免 GC 时间过长，造成系统停顿。</p>
<p>如上：绿转白的是指定回收的内存块，可通过设置垃圾占比阈值来控制回收与否。</p>
<p><br></p>
<h1 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h1><p>JVM 的 GC 算法为<strong>分代收集</strong>，具体的设计为：</p>
<ol>
<li>频繁收集新生代</li>
<li>较少收集老年代</li>
<li>更少收集永久区/元空间</li>
</ol>
<p><br></p>
<p>新生代的垃圾收集：<big><strong>Young GC</strong></big>（YG，也叫 Minor GC）</p>
<p>对象确定在新生代分配之后，如果 Eden 区没有足够的空间，便会触发 YG。<br>步骤如下：</p>
<ol>
<li>将 <code>Eden</code> + <code>From Survivor</code> 区存活的对象复制到 <code>To Survivor</code></li>
<li>若 Survivor 区满，则将 Survivor 区内的存活对象转移到<strong>老年代</strong><ul>
<li>若老年代也满了（……），则抛出 <code>OutOfMemoryException</code></li>
</ul>
</li>
<li>清空 Eden 和 From Survivor</li>
<li>From Survivor 和 To Survivor <strong>交换</strong>，以备下次垃圾收集使用。</li>
</ol>
<p>整个 JVM 堆的垃圾收集：<big><strong>Full GC</strong></big>（也叫 Major GC）</p>
<p>触发 Full GC 的条件有很多：</p>
<ul>
<li>对象晋升时，对象大小大于老年代可用空间的大小</li>
<li>老年代的连续空间不足</li>
<li>Metaspace 达到阈值</li>
<li>显式调用 GC：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.gc();  <span class="comment">// 请求运行垃圾回收器触发 Full GC，不一定真的执行了垃圾回收，且不受代码控制</span></span><br><span class="line"></span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>
<p><small>（注：真正的垃圾回收机制，具体在什么时间点开始发生动作，是不可预料的；这和抢占式的线程在发生作用时的原理一样，你不知道它什么时候开始，什么时候完成。所以<strong>不能通过 Java 代码干预 Java 垃圾回收</strong>。）</small></p>
<p>Young GC 被触发的次数大大高于 Old GC 被触发的次数。</p>
<p>触发了 Full GC 之后，整个应用程序会暂停一小段时间，称作 <strong>STOP THE WORLD</strong>，是独占式的垃圾回收。<br>如果执行 Full GC 之后老年代的空间仍不足：抛出 <code>OutOfMemoryException: Java heap space</code><br>如果执行 Full GC 之后元空间的空间仍不足：抛出 <code>OutOfMemoryException: Metaspace</code></p>
<p>顺便借这里聊一聊老年代存储的对象和晋升机制：</p>
<ul>
<li>大对象（由 JVM 参数决定）在分配内存的时候，会直接划归到老年代，如数组；</li>
<li>存储在新生代的对象，经过 N 次 GC 之后会<strong>晋升</strong>到老年代。默认 N = 15，且不能超过 15。<ul>
<li>为啥是 15？对象头的 Mark Word 里面，记录对象岁数的空间就 4 位，最大就是 1111 -&gt; 15。</li>
</ul>
</li>
<li>Survivor 空间不足的时候。</li>
</ul>
<h1 id="safe-point"><a href="#safe-point" class="headerlink" title="safe point"></a>safe point</h1><p>程序执行时并非在所有地方都能停顿下来开始执行 GC。因此。某些特定的时间点被称为 <strong>safe-point</strong>。</p>
<p>在使用 GC roots 分析可达性时，引用关系不会发生改变的点就是 safe-points，包括：</p>
<ul>
<li>方法调用</li>
<li>循环跳转</li>
<li>异常跳转</li>
</ul>
<p><br></p>
<h1 id="垃圾收集器（Garbage-Collector）"><a href="#垃圾收集器（Garbage-Collector）" class="headerlink" title="垃圾收集器（Garbage Collector）"></a>垃圾收集器（Garbage Collector）</h1><p>JDK 1.7 update 14 版本中，针对 HotSpot 虚拟机设计的垃圾收集器在不同代内存的作用分布如下：</p>
<p><img src="/2021/07/09/garbage-collection/jdk-1-7-gc.jpg" alt></p>
<p>上图中，连着线的 GC 说明线的两头相连的收集器可以结合使用。</p>
<p>在介绍各种垃圾回收器之前，我们先给出一个定义：<br><strong>吞吐量</strong>：运行用户代码时间占用户代码时间和垃圾回收时间总和的百分比，越高说明垃圾回收对程序的影响越小，即程序吞吐量越大。</p>
<p>JVM 提供如下多种垃圾收集器：</p>
<h2 id="串行-GC（Serial-Garbage-Collector）"><a href="#串行-GC（Serial-Garbage-Collector）" class="headerlink" title="串行 GC（Serial Garbage Collector）"></a>串行 GC（Serial Garbage Collector）</h2><p><img src="/2021/07/09/garbage-collection/serial-gc.jpg" alt></p>
<p>单线程执行 GC 不存在线程切换，因此在单 CPU 环境下性能较好。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">JVM 参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-XX:SurvivorRatio</td>
<td style="text-align:center">设置 Eden 区与 Survivor 区的比例</td>
</tr>
<tr>
<td style="text-align:center">-XX:PretenureSizeThreshold</td>
<td style="text-align:center">设置大对象直接进入老年代的阈值</td>
</tr>
<tr>
<td style="text-align:center">-XX:MaxTenuringThreshold</td>
<td style="text-align:center">设置对象进入老年代的年龄阈值</td>
</tr>
</tbody>
</table>
</div>
<p>包括：</p>
<p><strong>Serial</strong></p>
<ul>
<li>JDK 1.3.1 之前，新生代唯一的 GC</li>
<li>也是 JVM Client 模式下默认的新生代收集器</li>
<li>使用单线程串行回收方式；使用复制算法，因此用于新生代</li>
</ul>
<p><strong>Serial Old</strong></p>
<ul>
<li>Serial 的老年代版本</li>
<li>同为单线程操作，使用标记-压缩算法</li>
<li>作为 CMS 收集器的备案</li>
</ul>
<p>启用<font color="#FF8C00">指定</font>的收集器：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">JVM 参数</th>
<th style="text-align:center">新生代</th>
<th style="text-align:center">老年代</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-XX:+UseSerialGC</td>
<td style="text-align:center"><font color="#FF8C00">Serial</font></td>
<td style="text-align:center"><font color="#FF8C00">Serial Old</font></td>
</tr>
<tr>
<td style="text-align:center">-XX:+UseParNewGC</td>
<td style="text-align:center">ParNew</td>
<td style="text-align:center"><font color="#FF8C00">Serial Old</font></td>
</tr>
<tr>
<td style="text-align:center">-XX:+UseParallelGC</td>
<td style="text-align:center">Parallel Scavenge</td>
<td style="text-align:center"><font color="#FF8C00">Serial Old</font></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h2 id="并行-GC（Parallel-Garbage-Collector）"><a href="#并行-GC（Parallel-Garbage-Collector）" class="headerlink" title="并行 GC（Parallel Garbage Collector）"></a>并行 GC（Parallel Garbage Collector）</h2><p><img src="/2021/07/09/garbage-collection/parallel-gc.jpg" alt></p>
<p>将串行回收器多线程化，在多 CPU 环境下有更好的性能。<br>与串行回收器有相同的回收策略、算法、参数。</p>
<p>还包括以下参数：</p>
<table>
    <tr>
        <th>垃圾收集器</th>
        <th>JVM 参数</th>
        <th>作用</th>
    </tr>
    <tr>
        <th>ParNew</th>
        <td>-XX:ParallelGCThreads</td>
        <td>指定 GC 时工作的线程数量</td>
    </tr>
    <tr>
        <th rowspan="3">Parallel Scavenge</th>
        <td>-XX:MaxGCPauseMillis</td>
        <td>最大的垃圾收集暂停时间</td>
    </tr>
    <tr>
        <td>-XX:GCTimeRatio</td>
        <td>设置垃圾收集吞吐量</td>
    </tr>
    <tr>
        <td>-XX:+UseAdaptiveSizePolicy</td>
        <td>打开自适应垃圾收集策略</td>
    </tr>
    <tr>
        <th>Parallel Old</th>
        <td>-XX:ParallelGCThreads</td>
        <td>指定 GC 时工作的线程数量</td>
    </tr>
</table>

<p>包括：</p>
<p><strong>ParNew</strong></p>
<ul>
<li>Serial 的多线程版本：因此也是使用复制算法，应用于新生代</li>
<li>是 JVM Server 模式下默认的新生代收集器</li>
</ul>
<p><strong>Parallel Scavenge</strong></p>
<ul>
<li>与 ParNew 类似：使用复制算法，应用于新生代</li>
<li>JDK 1.8 默认的收集器</li>
<li>追求高吞吐量，高效利用 CPU</li>
</ul>
<p><strong>Parallel Old</strong></p>
<ul>
<li>Parallel Scavenge 的老年代版本</li>
<li>使用标记-压缩算法</li>
</ul>
<p>启用<font color="#FF8C00">指定</font>的收集器：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">JVM 参数</th>
<th style="text-align:center">新生代</th>
<th style="text-align:center">老年代</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-XX:+UseParNewGC</td>
<td style="text-align:center"><font color="#FF8C00">ParNew</font></td>
<td style="text-align:center">Serial Old</td>
</tr>
<tr>
<td style="text-align:center">-XX:+UseConcMarkSweepGC</td>
<td style="text-align:center"><font color="#FF8C00">ParNew</font></td>
<td style="text-align:center"><font color="#FF8C00">CMS</font></td>
</tr>
<tr>
<td style="text-align:center">-XX:+UseParallelGC</td>
<td style="text-align:center"><font color="#FF8C00">Parallel Scavenge</font></td>
<td style="text-align:center">Serial Old</td>
</tr>
<tr>
<td style="text-align:center">-XX:+UseParallelOldGC</td>
<td style="text-align:center"><font color="#FF8C00">Parallel Scavenge</font></td>
<td style="text-align:center"><font color="#FF8C00">Parallel Old</font></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h2 id="并发标记-清除（Concurrent-Mark-Sweep-CMS-Garbage-Collector）"><a href="#并发标记-清除（Concurrent-Mark-Sweep-CMS-Garbage-Collector）" class="headerlink" title="并发标记-清除（Concurrent Mark-Sweep, CMS Garbage Collector）"></a>并发标记-清除（Concurrent Mark-Sweep, <strong>CMS</strong> Garbage Collector）</h2><p>顾名思义：CMS 使用了标记-清除算法，且属于<strong>并行</strong> GC。</p>
<ul>
<li>以获取最短回收停顿时间为目标</li>
<li>使用于老年代的垃圾收集</li>
<li>因为配置参数太多，给 GC 代码库带来了很多复杂性，从 JDK 9 已经被 <code>@Deprecated</code> 了</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>GC 算法</th>
<th>JVM 参数（约数）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Common</td>
<td>50</td>
</tr>
<tr>
<td>Parallel</td>
<td>6</td>
</tr>
<tr>
<td>CMS</td>
<td>72</td>
</tr>
<tr>
<td>G1</td>
<td>26</td>
</tr>
<tr>
<td>ZGC</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>步骤：</p>
<ol>
<li><strong>初始标记</strong>（initial-mark）：标记作为 GC Roots 的对象（STOP THE WORLD）</li>
<li><strong>并发标记</strong>（concurrent-mark）：从 GC Roots 开始对堆进行可达性分析，找出所有的活对象<ul>
<li><strong>并发</strong>：指的是标记对象的线程们<strong>穿插</strong>着应用线程执行，所以是不会 STOP THE WORLD 的</li>
</ul>
</li>
<li>预清理（concurrent-preclean）：修正并发期间，由于应用程序的操作导致的<strong>标记变动</strong>的一部分对象的标记记录<ul>
<li>非必须，可关闭</li>
<li>存在的意义：节省下面的重新标记 STOP THE WORLD 的时间，让重新标记少处理一些</li>
</ul>
</li>
<li>重新标记（remark）：重新并发标记（STOP THE WORLD），标记垃圾最后的机会</li>
<li><strong>并发清理</strong>（concurrent-sweep）</li>
<li>并发重置（concurrent-reset）：将状态重置，等待下一次 CMS。</li>
</ol>
<p><img src="/2021/07/09/garbage-collection/cms-gc.jpg" alt></p>
<p>缺点：</p>
<ol>
<li>产生大量空间碎片，可能提前触发 Full GC</li>
<li>无法清除浮动垃圾</li>
<li>并发收集器对 CPU 资源敏感</li>
</ol>
<p>注：</p>
<ul>
<li>CMS 收集器中，当老年代内存使用超过一定比例时，系统将会进行垃圾回收；</li>
<li>当剩余内存不能满足程序运行要求时，系统会出现 Concurrent Mode Failure，然后临时采用 Serial Old 算法进行清除；</li>
<li>此时性能会降低。</li>
</ul>
<p>可用参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">JVM 参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-XX:-CMSPrecleaningEnabled</td>
<td style="text-align:center">禁用预清理操作</td>
</tr>
<tr>
<td style="text-align:center">-XX:ConcGCThreads</td>
<td style="text-align:center">设置并发运行的线程数量，如未设置，则使用 ParallelCMSThreads 计算</td>
</tr>
<tr>
<td style="text-align:center">-XX:ParallelCMSThreads</td>
<td style="text-align:center">（早期版本）设置并发运行的线程数量</td>
</tr>
<tr>
<td style="text-align:center">-XX:CMSInitiatingOccupancyFraction</td>
<td style="text-align:center">当老年代空间使用量达到某个百分比时，执行 CMS。默认 68</td>
</tr>
<tr>
<td style="text-align:center">-XX:+CMSCompactAtFullCollection</td>
<td style="text-align:center">GC 后进行一次碎片整理</td>
</tr>
<tr>
<td style="text-align:center">-XX:CMSFullGCsBeforeCompaction</td>
<td style="text-align:center">指定执行多少次 GC 后，进行一次碎片整理</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h2 id="G1（Garbage-First）Garbage-Collector"><a href="#G1（Garbage-First）Garbage-Collector" class="headerlink" title="G1（Garbage-First）Garbage Collector"></a><strong>G1</strong>（Garbage-First）Garbage Collector</h2><p>分区算法的应用：因此 G1 应用于堆的<strong>全世代</strong>，优先回收垃圾比例最高的区域。</p>
<ul>
<li>从 JDK 1.7 开始投入使用，是 JDK 9 后的默认 GC<ul>
<li>CMS 的取代者</li>
</ul>
</li>
<li>将堆划分为多个区域，每次收集部分区域，减少 GC 停顿时间</li>
<li>兼顾吞吐量和停顿时间，可直观设定停顿时间</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">JVM 参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-XX:+UseG1GC</td>
<td style="text-align:center">打开 G1 收集器开关</td>
</tr>
<tr>
<td style="text-align:center">-XX:MaxGCPauseMillis</td>
<td style="text-align:center">指定目标最大停顿时间</td>
</tr>
<tr>
<td style="text-align:center">-XX:ParallelGCThreads</td>
<td style="text-align:center">设置并发线程数量</td>
</tr>
<tr>
<td style="text-align:center">-XX:InitiatingHeapOccupancyPercent</td>
<td style="text-align:center">指定堆的使用率为多少的时候，触发并发标记周期。默认 45</td>
</tr>
</tbody>
</table>
</div>
<p>G1 对内存空间的划分与传统的内存空间划分有所不同：</p>
<p><img src="/2021/07/09/garbage-collection/g1-division.webp" alt></p>
<p>G1 分四个阶段，而且按照顺序循环往复：</p>
<ol>
<li>新生代 GC</li>
<li><strong>并发标记周期</strong></li>
<li>混合收集</li>
<li>Full GC（非必须）</li>
</ol>
<p><img src="/2021/07/09/garbage-collection/g1-steps.png" alt></p>
<h3 id="新生代-GC"><a href="#新生代-GC" class="headerlink" title="新生代 GC"></a><strong>新生代 GC</strong></h3><p>G1 的新生代 GC 就是复制算法的那一套：</p>
<ul>
<li>Eden 区被占满的时候，新生代 GC 就会被启动</li>
<li>回收后，Eden + from survivor 区会被清空<ul>
<li>部分新生代对象会直接晋升到老年代</li>
<li>to survivor 会保留另一部分活的对象，然后 from 和 to 两块 survivor 区对调</li>
</ul>
</li>
</ul>
<h3 id="并发标记周期"><a href="#并发标记周期" class="headerlink" title="并发标记周期"></a><strong>并发标记周期</strong></h3><p>G1 的并发标记周期如下：</p>
<p><img src="/2021/07/09/garbage-collection/g1-gc.jpg" alt></p>
<p>由上图可知，G1 是参照了 CMS 而设计的，吸取了 CMS 的优点，包括<strong>初始标记</strong>、<strong>并发标记</strong>、<strong>重新标记</strong>和<strong>并发清理</strong>。<br>另：</p>
<ul>
<li>根区域扫描：扫描 survivor 区域，标记可以直接到达老年代的对象</li>
<li>独占清理：计算活跃度（存活对象与可清理对象的比例）并进行排序，统计出活跃度低的以及完全空闲的那些部分，便于之后进行清理<ul>
<li>紧接着的<strong>并发清理</strong>清理掉的是完全空闲的空间。</li>
</ul>
</li>
</ul>
<p>所以，G1 的并发标记周期针对的是<strong>老年代</strong>的堆空间。</p>
<h3 id="混合收集"><a href="#混合收集" class="headerlink" title="混合收集"></a><strong>混合收集</strong></h3><p>在这里清除最主要的数据。</p>
<ol>
<li>由于已经触发了 Young GC，Eden 区域会被清空</li>
<li>被标记的年轻代和老年代都会被回收</li>
<li>活跃度低的会被清理，剩余的存活对象会被移动到其他区域，减少内存碎片。</li>
</ol>
<p><img src="/2021/07/09/garbage-collection/g1-mix-gc.png" alt></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Blog 的部署</title>
    <url>/2021/05/27/hexo-deployment/</url>
    <content><![CDATA[<p>相信各位，特别是喜欢玩博客的朋友都有听过 Hexo 这个框架了，本人在用它来搭建自己的空间的时候遇到了不少的问题，现在就写一篇 blog 来记录一下搭建过程。</p>
<span id="more"></span>
<p><br></p>
<h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><p>Hexo 是一款基于 Node.js 的静态博客框架，依赖少，而且可以很方便地将静态页面托管在 Github 上。详细介绍或者 API 可参考 <a href="https://hexo.io/zh-cn/">Hexo 官网</a>或者它的 <a href="https://github.com/hexojs/hexo">Github 工程页面</a>。</p>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="1-准备-Github-账号与仓库"><a href="#1-准备-Github-账号与仓库" class="headerlink" title="1. 准备 Github 账号与仓库"></a>1. 准备 Github 账号与仓库</h3><ol>
<li>在<a href="github.com"> Github 官网</a>注册好账号，并记录下自己的【用户名】。<ul>
<li>这一步很重要，因为这与你将要创建的博客的<strong>访问网址</strong>直接相关。</li>
<li>注：用户名可以修改，但是有的时候会带来<a href="https://docs.github.com/en/github/setting-up-and-managing-your-github-user-account/managing-user-account-settings/changing-your-github-username">副作用</a>。</li>
</ul>
</li>
<li>创建以 [用户名].github.io 为名的 repository。</li>
</ol>
<h3 id="2-建立本机与-Github-的-SSH-连接"><a href="#2-建立本机与-Github-的-SSH-连接" class="headerlink" title="2. 建立本机与 Github 的 SSH 连接"></a>2. 建立本机与 Github 的 SSH 连接</h3><p>从 <a href="https://git-scm.com/">git 官网</a>下载并安装 git。安装完成后可通过以下命令验证：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p>
<p>完后需要生成 ssh key<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C your_email@example.com</span><br><span class="line">[press enter] //默认位置~/.ssh</span><br><span class="line">[press enter] //key不需要密码保护</span><br><span class="line">[press enter] //确认不需要密码保护</span><br></pre></td></tr></table></figure><br>随后复制 ssh key 到 <a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">Github 页面中</a>。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pbcopy &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>
<p>具体可参照 Github 提供的<a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">方法</a>。</p>
<p>验证方法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<h3 id="3-安装-Hexo-及其依赖"><a href="#3-安装-Hexo-及其依赖" class="headerlink" title="3. 安装 Hexo 及其依赖"></a>3. 安装 Hexo 及其依赖</h3><ul>
<li>Node.js <a href="https://nodejs.org/en/">安装</a><ul>
<li>验证：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li>
<li>注：所安装的 Node.js 版本需在 12 以上。</li>
</ul>
</li>
<li><p>Hexo：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hexo Git Developer：用于博客页面的更新与部署。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-开搞"><a href="#4-开搞" class="headerlink" title="4. 开搞"></a>4. 开搞</h3><ul>
<li><p>在适当的位置初始化 Hexo 博客文件夹：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init myBlog</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入到新创建的文件夹中：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd myBlog</span><br></pre></td></tr></table></figure>
<p>  此时能看见的文件与文件夹：</p>
<ul>
<li><code>node_modules</code>：依赖包</li>
<li><code>public</code>：存放生成的页面</li>
<li><code>scaffolds</code>：生成文章的模板</li>
<li><code>source</code>：存放文章的位置</li>
<li><code>themes</code>：博客主题</li>
<li><code>_config.yml</code>：博客配置文件</li>
</ul>
</li>
<li><p>配置页面</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="comment"># 配置内容</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:[用户名]/[用户名].github.io.git</span>  <span class="comment"># 该【用户名】为之前步骤提到的需要记录的用户名</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span>  <span class="comment"># 新创建的 Github repo 的 branch</span></span><br></pre></td></tr></table></figure>
<p>  注：</p>
<ul>
<li>配置的用户名需保持一致，此时 Github Pages 会根据 repo 所配置的值生成页面的访问地址。如用户名为 zhangsan 的话，最终的博客访问网址为 <a href="https://zhangsan.github.io">https://zhangsan.github.io</a></li>
<li>repo 亦可配置按照 https 方式配置：<a href="https://github.com/[用户名]/[用户名].github.io.git。">https://github.com/[用户名]/[用户名].github.io.git。</a></li>
</ul>
</li>
<li><p>清理 Hexo 博客文件夹：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的博客页面</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new myPage</span><br></pre></td></tr></table></figure>
<ul>
<li>此时文件 myPage.md 会在 <code>source/_posts</code> 下生成。</li>
</ul>
</li>
<li><p>生成 Hexo 博客静态页面：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署 Hexo 静态页面至 Github 中，由 <a href="https://pages.github.com/">Github Pages</a> 保管并渲染、显示：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>  注：如配置成 https 形式访问，则会有提示输入账号密码。</p>
</li>
<li><p>此时访问 <em><a href="https://[用户名].github.io">https://[用户名].github.io</a></em>，即可登入搭建的页面啦。</p>
</li>
<li><p>也可现在本地搭建 Hexo 服务，通过 <a href="http://localhost:4000">http://localhost:4000</a> 查看博客效果：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></p>
<p><a href="https://fly-luck.github.io/2016/03/05/Hexo%20Blog/">Luck’s Cabin - Hexo博客部署</a></p>
]]></content>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2022/11/12/insertion-sort/</url>
    <content><![CDATA[<p>插入排序也是比较排序的一种。</p>
<span id="more"></span>
<p>在通过插入排序构建有序序列时，采用 in-place 排序：</p>
<ul>
<li>对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并<strong>插入</strong>未排序数据，直到全部元素按序插入完成；</li>
<li>从后向前扫描过程中，需要反复把已排序元素逐步<strong>向后挪位</strong>，为最新元素提供插入空间；</li>
<li>只需要用到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 的额外空间</li>
</ul>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>以升序排序为例：</p>
<ol>
<li>从第一个元素开始，该元素可认为已经被排序</li>
<li>从未排序序列中取出下一个元素 temp</li>
<li>从后向前扫描已经排序的序列</li>
<li>若已排序序列中某元素 A 大于 temp，则将 A 往后移动一个位置</li>
<li>重复步骤 3 ~ 4，直到找到不大于 temp 的已排序元素</li>
<li>将新元素 temp 插入到该位置（不大于 temp 的已排序元素）之后</li>
<li>重复步骤 2 ~ 6，最终完成排序。</li>
</ol>
<p>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> hkey)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) {</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;  <span class="comment">// 防止溢位</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; hkey) {</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; hkey) {</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>该算法可认为是插入排序的一个变种，称为二分查找插入排序。<br>⚠️注意：<strong>二分查找只对有序序列有效</strong>。</p>
<h1 id="复杂度评估"><a href="#复杂度评估" class="headerlink" title="复杂度评估"></a>复杂度评估</h1><p><strong>空间复杂度</strong>为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p><strong>时间复杂度</strong>的最好情况：序列本身有序且顺序，只需比较 n-1 次</p>
<p>最坏情况：序列原本逆序</p>
<ul>
<li>需要比较 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.634ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4700.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3700.4,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(4200.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container> 次，赋值 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="40.981ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 18113.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1267,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2089.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3089.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3589.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3978.4,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(4478.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4978.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(5478.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(6478.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6867.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7690.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(8690.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(9190.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(9857.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(10912.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(11301.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(12124.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(13124.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(13624.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(14013.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(14402.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(15224.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(16224.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(16724.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(17113.8,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(17613.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container> 次</li>
<li>因此时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>插入排序并不适合对于数据量比较大的排序应用；不过若数量级小于千，插入排序还是一个不错的选择。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>中间变量保存插入数据，比较过程中不断右移（左移）已排序数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">int</span> toBeInserted = a[i];  <span class="comment">// get the one to be inserted into the ordered list</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="comment">// 找出不大于将要插入的元素的那个位置</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; toBeInserted) {</span><br><span class="line">                    a[j] = a[j - <span class="number">1</span>];  <span class="comment">// 在 for 循环内，将比它大的元素往后移动</span></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    a[j] = toBeInserted;  <span class="comment">// set that one into the ordered list</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>比较过程中交换数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortThenSwap</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                    a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                    a[j - <span class="number">1</span>] = temp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 概述</title>
    <url>/2022/05/14/docker/</url>
    <content><![CDATA[<p>Docker 是利用 Go 开发的一种虚拟容器技术，属于轻量级的虚拟化。</p>
<span id="more"></span>
<p>Docker 本身不是容器，而是创建容器的工具，是应用容器的引擎。</p>
<p><img src="/2022/05/14/docker/docker.png" alt></p>
<p>这句 slogan <strong>“Build, ship and run.”</strong> 就很能说明 Docker 的思想：如同它的 logo 一样，Docker 是一条大鲸鱼，承载的一个个的集装箱就是各个不同的容器，容器之间相互<strong>隔离</strong>。<br>跟虚拟机一样，Docker 的核心思想也是“隔离”。Docker 通过隔离机制，既可以保障每个集装箱里的东西互不相干，也能将服务器资源压榨到最大程度。</p>
<p>由于 Docker 将包括运行环境在内的应用上下文一起打包，它的出现大大减少了开发过程中因为开发、测试环境和生产环境之间的切换导致的程序不兼容问题，简化与加快了产品发布流程。</p>
<p>Docker 的核心概念包括：</p>
<ul>
<li>镜像 Image</li>
<li>容器 Container</li>
<li>仓库 Repository</li>
</ul>
<p>先说说镜像。</p>
<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p>镜像 Image 是一种<strong>轻量级</strong>、<strong>可执行</strong>的独立软件包，提供了容器运行时所需的程序、库、资源、配置等文件。</p>
<ul>
<li>包含一切为运行时准备的配置参数、环境变量等</li>
<li>不包含任何动态数据，其内容在构建之后也不会被改变</li>
<li>基于基础镜像（没有父镜像）可制作各种具体的应用镜像</li>
</ul>
<p>获得镜像的方式：</p>
<ul>
<li>通过 Dockerfile 制作</li>
<li>通过传输拷贝方式获得</li>
<li>从远程仓库下载</li>
</ul>
<p>Image 属于联合文件系统，是一种<strong>分层</strong>、<strong>轻量级</strong>且<strong>高性能</strong>的文件系统，是 Docker image 的基础。</p>
<ul>
<li>支持对文件系统的修改作为一次提交来逐层叠加</li>
<li>可将不同目录挂载到同一个虚拟文件系统下</li>
</ul>
<p>从 Registry 拉取镜像的时候，是一层一层并行下载的。好处是能实现<strong>共享资源</strong>。</p>
<ul>
<li>比如有多个镜像都从相同 base 镜像构建而来</li>
<li>宿主机只需在磁盘和内存各保存一份 base，就可以为所有容器服务</li>
</ul>
<p>镜像加载原理</p>
<ul>
<li>最底层是 <strong>bootfs</strong>(boot file system) 主要包含：<ul>
<li>bootloader：引导加载 kernel</li>
<li>kernel：最终拥有对内存的使用权</li>
</ul>
</li>
<li>image 最底层是 kernel</li>
</ul>
<p>镜像加载成功之后，就会在容器里运行相应的程序。</p>
<h2 id="远程仓库-Docker-Registry"><a href="#远程仓库-Docker-Registry" class="headerlink" title="远程仓库 Docker Registry"></a>远程仓库 Docker Registry</h2><p>Docker Registry，Docker 注册中心，是 docker 镜像的地址，负责管理 Docker Image。</p>
<p>默认使用官方的 <a href="https://hub.docker.com/">Docker Hub</a>，其拥有大量的高质量的官方镜像。<br>可通过配置 <code>/etc/docker/daemon.json</code> 设置 docker 的镜像地址，加快镜像的下载速度：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://xxx.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>Docker image 的构建文件，格式及关键字如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>    <span class="comment"># 指明当前新镜像基于哪一个基础镜像</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>    <span class="comment"># 镜像维护者信息</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">    <span class="comment"># 容器构建时需要运行的命令</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>    <span class="comment"># 当前容器对外暴露的接口</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">    <span class="comment"># 指定在创建容器后终端默认登陆进来的工作目录</span></span></span><br><span class="line"><span class="keyword">ARG</span>    <span class="comment"># 用于构建镜像过程中设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span>    <span class="comment"># 用于构建镜像过程中，及容器运行时设置环境变量</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash">    <span class="comment"># 将宿主机目录下的文件复制至镜像。该命令会自动处理 URL 和解压 tar 包</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">    <span class="comment"># 类似于 ADD，复制文件和路径到镜像中。从构建上下文目录中源路径的文件/目录复制到新的一层的镜像内的目标路径位置</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">    <span class="comment"># 容器数据卷</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">    <span class="comment"># 指定一个容器启动时要执行的命令。可有多个 CMD 命令，但只有最后一个生效，且会被 docker run 之后的参数替换</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash">    <span class="comment"># 和 CMD 一样，指定容器启动程序和参数</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span>    <span class="comment"># 构建一个被继承的 DockerFile 时，运行该命令，父镜像在被子继承后父镜像的 ONBUILD 被触发</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/14/docker/docker-lifecycle.png" alt></p>
<p>Dockerfile 的每<strong>一行</strong>对应的就是 image 的<strong>一层</strong>文件系统；从 Dockerfile 上往下，分别往 bootfs 层叠加成最终的 image。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器存放了如应用程序代码、依赖库以及其依赖关系等内容。</p>
<p>容器提供了三种隔离类型：</p>
<ol>
<li>工作区隔离（流程、网络）</li>
<li>资源隔离（CPU、内存）</li>
<li>文件系统隔离（联合文件系统 UnionFS）</li>
</ol>
<p>容器状态分三种：运行（<strong>Running</strong>）、暂停（<strong>Pause</strong>）和停止（<strong>Stop</strong>）。</p>
<p>容器使用 Linux 系统中存在的结构（cgroups, namespaces, …），并在其之上构建一个抽象。<br>使用容器不仅可以分发应用<strong>程序的二进制代码</strong>，还可以以实用的方式交付运行应用程序所需的<strong>整个环境</strong>。</p>
<p>容器与虚拟机的区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>虚拟机</th>
<th>容器</th>
</tr>
</thead>
<tbody>
<tr>
<td>隔离级别</td>
<td>操作系统级</td>
<td>进程级（内核级）</td>
</tr>
<tr>
<td>隔离策略</td>
<td>Hypervisor(VMM)</td>
<td>CGroups</td>
</tr>
<tr>
<td>系统资源</td>
<td>5~15%</td>
<td>0~5%</td>
</tr>
<tr>
<td>启动时间</td>
<td>分钟级</td>
<td>秒级</td>
</tr>
<tr>
<td>镜像存储</td>
<td>GB - TB</td>
<td>KB - MB</td>
</tr>
<tr>
<td>集群规模</td>
<td>上百</td>
<td>上万</td>
</tr>
<tr>
<td>高可用策略</td>
<td>备份、容灾、迁移</td>
<td>弹性、负载、动态</td>
</tr>
</tbody>
</table>
</div>
<p>上图：</p>
<p><img src="/2022/05/14/docker/vm-container.png" alt></p>
<p>可知 VM 虚拟出的是完整的操作系统（包括内核），而容器直接运行在宿主机内核上，没有自己的内核和虚拟硬件。<br>VM 提供的是不同操作系统之间数据和环境的隔离；而容器提供的是不同应用及其运行环境的隔离。<br>所以容器更加小巧轻便，更高效地利用物理机的资源，消耗资源更少，启动速度更快，能实现快速的运维部署、升级、扩/缩容。</p>
<p>在 Docker 中，所有容器通过 <strong>Docker Engine</strong> 支撑服务。</p>
<h2 id="容器数据卷-Volume"><a href="#容器数据卷-Volume" class="headerlink" title="容器数据卷 Volume"></a>容器数据卷 Volume</h2><p>上面提到，镜像包含的是资源、配置和运行时，并不包括任何动态数据。镜像内应用和环境如果需要完成<strong>数据持久化</strong>，需要通过挂载数据卷的方式。</p>
<p><strong>匿名挂载</strong>：通过 <code>-v</code> 指定容器内部需要挂载的路径</p>
<pre><code>docker run -d -P --name nginx1 -v /home/raymond/test:/etc/nginx nginx
</code></pre><p><strong>具名挂载</strong>：常用的方式，通过 <code>-v 卷名:宿主机路径:容器内路径</code> 指定容器某个路径需要具名挂载到宿主机某一个卷上面</p>
<pre><code>docker run -d -P --name nginx2 -v nginx2:/home/raymond/test:/etc/nginx nginx 
</code></pre><p>当然也可以通过 Dockerfile 的 VOLUME 关键字挂载数据卷。</p>
<p>如果没有指定宿主机路径，Docker 会自动在 <code>/var/lib/docker/volume/</code> 下生成目录作为宿主机路径。</p>
<p>要注意的是，如果有多个容器挂载了同一个宿主机目录，当其中一个容器删除了挂载目录的一个文件后，另外一个容器<strong>还是可以看到该文件</strong>。<br>这是因为容器挂载目录的文件是<strong>互相同步复制备份</strong>的，<strong>而不是共享</strong>某个目录，多个容器查看同一个备份。</p>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p>最全的指令可到<a href="https://docs.docker.com/reference/">官方学习文档</a>查询，这里简单提几个常用的指令。</p>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version  <span class="comment"># 查看 Docker client 和 server 版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker info  <span class="comment"># 显示 Docker client 和 server 信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker COMMAND --<span class="built_in">help</span>  <span class="comment"># 帮助指令</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker ps  <span class="comment"># 查看运行中的容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker top CONTAINER_ID  <span class="comment"># 查看容器 top 信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect CONTAINER_ID  <span class="comment"># 查看容器元数据信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker attach CONTAINER_ID  <span class="comment"># 进入容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker stats  <span class="comment"># 查看所有容器状态</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker cp SRC_PATH CONTAINER_ID:DEST_PATH  <span class="comment"># 将主机文件复制到容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker cp CONTAINER_ID:SRC_PATH DEST_PATH  <span class="comment"># 将容器文件复制到主机</span></span></span><br></pre></td></tr></table></figure>
<h2 id="镜像指令"><a href="#镜像指令" class="headerlink" title="镜像指令"></a>镜像指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images [OPTIONS] [REPOSITORY[:TAG]]  <span class="comment"># 列出本地 Docker 中所有可用镜像。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker search REPOSITORY  <span class="comment"># 搜索镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull REPOSITORY  <span class="comment"># 从 registry 下载 latest 镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull REPOSITORY:[TAG]  <span class="comment"># 从 registry 下载指定版本（TAG）镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi [-f] REPOSITORY[:TAG]  <span class="comment"># 删除镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi [-f] IMAGE_ID  <span class="comment"># 删除镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi [-f] IMAGE_ID IMAGE_ID IMAGE_ID... <span class="comment"># 删除多个镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi [-f] $(docker images -aq)  <span class="comment"># 批量删除镜像</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image  <span class="comment"># 单个镜像父指令。</span></span></span><br></pre></td></tr></table></figure>
<p>比如要构建某个镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image build [OPTIONS] PATH | URL | -</span></span><br></pre></td></tr></table></figure>
<p>常见 OPTION：</p>
<ul>
<li><code>--cache-from</code>：指定构建镜像文件的 cache</li>
<li><code>--no-cache</code>：构建镜像文件时禁止使用 cache</li>
</ul>
<h2 id="容器指令"><a href="#容器指令" class="headerlink" title="容器指令"></a>容器指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run [OPTIONS] REPOSITORY [COMMAND] [ARG...]  <span class="comment"># 运行容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps [OPTIONS]  <span class="comment"># 查询容器列表</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rm [OPTIONS] CONTAINER_ID [CONTAINER_ID]  <span class="comment"># 删除容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker start CONTAINER_ID  <span class="comment"># 启动容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker restart CONTAINER_ID  <span class="comment"># 重启容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker stop CONTAINER_ID  <span class="comment"># 停止正在运行的容器，容器进入 exited 状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">kill</span> CONTAINER_ID  <span class="comment"># 强制停止指定容器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker commit [OPTIONS] CONTAINER_ID [REPOSITORY[:TAG]]  <span class="comment"># 通过提交容器来创建镜像</span></span></span><br></pre></td></tr></table></figure>
<p>退出容器：</p>
<pre><code>exit（容器进入 exited 状态）
CTRL+P+Q（退出容器交互模式，但容器还是 up 的状态）
</code></pre><h2 id="挂载指令"><a href="#挂载指令" class="headerlink" title="挂载指令"></a>挂载指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker volume ls  <span class="comment"># 查看挂载列表</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker volume inspect [VOLUME]  <span class="comment"># 查看某个 volume 的挂载信息</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>容器化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection 接口</title>
    <url>/2022/04/30/java-collection/</url>
    <content><![CDATA[<p>Collection 和 Map 接口并称 Java 集合类中的“二王”。</p>
<span id="more"></span>
<p>可将 Collection 理解为一个动态的对象数组；与数组不同的是，Collection 集合中的对象内容可以被任意扩充，方便于添加或删除。</p>
<p>特点是性能高，且容易扩展和修改。</p>
<p><small>* 注意 Collection 和 Collections 的区别。</small></p>
<p>Collection 不从 Cloneable 和 Serializable 接口继承：</p>
<ul>
<li>如果在所有实现中都授予克隆和序列化，最终反而会导致更少的灵活性和更多的限制。</li>
</ul>
<h1 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h1><p>基本集合操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合是否包含某元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器，继承自 Iterable 接口</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将集合转换成 Object 数组</span></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 toArray() 类似，如果参数 a 数组的长度小于集合的大小，则不填充, 等同于 toArray()</span></span><br><span class="line">    <span class="comment">// 否则填充 a 数组，此时返回的数组与 a 相同</span></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="comment">// 添加成功返回 true，无变化返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合是否是指定集合的超集</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定集合添加进本集合</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定集合从本集合中移除</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留指定集合的所有元素, 移除本集合中的其他所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空集合</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的大部分接口方法在抽象类 <code>AbstractCollection</code> 中实现，并将基础方法 <code>size()</code> 和 <code>iterator()</code> 抽象化。</p>
<p>集合比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>在实现的时候需要注意 equals() 和 hashCode() 俩方法的区别，以及关注实现 equals() 的原则。</p>
<p>由于从 Java 8 开始引入了函数式编程，因此 Collection 也实现了 <a href="/2022/02/07/fp/#进阶应用：Stream">Stream</a> 相关的新接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">    <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">            each.remove();</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行计算的 stream</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的 Stream 只能单向遍历数据源一次，最终产生一个结果。</p>
<h1 id="子类及接口"><a href="#子类及接口" class="headerlink" title="子类及接口"></a>子类及接口</h1><p><img src="/2022/04/30/java-collection/collection-diagram.png" alt></p>
<h2 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h2><p>实现了 Collection 接口的部分核心接口方法，其直接子类：<code>AbstractList</code>, <code>AbstractQueue</code>, <code>AbstractSet</code>。</p>
<h3 id="应用：不可修改集合"><a href="#应用：不可修改集合" class="headerlink" title="应用：不可修改集合"></a>应用：不可修改集合</h3><p>通过继承 AbstractCollection 来实现一个不可修改集合：实现 <code>iterator()</code> 及 <code>size()</code>。</p>
<p>Iterator() 接口默认不实现 remove()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用：可修改集合"><a href="#应用：可修改集合" class="headerlink" title="应用：可修改集合"></a>应用：可修改集合</h3><p>实现 iterator(), size(), add() 来满足条件。</p>
<p>AbstractCollection 默认不实现 add()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p>List 描述的是有序集合，允许重复元素。</p>
<p>List 以线性方式存储元素，因此具有“索引”的概念，可使用整数索引随机访问，或者通过 <code>listIterator()</code> 获取对象。</p>
<p>List 的默认构造会产生 10 个元素大小的空 List。</p>
<p>基本接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接实现类：</p>
<ul>
<li><a href="/2021/06/07/arraylist"><code>ArrayList</code></a>：可动态增长和缩减的索引序列</li>
<li><a href="/2021/06/12/linkedlist"><code>LinkedList</code></a>：可在任意位置高效增减的有序序列</li>
<li><code>Vector</code></li>
<li><code>Stack</code></li>
</ul>
<h3 id="List-lt-gt-Arrays"><a href="#List-lt-gt-Arrays" class="headerlink" title="List &lt;-&gt; Arrays"></a>List &lt;-&gt; Arrays</h3><p>List 调用 <code>toArray()</code> 可转化为 Array。</p>
<p>Array 调用 <code>Arrays.asList(array)</code> 可转化为 List。<br>但要注意的是，该方法返回的是 Arrays 工具类的一个内部类，相当于一个集合视图：</p>
<ul>
<li>不能对其添加删除，否则抛出 UnsupportedOperationException</li>
<li>不能扩容</li>
</ul>
<h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h2><p>Set 不能有重复元素，最多有一个为 null 值的元素。</p>
<p>基本接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;  <span class="comment">// 拒绝添加重复的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;  <span class="comment">// 两个 set 包含相同的元素，但顺序不必相同</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;  <span class="comment">// 保证具有相同元素的 set 将会得到相同的散列码</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set 并没有声明 get()，具体如何访问 Set 中的元素，需要实现类去自定义。</p>
<h3 id="抽象实现类-AbstractSet"><a href="#抽象实现类-AbstractSet" class="headerlink" title="抽象实现类 AbstractSet"></a>抽象实现类 <code>AbstractSet</code></h3><p>为 AbstractCollection 的子类，其对 hashCode() 和 equals() 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 遍历集合中所有元素，返回它们的 hashCode 之和</span></span><br><span class="line"><span class="comment">// 因此包含相同元素集的集合 hashCode 值应该相等</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 先比较两个集合的 size</span></span><br><span class="line"><span class="comment">// 再调用 AbstractCollection 的 containsAll()，比较每个元素的相等性</span></span><br></pre></td></tr></table></figure>
<h3 id="子接口-SortedSet"><a href="#子接口-SortedSet" class="headerlink" title="子接口 SortedSet"></a>子接口 <code>SortedSet</code></h3><ul>
<li>暴露了用于排序的 Comparator 对象</li>
<li>要求实现类必须保证元素有序：或是自然顺序，或是 Comparator 实现的排序方法，且自定义 compare() 可以获得集合的子集视图</li>
<li>只为单个元素提供头部或尾部的访问：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;  <span class="comment">// 获得子集视图，下同</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="子接口-NavigableSet"><a href="#子接口-NavigableSet" class="headerlink" title="子接口 NavigableSet"></a>子接口 <code>NavigableSet</code></h3><p>顾名思义，“可以导航的” set，是 SortedSet 的子接口，定义了用于在有序集中查找和遍历的接口方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E s)</span></span>;  <span class="comment">// 返回 set 中小于给定元素的最大元素</span></span><br><span class="line"><span class="function">E <span class="title">floor</span><span class="params">(E e)</span></span>;  <span class="comment">// 返回 set 中不大于给定元素的最大元素</span></span><br><span class="line"><span class="function">E <span class="title">ceiling</span><span class="params">(E e)</span></span>;  <span class="comment">// 返回 set 中不小于给定元素的最小元素</span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span>;  <span class="comment">// 返回 set 中大于给定元素的最小元素</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;  <span class="comment">// 获取并删除 set 中第一个（最小）元素</span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;  <span class="comment">// 获取并删除 set 中最后一个（最大）元素</span></span><br></pre></td></tr></table></figure>
<p>针对元素排序而声明的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span></span>;    <span class="comment">// 返回由原 NavigableSet 倒序排列的 NavigableSet</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;    <span class="comment">// 根据 descendingSet() 的结果调用 iterator()</span></span><br></pre></td></tr></table></figure>
<h3 id="通用实现类-TreeSet"><a href="#通用实现类-TreeSet" class="headerlink" title="通用实现类 TreeSet"></a>通用实现类 TreeSet</h3><p><code>TreeSet</code> 属于有序集合，使用<strong>红黑树</strong>完成排序，可将元素以任意顺序插入到集合中。<br>顾名思义，TreeSet 建立了一棵树，每次添加元素，新元素会被放在正确的排序位置上；因此在遍历的时候，迭代器总以排好序的顺序访问元素，按照<strong>排序后</strong>的顺序输出。<br>因此 TreeSet 添加速度比散列表慢，但比添加到数组或链表快。</p>
<p>TreeSet 实现了 NavigableSet，在其基础上增加了几个便于定位元素以及反向遍历的方法。  </p>
<p>实现代码概要如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  <span class="comment">// 以此来实现元素的唯一性</span></span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，TreeSet 的底层其实是由 TreeMap 实现的；也就是说，TreeSet 的<strong>核心</strong>为使用了 TreeMap 的 Key 及 KeySet 的子类。</p>
<p>TreeSet 的元素保证有序，按照自然顺序或指定 Comparator 排序规则排序。<br>TreeSet 的 Comparable 接口实现：如果 a 与 b 相等，调用 a.compareTo(b) 返回 0；如 a 大于 b ，返回值大于 0；否则返回值小于 0。<br>还可通过 Comparator 对象传递给 TreeSet 构造器，告诉 TreeSet 使用不同的比较方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>;  <span class="comment">// 返回值与 compareTo() 一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要比较的时候，可新建一个 Comparator 接口的类，将该类对象传入 TreeSet 构造器中；或使用匿名内部类方法传递。</p>
<p>如果要插入自定义的对象，就必须通过实现 Comparable 接口自定义排列顺序，因为 Object 类中不提供任何 compareTo 接口的默认实现；<br>注意数字比较时候的溢出：大正整数减去小负整数；<br>覆盖 Comparator<T> 中的 equals()，会使 TreeSet 添加元素的效率更高。</T></p>
<p>TreeSet 的 descendingSet()，headSet() 等方法与 TreeMap（NavigableMap）中类似名称的方法起着类似作用。</p>
<h2 id="其他通用实现类"><a href="#其他通用实现类" class="headerlink" title="其他通用实现类"></a>其他通用实现类</h2><p><code>HashSet</code>：没有重复元素的无序集合，继承自 AbstractSet，内部有一个 HashMap 成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure>
<p>可以看出，HashSet 的底层其实是由 HashMap 实现的；也就是说，HashSet 的<strong>核心</strong>为使用了 HashMap 的 Key 及 KeySet 的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  <span class="comment">// 以此来实现元素的唯一性（不允许重复值）</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次往 HashSet 添加元素时，都会将元素作为 key 添加进来，同时新建 Object 对象用于填充内部 HashMap 的 value</p>
<p>HashSet 与 HashMap 的关系，如同 TreeSet 与 TreeMap 的关系。</p>
<p><br></p>
<p><code>LinkedHashSet</code>：HashSet 的子类，可记住元素插入次序的集</p>
<ul>
<li>使用双向链表记录插入顺序，遍历时依照该插入顺序</li>
<li>对于同一个元素，其插入顺序不会因多次插入而变化。只有当其被移除后再次插入时，顺序才会改变</li>
</ul>
<p><code>EnumSet</code>：枚举类型元素集的高效实现</p>
<ul>
<li>底层是位向量（bit vector）</li>
<li>枚举类型序列有限：EnumSet 使用位序列实现；如对应值在 EnumSet 中，则相应的位被置为 1</li>
<li>使用静态工厂法构造该集</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDay</span> </span>&#123;MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;</span><br><span class="line">EnumSet&lt;WeekDay&gt; workday = EnumSet.range(WeekDay.MONDAY, WeekDay.FRIDAY);</span><br><span class="line">EnumSet&lt;WeekDay&gt; never = EnumSet.noneOf(WeekDay.Class); </span><br></pre></td></tr></table></figure>
<h2 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h2><p>从尾部添加元素，从头部删除元素（FILO / LIFO）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队列尾添加元素, 成功返回 true，否则抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队列尾添加元素，成功返回 true，否则返回 false 或抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除队列头元素，并返回该元素，如果为空则抛出异常</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除队列头元素，并返回该元素，如果为空则返回 null</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列头元素，如果为空则抛出异常</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列头元素，如果为空则返回 null</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：<code>PriorityQueue</code>，优先队列，允许高效删除最小/大元素。</p>
<ul>
<li>使用堆（heap）实现，将最小元素移动到根节点；</li>
<li>因此无论何时调用 remove()，总会获得当前优先队列中的最小元素；</li>
<li>元素按照任意顺序插入，按照排好序的顺序检索</li>
</ul>
<p>优先队列既可保存实现了 Comparable 接口的类对象，也可以保存在构造器中提供比较器的对象。<br>典型的使用示例是任务调度：每启动一个新的任务，都将优先级最高的任务从队列中删除。</p>
<h2 id="Deque-接口"><a href="#Deque-接口" class="headerlink" title="Deque 接口"></a>Deque 接口</h2><p>发音 <code>/‘dek/</code>, short for ‘double end queue’.</p>
<p>继承自 Queue 接口；与 Queue 不同的是，Deque 可在<strong>头部或尾部同时</strong>添加或删除元素，即允许在队列两边入队（offer）及出队（poll）。</p>
<ul>
<li>实现类是 FIFO 队列时，元素被插在 Deque 尾部，头部元素先被删除</li>
<li>不支持在队列中间添加元素</li>
<li>实现类既可以是栈，也可以是队列</li>
<li>与 List 接口不同，Deque 不提供对元素的索引访问</li>
</ul>
<p>实现类主要有两个，它们都同时暴露 Deque 的 FIFO 和 LIFO 方法。</p>
<ul>
<li><a href="/2021/06/12/linkedlist"><code>LinkedList</code></a></li>
<li><code>ArrayDeque</code>：用循环数组实现的双端序列</li>
</ul>
<p>实现：Deque 队列与 Deque 栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; elements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加至队尾</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        elements.addLast(e);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头元素先出队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeFirst();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; elements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加至头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        elements.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头部元素先出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeFirst();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue&lt;Integer&gt; myQueue = <span class="keyword">new</span> MyQueue&lt;&gt;();</span><br><span class="line">        myQueue.enqueue(<span class="number">1</span>);</span><br><span class="line">        myQueue.enqueue(<span class="number">2</span>);</span><br><span class="line">        myQueue.enqueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Integer e;</span><br><span class="line">        <span class="keyword">while</span>((e = myQueue.dequeue()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output 1 2 3</span></span><br><span class="line"></span><br><span class="line">        MyStack&lt;Integer&gt; myStack = <span class="keyword">new</span> MyStack&lt;&gt;();</span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        myStack.push(<span class="number">2</span>);</span><br><span class="line">        myStack.push(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span>((e = myStack.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output 3 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要实现一个纯粹的队列或栈，还需亲自动手封装。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>Queue 接口中声明的方法在 Deque 作为队列时相应的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Queue</th>
<th>Deque</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(e)</td>
<td>addLast(e)</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody>
</table>
</div>
<p>Deque 的实现类也可作为 LIFO 的栈使用，即元素被插在 Deque 头部，头部元素最先被删除：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Stack</th>
<th>Deque</th>
</tr>
</thead>
<tbody>
<tr>
<td>push(e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody>
</table>
</div>
<p>无论 Deque 作为队列还是栈使用，peek() 都返回头部元素。</p>
<p>虽然 Deque 允许插入 null 元素，但其实现类不应该允许，因为有时 null 是某些方法的<strong>特殊返回值</strong>。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合类</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的函数式编程</title>
    <url>/2022/02/07/fp/</url>
    <content><![CDATA[<p>函数式编程（<strong>F</strong>unctional <strong>P</strong>rogramming）是自 JDK 1.8 以来引入的一个非常重要的特性，也是 Java 编程未来的发展方向。</p>
<span id="more"></span>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>作为一种<strong>编程范式</strong>来说，函数式编程面世的时间已经很早了，而且其对使用者的建模和抽象的要求是特别高的。<br>换句话来说，函数式编程具有自己的一套世界观和哲学观：</p>
<p>函数式编程以<strong>函数</strong>作为第一对象（函数作为一个变量，从而可以作为参数或返回值），注重<strong>描述</strong>（描述性的高级语言）而非具体的执行步骤，更关心代数结构之间的关系。</p>
<p>市面上常见的函数式编程语言有 JavaScript, Scala, Erlang, LISP, Clojure, Haskell 等。</p>
<h1 id="函数式编程的编程特性"><a href="#函数式编程的编程特性" class="headerlink" title="函数式编程的编程特性"></a>函数式编程的编程特性</h1><p><strong>不可变</strong><br>将对象的变化拆解开，无需考虑并发问题，大大减少发生 bug 的可能性。</p>
<p><strong>惰性求值</strong><br>需要结果的时候才进行求值。</p>
<p><strong>闭包</strong><br>FP 必须有的特性。</p>
<p><strong>高阶函数</strong><br>函数在经过一系列的转换之后生成新的函数，新函数的<strong>阶</strong>比原函数的更高。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码：</span></span><br><span class="line">Function&lt;?&gt; callTwice(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>柯里化（Currying）</strong><br>由数学家 Haskell Curry 提出，指的是将一个多参数函数转化为单参数函数的方法，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">plus(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">plus(<span class="number">1</span>)(<span class="number">2</span>)  <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>
<p><strong>部分应用</strong><br>Partial Application，将多个参数的函数进行拆分，拆成多个只有一个参数或部分参数的函数，与柯里化较为相似。</p>
<p><strong>结合律</strong><br>指函数功能的组合。</p>
<p>千万不要认为函数式编程（FP）和 OOP 是两个水火不相容的东西，因为现在的发展趋势是混合式的范式编程，即：你中有我，我中有你。</p>
<p>然而要注意的一点是：以上提到的特性中的大部分，包括柯里化、部分应用等，在 JDK 1.8 都是用不了的，这也是 JVM 为了向前兼容的结果。<br>所以 JDK 1.8 所提供的所谓的“函数式”距离真正的函数式还很远，能应用到的只是<strong>阉割版</strong>的函数式编程。</p>
<h1 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h1><p>在 Java 8 之前的版本中，我们有很多适用函数式编程的场景：</p>
<ul>
<li>创建一个新的线程（Runnable）</li>
<li>UI 编程</li>
<li>异步回调</li>
<li>策略模式，如 Comparator</li>
<li>……</li>
</ul>
<p>只是基于当时版本的语言特性，需要用比较“蛋疼”的<strong>匿名内部类</strong>来实现。</p>
<p>JDK 1.8 引入函数式编程之后，我们可以使用其支持的 <strong>Lambda 表达式</strong>来简化以上场景的实现。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>一个 Lambda 表达式要表达的是一个方法（函数），经 Lambda 表达式转换过后的方法能够作为一个变量去被引用。</p>
<p>相比于普通方法，Lambda 表达式在保留<strong>方法签名</strong>（<strong>入参</strong>）、<strong>返回值</strong>和<strong>函数体</strong>这几个函数必需的部分之后，使用运算符 <strong><code>-&gt;</code></strong> 将方法签名和函数体连接起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设我们有这个方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">(T param1, R param2)</span> </span>&#123;</span><br><span class="line">    ...  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为用 Lambda 表达式表示：</span></span><br><span class="line">XXFunction fn = (T param1, R param2) -&gt; &#123;</span><br><span class="line">    ...  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三要素：参数、函数体和箭头（-&gt;）</span></span><br></pre></td></tr></table></figure>
<p>以上：Lambda 表达式是一个表达式，它是没有名字的；我们定义了一个 Function 变量 <code>fn</code> 保存了这个 Lambda 表达式的引用。</p>
<p>Lambda 表达式包含了很多语法糖。除了忽略访问权限和返回类型之外，还包括：</p>
<ul>
<li>编译器可对参数类型进行推导</li>
<li>单行函数体可省略大括号</li>
<li>单入参可省略小括号</li>
</ul>
<p>给大家看一个普通的 Java 方法 Lambda 转化前后的过程：</p>
<h3 id="转写-Lambda-表达式步骤"><a href="#转写-Lambda-表达式步骤" class="headerlink" title="转写 Lambda 表达式步骤"></a>转写 Lambda 表达式步骤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XXFunction aBlockOfCode = <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<code>public</code> 是多余的，可以省略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XXFunction aBlockOfCode = <span class="function"><span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的名字也是多余的，因为 Lambda 表达式没有名字，且方法引用已经赋值给了 aBlockOfCode：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XXFunction aBlockOfCode = <span class="keyword">void</span> (String s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，编译器可以自行判断函数返回类型和入参的参数类型，因此这俩可以省略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XXFunction aBlockOfCode = (s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再使用运算符 <strong><code>-&gt;</code></strong> 将方法签名和函数体连接起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XXFunction aBlockOfCode = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单行函数体可省略大括号，单入参可省略小括号，最终可得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XXFunction aBlockOfCode = s -&gt; System.out.println(s);  <span class="comment">// ELEGANT!</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：没有入参的话，需要一个空括号 <code>()</code> 代替方法签名。</p>
<h3 id="表示高阶函数"><a href="#表示高阶函数" class="headerlink" title="表示高阶函数"></a>表示高阶函数</h3><p>明白了 Java 的 Lambda 表达式连接规则之后，我们就能很容易写出来属于 Java Lambda 的高阶函数了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a -&gt; b -&gt; c -&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是：</span></span><br><span class="line">(a) -&gt; &#123;(b) -&gt; &#123;(c) -&gt; d;&#125;&#125;</span><br><span class="line"><span class="comment">// 即：</span></span><br><span class="line">methodA(a) &#123;</span><br><span class="line">    methodB(b) &#123;</span><br><span class="line">        methodC(c) &#123;</span><br><span class="line">            d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从纯函数式层面，我们可以理解为 (a, b, c) -&gt; d</span></span><br><span class="line"><span class="comment">// 但是 Java 不具备柯里化，所以还只能按照 a -&gt; b -&gt; c -&gt; d 理解</span></span><br></pre></td></tr></table></figure>
<p>从柯里化的角度来说，等于：</p>
<ul>
<li>fn = a -&gt; b -&gt; c -&gt; d</li>
<li>fn1 = fn(a)</li>
<li>fn2 = fn1(b)</li>
<li>fn3 = fn2(c) = d</li>
</ul>
<p>说完这么多，有人就问了，Lambda 既然能够表示一个函数，那它在 Java 语言里面的类型是什么？</p>
<p>回到上面我们提到的 Java 函数式编程适用场景。<br>Java 为了能够向前兼容，使用了接口（Interface）作为 Lambda 的类型；因为 Lambda 表达式表示的是函数，那么这种表示函数的接口，我们称之为“<strong>函数式接口</strong>”。</p>
<h2 id="函数式接口-SAM"><a href="#函数式接口-SAM" class="headerlink" title="函数式接口 SAM"></a>函数式接口 SAM</h2><p>能够描述某个函数的接口，其接口里面相对应的方法签名应该<strong>只有一个</strong>。<br>因此函数式接口中的 Single Abstract Method，由名字我们可以看出：给一个函数定义一个接口，接口内只能有<strong>单个非默认/静态实现方法</strong>。</p>
<p>所有 Lambda 类型都是一个接口，Lambda 表达式本身是这个接口的实现。<br>所以，即使 Lambda 表达式没有名字，但是一对应上 SAM，大家都会懂它描述的是哪个方法。</p>
<p>在接口定义中可使用 <code>@FunctionalInterface</code> 注解进行修饰，但不是必须的。</p>
<p>反过来：如果某个接口类只有一个非默认/静态方法，我们可以认为它是一个函数式接口，Lambda 表达式可以赋值给该接口类的实现中。</p>
<p>书接上回的 Lambda 表达式。定义好接口之后，可以得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  <span class="comment">// 如果加上了注释，编译器会进行校验</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyLambdaInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span></span>;  <span class="comment">// 只能有单个非默认/静态实现方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MyLambdaInterface aBlockOfCode = s -&gt; System.out.println(s);  <span class="comment">// aBlockOfCode 的类型为 MyLambdaInterface</span></span><br></pre></td></tr></table></figure>
<p>在不同版本的 Java 中，对接口的实现和使用是不一样的。</p>
<p>我们先有这么一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enact</span><span class="params">(MyLambdaInterface myLambda, String s)</span> </span>&#123;</span><br><span class="line">    myLambda.doSomeShit(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 7 及更早版本，我们先要有一个 MyLambdaInterface 的实现类，再将实现类传入 enact() 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLambdaInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyLambdaInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">MyLambdaInterface interfaceImpl = <span class="keyword">new</span> MyLambdaInterfaceImpl();</span><br><span class="line">enact(interfaceImpl, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从 Java 8 开始，定义好了函数式接口之后，可以直接将 Lambda 表达式传入 enact()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">enact(s -&gt; System.out.println(s), <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用比旧版本的方便得多了。</p>
<p>以下为 JDK 8 常用的内置函数式接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Function&lt;T,R&gt;</code></td>
<td>T</td>
<td>R</td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td><code>void</code></td>
<td>T</td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td>T</td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>Runnable</code></td>
<td><code>void</code></td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td>T</td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
</div>
<p>两个 input 用 <code>BiFunction</code>，三个 input 的没有，要自定义。</p>
<p>上述的 a -&gt; b -&gt; c -&gt; d 可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;?,Consumer&lt;?&gt;&gt; fn = a -&gt; &#123;b -&gt; c -&gt; d&#125;;</span><br><span class="line">Function&lt;?,Consumer&lt;?&gt;&gt; fn1 = b -&gt; &#123;c -&gt; d&#125;;</span><br><span class="line">Function&lt;?,?&gt; fn2 = c -&gt; &#123;d&#125;;</span><br></pre></td></tr></table></figure>
<p>区分了这么多类型的接口，是因为 Java 属于强类型的编程语言，需要对输入产出进行明确的类型划分。<br>在此背景下，任意两个接口之间因为互相没有实现或扩展关系，所以互相不能强制转换；比如：<code>Predicate&lt;?&gt;</code> 不能赋值给 <code>Function&lt;?,Boolean&gt;</code>。<br>虽然看上去像多态，但是不要将多态往函数式编程上靠。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>函数式接口不仅可以直接使用 Lambda 表达式赋值；对于已有的方法（函数）来说，要想在函数式编程中更优雅地使用，还可以通过<strong>方法引用</strong>去使用它们。</p>
<p>所谓“更优雅地使用”，指的是虽然我们可以通过给现有方法包装一层 Lambda 表达式去赋值给函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = () -&gt; Integer.parseInt(<span class="string">&quot;9527&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是从 Java 8 开始，可以使用方法引用去引用一个已经定义好的 Java 方法。</p>
<p>方法引用使用 <code>::</code> 操作符来确定需要引用的方法的<strong>唯一名称</strong>：</p>
<p><strong>1</strong>. 静态方法：类名<code>::</code>静态方法名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer::parseInt;  <span class="comment">// 告知属于哪个类</span></span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 构造函数引用：类名<code>::new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person::<span class="keyword">new</span>;  <span class="comment">// 告知属于哪个类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数的引用类型是 Supplier&lt;Clazz&gt;</span></span><br><span class="line"><span class="comment">// 有参构造函数的引用类型是 Function&lt;T,Clazz&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3</strong>. 指定实例的方法引用：实例对象<code>::</code>实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str::subString;  <span class="comment">// 告知属于哪个实例</span></span><br></pre></td></tr></table></figure>
<p><strong>4</strong>. <strong>指定类型</strong>中任意一个实例方法的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设有类 T：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    method1(arg2..argN);  <span class="comment">// 参数个数为 N - 1</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现有以下函数式接口：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fn</span> </span>&#123;</span><br><span class="line">    apply(T arg1, arg2..argN)  <span class="comment">// 参数个数为 N</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那当某个方法对接口进行方法引用的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">otherMethod(Fn fn);</span><br></pre></td></tr></table></figure>
<p>我们可以引用指定 T 的一个形参数量比 SAM 少一个的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">otherMethod(T::method1);  <span class="comment">// 以此完成对指定类型中任意一个实例方法的引用</span></span><br></pre></td></tr></table></figure>
<p>如此，当调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fn.apply(TInstance arg1, arg2..argN);</span><br></pre></td></tr></table></figure>
<p>的时候，<code>arg2..argN</code> 等参数会传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TInstance.method1(arg2..argN)</span><br></pre></td></tr></table></figure>
<p>里面；<code>method1()</code> 会被调用，同时 <code>arg1</code> 会被作为调用 <code>method1()</code> 方法的实例。可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fn(arg1, arg2..argN) == arg1.method1(arg2..argN)</span><br></pre></td></tr></table></figure>
<h3 id="函数式接口转换"><a href="#函数式接口转换" class="headerlink" title="函数式接口转换"></a>函数式接口转换</h3><p>由于 Java 是强类型语言，Java 8 的函数式接口有的时候比较难用；然而在某些我们并不要求函数签名完全一致的场合中（也是其他函数式编程语言的特性），希望可以就不同的函数式接口进行转换。<br>比如说：</p>
<ul>
<li>某个方法引用要求传入 <code>Function</code>，但实际应用的时候不关心输入，希望传入 <code>Supplier</code>；</li>
<li>某个方法引用要求传入 <code>Consumer</code>，但目前手头上的是 <code>Function</code>；</li>
<li>某个方法引用仅要求 <code>Runnable</code>，但目前手头上的是 <code>Supplier</code></li>
</ul>
<p>以上的情况，手头上有的都不能直接传入对方法的引用中，需要另外编写 util 方法去转换，或者：</p>
<p>就编程经验来说，我们可以采取一个特殊的 <strong>void-compatibility</strong> 规则：<br>如果 Lambda 是一个语句表达式，那么即使该 Lambda 表达式有返回值，也可以赋值给返回值签名为 void 的函数。</p>
<p>这样子的话，单句的 Lambda 表达式可以赋值给 <code>Consumer</code> 和 <code>Runnable</code>。</p>
<h1 id="进阶应用：Stream"><a href="#进阶应用：Stream" class="headerlink" title="进阶应用：Stream"></a>进阶应用：Stream</h1><p>不仅是在 Java 8，<code>Stream</code> 在整个函数式编程中都占有着举足轻重的地位。</p>
<p>首先，Stream 是一个<strong>哲学</strong>上的概念；相对于 List 来说，Stream：</p>
<ul>
<li>可以是无限的：《SICP》认为在函数式编程中，所有的东西都是不可变的；而在实际处理一些会变化的场景时，将场景看作是一个与时间有关的函数，函数本身（即场景变化的历史）不可变。</li>
<li>可以并行处理</li>
<li>可能延迟处理：在无限的流中执行操作，得到的中间结果不可能实时显示出来。</li>
</ul>
<p>相对于 List 的 foreach 将每个点分开来处理，Stream 引用一些函数将其自身<strong>变形</strong>至其他的 Stream 来做另外的处理，但是不需要拆分至每一个元素。</p>
<p>创建 Stream 的方法：</p>
<ul>
<li>静态数据构建有限流：<code>Stream.of(T)</code></li>
<li>容器：<code>[collection|map].stream()</code></li>
<li>动态生成有限/无限流：<code>Stream.iterate(T, UnaryOperator)</code> <code>Stream.generate(Supplier)</code></li>
<li>其他 API：<code>Files.lines()</code> …</li>
</ul>
<p>一个很有名的 Stream 响应式编程应用就是点击事件的处理，根据 Stream 中规定时间段内的点击次数来判断单击/双击事件。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>Java 8 中的 Stream 有很多 API，主要分两种类别：</p>
<p><strong>Intermediate</strong>：中间状态操作，应用在 Stream 的变化之中的 API；结果不能实时显示。</p>
<ul>
<li>filter</li>
<li>distinct</li>
<li>skip</li>
<li>limit</li>
<li>map / flatMap</li>
<li>sorted</li>
<li>peek</li>
<li>…</li>
</ul>
<p><strong>Terminal</strong>：这些 API 一旦被调用，Stream 就在操作调用前变为有限的流；随后 Stream 被终结，在往后的计算中不能再被使用。</p>
<ul>
<li>count / sum</li>
<li>collect / reduce</li>
<li>foreach</li>
<li>anyMatch / allMatch / noneMatch</li>
<li>…</li>
</ul>
<p><img src="/2022/02/07/fp/stream-execution.jpg" alt></p>
<p>其中被誉为函数式编程“三板斧”的三个高阶函数：</p>
<ul>
<li><code>filter(Predicate predicate)</code>：根据传入的条件过滤期望结果</li>
<li><code>map(Function mapper)</code>：根据传入的函数做映射</li>
<li><code>reduce(BinaryOperator acc)</code> / <code>reduce(T identity, BinaryOperator acc)</code> / <code>reduce(U Identity, BiFunction acc, BinaryOperator combiner)</code>：根据传入的函数将流折叠（计算 Stream 的值得到最终的累积结果）</li>
</ul>
<p>注：reduce() 与递归不同；递归是在循环里面调用自己，而 reduce() 没有调用传入的函数本身。</p>
<p><img src="/2022/02/07/fp/filter-map-reduce.jpg" alt></p>
<p>reduce() 做累加的例子：</p>
<p><img src="/2022/02/07/fp/reduce-accumulation.jpg" alt></p>
<p>用到了 <code>reduce(T identity, BinaryOperator acc)</code>，也是<strong>用得最多</strong>的 reduce() 函数。</p>
<p><em>Hadoop</em> 正是借鉴了函数式编程中 <code>map</code> 和 <code>reduce</code> 的概念，创建了属于自己的 MapReduce。</p>
<h2 id="reduce-可以用来实现什么"><a href="#reduce-可以用来实现什么" class="headerlink" title="reduce 可以用来实现什么"></a>reduce 可以用来实现什么</h2><p><strong>求和</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Collection&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(<span class="number">0</span>, (acc, curr) -&gt; acc + curr);</span><br><span class="line">    <span class="comment">// 或：return list.stream().reduce(0, Integer::sum);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>求最大值</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">max</span><span class="params">(Collection&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(Math::max).orElse(<span class="keyword">null</span>);  <span class="comment">// reduce(BinaryOperator acc) 要求累计值和当前值类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拼接字符串</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">join</span><span class="params">(Collection&lt;Integer&gt; list, String delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().map(String::valueOf)</span><br><span class="line">        .reduce((acc, curr) -&gt; String.join(delimiter, acc, curr)).orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>存放进 Collection</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">toList</span><span class="params">(Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> stream.reduce(ret,</span><br><span class="line">                         (acc, curr) -&gt; &#123;  <span class="comment">// BiFunction 规避了累计值和当前值类型必须相同的问题</span></span><br><span class="line">                             acc.add(curr);</span><br><span class="line">                             <span class="keyword">return</span> acc;  <span class="comment">// 讨巧的实现，每次都返回累加后的自己，不是一个新元素，严格来说这并不正确</span></span><br><span class="line">                         &#125;,</span><br><span class="line">                         (list1, list2) -&gt; &#123;  <span class="comment">// 并行执行 stream 的时候所要引用的表达式</span></span><br><span class="line">                             list1.addAll(list2);</span><br><span class="line">                             <span class="keyword">return</span> list1;</span><br><span class="line">                         &#125;);  <span class="comment">// 应该使用 collect 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常来说，应该用 collect()</span></span><br></pre></td></tr></table></figure>
<p><strong>实现 map</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T,R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T,R&gt; mapFn)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(ret,</span><br><span class="line">                                (acc, curr) -&gt; &#123;</span><br><span class="line">                                    acc.add(mapFn.apply(curr));  <span class="comment">// 转换</span></span><br><span class="line">                                    <span class="keyword">return</span> acc;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                (list1, list2) -&gt; &#123;</span><br><span class="line">                                    list1.addAll(list2);</span><br><span class="line">                                    <span class="keyword">return</span> list1;</span><br><span class="line">                                &#125;);</span><br><span class="line">    <span class="comment">// for 循环也能实现，但是 for 属于有限数量的遍历，不能应用到无限的 stream 中去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现 filter</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(ret,</span><br><span class="line">                                (acc, curr) -&gt; &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (p.test(curr)) &#123;</span><br><span class="line">                                        acc.add(curr);  <span class="comment">// 过滤</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">return</span> acc;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                (list1, list2) -&gt; &#123;</span><br><span class="line">                                    list1.addAll(list2);</span><br><span class="line">                                    <span class="keyword">return</span> list1;</span><br><span class="line">                                &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Transducer</strong>：多个 reduce 自由组合的一种模式，从而自定义 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取上面例子的 BiFunction 做结合：</span></span><br><span class="line">.reduce(</span><br><span class="line">    (acc, curr) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.test(curr)) &#123;  <span class="comment">// 最外层的 reduceFunction</span></span><br><span class="line">            R newValue = mapFn.apply(curr);  <span class="comment">// 里一层的 reduceFunction</span></span><br><span class="line">            acc.add(newValue);  <span class="comment">// 最里层的 reduceFunction</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 这样的组合为一个 transducer</span></span><br></pre></td></tr></table></figure>
<p>每一个 reduceFunction 由 <code>Function</code> 和 <code>BiFunction</code> 组成，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (acc,curr) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> biFunction.apply(acc, function.apply(curr));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后通过函数组合 <code>f1.compose(f2)</code> 或 <code>f2.andThen(f1)</code>（这个语义上更直观）完成组合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1 * f2 == f3(x), 相当于 f1(f2(x)).</span><br></pre></td></tr></table></figure>
<p>组合过程中没有对任意一个函数做过任何一次调用。</p>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect()"></a><strong>collect()</strong></h2><p><code>Stream.collect()</code> 跟 reduce() 是兄弟函数，是增强版的 reduce()，所使用的频率高于 reduce()。</p>
<p>函数签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner);  <span class="comment">// supplier 是承载状态改变的容器</span></span><br><span class="line">collect(Collector collector);  <span class="comment">// Collector 类封装了 .collect() 所需要的全部要素</span></span><br></pre></td></tr></table></figure>
<p>区别在于：</p>
<p>对于传入的 accumulator 函数 <code>(acc, curr)</code>，collect 会将 acc 变成一个<strong>有状态</strong>的量，每次 accumulate 的时候可以直接获取 acc 当前状态；而 reduce 设计上的本意是<strong>不让修改</strong> acc 的。</p>
<p>也就是说，collect 操作的 acc 是可变数据，语义示意如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R container = supplier.get();</span><br><span class="line"><span class="keyword">for</span> (T data : datas) &#123;</span><br><span class="line">    accumulator.accept(container, data);  <span class="comment">// 没有返回值，每一次循环更新累计值 container 的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> container;  <span class="comment">// 返回内部更改过状态的累计值</span></span><br></pre></td></tr></table></figure>
<p>而 reduce（<code>reduce(initValue, (acc, curr))</code>）操作的是不可变数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R ret = initValue;</span><br><span class="line"><span class="keyword">for</span> (T data : datas) &#123;</span><br><span class="line">    ret = accumulator.apply(ret, data);  <span class="comment">// 每一次根据累计值和当前元素返回一个新的累计值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>再多说一嘴 <code>Collector</code> 接口：</p>
<p>鉴于每一次传递参数的时候，对应特定的 collect() 结果，都会传递对应的一套 supplier, accumulator 和 combiner 的组合；所以 JDK 的开发者们干脆就设计了 Collector 的接口，将一系列的函数放在了一起。</p>
<p>因此 Collector 各个参数就很明显了：</p>
<ul>
<li><code>Supplier</code>：累计数据构造函数</li>
<li><code>Accumulator</code>：累计函数，同 reduce() 参数</li>
<li><code>Combiner</code>：合并函数，在并行场合下做处理使用，同 reduce() 参数</li>
<li><code>Finisher</code>：对累计数据做最终转换</li>
<li>*<code>Characteristics</code>：特征（并发 CONCURRENT / 无序 UNORDERED / 无 Finisher IDENTITY_FINISH）</li>
</ul>
<p><small>注：IDENTITY 函数在函数式编程的意思是：输入一个值，将其自身输出。</small></p>
<p>比如 <code>Collectors.toList()</code> 的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>,  <span class="comment">// supplier</span></span><br><span class="line">                                List::add,  <span class="comment">// accumulator</span></span><br><span class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,  <span class="comment">// combiner</span></span><br><span class="line">                                CH_ID);  <span class="comment">// characteristics</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Combiner 需满足同一律：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Combiner.apply(acc, []) == acc;</span><br></pre></td></tr></table></figure>
<p>Finisher 需满足结合律：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">acc.accept(t1);</span><br><span class="line">acc.accept(t2);</span><br><span class="line">finisher.apply(acc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line">acc1.accept(t1);</span><br><span class="line">acc2.accept(t2);</span><br><span class="line">finisher.apply(combiner.apply(t1, t2));</span><br></pre></td></tr></table></figure>
<p>以上所有的条件，都是基于 Stream 能并发处理数据的特性，需要确保数据的一致性。</p>
<h2 id="Collectors-工具类"><a href="#Collectors-工具类" class="headerlink" title="Collectors 工具类"></a>Collectors 工具类</h2><p>JDK 的静态工具类 <code>Collectors</code> 已经给我们提供了很多即用的 API 了，包括：</p>
<ul>
<li>流转容器：toList() / to(Concurrent)Map() / toSet() / toCollection()</li>
<li>counting() / averagingXX() / joining() / summingXX()</li>
<li>分组：groupingBy() / partitioningBy()</li>
<li>mapping() / reducing()</li>
<li>…</li>
</ul>
<p>下面挑一两个来简单说一下。</p>
<p><br></p>
<h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title=".groupingBy()"></a><strong>.groupingBy()</strong></h3><p>函数签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 classifier 单纯将 stream 数据分到对应的 key 上，再存放成 Map&lt;key, List&gt;，默认使用 HashMap</span></span><br><span class="line">Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt; groupingBy(Function classfier);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分到 key 上之后，对每个 key 的元素进行后续的 collect() 操作</span></span><br><span class="line">Collector&lt;T,?,Map&lt;K,D&gt;&gt; groupingBy(Function classfier, Collector downstream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，允许自定义 Map 创建</span></span><br><span class="line">Collector&lt;T,?,M&gt; groupingBy(Function classfier, Supplier mapFactory, Collector downstream);  </span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/07/fp/groupingby.jpg" alt></p>
<p>第一个函数签名是直接将分到不同的 key 上的数据流用 <strong>List</strong> 汇总并返回；<br>剩余的函数签名，使用的是<strong>传入的 Collector</strong> 对不同的 key 上分到的数据流进行处理（数据分类完之后再做事情）。<br>理论上来说，Collectors 工具类<strong>所有的 API</strong> 都可以作为传入的 Collector。</p>
<p>所以 <code>.groupingBy()</code> 能够很简单地解决多级分层的问题。</p>
<p><br></p>
<h1 id="进阶应用：Optional"><a href="#进阶应用：Optional" class="headerlink" title="进阶应用：Optional"></a>进阶应用：Optional</h1><p>Optional 在 JDK 8 中和 Stream 具有同等重要的地位，它最大的意义在于能够简化 null check，免除了编程时 NullPointerException 带来的痛苦：</p>
<p>我们可以用一个类似于“薛定谔的猫”的容器图来描述 Optional 的功能：</p>
<p><img src="/2022/02/07/fp/optional-schrdinger.jpg" alt></p>
<p>Optional 本身不会为 null。</p>
<p>Optional 的一些 API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ofNullable(T t);  <span class="comment">// 允许传入值为空</span></span><br><span class="line">of(T t);  <span class="comment">// 空值会报错</span></span><br><span class="line">orElse(T t);  <span class="comment">// return x != null ? x : t</span></span><br><span class="line">orElseGet(Function fn);  <span class="comment">// return x != null ? x : fn()</span></span><br><span class="line">ifPresent(Function fn);  <span class="comment">// if x != null execute fn()</span></span><br></pre></td></tr></table></figure>
<p>举个例子，假设有下面的 <code>Person</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = getSomeOne();</span><br></pre></td></tr></table></figure>
<p>在 Java 7 及之前的版本中，如果要对 person 对象进行空值判断，我们需要一个甚至多个 <code>if-else</code> 代码块。</p>
<p>从 Java 8 开始，只需要声明一个 <code>Optional</code> 对象，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Person&gt; personOpt = Optional.ofNullable(person);  <span class="comment">// “薛定谔的箱子”</span></span><br></pre></td></tr></table></figure>
<p>存在就开干</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line">If (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">personOpt.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>存在即返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="keyword">return</span> person == <span class="keyword">null</span> ? UNKNOWN_PERSON : person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> personOpt.orElse(UNKNOWN_PERSON);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="keyword">return</span> person == <span class="keyword">null</span> ? getPersonFromDb() : person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> personOpt.orElseGet(() -&gt; getPersonFromDb());</span><br></pre></td></tr></table></figure>
<p>其实以上代码只是 Optional 边边角角的应用。<br>Optional 对于空值的判断的判断其实还不如 if-else。Optional 自身最大的意义并不仅仅在于做非空判断，而是在于它在做完非空判断之后，还能接着<strong>执行</strong>其他的诸如 <code>.filter()</code> <code>.map()</code> <code>.flatMap()</code> 等<strong>方法且不会出错</strong>。</p>
<p>上面提到的三个方法，是 Optional 的价值所在，是 Optional 相对于 if-else 代码块的优势，否则要只是做非空判断的话，还真的不如直接写 if-else。</p>
<p>先说 Optional 最重要的 <code>.map()</code>：</p>
<p><br></p>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a><strong>map()</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>map() 的返回值是 Optional 类型。</p>
<p>再来一个容器图：</p>
<p><img src="/2022/02/07/fp/optional-map.jpg" alt></p>
<p>可知如果存在值 x，随后可以通过 <code>.map(fn)</code> 计算 <code>fn(x)</code> 的值；倘若值为 null，fn 不会被调用，即使调用了 <code>.map(fn)</code>，方法也不会抛出 NullPointerException，且可以<strong>接着往下级联处理</strong>，完全不用担心，也不用理会这条处理链当中的任何一个节点会出错（抛 NullPointerException 异常）。</p>
<p>如果接着 fn(x) 之后再有 <code>.map(gn)</code> 的话，那处理链下一个节点里面就是 <code>gn(fn(x))</code>，不难看出 Optional 的处理链就是<strong>函数组合</strong>。</p>
<p>应用于多层嵌套 null 检查非常管用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String name = person.getLastName();</span><br><span class="line">    <span class="keyword">return</span> name == <span class="keyword">null</span> ? <span class="keyword">null</span> : name.toUpperCase();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> personOpt.map(p -&gt; p.getLastName())</span><br><span class="line">                .map(name -&gt; name.toUpperCase())</span><br><span class="line">                .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>如上，在抛弃一大堆嵌套的 if-else 代码块之后，处理链代码会变得非常简单明了，维护性也会大大提高。</p>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a><strong>flatMap()</strong></h2><p>如果 <code>fn(x)</code> 的结果是一个 Optional，应该怎么处理？</p>
<p><img src="/2022/02/07/fp/optional-flatmap1.jpg" alt></p>
<p>这个时候可以使用另一个方法 <code>flatMap()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flatMap(Function&lt;? <span class="keyword">super</span> T,Optional&lt;U&gt;&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>根据函数式编程的语义，flatMap() 接收返回值为 Optional 的函数，将传入的 Optional 对象“外包装去掉”取出值 value，再将 value join 进 map() 生成的 Optional 中：</p>
<p><img src="/2022/02/07/fp/optional-flatmap2.jpg" alt></p>
<p>Optional 中的 map() 和 flatMap()，和 Stream 中的 map() 和 flatMap() 语义差不多，都是属于函数式编程里面<strong>范畴</strong>的概念。<br>在这个概念里面，Optional 和 Stream 被称为 <strong>Functor</strong> <strong>函子</strong> / <strong>Monad</strong> <strong>单子</strong>，它们的 map() 以及 flatMap() 这些函数能够建立它们函子所在世界里面的映射关系。</p>
<p><br></p>
<p>Optional 不太好的地方在于它与 Stream 的结合不太好，<code>ofNullable()</code> 的形参是单个元素，倘若有集合（如 List）需要处理的话，最好还是使用 Stream 的 .filter()，跟 Optional 的关系就不大了。</p>
<h2 id="Functor-amp-Monad"><a href="#Functor-amp-Monad" class="headerlink" title="Functor &amp; Monad"></a>Functor &amp; Monad</h2><p>实现了 map() 在内部世界映射的称之为 Functor；实现了 flatMap() 通过跨范畴映射并 join 到对应容器的称之为 Monad。</p>
<p>除了 Optional 和 Stream 之外，函数式编程还有非常多类似的概念：</p>
<p><img src="/2022/02/07/fp/functor-monad.jpg" alt></p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h2><p>Future 的增强版，部分实现了函数式编程中 Promise 的功能。</p>
<p>有这么一个例子：</p>
<p><img src="/2022/02/07/fp/completablefunction-example.jpg" alt></p>
<p>service4 依赖于 service2 和 service3 的结果，service2 依赖于 service1 的结果，service1 和 service3 之间无关联。</p>
<p>倘若使用 Future 实现，那么上面的一段话我们还要想一遍，用代码步骤去阐述依赖关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;String&gt; task1 = pool.submit(FutureExample::service1);</span><br><span class="line">Future&lt;String&gt; task3 = pool.submit(FutureExample::service3);</span><br><span class="line"></span><br><span class="line">String ret1 = task1.get();</span><br><span class="line">Future&lt;String&gt; task2 = pool.submit(() -&gt; service2(ret1));</span><br><span class="line"></span><br><span class="line">String ret2 = task2.get();</span><br><span class="line">String ret3 = task3.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> service4(ret2, ret3);</span><br></pre></td></tr></table></figure>
<p>这种服务依赖关系一旦有所改变，修改代码的时候还要将这一大段逻辑从头到尾去看一遍；而且随着系统复杂度日渐提高，这段代码的维护成本会上涨得更快。</p>
<p>用 CompletableFuture 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(FutureExample::service1, pool).thenApply(FutureExample::service2);</span><br><span class="line">CompletableFuture&lt;String&gt; cf3 = CompletableFuture.supplyAsync(FutureExample::service3, pool);  <span class="comment">// Executor 专用方法签名</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf4 = cf2.thenCombine(cf3, FutureExample::service4);</span><br><span class="line"><span class="keyword">return</span> cf4.join();</span><br></pre></td></tr></table></figure>
<p>描述性的语言让代码变得简洁、可维护。</p>
<p>CompletableFuture API 里面的关键字：</p>
<ul>
<li><code>accept-</code>：接收参数为 Consumer</li>
<li><code>apply-</code>：接收参数为 Function</li>
<li><code>handle-</code>：接收参数为 BiFunction</li>
<li><code>runAfter-</code>：接收参数为 Runnable</li>
<li><code>-Either/Both-</code>：等待任意任务完成还是全部完成</li>
<li><code>-then-</code>：等待当前任务完成再执行另外一个</li>
<li><code>-Async-</code>：后续任务是否异步执行</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的异常处理</title>
    <url>/2021/07/17/java-exceptions/</url>
    <content><![CDATA[<p>异常是导致程序中断运行的一种指令流，如果不对异常进行正确处理，则可能导致程序的中断运行，造成不必要的损失。</p>
<span id="more"></span>
<p>当程序的运行出现逻辑错误，或出现无效的情况时，即为发生了异常。</p>
<ul>
<li>Java 定义的异常全部基于 <code>Throwable</code>，基本继承于 Throwable 的两个子类 <code>Error</code> 和 <code>Exception</code></li>
<li>其中 Error 仅发生在 JVM 级别的错误时才会抛出，一般程序不会处理。</li>
</ul>
<p>类图如下：</p>
<p><img src="/2021/07/17/java-exceptions/java-exceptions.png" alt></p>
<h1 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception"></a>Unchecked Exception</h1><p><strong>运行时异常</strong></p>
<ul>
<li>表示错误，即程序的问题或逻辑错误，运行的时候无法恢复，不需要抛出异常</li>
<li>包括 <code>Error</code>，<code>RuntimeException</code> 及其子类，如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutOfMemoryError</span><br><span class="line">IllegalArgumentException</span><br><span class="line">NullPointerException</span><br><span class="line">IllegalStatementException</span><br><span class="line">ClassCastException</span><br><span class="line">ClassNotFoundException</span><br><span class="line">IndexOutOfBoundException</span><br><span class="line">NoSuchMethodException</span><br><span class="line">ArithmeticException</span><br></pre></td></tr></table></figure></li>
<li>Error：系统级的错误和程序不必处理的异常</li>
</ul>
<h1 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception"></a>Checked Exception</h1><p>受检查异常（<strong>非运行时异常</strong>）</p>
<ul>
<li>表示无效操作，即不是程序可以预测的异常，比如无效的用户输入、文件不存在等<ul>
<li>必须显式地捕获处理（try / catch）或向外抛出（throws）</li>
</ul>
</li>
<li>上图红色类即为非运行时异常</li>
<li>包括 Exception 除 RuntimeException 之外的所有子类，如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileNotFoundException</span><br><span class="line">SocketException</span><br><span class="line">SQLException</span><br><span class="line">IOException</span><br></pre></td></tr></table></figure></li>
<li>extends Exception</li>
</ul>
<h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><p>通常我们要处理 Checked Exception，可以使用 <code>throws</code> 关键字或 <code>try-catch</code> 块进行处理。</p>
<p><big><code>throws</code></big></p>
<ul>
<li>如果要监控整个方法中的某一类异常，且将其往外抛出，可使用 <code>throws</code> 关键字</li>
<li>当方法 return 前，任何一句代码发生对应异常，或使用 <code>throw</code> 关键字手动抛出的时候，异常都会向外抛出，交由外层调用方法进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == b) &#123;</span><br><span class="line">        <span class="comment">// 抛给 method 的调用者</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;divided by 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    c = a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = divide(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="comment">// 如果不作处理，异常会层层外抛，最终交由 JVM 处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>throw</code> 和 <code>throws</code> 比较</p>
<ul>
<li>throws 出现在方法函数头，throw 出现在函数体；</li>
<li>throws 表示出现异常的一种可能性，声明可能会抛出一个异常，并不一定发生该种异常；</li>
<li>throw 则是真实抛出了异常：执行 throw 则一定抛出了某种异常</li>
</ul>
<p><code>try-catch-finally</code></p>
<ul>
<li>如需要对某一块代码中的代码进行监控，且有意对异常在方法内进行处理：使用 try-catch 块</li>
<li>在 try-catch 块中仍可配合 throw/throws 将异常外抛</li>
</ul>
<p>基本格式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == b) &#123;</span><br><span class="line">        <span class="comment">// 抛给 method 的调用者</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;divided by 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    c = a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> result = divide(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error, cause: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>try - catch - finally</code> 语句块中：</p>
<ul>
<li>有 try 子句必有 catch 子句或者 finally 子句；</li>
<li>finally 子句中的内容一定会被执行，除非在 try 或者 catch 子句中含有 JVM 终止的语句（<code>System.exit(0);</code>）；</li>
<li>若 try 部分中有返回值（<code>return</code>），则将会先将该 return 语句挂起，先执行 finally 部分；<ul>
<li>finally 子句在 try 或 catch 子句中的 return 语句执行之后（如 return 紧接一个运算或方法调用），return 返回之前（方法出栈）；</li>
</ul>
</li>
<li>如果 finally 中没有 return，则：如在 finally 块中修改原来 try 要返回的变量值，则不会影响该变量值；</li>
<li>如果 finally 子句和 try 或 catch 语句中都有 return 语句，真正返回的是 finally 中的 return 语句。</li>
</ul>
<p>另：可自定义异常 —— 继承 <code>Exception</code> / <code>RuntimeException</code> 类</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程安全集合类</title>
    <url>/2021/10/02/java-concurrent-collections/</url>
    <content><![CDATA[<p>线程安全集合类是 Java 除了并发工具类和多线程执行器之外，另外一种成熟的并发编程解决方案。</p>
<span id="more"></span>
<p>在还没有推出线程安全集合的早期，开发任务使用 <code>Collections</code> 工具类中的<strong>同步包装器</strong>来实现线程安全的集合操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">Collection&lt;E&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List <span class="title">synchronizedList</span><span class="params">(List&lt;E&gt; l)</span>    <span class="comment">// 所有方法都带同步锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set <span class="title">synchronizedSet</span><span class="params">(Set&lt;E&gt; s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; SortedSet <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet&lt;E&gt; s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K, V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K, V&gt; SortedMap&lt;K, V&gt; <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap&lt;K, V&gt; s)</span></span></span><br></pre></td></tr></table></figure>
<p>Java 在后来的 JDK 中推出了两个线程安全的集合类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable</span><br><span class="line">Vector</span><br></pre></td></tr></table></figure></p>
<p>至今，在 JCF 中的同步接口包括：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingDeque</span><br><span class="line">BlockingQueue</span><br><span class="line">ConcurrentMap</span><br><span class="line">ConcurrentNavigableMap</span><br><span class="line">TransferQueue</span><br></pre></td></tr></table></figure></p>
<p>以上都是能够避免 <code>ConcurrentModificationException</code> 的类和方法。</p>
<p>我们先从阻塞队列开始说起。</p>
<p><br></p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列使用一个锁（入队和出队使用同一个锁）或两个锁（入队和出队分别使用不同的锁）实现数据的同步操作。</p>
<p>阻塞插入：当队列满的时候，队列会阻塞插入元素的线程，直到队列有空缺为止；<br>阻塞移除：当队列为空的时候，获取元素的线程会等待至队列非空为止。</p>
<p>生产者 / 消费者模型中用得比较多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法 / 特殊情况处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>超时退出</th>
<th>一直阻塞</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td><font color="red">o</font>ffer(e)</td>
<td><font color="red">o</font>ffer(e, time, unit)</td>
<td>pu<font color="blue">t</font>(e)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>p<font color="red">o</font>ll()</td>
<td>p<font color="red">o</font>ll(time, unit)</td>
<td><font color="blue">t</font>ake()</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>正常动作</th>
<th>特殊情况动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>添加元素（添加 null 值非法）</td>
<td>队列满时抛出 <code>IllegalStateException(&quot;Queue full&quot;)</code></td>
</tr>
<tr>
<td>offer</td>
<td>添加元素并返回 true</td>
<td>队列满时返回 false</td>
</tr>
<tr>
<td>put</td>
<td>添加元素</td>
<td>队列满时<strong>阻塞</strong></td>
</tr>
<tr>
<td>remove</td>
<td>移除并返回队列头元素</td>
<td>队列空时抛出 <code>NoSuchElementException</code></td>
</tr>
<tr>
<td>poll</td>
<td>移除并返回队列头元素</td>
<td>队列空时返回 null</td>
</tr>
<tr>
<td>take</td>
<td>移除并返回队列头元素</td>
<td>队列空时<strong>阻塞</strong></td>
</tr>
<tr>
<td>element</td>
<td>返回队列头元素</td>
<td>队列空时抛出 <code>NoSuchElementException</code></td>
</tr>
<tr>
<td>peek</td>
<td>返回队列头元素</td>
<td>队列空时返回 null</td>
</tr>
</tbody>
</table>
</div>
<p>注意：使用无界队列时，put() 永远不会阻塞，offer() 永远返回 true。</p>
<p><br></p>
<p>阻塞队列使用<strong>通知模式</strong>实现：</p>
<ol>
<li>生产者往满队列添加元素时，生产者会被阻塞；</li>
<li>消费者将满队列中的一个元素消费掉之后，通知生产者当前队列可用。</li>
</ol>
<p>在 JCF 中，阻塞队列对应着 <code>BlockingQueue</code>、<code>BlockingDeque</code> 和 <code>TransferQueue</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E element, <span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 添加给定元素，成功则返回 true，队列满时返回 false</span></span><br><span class="line">    <span class="comment">// 必要时阻塞，直至元素已经被添加，或添加操作超时</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E element)</span></span>;  <span class="comment">// 添加元素，在必要时阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span>  <span class="comment">// 移除并返回头元素，必要时阻塞</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 移除并返回队列头元素</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 必要时阻塞，直至元素可用，或移除操作超时</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 失败时返回 null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向阻塞队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="comment">// 添加元素，必要时阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E element, <span class="keyword">long</span> time, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E element, <span class="keyword">long</span> time, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="comment">// 添加给定元素，成功时返回 true，队列满时返回 false</span></span><br><span class="line">    <span class="comment">// 必要时阻塞，直至元素被添加，或添加操作超时</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">pollFirst</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="comment">// 移除并返回头元素或尾元素</span></span><br><span class="line">    <span class="comment">// 必要时阻塞，直至元素可用，或移除操作超时</span></span><br><span class="line">    <span class="comment">// 失败时返回 null</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">takeFirst</span><span class="params">()</span></span>;  <span class="comment">// 移除并返回头元素，必要时阻塞</span></span><br><span class="line">    <span class="function">E <span class="title">takeLast</span><span class="params">()</span></span>;  <span class="comment">// 移除并返回尾元素，必要时阻塞</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TransferQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传输一个值，或尝试在给定时间内传输这个值</span></span><br><span class="line"><span class="comment">     * 阻塞至另一线程将元素删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试在给定时间内传输这个值</span></span><br><span class="line"><span class="comment">     * 阻塞至另一线程将元素删除</span></span><br><span class="line"><span class="comment">     * 调用成功时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E element, <span class="keyword">long</span> time, TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><p><code>ArrayBlockingQueue</code>：由数组结构组成的<strong>有界</strong>阻塞队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    ArrayBlockingQueue&lt;E&gt;(<span class="keyword">int</span> capacity)  &#123;  <span class="comment">// 默认情况下不保证线程的公平（先阻塞的线程不一定先获得机会访问队列）</span></span><br><span class="line">        <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个带有指定的容量和公平性设置的阻塞队列</span></span><br><span class="line">    <span class="comment">// 使用循环数组实现</span></span><br><span class="line">    ArrayBlockingQueue&lt;E&gt;(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair) &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下以 ArrayBlockingQueue 为例，说明一下阻塞队列“通知模式”的实现：</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能通过此方法判断入队是否成功</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>LinkedBlockingQueue</code>：由链表结构组成的<strong>有界</strong>阻塞队列</p>
<p><code>LinkedBlockingDeque</code>：由链表结构组成的<strong>无界</strong>双向阻塞队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个无上限的阻塞队列或双向队列</span></span><br><span class="line"><span class="comment"> * 采用锁来保持同步</span></span><br><span class="line"><span class="comment"> * 链表实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LinkedBlockingQueue&lt;E&gt;()</span><br><span class="line">LinkedBlockingDeque&lt;E&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造有限的阻塞队列或双向队列</span></span><br><span class="line"><span class="comment"> * 链表实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LinkedBlockingQueue&lt;E&gt;(<span class="keyword">int</span> capacity)</span><br><span class="line">LinkedBlockingDeque&lt;E&gt;(<span class="keyword">int</span> capacity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时最好设定初始容量，防止过度膨胀</span></span><br></pre></td></tr></table></figure>
<p><code>PriorityBlockingQueue</code>：⽀持优先级排序的<strong>⽆界</strong>阻塞队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个无边界阻塞优先队列，同优先级的元素不能保证顺序</span></span><br><span class="line"><span class="comment"> * 使用堆（priority heap）实现</span></span><br><span class="line"><span class="comment"> * 默认采用自然顺序的升序排列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * initialCapacity 初始值为 11</span></span><br><span class="line"><span class="comment"> * comparator 为用来对元素进行比较的比较器，如未指定则元素应实现 Comparable 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PriorityBlockingQueue&lt;E&gt;()</span><br><span class="line">PriorityBlockingQueue&lt;E&gt;(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">PriorityBlockingQueue&lt;E&gt;(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br></pre></td></tr></table></figure>
<p><code>DelayQueue</code>：使⽤优先级队列实现的<strong>⽆界</strong>阻塞队列，支持延时获取元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DelayQueue&lt;E extends Delayed&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含 Delayed 元素的无界的、阻塞时间有限的阻塞队列</span></span><br><span class="line"><span class="comment"> * 使用堆（priority heap）实现</span></span><br><span class="line"><span class="comment"> * 基于时间调度的序列，只有延迟超过时间的元素才可从队列中移出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DelayQueue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> </span>&#123;&#125;  <span class="comment">// 队列元素必须实现 Delayed 接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到该对象的延迟</span></span><br><span class="line"><span class="comment">// 用给定时间单位度量</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<p>应用场景：</p>
<ul>
<li>缓存系统的设计：保存需要缓存的元素的有效期，使用线程循环地去查询队列；一旦获取到了元素，说明元素到期；</li>
<li>定时任务调度：保存需要执行的任务和执行时间点，一旦获取到了元素，说明当前时间点开始执行获取到的任务。</li>
</ul>
<p><code>LinkedTransferQueue</code>：由链表结构实现的 TransferQueue，<strong>⽆界</strong>阻塞队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedTransferQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有消费者在等待，返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xfer(e, <span class="keyword">true</span>, NOW, <span class="number">0</span>) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfer the element to a consumer, waiting if necessary to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll), ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果没有消费者在等待，则将元素存放在队列尾节点，直到元素被消费后才返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, SYNC, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SynchronousQueue</code>：<strong>不存储元素</strong>的阻塞队列，简单实现了阻塞机制</p>
<ul>
<li>每一个 <code>put()</code> 操作都要等一个 <code>take()</code> 操作，否则便不能继续添加元素；</li>
<li>生产者可通过其直接将资源传递给消费者，中间不做任何保存；</li>
<li>非常适合传递性的场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer transferer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>生产者线程向队列插入元素，消费者线程从队列取出元素</p>
<ul>
<li>worker（工作者）线程周期性地将中间结果存储到阻塞队列</li>
<li>其他 worker 线程移除中间结果作进一步修改</li>
<li>阻塞队列会自动做负载均衡<ul>
<li>搜索或移除元素时，会等待队列变为非空</li>
<li>添加元素时，会等待队列有可用空间</li>
</ul>
</li>
<li>会创建专门的线程去访问各对象，而不是各种有可能的工作线程</li>
</ul>
<p><br></p>
<h1 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h1><p>JDK <code>concurrent</code> 包下还有许多线程安全的集合类，使用起来跟普通的名字对应的集合类几乎没有区别。</p>
<p>它们的使用特点是：<code>size()</code> 不必在常量时间内操作</p>
<ul>
<li>确定集合的当前大小需要遍历</li>
<li>集合返回弱一致性（weak consistent）的迭代器，因此不一定反映出构造后所有的修改</li>
<li>不会抛出 ConcurrentModificationException</li>
</ul>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>跟阻塞队列不同的是，<code>ConcurrentLinkedQueue</code> 采用<strong>自旋 CAS</strong> 的方式实现线程安全操作。</p>
<p><img src="/2021/10/02/java-concurrent-collections/concurrentlinkedqueue-class-diagram.png" alt></p>
<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><p><img src="/2021/10/02/java-concurrent-collections/concurrentlinkedqueue-enqueue.png" alt></p>
<p>上图为新创建的队列每添加一个节点时所留的快照。</p>
<p>新入队的元素永远都是被添加到队列的尾部，成为队列的尾节点；需要注意的是，<strong>tail 节点不总是尾节点</strong>。</p>
<ul>
<li>如 tail 节点的 next 不为空，有新元素入队后，tail 节点会指向新元素（tail 成为尾节点）；</li>
<li>如 tail 节点的 next 为空，新元素入队后，tail 节点的 next 会指向新元素（tail 的 next 成为尾节点）；</li>
<li>因为队列刚刚创建的时候 head = tail，第一个元素添加进去后，head 和 tail 的 next 节点都会指向第一个元素。</li>
</ul>
<p>以上为单线程操作时的基本情况；如果是多线程操作的话，情况会更加复杂，因为会存在多个线程插队的情况。</p>
<h3 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h3><p><img src="/2021/10/02/java-concurrent-collections/concurrentlinkedqueue-dequeue.png" alt></p>
<p>上图为队列每移除一个元素时所留的快照。</p>
<p>与入队方法类似的是，并不是每次出队的时候都更新 head 节点：当 head 节点有元素值时，直接弹出元素，不更新 head 节点；head 节点没有元素时才更新 head 节点。</p>
<p><br></p>
<p>下面基于 Java 7 的实现来看看 ConcurrentLinkedQueue 的关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个可被多线程安全访问的无边界非阻塞的队列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 非阻塞的 FIFO 并发队列</span></span><br><span class="line"><span class="comment"> * 采用 CAS 操作保证同步</span></span><br><span class="line"><span class="comment"> * 底层采用链表实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;  <span class="comment">// volatile 保证数据可见性</span></span><br><span class="line"></span><br><span class="line">        Node(E item) &#123;</span><br><span class="line">            UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;  <span class="comment">// 更改 Node 中的数据域 item</span></span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);  <span class="comment">// 期望值是 cmp，设置为 val</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;  <span class="comment">// 惰性设置 next 的值，不一定会成功</span></span><br><span class="line">            UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;  <span class="comment">// 更改 Node 中的指针域 next</span></span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);  <span class="comment">// 期望值是 cmp，设置为 val</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);  <span class="comment">// head 和 tail 指向同一个节点，item 和 next 都为 null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">            h.lazySetNext(h);  <span class="comment">// 将自己的 next 节点设置为 head 节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; next = p.next;</span><br><span class="line">        <span class="comment">// 如果 p 的 next 链接到自身，说明 p 已经被出队了</span></span><br><span class="line">        <span class="comment">// 出队了咋办？那就回到 head 重新开始遍历</span></span><br><span class="line">        <span class="comment">// 否则就直接返回 next</span></span><br><span class="line">        <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);  <span class="comment">// 创建入队的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获得尾节点，再入队</span></span><br><span class="line">        retry:  <span class="comment">// 入队不成功会重复尝试</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;  <span class="comment">// 死循环</span></span><br><span class="line">            Node&lt;E&gt; t = tail;</span><br><span class="line">            Node&lt;E&gt; p = t;  <span class="comment">// 定义 p 表示队列尾节点，默认指向 tail 节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">                Node&lt;E&gt; next = succ(p);  <span class="comment">// 获取 p 的下一个（next）节点</span></span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;  <span class="comment">// p 存在 next 节点：说明 p 不是尾节点，需要更新 p</span></span><br><span class="line">                    <span class="comment">/* 更新 p 之前：*/</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp;  <span class="comment">// 循环到第二次了（tail 的 next 不为空，next 的 next 也不为空）</span></span><br><span class="line">                        t != tail)  <span class="comment">// 且：tail 被修改了（其他线程得逞了）</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;  <span class="comment">// tail 被修改了，就要重新开始迭代，更新 p 节点</span></span><br><span class="line"></span><br><span class="line">                    p = next;  <span class="comment">// 重新设置 p 节点为其 next 节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// p 是尾节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;  <span class="comment">// 尝试将 n 入队：CAS 设置尾节点 next 域从 null 到指向 n</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt;= HOPS)  <span class="comment">// 第二次：tail 至少滞后尾节点两个了（tail 的 next 和 next 的 next 都不为空）</span></span><br><span class="line">                        casTail(t, n);  <span class="comment">// 设置已入队的 n 为 tail 节点，此时 tail 节点就是尾节点了</span></span><br><span class="line">                        <span class="comment">// 更新失败了也没关系：失败了意味着有别的节点更新了 tail</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 返回入队成功</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// CAS 设置失败，说明 p 的 next 域不是 null 了（中途被某个线程设置得逞了）</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = succ(p);  <span class="comment">// 重新设置 p 节点为其 next 节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        Node&lt;E&gt; p = h;  <span class="comment">// 定义 p 表示队列头节点，默认指向 head 节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            E item = p.item;  <span class="comment">// 获取 p 节点（头节点）元素</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 头节点元素不为空，且 CAS 清空 p 的元素成功：</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS) &#123;  <span class="comment">// 第二次：从“next 不为空”而来</span></span><br><span class="line">                <span class="comment">// head 至少滞后头节点两个了</span></span><br><span class="line">                    Node&lt;E&gt; q = p.next;</span><br><span class="line">                    updateHead(h, (q != <span class="keyword">null</span>) ? q:p);  <span class="comment">// 更新头节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> item;  <span class="comment">// 返回元素值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 头节点 p 的元素为空，或者 CAS 操作失败（头节点元素不是预期的值：头节点被改变了）</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);  <span class="comment">// 获取 p 的下一个节点 next</span></span><br><span class="line">            <span class="comment">// next 为空：队列已经空了</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);  <span class="comment">// 更新头节点</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 跳出循环，返回 null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// next 不为空：头节点指向 next，继续循环</span></span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li><code>offer()</code> 主要做了两件事，一是找到尾节点，二是 CAS 设置新的尾节点，失败了就不断重试；</li>
<li>尾节点可能是 tail 节点，也可能是 tail 的 next 节点；</li>
<li>与之相类似：头节点可能是 head 节点，也可能是 head 的 next 节点；</li>
<li><code>HOPS</code> 的阈值判断对应的是上文提到的“<strong>tail 节点不总是尾节点 / head 节点不总是头节点</strong>”的实现。</li>
</ul>
<p>为啥非得要用 <code>HOPS</code> 去判断是否应该更新尾节点和设置 tail 节点？像下面这样写得简单点不好吗：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t.casNext(<span class="keyword">null</span>, n) &amp;&amp; casTail(t, n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>像上面这样子写的话，循环里面的每一次操作无论成功与否，都需要执行 CAS 操作，会给系统带来极大的开销，没有太大必要，还影响了 ConcurrentLinkedQueue 的执行效率。<br>所以 Doug Lea 使用 HOPS 变量来控制 tail 节点的更新频率，不需要在每一次的节点入队都需要更新 tail 节点。</p>
<p>tail 节点距离尾节点越长，每次 offer 入队 CAS 操作更新 tail 节点的次数越少，但定位尾节点所需的时间就越长。<br>但是还是划得来的，因为可以通过增加 volatile 变量的读操作来减少写操作。</p>
<p>Java 8 的实现与 Java 7 的实现相差不是很大。</p>
<p><br></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code> 不仅是 <code>HashMap</code> 的线程安全实现，而且更高效。因为：</p>
<p>在多线程环境下使用 HashMap，因其不是线程安全的类，容易发生死循环：HashMap 扩容的时候会 rehash，内部类 Entry 列表会形成环形的数据结构，next 节点就一直不为空了。</p>
<p>如果线程安全的旧集合 Hashtable：Hashtable 的同步（<code>synchronized</code>）都是方法级别的，加锁的时候整个对象都被锁住了，竞争激烈的时候效率低下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;(<span class="keyword">int</span> initialCapacity) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了跟 HashMap 同名的方法之外，还有：</span></span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 如该键不在映射表中，则将给定键值对关联，并返回 null</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 否则返回与该键关联的现有值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 如给定的键与给定值关联，删除给定键值对并返回 true</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 否则返回 false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 如给定键当前与 oldValue 相关联，则将 newValue 与键相关联</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 否则返回 false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Java-7-amp-before-的实现"><a href="#Java-7-amp-before-的实现" class="headerlink" title="Java 7 &amp; before 的实现"></a>Java 7 &amp; before 的实现</h3><p><strong>分段锁</strong>实现并发更新，提升访问效率。其底层采用了<strong>数组</strong> + <strong>链表</strong>的实现方式。</p>
<p>核心的静态类如下：</p>
<p><img src="/2021/10/02/java-concurrent-collections/concurrenthashmap-class-diagram.png" alt></p>
<ul>
<li><code>Segment</code>：继承 ReentrantLock 充当锁的角色，每个 Segment 对象通过数组维护一个键值对的链表；<ul>
<li>一个 Segment 的结构和一个 HashMap 是差不多的；</li>
<li>因此 Segment 为<strong>分段锁</strong>的实现</li>
</ul>
</li>
<li><code>HashEntry</code>：键值对，map 的基本存储单元<ul>
<li>要对 HashEntry 进行修改的话，需要先获取管理它的 Segment 的同步状态</li>
</ul>
</li>
</ul>
<p>每个 ConcurrentHashMap 对象维护一个 Segment 数组，每个 Segment 对象扩展一个可重入锁，分别只锁对应散列值的数据，一定程度上提高了并发效率。</p>
<p>基本层级如下：</p>
<p><img src="/2021/10/02/java-concurrent-collections/concurrenthashmap-structure.png" alt></p>
<p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个可被多线程安全访问的散列映射表</span></span><br><span class="line"><span class="comment">     * 基于 Hashtable 及 ConcurrentMap 的高性能同步实现，支持 Hashtable 所有旧方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * initialCapacity 默认为 16</span></span><br><span class="line"><span class="comment">     * loadFactor：如每个桶平均负载超过该因子，表大小会被重新调整（默认为 0.75）</span></span><br><span class="line"><span class="comment">     * concurrencyLevel：并行度，并发写线程的估计数目，简单点理解就是有多少把锁；默认 16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrentLevel = MAX_SEGMENTS;  <span class="comment">// 修正，防止溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="comment">// 要保证 segments 数组长度是 2 的 N 次方：为了能通过按位与的散列算法来定位 segments 数组的索引（HashMap 基础）</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;  <span class="comment">// segments 数组长度</span></span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;  <span class="comment">// segments 数组大小不小于并行度</span></span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;  <span class="comment">// 左移，即乘以 2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 以上两个参数用来定位某个键值对对应的 segment 的位置 */</span></span><br><span class="line">        <span class="comment">// 因为 concurrencyLevel 默认是 16:</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift; <span class="comment">// sshift 默认是 4，因此段偏移量默认是 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;  <span class="comment">// 段掩码，默认 16 - 1 = 15</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;  <span class="comment">// 修正，防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;  <span class="comment">// 计算 segment 元素内数组的容量阈值</span></span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;  <span class="comment">// segment 元素内部数组的初始化容量，默认为 2</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;  <span class="comment">// 保证 segment 内部数组的长度也是 2 的 N 次方</span></span><br><span class="line">        <span class="comment">// 初始化 segments 首元素</span></span><br><span class="line">        Segment&lt;K,V&gt;[] s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),  <span class="comment">// 内部阈值</span></span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        <span class="comment">// 初始化 segments 数组</span></span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0);  <span class="comment">// ordered write of segment[0] 将首元素 s0 设置到 ss 中</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) &#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentHashMap&lt;K,V&gt;() &#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 先尝试两次不对 segment 加锁来统计 count，如果统计过程中修改次数发生变化，再加锁；如果没有改变，则返回 size。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock();  <span class="comment">// force creation 两次尝试失败了，加锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;  <span class="comment">// 记录修改次数</span></span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == last)  <span class="comment">// 尝试成功（通过判断两次的总修改次数没有变化），或者：加锁之后肯定满足条件</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 volatile 变量，不需要加锁</span></span><br><span class="line">    <span class="comment">// （使用 volatile 替换锁的经典场景）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);  <span class="comment">// 再散列</span></span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;  <span class="comment">// 定位到 segment：跟 segmentForHash() 是一样的</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);  <span class="comment">// 根据散列值从 segment 中定位到元素</span></span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                    <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put 方法需要加锁，发生扩容的时候，只对当前的 segment 扩容</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位 segment 的方法：</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        ...  <span class="comment">// 计算哈希值，并且进行再散列（使用 Wang/Jenkins hash 变种算法）</span></span><br><span class="line">        <span class="comment">// 为的是减少散列冲突，让 HashEntry 元素尽可能均匀地分布于不同的 Segment 之间，从而提高存储效率。 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">segmentForHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;  <span class="comment">// 根据高四位值确定 segment 的位置</span></span><br><span class="line">        <span class="keyword">return</span> (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Since-Java-8-的实现"><a href="#Since-Java-8-的实现" class="headerlink" title="Since Java 8 的实现"></a>Since Java 8 的实现</h3><p>与 Java 7 最大的一点不同，是 Java 8 的 ConcurrentHashMap <strong>放弃了分段锁的实现 Segment</strong>，改用 Node + CAS + <code>synchronized</code> 保证并发安全：</p>
<p>直接用原 Segment 类中的 <strong>table 数组</strong>存储键值对；</p>
<ul>
<li>如果定位到 table 数组上的 Node 为空，则采用 <strong>CAS</strong> 操作写入数据；</li>
<li>如果不为空，则使用 <code>synchronized</code> 锁住<strong>链表头节点</strong>再写入数据。</li>
</ul>
<p>同一个桶里面 HashEntry 的 Node（键值对）的组织形式会经历从<strong>链表</strong>到<strong>红黑树</strong>的转变：</p>
<ul>
<li>当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD 时：链表转换为红黑树；</li>
<li>更像是 Java 8 中的 HashMap 实现</li>
</ul>
<p><img src="/2021/10/02/java-concurrent-collections/concurrenthashmap-new-structure.png" alt></p>
<p><br></p>
<h3 id="问题：短时间内插入大量数据至-ConcurrentHashMap"><a href="#问题：短时间内插入大量数据至-ConcurrentHashMap" class="headerlink" title="问题：短时间内插入大量数据至 ConcurrentHashMap"></a>问题：短时间内插入大量数据至 ConcurrentHashMap</h3><p>首先我们要明确，插入数据的性能损耗点，在于<strong>扩容操作</strong>和<strong>锁的争夺</strong>。</p>
<p>第一，通过配置合理的容量大小和扩容因子，尽可能减少扩容的发生；<br>第二，通过 ConcurrentHashMap 的 <code>spread()</code> 进行预处理，将存在 hash 冲突的数据放到一个组中，每个组使用单线程 <code>put()</code>，从而保证锁停留在偏向锁级别，不会升级。</p>
<p><br></p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个可被多线程安全访问的有序映射表</span></span><br><span class="line"><span class="comment"> * TreeMap 的同步实现，实现了 ConcurrentNavigableMap 接口</span></span><br><span class="line"><span class="comment"> * 第一个构造器要求键实现 Comparable 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ConcurrentSkipListMap&lt;K, V&gt;()</span><br><span class="line">ConcurrentSkipListMap&lt;K, V&gt;(Comparator&lt;? <span class="keyword">super</span> K&gt; comp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关的集合操作方法和 ConcurrentHashMap 是一样的</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="其它线程安全集合"><a href="#其它线程安全集合" class="headerlink" title="其它线程安全集合"></a>其它线程安全集合</h2><p><code>ConcurrentSkipListSet</code></p>
<ul>
<li>线程安全的有序集合</li>
<li>可以视为 <code>TreeSet</code> 的同步实现，实现了 NavigableSet 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListSet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ConcurrentSkipListSet&lt;E&gt;()</span><br><span class="line">ConcurrentSkipListSet&lt;E&gt;(Comparator&lt;? <span class="keyword">super</span> E&gt; comp)</span><br><span class="line"><span class="comment">// 构造一个可被多线程安全访问的有序集</span></span><br><span class="line"><span class="comment">// 第一个构造器要求元素实现 Comparable 接口</span></span><br></pre></td></tr></table></figure>
<p><code>CopyOnWriteArrayList</code></p>
<p>先说一下概念：<strong>CopyOnWrite</strong>, COW，复制再写入</p>
<ul>
<li>在添加元素的时候，先将原集合列表复制一份，再添加新的元素</li>
<li>只适合<strong>读多写少</strong>的情况</li>
</ul>
<p>该集合类参考了延时懒惰策略和读写分离的思想</p>
<ul>
<li>在读取时，多线程正常读取内容</li>
<li>写内容时，将当前对象进行复制，往<strong>新的对象进行修改</strong>，完成后再将引用指向新的对象</li>
<li>将读写分离，属于读写锁的实现（读同步，写互斥）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加元素时，先加锁，再进行复制替换操作，最后释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> added;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = <span class="keyword">this</span>.getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="keyword">this</span>.setArray(newElements);</span><br><span class="line">        added = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> added;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="keyword">this</span>.getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的实现：<code>CopyOnWriteArraySet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加元素：调用 CopyOnWriteArrayList 的 addIfAbsent()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = <span class="keyword">this</span>.getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e,snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> : <span class="keyword">this</span>.addIfAbsent(e,snapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合类</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程工具类</title>
    <url>/2021/09/04/java-concurrent-utils/</url>
    <content><![CDATA[<p>本帖再介绍多几个 Java 多线程编程（<code>java.util.concurrent</code> 包）的工具类。</p>
<span id="more"></span>
<h1 id="原子类-Atomic"><a href="#原子类-Atomic" class="headerlink" title="原子类 Atomic*"></a>原子类 Atomic*</h1><p>Java 1.5 开始提供了很多 <code>Atomic*</code> 类，其操作保证了操作的原子性，执行过程中不会被其他线程中断。包括：</p>
<p>原子更新基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicBoolean</span><br><span class="line"></span><br><span class="line">AtomicInteger</span><br><span class="line"></span><br><span class="line">AtomicLong</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span></span>;  <span class="comment">// 以原子方式将 delta 与实例中的值相加</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;  <span class="comment">// 如果实例中的值为预期 expect，则以原子方式将 update 更新到实例中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span>  <span class="comment">// 以原子方式加 1，返回自增前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span>  <span class="comment">// 以原子方式设置新值，返回旧的值</span></span></span><br></pre></td></tr></table></figure>
<p>原子更新数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicIntegerArray</span><br><span class="line"></span><br><span class="line">AtomicLongArray</span><br><span class="line"></span><br><span class="line">AtomicReferenceArray</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span></span><br></pre></td></tr></table></figure>
<p>原子更新引用：更新引用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicReference&lt;T&gt;</span><br><span class="line"></span><br><span class="line">AtomicStampedReference&lt;T&gt;  <span class="comment">// 带版本号的引用类型</span></span><br><span class="line"><span class="comment">// 将整数值和引用关联起来（Pair）</span></span><br><span class="line"><span class="comment">// 用此来解决 ABA 问题</span></span><br><span class="line"></span><br><span class="line">AtomicMarkableReference&lt;T&gt;  <span class="comment">// 带标识位的引用类型</span></span><br></pre></td></tr></table></figure>
<p>原子更新属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicIntegerFieldUpdater&lt;T&gt;</span><br><span class="line"></span><br><span class="line">AtomicLongFieldUpdater&lt;T&gt;</span><br><span class="line"></span><br><span class="line">AtomicReferenceFieldUpdater&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>原子类基于 CAS 算法实现，使用方法简单，性能更高效，线程安全。</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>允许<strong>一个或多个</strong>线程等待其他线程完成操作。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);  <span class="comment">// 在这里相当于一个计数器：等待两个线程执行完成</span></span><br><span class="line"><span class="comment">// 一个线程调用 countDown() happens-before 于另一个线程调用同一个 CountDownLatch 的 await()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">    c.countDown();  <span class="comment">// 计数器减 1</span></span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">    c.countDown();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">c.await();  <span class="comment">// 当 countDown() 到 0 的时候，CountDownLatch 就会从 await() 返回</span></span><br><span class="line"><span class="comment">// c.await(10000, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>join()</code> 方法也可以实现相同功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123; System.out.println(<span class="string">&quot;t1 finished&quot;</span>); &#125;);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123; System.out.println(<span class="string">&quot;t2 finished&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(<span class="string">&quot;all threads finished&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但除了上述例子，使用 CountDownLatch 能实现的功能比 join() 多：<br>CountDownLatch 可以用在多个线程，也可以用在一个线程中的多个步骤，这是 join() 所不能比拟的。</p>
<p>应用：多线程解析同个 .xls 文件多个 sheet，或多个线程获取不同页面的信息。</p>
<p><br></p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>顾名思义，它是可以<strong>循环使用</strong>（cyclic）的屏障（barrier）。</p>
<p>让一组线程到达一个屏障（也可以称之为“同步点”）之后被阻塞，直到最后一个线程到达屏障，屏障才会被解除，所有被屏障拦截的线程才会继续运行。<br>就像是到了一定条件才拉闸放水一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier b = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);  <span class="comment">// 直到第 3 个线程到了才会解封</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c.await();  <span class="comment">// 每一个线程调用一次 await()，屏障记一次到达的线程个数，随后该线程被阻塞</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// handle exceptions</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    c.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// handle exceptions</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述例子中因 parties = 3，程序中的两个线程会被一直阻塞。</span></span><br><span class="line"><span class="comment">// parties 改为 2 的话，两个线程最终会运行结束，且输出的 “1” 和 “2” 顺序不保证。</span></span><br></pre></td></tr></table></figure>
<p>另：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier b = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());  <span class="comment">// A 是屏障解除时优先执行的 barrierAction</span></span><br><span class="line"><span class="comment">// 这个方法用在需要有一个线程保证被优先执行的场景</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>带 barrierAction 的构造函数可应用于多线程计算数据，随后合并计算结果的场景。barrierAction 是执行合并结果的线程。</p>
<h2 id="CyclicBarrier-v-s-CountDownLatch"><a href="#CyclicBarrier-v-s-CountDownLatch" class="headerlink" title="CyclicBarrier v.s. CountDownLatch"></a>CyclicBarrier v.s. CountDownLatch</h2><p>CountDownLatch 更像是一个<strong>计数器</strong>，线程完成一个就记录一个，计数是递减而不是递增；而 CyclicBarrier 更像是一个<strong>阀门</strong>，计数递增，所有线程到达之后阀门才被打开，然后所有线程继续执行。</p>
<p>CyclicBarrier 的计数器可以使用 <code>reset()</code> 重置；而 CountDownLatch 的计数器<strong>只能使用一次</strong>，初始化之后就不能被更改。<br>因此 CyclicBarrier 能够处理更为复杂的业务场景：比如说计算结果出错了，可以通过重置计数器，再次创建线程重新计算；CountDownLatch 就做不到这样的功能。</p>
<p>CyclicBarrier 还提供了其他有用的方法，如 <code>getNumberWaiting()</code>（获取目前多少个线程被阻塞）<code>isBroken()</code>（阻塞线程是否被中断）等方法。 </p>
<p><br></p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>通常译作“信号量”。</p>
<p>保持在 0 和指定最大值之间的一个计数值，用于控制同时访问特定资源的线程数量，通过协调各个线程来保证合理地使用公共资源。</p>
<ul>
<li>当线程完成一次对该信号量对象的等待（wait）时，计数值减一</li>
<li>当线程完成一次对该信号量对象的释放（release）时，计数值加一</li>
<li>当计数值为 0：等待该对象的线程数达到最大值，别的线程等待该信号量对象就不再能成功了，直至该对象变成 signaled 状态</li>
</ul>
<p>信号量对象状态：</p>
<ul>
<li>对象计数值大于 0：signaled</li>
<li>计数值等于 0：nonsignaled</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span>  <span class="comment">// 获取访问许可，获取时并不会加持任何锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span>  <span class="comment">// 释放访问许可</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">availablePermits</span><span class="params">()</span>  <span class="comment">// 返回当前可用的许可数</span></span></span><br><span class="line"><span class="function"><span class="title">getQueueLength</span><span class="params">()</span>  <span class="comment">// 正在等待获取许可的线程数</span></span></span><br><span class="line"><span class="function"><span class="title">hasQueuedThreads</span><span class="params">()</span>  <span class="comment">// 是否有线程正在等待获得许可</span></span></span><br></pre></td></tr></table></figure>
<p>应用举例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...  <span class="comment">// 获取许可之后执行的操作</span></span><br><span class="line"></span><br><span class="line">        s.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可应用于流量控制。</p>
<h2 id="Semaphore-v-s-Mutex"><a href="#Semaphore-v-s-Mutex" class="headerlink" title="Semaphore v.s. Mutex"></a>Semaphore v.s. Mutex</h2><p>信号量适用于控制一个仅支持有限个用户的共享资源；而互斥锁（<strong>Mut</strong>ual <strong>Ex</strong>clusion, mutex）则是防止两个以上线程同时对一个公共资源进行读写的机制。</p>
<p>互斥与信号量的区别：</p>
<ol>
<li>互斥仅允许一个线程在某段时间内进入受保护的控制块</li>
<li>信号量则可允许有限个线程同时访问受保护的资源</li>
<li>信号量有受线程控制的变量，互斥锁没有</li>
<li><code>new Semaphore(1);</code> 即 binary semaphore，相当于互斥锁</li>
</ol>
<p>binary semaphore 与 mutex 的区别：</p>
<ol>
<li>初始状态不同：binary semaphore 是 <code>0</code>，即 unsignaled 状态；mutex 是 <code>1</code>，即可获取的状态</li>
<li>相当于上述区别的 3：mutex 所有权不能被抢夺，而 binary semaphore 必要时会被占用</li>
</ol>
<p><br></p>
<p>以上的类都提供了并发流程控制的手段。</p>
<p><br></p>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>用于进行线程之间的数据交换，相当于提供了一个同步点：在同步点里面，两个线程可以交换彼此的数据。<br>如果第一个线程先执行了 Exchanger 的方法，它会一直等待第二个线程也执行相对应的方法（除非当前线程被中断）；当两个线程都到达同步点的时候，开始交换数据。</p>
<p>应用：遗传算法，校对工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            String data = <span class="string">&quot;data1&quot;</span>;</span><br><span class="line">            exchangeData(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            String data = <span class="string">&quot;data2&quot;</span>;</span><br><span class="line">            exchangeData(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchangeData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;Thread %s exchanging %s.%n&quot;</span>, Thread.currentThread().getName(), data);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            String exchange = exchanger.exchange(data);</span><br><span class="line">            System.out.printf(<span class="string">&quot;Thread %s got %s.%n&quot;</span>, Thread.currentThread().getName(), exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Thread pool-1-thread-1 exchanging data1.</span></span><br><span class="line"><span class="comment">// Thread pool-1-thread-2 exchanging data2.</span></span><br><span class="line"><span class="comment">// Thread pool-1-thread-1 got data2.</span></span><br><span class="line"><span class="comment">// Thread pool-1-thread-2 got data1.</span></span><br></pre></td></tr></table></figure>
<h1 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork-Join 框架"></a>Fork-Join 框架</h1><p>From Java 7.</p>
<p>看名字就能猜出这个框架大概是干嘛的了：</p>
<ul>
<li><strong>Fork</strong>：将一个大任务切分成若干个子任务，让它们并行执行</li>
<li><strong>Join</strong>：合并所有子任务的执行结果</li>
</ul>
<p>Fork-Join 能满足应用在每个处理器内核分别使用一个线程，完成计算密集型任务的需求，实现并行执行任务的“分治”计算过程，就像是单机版的 MapReduce 一样。</p>
<p><img src="/2021/09/04/java-concurrent-utils/fork-join.png" alt></p>
<p><img src="/2021/09/04/java-concurrent-utils/fork-join2.png" alt></p>
<h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>每一个线程分别负责一个存储了任务的队列；某个线程执行速度快，将自己负责的队列中所有资源消费完（执行完所有任务）之后，会从其它线程负责的队列中“窃取”任务来执行。</p>
<p>工作窃取算法应用于<strong>阻塞双端队列</strong>（<strong>LinkedBlockingDeque</strong>）中：</p>
<ul>
<li>被窃取的线程永远从其负责的队列的<strong>头部</strong>获取；</li>
<li>窃取任务的线程永远从别的队列的<strong>尾部</strong>获取</li>
</ul>
<p><img src="/2021/09/04/java-concurrent-utils/task-steal.png" alt></p>
<ul>
<li>优点：充分利用线程进行并行计算，减少线程之间的竞争，从而加快进度</li>
<li>缺点：不能完全避免竞争；消耗系统资源</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>执行的步骤比较清晰：</p>
<ol>
<li>按照一定粒度分割任务；如果粒度未达要求，就继续分割到满意为止；</li>
<li>执行任务并合并结果</li>
</ol>
<p>所有子任务会被分配到不同的双端队列中，此时启动多个线程分别从队列中获取任务并执行；执行完毕的子任务，结果（如果有返回值的话）会统一放到一个队列中，另外的线程会从队列中取得数据，合并并返回。</p>
<p>伪代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (problemSize &lt; threshold)</span><br><span class="line">    <span class="comment">// solve problem directly</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * break problem into subproblems</span></span><br><span class="line"><span class="comment">     * recursively solve each subproblem</span></span><br><span class="line"><span class="comment">     * combine the results</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java 中与 Fork-Join 框架相关的类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> ForkJoinTask&lt;V&gt;  <span class="comment">// 抽象类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：</span></span><br><span class="line"></span><br><span class="line">RecursiveAction  <span class="comment">// 无返回值</span></span><br><span class="line">RecursiveTask  <span class="comment">// 有返回值</span></span><br></pre></td></tr></table></figure></p>
<p>当 <code>ForkJoinTask</code> 的实例被提交至 <code>ForkJoinPool</code> 中时，task 开始执行：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinPool  <span class="comment">// 实现了 ExecutorService 接口</span></span><br><span class="line"><span class="comment">// task 会被分发到当前工作线程所维护的双端队列头部中</span></span><br><span class="line"><span class="comment">// 倘若当前队列为空，它会随机窃取别的队列尾部的任务</span></span><br></pre></td></tr></table></figure></p>
<p>实例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">// 等待执行结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 1 累加到 10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        Future&lt;Integer&gt; result = pool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task.isCompletedAbnormally())</span><br><span class="line">            <span class="comment">// 处理 task 执行过程中的异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程基础类</title>
    <url>/2021/08/24/java-multi-threads-basic-classes/</url>
    <content><![CDATA[<p>说到 Java 多线程的基础，你最先想到什么？是不是 <code>Thread</code> ？</p>
<span id="more"></span>
<p>其实具体来说，Java 实现多线程，主要有三种方法：</p>
<ol>
<li>实现 Runnable 接口</li>
<li>继承 Thread 类</li>
<li>使用 Callable、Future 等有返回值的类</li>
</ol>
<p>前两种方法没有返回值，但是是最常用的方法。</p>
<p>从 JDK 1.5 开始，上述的基本工作单元就和 Executor 框架分开了。</p>
<p><br></p>
<h1 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h1><p>Runnable 是开启一个新线程的基础。我们所常用的“开启一个新线程”，或创建 <code>Thread</code> 对象，实质上就是继承 Runnable 接口。</p>
<p>如果某个类需要实现一个 <code>Thread</code> 类，但是已经继承了另一个类的话，就无法再直接继承 Thread 类了。<br>此时只能通过<strong>实现 Runnable 接口</strong>来满足需求，启动时将其实例作为参数传入 Thread 构造函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 必须覆盖该方法：在方法内提供所要执行的指令</span></span><br><span class="line">    <span class="comment">// 可通过创建类，实现接口并在 run 方法内完成特定的计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomethingAsync();  <span class="comment">// 自定义方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Runnable target = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="keyword">new</span> Thread(target).start();</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>本质上是实现 Runnable。通过继承 Thread 并调用 t.start() 方法来启动线程。<br>t.start() 是 native 方法。</p>
<p>继承 Thread 类之后，我们需要覆写 <code>run</code> 方法来自定义操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomethingAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 方法</span></span><br><span class="line"></span><br><span class="line">Thread(Runnable target)    <span class="comment">// 构建一个新线程，用于调用给定 target 的 run 方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 启动线程，将触发 run 方法</span></span></span><br><span class="line"><span class="function"><span class="comment">// 该方法立即返回，且新线程将并行运行</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>    <span class="comment">// 调用关联 Runnable 的 run 方法</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span>    <span class="comment">// 返回代表当前执行线程的 Thread 对象</span></span></span><br></pre></td></tr></table></figure>
<p>Thread 初始化的时候，会将 daemon 和 priority 设置为父线程的对应属性，再将父线程的 inheritableThreadLocal 复制过来。</p>
<p><br></p>
<p>如果直接调用 run 方法只会执行<strong>同一个线程</strong>的任务。</p>
<p>Thread 调用到最后一行，或者调用过程中出现了不可捕获的异常，线程会终止。</p>
<p>Thread 的 run 方法并不能抛出任何被检测到的异常，因此我们在设计的时候，需要在线程死亡之前，将异常传递到一个<strong>用于未被捕获的异常的处理器</strong>，该处理器实现 <code>Thread.UncaughtExceptionHandler</code> 类获取异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 / 获取未捕获异常的默认处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(Thread.UncaughtExceptionHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Thread.UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 设置 / 获取未捕获异常的处理器</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如未安装处理器，则对于独立线程：处理器为空</span></span></span><br><span class="line"><span class="comment"><span class="function"> * </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 对于线程组：线程组对象作为处理器</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 默认：创建的所有线程属于相同的线程组</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(Thread.UncaughtExceptionHandler handler)</span></span></span><br><span class="line"><span class="function">Thread.UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UncaughtExceptionHandler 接口：</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当一个线程因未捕获异常而终止，按理将 report 记录至日志中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * t：由于未捕获异常而终止的线程</span></span><br><span class="line"><span class="comment"> * e：未捕获的异常对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 实现 Thread.UncaughtExceptionHandler 接口</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如有父线程组：调用父线程组该方法</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 否则：</span></span></span><br><span class="line"><span class="comment"><span class="function"> *   如 Thread.getDefaultUncaughtExceptionHandler 非空：调用该处理器</span></span></span><br><span class="line"><span class="comment"><span class="function"> *   如 Throwable e 为 ThrowDeath 实例：什么都不做</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 否则：System.err(Thread.name + e.printStackTrace())</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.lang.ThreadGroup</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span></span><br></pre></td></tr></table></figure>
<p>通过扩展 Thread 类实现多线程的方法已不再被推荐：</p>
<ul>
<li>首先，设计程序的时候应该从运行机制上去减少需要运行的任务数量</li>
<li>再者如有很多任务，为每个任务创建独立的线程，会造成很大的开销</li>
</ul>
<p>我们应该引入“池”的概念，即使用线程池（thread pool）去解决问题。</p>
<p><br></p>
<h1 id="Callable-amp-Future"><a href="#Callable-amp-Future" class="headerlink" title="Callable &amp; Future"></a>Callable &amp; Future</h1><p>Callable 和 Future 都是接口类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型参数 V 是返回值的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 运行一个将产生结果的任务</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 相当于 Runnable 的 run</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存异步计算的结果</span></span><br><span class="line"><span class="comment"> * 启动一个线程并传入 Future 对象，计算完毕后线程会获得结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取结果；</span></span><br><span class="line"><span class="comment">     * 如无结果可用，则进入同步队列并阻塞，直至真正得到结果或超时为止</span></span><br><span class="line"><span class="comment">     * 如被中断：抛出 InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span>;  <span class="comment">// 如不成功，抛出 TimeoutException</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试取消任务</span></span><br><span class="line">    <span class="comment">// 如任务已经开始，且 mayInterrupt 参数值为 true，则将正在运行的线程终端</span></span><br><span class="line">    <span class="comment">// 如被成功取消则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterrupt)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如任务在完成前被取消，返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如任务结束（正常结束、中途取消或异常终止），返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>FutureTask</code> 是 Future 接口的实现类，既可以提交到线程池中执行，也可以通过 <code>run()</code> 直接执行。</p>
<p>三种状态：<strong>未启动</strong>、<strong>已启动</strong>和<strong>已完成</strong>，比线程的粒度大很多，层次更高（不要跟线程状态混淆了）。</p>
<p><img src="/2021/08/24/java-multi-threads-basic-classes/futuretask.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// extends Runnable, Future&lt;V&gt;</span></span><br><span class="line"></span><br><span class="line">    FutureTask(Callable&lt;V&gt; task) &#123;&#125;</span><br><span class="line">    FutureTask(Runnable task, V result) &#123;&#125;</span><br><span class="line">    <span class="comment">// 构造一个既是 Future&lt;V&gt; 又是 Runnable 的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 Future 接口方法时，FutureTask 对应不同状态时候的不同返回：</p>
<p><img src="/2021/08/24/java-multi-threads-basic-classes/future-get-cancel.png" alt></p>
<p>FutureTask 实现浅析：</p>
<p><img src="/2021/08/24/java-multi-threads-basic-classes/futuretask-implm.png" alt></p>
<p>可知 FutureTask 扩展了 Sync 继承了 AQS，其接口方法的实现是基于<strong>共享式</strong>获取资源而实现的。<br>再结合不同状态时候调用 Future 接口方法的不同返回，可知：</p>
<ul>
<li>FutureTask 还没完成的时候，如果调用 get()，“阻塞”的意思是调用 get() 的线程会<strong>进入同步队列</strong>中等待</li>
<li>直到 FutureTask 完成之后，AQS 的等待通知机制会通知同步队列头节点，<strong>唤醒</strong>第一个线程 get()</li>
<li>而调用 run() / cancel() 也会唤醒同步队列的第一个线程进行操作</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map 接口</title>
    <url>/2022/05/06/java-map/</url>
    <content><![CDATA[<p>Java 集合类“二王”中的另一个，就是 Map 接口。</p>
<span id="more"></span>
<p>Map，意为映射表，表的元素是一个又一个的 <code>Entry</code> 对象。<br>每个 Entry 对象为一键值对（Key-Value pair），key 与 value 可以是任意的 Object，Map 提供接口方法通过 key 去查找 value。</p>
<p>由于要根据 key 来区分不同的 Entry：key 不能重复，不能对同一个 key 存放两个值，而 value 可以重复（包括 <code>null</code>）。<br>如对同一个 key 两次调用 put()，第二次的值会取代第一个值，put() 将返回用这个键参数存储的上一个值。</p>
<p>Map 不继承 Collection 接口：Map 不是集合，如继承自 Collection：键值对何去何从？作为一组对象存放于 collection？这样子会加大映射表的负担，增加操作的复杂度。</p>
<h1 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h1><p>JDK 为映射表的 Key 和 Value 规定了两个范型：<K, v>。</K,></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否包含指定的 Key</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否包含指定的 Value</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 Key 获取 Value</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 Entry</span></span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 Key 删除 Entry</span></span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 Collection 接口的 addAll 类似，将指定的 Map 对象添加进此 Map</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 Map 中的所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合框架 JCF 并没有将映射表本身视为一个集合；而其他数据结构框架会将其视为对（pair）集合，或用键作为索引的值的集合。</p>
<p>可以通过一些已经实现的方法获得映射表的视图，这些视图实现了 Collection 接口或者它的子接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为 Map 接口提供的的集合视图：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的 Key 作为一个 Set 读取</span></span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 如 map 被修改，keySet 会变为 undefined</span></span><br><span class="line">    <span class="comment">// 可通过 remove 等操作移除，对应地移除 map 的映射；不支持 add 类型操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的 Value 作为一个集合读取</span></span><br><span class="line">    <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 如 map 被修改，values 会变为 undefined</span></span><br><span class="line">    <span class="comment">// 可通过 remove 等操作移除，对应地移除 map 的映射；不支持 add 类型操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的 Entry 作为一个 Set 读取</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">    <span class="comment">// 如 map 被修改，entrySet 会变为 undefined</span></span><br><span class="line">    <span class="comment">// 可通过 remove 等操作移除，对应地移除 map 的映射；不支持 add 类型操作</span></span><br><span class="line">    <span class="comment">// 注：只添加键不添加值是无意义的。</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们需要说一下 <code>hashCode()</code> 和 <code>equals()</code> 这两个重要的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 映射表比较接口，需要子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="hashCode-amp-equals"><a href="#hashCode-amp-equals" class="headerlink" title="hashCode() &amp; equals()"></a>hashCode() &amp; equals()</h2><p>如果两个对象相等（equals() 返回 <code>true</code>），则散列值 hash code 一定相同；如两个对象 hash code 值相等，对象则不一定相等。</p>
<ul>
<li>hash code 相等即键值对的 hash value 相等；</li>
<li>hash value 相等并不一定能得出键值对相等，不同的键值对可能会得出一样的散列值，这就是<strong>哈希冲突</strong>，又称散列冲突。</li>
</ul>
<p>equals()，表示某个类逻辑上的相等，不同于 <code>==</code> 判断内存地址是否相等。</p>
<p>有需要的话，类需要重写 equals() 实现该类对象的逻辑比较判断。</p>
<p>现在，假设有某一个类：</p>
<p>如果在<strong>散列表数据结构</strong>（HashSet, HashTable, HashMap 等）中用到该类，hashCode() 与 equals() 有关系，否则两者没关系。<br><strong>该类作为散列表的 key 的话，必须重写 hashCode()。</strong></p>
<p>如果有必要重写 hashCode() 或 equals()，最好两个一起重写；如果重写了 equals()，也应重写 hashCode() 方法：</p>
<ul>
<li>重写 hashCode() 之后，返回值可能相同，但 identityHashCode() 不会相同：因为 identityHashCode() 返回对象物理地址产生的 hash 值</li>
</ul>
<p>重写 equals() 后应检查是否符合：</p>
<ul>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>自反性</li>
<li>非空性</li>
</ul>
<p>注：散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。<br>如不需要按照排序访问键，就最好选择散列。如果不能通过 get() 得到，返回的则是 null。</p>
<h2 id="New-from-JDK-1-8"><a href="#New-from-JDK-1-8" class="headerlink" title="New from JDK 1.8"></a>New from JDK 1.8</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 get 方法类似, 但当获取不到对应的 Value 时, 返回指定的默认 Value</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 put 方法类似, 当不存在对应的 Entry 时 put 并返回 null, 若存在则返回 Value</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有当 Map 中存在 Entry 包含指定的 Key-Value 时, 才删除该 Entry</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有当 Map 中存在 Entry 包含指定的 Key 以及 Value 时, 才用新的 Value 替换旧 Value</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有当 Map 中存在 Entry 包含指定的 Key 以及任意 Value 时, 才用新的 Value 替换旧 Value</span></span><br><span class="line">    <span class="comment">// 返回旧 Value 或 null（如果没替换或原 Key 映射的 Value 为 null）</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于从 Java 8 开始引入了<a href="/2022/02/07/fp">函数式编程</a>，因此 Map 也实现了与此相关的新接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于构建本地缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于 Map 的合并</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部替换</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部接口-Map-Entry"><a href="#内部接口-Map-Entry" class="headerlink" title="内部接口 Map.Entry"></a>内部接口 Map.Entry</h2><p>Entry 沿用了 Map 接口的范型 <K, v>，代表 Map 中每一个单独的元素。</K,></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 获取此 Entry 的 Key</span></span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取此 Entry 的 Value</span></span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置此 Entry 的 Value</span></span><br><span class="line">    <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// equals() 及 hashCode() 用于判断两个 Entry 对象是否相等</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since 1.8, 返回一个根据 Key 来比对的比较器, 可用于排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K extends Comparable&lt;? <span class="keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since 1.8, 返回一个根据 Value 来比对的比较器, 可用于排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V extends Comparable&lt;? <span class="keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since 1.8, 返回一个根据 Key 来比对的比较器, 但比对方式来源于入参比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since 1.8, 返回一个根据 Value 来比对的比较器, 但比对方式来源于入参比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="keyword">super</span> V&gt; cmp) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map 中的 keySet，values，entrySet 与其息息相关。</p>
<h1 id="子类及接口"><a href="#子类及接口" class="headerlink" title="子类及接口"></a>子类及接口</h1><p><img src="/2022/05/06/java-map/map-diagram.png" alt></p>
<h2 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h2><p>映射表抽象类，为 Map 的实现类预先实现了许多 Map 接口声明的方法。</p>
<p>不过，AbstractMap 所实现的方法大多依赖于 entrySet()；而 AbstractMap 并未实现 entrySet()，它选择交给子类实现。</p>
<p>AbstractMap 提供了两个实现了 Map.Entry 接口的静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明 key 为 final：确保了 Entry 对象内 key 一旦被设置后就不可再修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImmutableEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明 key 和 value 为 final：确保了 Entry 对象内 key 和v alue 一旦被设置后就不可再修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SortedMap-接口"><a href="#SortedMap-接口" class="headerlink" title="SortedMap 接口"></a>SortedMap 接口</h2><p>继承自 Map</p>
<ul>
<li>接口暴露了用于排序的比较器对象，且定义的方法可以获得集合的子集视图</li>
<li>要求其实现类必须保证内部元素可以按自然或 Comparator 的顺序排列</li>
</ul>
<h2 id="NavigableMap-接口"><a href="#NavigableMap-接口" class="headerlink" title="NavigableMap 接口"></a>NavigableMap 接口</h2><p>扩展自 SortedMap，包含用于在映射表中查找和遍历的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回小于指定 key 的最大 entry</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回小于指定 key 的最大 key</span></span><br><span class="line">    <span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不大于指定 key 的最大 entry</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不大于指定 key 的最大 key</span></span><br><span class="line">    <span class="function">K <span class="title">floorKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不小于指定 key 的最小 entry</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不小于指定 key 的最小 key</span></span><br><span class="line">    <span class="function">K <span class="title">ceilingKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回大于指定 key 的最小 entry</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回大于指定 key 的最小 key</span></span><br><span class="line">    <span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除并返回第一个 entry</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除并返回最后一个 entry</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个与当前 map 反序的 map</span></span><br><span class="line">    <span class="function">NavigableMap&lt;K,V&gt; <span class="title">descendingMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个与当前 key set 反序的 key set</span></span><br><span class="line">    <span class="function">NavigableSet&lt;K&gt; <span class="title">descendingKeySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指定 key 范围之间的视图</span></span><br><span class="line">    <span class="function">NavigableMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K from, K to)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个小于指定 key 的视图</span></span><br><span class="line">    <span class="function">NavigableMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个大于指定 key 的视图</span></span><br><span class="line">    <span class="function">NavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><p>概括一下常用的非线程安全的 Map 实现类：</p>
<p><a href="/2022/05/08/java-hashmap"><strong><code>HashMap</code></strong></a>：存储 k-v 关联的数据结构，对 key 进行散列</p>
<p><strong><code>TreeMap</code></strong></p>
<p>TreeMap 键值有序排列的映射表，元素整体以红黑树形式排序。<br>TreeMap 实现了 NavigableMap 接口，内部 Entry 为静态类 TreeMap.Entry。</p>
<p><strong><code>LinkedHashMap</code></strong></p>
<p>可记住 k-v 项添加次序（有序）的映射表。</p>
<p>LinkedHashMap 使用<strong>访问顺序</strong>对映射表条目进行迭代，而非插入顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;K, V&gt;(initialCapacity,  <span class="comment">// 给定的初始容量</span></span><br><span class="line">                    loadFactor,       <span class="comment">// 填充因子</span></span><br><span class="line">                    <span class="keyword">true</span>)             <span class="comment">// 元素访问顺序，true 为按照访问顺序，false 为按照插入顺序</span></span><br></pre></td></tr></table></figure>
<p>当 entry 插入到表中时，会被并入双向链表中。每次调用 get() 或 put() 的时候，受影响（被改动过的）的 entry 会从当前位置被删除，并放到 entry 链表尾部。</p>
<p>只有 entry 在链表中的位置受影响，散列表中<strong>桶的位置不受影响</strong>。</p>
<p>访问顺序对于实现高速缓存的“最近最少使用”（LRU）原则十分重要</p>
<ul>
<li>在实际应用中，访问频繁的元素会被置于内存，不频繁的被放入数据库</li>
<li>在表中找不到元素项且表已满时，可将迭代器加入表中，并将枚举的前几个元素（近期最少使用的元素）删除</li>
</ul>
<p>根据 LinkedHashMap 的属性，可以实现 LRU：</p>
<ul>
<li>覆盖 LinkedHashMap 的 <code>protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code></li>
<li>每当方法返回 true 时，添加一个新条目，从而删除 eldest 条目</li>
<li>另还可对 eldest 进行评估，以此决定是否应该将它删除</li>
</ul>
<p><strong><code>EnumMap</code></strong></p>
<p>键值属于枚举类型的映射表，底层是数组，直接且高效。</p>
<p><strong><code>WeakHashMap</code></strong></p>
<p>对于弱引用对象来说，垃圾回收器将其回收，要先将引用这个对象的弱引用放入队列中。<br>当弱引用进入队列，意味着该引用不再被他人使用。</p>
<p>WeakHashMap 使用弱引用保存键，并周期性检查队列，以便找出新添加的弱引用，保证垃圾回收时 key 能被回收，随即回收 value，从而使对应的 entry 消失，一定程度避免内存溢出。</p>
<p><strong><code>IdentityHashMap</code></strong></p>
<p>IdentityHashMap 的键的散列值是使用 <code>System.IdentityHashCode()</code> 计算的，根据<strong>对象的内存地址</strong>来计算散列码。</p>
<p>因此比较两个对象的时候，IdentityHashMap 使用 <code>==</code>，而不是 equals()。<br>也就是说，不同的 key 即使内容相同，也被视为不同的对象。<br>所以 IdentityHashMap 允许重复的 key。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合类</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的线程（Threads）</title>
    <url>/2021/08/02/java-threads/</url>
    <content><![CDATA[<p>工欲善其事，必先利其器。在 Java 开发中，想要做好多线程开发和并发处理，了解 Java 中的线程至关重要。</p>
<span id="more"></span>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><strong>1</strong>. <strong>新建</strong>（<strong>New</strong>）</p>
<p>新创建了一个线程对象，但该线程尚未运行（因为还没被调用 <code>start()</code> 方法）。</p>
<p><strong>2</strong>. <strong>运行</strong>（<strong>Runnable</strong>）</p>
<p>当一个新创建的线程对象被调用了 <code>start()</code> 之后：线程便进入了可运行线程池中，进入可运行（runnable）状态，等待获取 CPU 的使用权；</p>
<ul>
<li>Java 线程将操作系统中的“就绪”和“运行”两种状态笼统地称作“运行中”</li>
<li>该线程可能正在运行（running），也可能没运行（ready），取决于操作系统当前提供的时间片。</li>
</ul>
<p><strong>3</strong>. <strong>阻塞</strong>（<strong>Blocked</strong>）</p>
<p>当线程试图去获取一个内部对象的<strong>同步锁</strong>（如进入 <code>synchronized</code> 块，非 <code>java.util.concurrent</code> 的锁），而该锁正被其他线程持有的时候，该线程就会暂时放弃 CPU 的使用权，从而<strong>停止运行</strong>，直到进入就绪状态。</p>
<p>JVM 会将该线程放入<strong>锁池</strong>；当所有其他线程释放了这个锁，且线程调度器允许本线程去持有它时，该线程脱离阻塞状态。</p>
<p><strong>4</strong>. <strong>等待</strong>（<strong>Waiting</strong>）</p>
<p>又称等待阻塞（不知道是谁提出的这个说法）。</p>
<p>对于某个处于 Running 态的线程来说，如果它需要等待另一个线程去通知调度器一个条件（Condition 对象）的时候，该线程进入等待状态。JVM 将该线程放入<strong>等待池</strong>。</p>
<p>使线程进入该状态的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object.wait()</span><br><span class="line">Thread.join()</span><br><span class="line">LockSupport.park()</span><br></pre></td></tr></table></figure></p>
<p>举一个场景说明一下阻塞和等待：</p>
<p><img src="/2021/08/02/java-threads/threads-block-waiting.png" alt></p>
<p><strong>5</strong>. <strong>计时等待</strong>（<strong>Timed waiting</strong>）</p>
<p>线程被调用一些超时计时方法后，会进入计时等待，JVM 将该线程放入等待池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object.wait(millis)</span><br><span class="line">Thread.sleep(millis)</span><br><span class="line">Thread.join(millis)</span><br><span class="line">Lock.tryLock(millis, unit)</span><br><span class="line">Condition.await(millis, unit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层方法：</span></span><br><span class="line">LockSupport.parkNanos(blocker, nanos)</span><br><span class="line">LockSupport.parkUntil(blocker, deadline)</span><br></pre></td></tr></table></figure>
<p>该状态一直保持到计时结束或接收到其他通知，随后线程会被被切换到 Runnable 状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span>    <span class="comment">// 等待某个指定的线程执行完毕</span></span></span><br><span class="line"><span class="function"><span class="comment">// 父线程等到调用该方法的子线程执行完毕才结束</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 等待指定的线程被终止或经过指定的时间</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span>    <span class="comment">// 休眠给定的毫秒数</span></span></span><br><span class="line"><span class="function"><span class="comment">// sleep 方法可能抛出 InterruptedException</span></span></span><br></pre></td></tr></table></figure>
<p><code>join()</code> 阻塞的是调用者所在的线程。因为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">// 永远等待下去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>概述：</p>
<ul>
<li>当前线程的 <code>wait()</code> 被调用后，当前线程的同步锁会被释放；调用当前线程 <code>join()</code> 的线程会被阻塞；</li>
<li>比如说 main() 方法调用 thread1.join()，阻塞的是 main() 方法所在的线程，即<strong>主线程</strong>，而不是 thread1。</li>
</ul>
<p>既然 wait() 被调用了，那么 notify() / notifyAll() 是在哪里被调用的？<br>答案在 JVM 里。底层代码在 <code>thread.cpp</code> 中，通过调用 native 方法 <code>notify()</code> 实现。</p>
<p>线程处于被阻塞或等待状态：暂时不活动，不执行任何代码，且消耗最少的资源。</p>
<p><strong>6</strong>. <strong>死亡</strong>（Dead / <strong>Terminated</strong>）</p>
<p>以下情况线程进入死亡态：</p>
<ul>
<li>线程执行完成（run() 正常退出）：自然死亡</li>
<li>未捕获到的异常事件终止了 run()：突然死亡</li>
<li>调用 stop() 杀死进程：<code>@Deprecated</code></li>
</ul>
<p>当一个线程被重新激活的时候，调度器会检查它的优先级是否比当前正在运行的线程更高；如有，则调度器从当前运行的线程中选择一个，剥夺它的运行权，转而执行新进程。</p>
<p>线程不可能长久处于被阻塞的状态中，必须从阻塞态中退出，且返回到就绪状态。</p>
<ul>
<li>如线程处于计时等待态（timed waiting），必须经过规定的毫秒数；</li>
<li>如线程调用 <code>wait()</code>，另一线程必须调用 <code>notify()</code> 或 <code>notifyAll()</code>；</li>
<li>如线程正等待另一线程拥有的对象锁，另一线程执行完所要做的事情之后，必须放弃该锁的所有权；</li>
<li>如线程正在等待输入或输出操作完成（阻塞操作），必须等待该操作完成。</li>
</ul>
<p><img src="/2021/08/02/java-threads/java-threads.png" alt></p>
<p>线程在阻塞态和运行态之间的切换：属于线程间通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread.<span class="function">State <span class="title">getState</span><span class="params">()</span>    <span class="comment">// 获得线程状态</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * NEW</span></span></span><br><span class="line"><span class="comment"><span class="function"> * RUNNABLE</span></span></span><br><span class="line"><span class="comment"><span class="function"> * BLOCKED</span></span></span><br><span class="line"><span class="comment"><span class="function"> * WAITING</span></span></span><br><span class="line"><span class="comment"><span class="function"> * TIMED_WAITING</span></span></span><br><span class="line"><span class="comment"><span class="function"> * TERMINATED</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span>    <span class="comment">// 确定某个线程是否活着</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如是就绪线程或阻塞线程：返回 true</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如仍是新建线程或死线程：返回 false</span></span></span><br><span class="line"><span class="comment"><span class="function"> * </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 注：</span></span></span><br><span class="line"><span class="comment"><span class="function"> *  无法确认 alive 线程是 runnable 状态还是 blocked 状态</span></span></span><br><span class="line"><span class="comment"><span class="function"> *  无法确认 runnable 线程是否已经是 running 状态</span></span></span><br><span class="line"><span class="comment"><span class="function"> *  无法区分 new 线程和 dead 线程</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="单个线程的操作"><a href="#单个线程的操作" class="headerlink" title="单个线程的操作"></a>单个线程的操作</h1><h2 id="已弃用操作"><a href="#已弃用操作" class="headerlink" title="已弃用操作"></a>已弃用操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span>    <span class="comment">// 暂停线程</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 弃用原因：</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如果调用该方法挂起一个持有锁的线程，那么这个锁在线程恢复之前不可用；</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 由此，调用该方法的线程试图获得同一个锁：导致死锁</span></span></span><br><span class="line"><span class="comment"><span class="function"> *    被挂起的线程等着被恢复；</span></span></span><br><span class="line"><span class="comment"><span class="function"> *    将其挂起的线程等着获得锁。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span>    <span class="comment">// 调用 suspend() 方法后用于恢复线程</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span>    <span class="comment">// 终止线程（终止所有未结束的方法，包括 run()）</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 弃用原因：</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 线程被终止时，会立即释放其持有的所有对象的锁：这样容易导致对象不一致</span></span></span><br><span class="line"><span class="comment"><span class="function"> * </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 由此可见当线程要终止另一个线程时，不知何时调用 stop() 才是安全的</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<p>因此有一个错误的说法：stop() 会导致某些对象被已停止的线程永久锁定。<br><strong>勘误</strong>：被停止的线程通过抛出 ThreadDeath 异常退出所有同步方法，因此实际上，该线程会释放所有内部锁。</p>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>可以理解为线程的一个标记位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向线程发送中断请求，请求成功后，该线程中断状态被设为 true</span></span><br><span class="line"><span class="comment"> * 中断状态是每个线程都具有的 boolean 标志，每个线程应随时检查该状态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如目前该线程正被一个 sleep()/wait() 调用阻塞了，此时调用 interrupt() 会抛出 InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 检查当前（正在执行该命令）线程是否被中断（静态方法）</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 先获取当前线程对象（Thread.currentThread()），再调用该方法</span></span></span><br><span class="line"><span class="comment"><span class="function"> *</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 副作用：会清除当前线程的中断状态，将其重置为 false</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 测试线程是否被中断</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 先获取当前线程对象（Thread.currentThread()），再调用该方法</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 该调用不改变线程的中断状态</span></span></span><br><span class="line"><span class="comment"><span class="function"> *</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 注：如线程被阻塞，则此时无法检测中断状态，会抛出 InterruptedException</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 因此如果循环调用 sleep() —— 需捕获 InterruptedException</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// 线程 sleep 的时候抛出异常</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// cleanup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理 <code>InterruptedException</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(delay);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在抛出 <code>InterruptedException</code> 之前，Java API 会先将中断状态清除（interrupted() 置为 <code>false</code>）。此时如果线程有依赖于中断状态的任务的话，将会受到影响。</p>
<p>可以通过在 Runnable 中自定义 boolean 标记来设定线程的中断与否。</p>
<p><br></p>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>Java 中的每一个线程均有一个优先级（<code>int</code> 类型），其高度依赖于系统：</p>
<ul>
<li>Java 的优先级会映射到宿主机平台的优先级上；</li>
<li>因此 Sun 提供的虚拟机，线程优先级会被忽略。</li>
</ul>
<p>每当线程调度器有机会选择新线程时：首选优先级高的线程。<br>如有高优先级线程未进入 Runnable 状态，低优先级线程永远不会被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span>    <span class="comment">// 设置线程优先级</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 必须在 Thread.MIN_PRIORITY 和 Thread.MAX_PRIORITY 之间</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 默认 Thread.NORM_PRIORITY</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 默认：线程继承父线程的优先级</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span>    <span class="comment">// 使当前线程处于让步状态</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如果其它与当前线程同样优先级的可运行线程存在，则那些线程接下来会被调度。</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> * 当前线程依旧是可执行（runnable）状态，具体来说是 runnable 中的 running 状态</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 其它线程会以竞争关系抢占资源</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> isDaemon)</span>    <span class="comment">// 将线程转换为守护线程（daemon thread）或用户线程</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 为其他线程提供服务，如计时线程</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 必须在线程启动（start()）前调用 setDaemon(true)</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 虚拟机不存在非 daemon 线程的时候就可以退出了</span></span></span><br><span class="line"><span class="comment"><span class="function"> * </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 注：守护线程应永远不要去访问固有资源：会在任何时候甚至在一个操作的中间发生中断</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 构建 daemon 线程时不能依靠 runnable 中的 finally 块来确保关闭或清理资源的逻辑，因为它不一定会被执行</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>我们知道，<a href="/2021/07/14/keywords/#synchronized"><code>synchronized</code></a> 和 <a href="/2021/07/14/keywords/#volatile"><code>volatile</code></a> 关键字是线程之间通过共享内存进行通信的方式。</p>
<p>另外，线程间通信还有基于等待 / 通知机制的相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Object;  <span class="comment">// 注：任何 Java 对象都带有这些方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>    <span class="comment">// 随机通知一个在对象上等待的线程，使线程从 wait() 方法返回，解除其阻塞状态</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 只能在同步方法或同步块（synchronized）内部使用</span></span></span><br><span class="line"><span class="comment"><span class="function"> * </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 能返回的前提是调用线程获取到了对象的锁</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如当前线程不是对象锁持有者：抛出 IllegalMonitorStateException</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 相当于调用 Condition.signal()</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span>    <span class="comment">// 通知所有在该对象上等待的线程，使它们从 wait() 方法返回，解除阻塞状态</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 只能在同步方法或同步块（synchronized）内部使用</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如当前线程不是对象锁持有者：抛出 IllegalMonitorStateException</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 相当于调用 Condition.signalAll()</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span>    <span class="comment">// 将线程置为等待（Waiting）状态，直到线程接到另外的线程的通知，或被中断</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 只能在同步方法中使用</span></span></span><br><span class="line"><span class="comment"><span class="function"> * </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 调用 wait() 后，会释放线程持有的该对象的同步锁</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如当前线程不是对象锁持有者：抛出 IllegalMonitorStateException</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 相当于调用 Condition.await()</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span></span><br><span class="line"><span class="function"><span class="comment">/** </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 将线程置为等待状态，直到接到通知或经过指定时间</span></span></span><br><span class="line"><span class="comment"><span class="function"> *</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 只能在同步方法中使用</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 如当前线程不是对象锁持有者：抛出 IllegalMonitorStateException</span></span></span><br><span class="line"><span class="comment"><span class="function"> * millis：毫秒数；nanos：纳秒数</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<p>比下面一段伪代码好的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (value != desired) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<p>及时性（sleep 时间越长，及时性越差）比伪代码好，开销（sleep 时间越短，开销越大）比伪代码低。</p>
<p>注：在通过条件判断是否进行等待 / 唤醒时，要注意“<strong>虚假唤醒</strong>”的情况：即线程从 blocked 到 ready 再到 running 没有进行判断。</p>
<p>造成虚假唤醒一般是使用 if 做判断导致；改成 while 做判断就好。</p>
<p>等待方（消费者）</p>
<ol>
<li>获取对象的锁</li>
<li>如条件不满足，则调用对象 wait()，被通知后仍然要检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<p>通知方（生产者）</p>
<ol>
<li>获取对象同步锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<h2 id="wait-和-notify-设计为-Object-方法的原因"><a href="#wait-和-notify-设计为-Object-方法的原因" class="headerlink" title="wait() 和 notify() 设计为 Object 方法的原因"></a>wait() 和 notify() 设计为 Object 方法的原因</h2><p>首先，wait() 和 notify() 不仅仅是普通方法或同步工具，更重要的是它们是 Java 中<strong>两个线程之间的通信机制</strong>。<br>在语言设计上的时候，如果不能通过 Java 关键字（例如 synchronized）实现，同时又要确保这个机制对每个对象可用, 那么 Object 类就是<strong>最合理的声明位置</strong>。</p>
<p>再者，Java 基于监视器 Monitor 的思想，每一个对象都有一个监视器，即<strong>每个对象都可上锁</strong>，这是在 Object 类而不是 Thread 类中声明 wait() 和 notify() 的另一个原因。</p>
<p><br></p>
<h1 id="方法比较"><a href="#方法比较" class="headerlink" title="方法比较"></a>方法比较</h1><p><code>wait()</code> v.s. <code>sleep()</code>：</p>
<p>首先，wait() <strong>与对象锁有关</strong>，会释放同步锁，而 sleep() 不释放同步锁。</p>
<p><strong>wait() 是 Object 的方法</strong></p>
<ul>
<li>可对任意一个对象调用；调用时一定会释放调用线程持有的对象锁，让调用线程进入等待此对象的等待池<ul>
<li>因此其依赖于 <code>synchronized</code> 关键字（<strong>必须在 <code>synchronized</code> 代码块中被调用</strong>）</li>
</ul>
</li>
<li>调用 wait() 时会将线程挂起，直到其他线程调用同一个竞争对象的 notify()（或 notifyAll()）去唤醒相关等待线程</li>
<li>被唤醒后，线程对象会进入对象锁池（lock pool），准备获得对象锁并进入 runnable 状态</li>
<li>适用范围：等待线程、数据库连接</li>
<li>另：wait(millis) —— 加上了超时时间，等待指定时间后会自动苏醒</li>
</ul>
<p><strong>sleep() 是 Thread 的静态方法</strong></p>
<ul>
<li>sleep(millis)：让线程休眠指定的时间，将执行机会转让给其他线程；但监控状态依然保持，线程会在休眠时间结束时恢复</li>
<li>即：sleep 的控制范围由当前线程决定，其并不依赖于 <code>synchronized</code> 关键字</li>
<li>sleep 不是 Object 的方法，不能改变对象的内部锁状态，只是让线程进入阻塞态</li>
<li>给其他线程执行机会的最佳方式，通常用在不需要等待资源情况下的阻塞</li>
</ul>
<p>wait() 涉及到线程之间的通信问题；而 sleep() 主要是线程的运行状态控制。</p>
<p>wait(millis) 和 sleep(millis)：</p>
<ul>
<li>都是等待指定时间后自动苏醒</li>
<li>调用 wait(millis) 的当前线程释放该同步监视器的锁定（释放锁）之后，可以不用 notify() 或 notifyAll() 方法把它唤醒。</li>
</ul>
<p><code>wait()</code> / <code>sleep()</code> v.s. <code>yield()</code>：</p>
<ul>
<li>调用 sleep() 或 wait() 后，线程被阻塞，进入 blocked 状态</li>
<li>调用 yield() 后，线程进入 runnable 中的 running 状态</li>
</ul>
<p><code>wait()</code>  v.s. <code>join()</code>：</p>
<ul>
<li>wait() 体现线程互斥，join() 体现线程同步</li>
<li>wait() 作用在对象上，join() 作用在线程上</li>
<li>wait() 必须由其他线程调用 notify() / notifyAll() 进行解锁</li>
<li>join() 不需要其他线程唤醒：只要被等待线程执行完毕，当前线程自动变为 runnable 状态</li>
<li>join() 用途：子线程完成业务逻辑之前，主线程一直等待直到所有子线程执行完毕。</li>
</ul>
<p><br></p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>我们使用 <a href="/2021/07/14/keywords/#synchronized">synchronized</a> &amp; <a href="/2021/07/14/keywords/#volatile">volatile</a>，本质上是线程之间数据的共享：</p>
<ul>
<li>需要严格限制变量的访问：竞争、加锁、释放锁…</li>
<li>复杂度比较高</li>
</ul>
<p>另外，JDK 还提供了另一种处理数据同步的方式：<code>ThreadLocal</code>。顾名思义，就是线程的局部变量。</p>
<p>与 synchronized 相反，ThreadLocal 关注的是线程之间数据的隔离；<br>每个 ThreadLocal 实例存储着只能被该线程访问和修改的变量，其他线程无法访问，这样就隔离了多个线程对数据的共享，避免共享变量。</p>
<p>除了 ThreadLocal 之外，Java 还提供了<a href="/2021/08/22/java-lock">锁机制</a>实现数据同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ThreadLocal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建, 无默认值</span></span><br><span class="line">ThreadLocal&lt;String&gt; strThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带默认值创建</span></span><br><span class="line">ThreadLocal&lt;Long&gt; longThreadLocal = <span class="keyword">new</span> longThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Long(<span class="number">101</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 提供初始值时应覆盖该方法</span></span></span><br><span class="line"><span class="function"><span class="comment">// 默认返回 null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span>  <span class="comment">// 得到线程当前值</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如首次调用，会调用 initialValue 方法</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span>  <span class="comment">// 为该线程设置新值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span>  <span class="comment">// 删除对应线程的值</span></span></span><br></pre></td></tr></table></figure>
<p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; df =</span><br><span class="line">    <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);  <span class="comment">// SimpleDateFormat 非线程安全，应用在并发场景中可以使用 ThreadLocal</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据：</span></span><br><span class="line">String dateStamp = df.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>Thread</code>：其实例持有一个成员变量 —— ThreadLocalMap 实例。</p>
<ul>
<li>ThreadLocalMap 是 ThreadLocal 类的内部类：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>ThreadLocal.ThreadLocalMap</code>：</p>
<ul>
<li>定义了内部类 <code>Entry</code>：继承自 <code>WeakReference</code> 类，泛型为 ThreadLocal：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由此我们可以得知，ThreadLocal 是以 ThreadLocal 对象为键，以任意对象为值的存储结构。</li>
</ul>
<p>设值操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 返回线程持有的 ThreadLocalMap 实例（为成员变量 threadLocals） **/</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 默认的初值为空 **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建 ThreadLocalMap, 设值为：&lt;当前 ThreadLocal 实例, 值&gt;, 并让线程持有该 ThreadLocalMap 实例 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 设值 **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();  <span class="comment">// 获取当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);  <span class="comment">// 获取线程所持有的 ThreadLocalMap 实例</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)  <span class="comment">// 如果 map 已创建（回顾上文的 Thread 代码：threadLocals 可能为空）</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);  <span class="comment">// 设值 &lt;当前 ThreadLocal 实例, 变量值&gt;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);  <span class="comment">// 创建 map &lt;当前 ThreadLocal 实例, 变量值&gt;，线程持有该 map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>取值操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 设默认值 **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();  <span class="comment">// 除非子类重写，否则默认的初值为空</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);  <span class="comment">// 重设 &lt;ThreadLocal 实例自身, 变量&gt;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);  <span class="comment">// 创建 map，并存入&lt;当前线程, 变量&gt;</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 取值 **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();  <span class="comment">// 当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);  <span class="comment">// 当前线程所持 map</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// map 不为空时，以当前 ThreadLocal 实例为 key 取 Entry，并返回值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T) e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(); <span class="comment">// 如果 map 或 entry 为空：返回默认的初值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清空操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());  <span class="comment">// 获取当前线程所持 map</span></span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);  <span class="comment">// 如果 map 不为空, 清理以当前 ThreadLocal 实例为 key 的 Entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小结：</p>
<p>往 ThreadLocal 设值：</p>
<ol>
<li>从当前线程获取其持有的 ThreadLocalMap 实例</li>
<li>将 ThreadLocalMap 实例的 key 设为 ThreadLocal 实例自身，value 为要存储的变量</li>
<li>如果没有则创建 ThreadLocalMap 实例，同样设置 key 和 value，并让当前线程持有该 ThreadLocalMap 实例</li>
</ol>
<p>从 ThreadLocal 取值：</p>
<ol>
<li>读取当前线程所持 ThreadLocalMap 实例成员变量；</li>
<li>再从该 ThreadLocalMap 实例中以当前 ThreadLocal 实例为 key 找到对应的 value</li>
</ol>
<p>当使用 ThreadLocal 保存变量，其保存在 ThreadLocalMap 中的变量只有持有该 map 的变量可以访问。<br>如果想要子线程也可以访问数据，我们可以使用 <code>InheritableThreadLocal</code>：其保存的变量不仅当前线程可以访问，还可以在子线程中被访问，从而实现变量传递。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    Thread root = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        threadLocal.set(<span class="string">&quot;ray&quot;</span>);</span><br><span class="line">        Thread leaf = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        leaf.start();</span><br><span class="line">    &#125;);</span><br><span class="line">    root.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 ThreadLocal 会导致内存泄漏吗？</p>
<p><strong>表象</strong>是这样的：</p>
<ul>
<li>使用 ThreadLocal 保存变量时，线程持有 ThreadLocalMap 实例</li>
<li>线程由线程池管理时：线程存在复用，ThreadLocalMap 实例不会消失<ul>
<li>ThreadLocalMap 中 Entry 的 key（ThreadLocal 实例）和 value 会被一直持有</li>
<li>导致内存泄漏</li>
</ul>
</li>
</ul>
<p>实际</p>
<ul>
<li>key 并非强引用的 ThreadLocal 实例，而是指向该实例的<strong>弱引用</strong></li>
<li>一个对象失去所有强引用，只有弱引用时：该对象会被 GC 标记为可回收</li>
<li>ThreadLocal 实例 key 被回收后，ThreadLocalMap 中会存在 key 为 null 的 Entry<ul>
<li>同时 get / set / remove 方法均会清理 key 为 null 的 Entry</li>
</ul>
</li>
<li>由此基本避免内存泄漏，但开发人员仍会在使用完 ThreadLocal 后手工调用 remove 进行清理</li>
</ul>
<p>应用场景：</p>
<ul>
<li>数据库连接</li>
<li>Session 管理</li>
<li>事务管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span>  <span class="comment">// 返回特定于当前线程的 Random 类实例</span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Java-程序本身就是多线程的进程"><a href="#Java-程序本身就是多线程的进程" class="headerlink" title="Java 程序本身就是多线程的进程"></a>Java 程序本身就是多线程的进程</h1><p>只有一个 <code>main</code> 方法的 Java 类，通过 jmx 命令查看线程的时候，会有如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[4] Signal Dispatcher  <span class="comment"># 分发处理发送 JVM 信号的线程</span></span><br><span class="line">[3] Finalizer  <span class="comment"># 调用对象 finalize() 的线程</span></span><br><span class="line">[2] Reference Handler  <span class="comment"># 清除 Reference 的线程</span></span><br><span class="line">[1] main  <span class="comment"># main 线程，用户程序入口</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2022/05/08/java-hashmap/</url>
    <content><![CDATA[<p>HashMap 在 Java 编程中的出镜率相当高，是 Map 接口最常见的实现类。</p>
<span id="more"></span>
<p>这里涉及到一个基本的概念：</p>
<h1 id="什么是-Hash？"><a href="#什么是-Hash？" class="headerlink" title="什么是 Hash？"></a>什么是 Hash？</h1><p>直译为“哈希”，意译为“散列”，是根据 Hash 算法对某个对象的实例域进行序列化，产生一个整数，得到的序列化结果被称为哈希值，或<strong>散列码</strong>（hash code）。</p>
<p>不同数据域的对象对应会产生不同的散列码。</p>
<p>给一个集合里面的所有对象计算散列码，我们称这个对象为散列表（hash table）。<br>散列表若要存放自定义类的时候，需实现该类的 <code>hashCode()</code> 方法（该方法应与 <code>equals()</code> 兼容）。</p>
<h2 id="Java-中的实现"><a href="#Java-中的实现" class="headerlink" title="Java 中的实现"></a>Java 中的实现</h2><p>在 Java 中，散列表使用<strong>链表数组</strong>实现，数组中的每个链表被称为<strong>桶</strong>（bucket）。</p>
<p>要想查找表中对象的位置，需要先计算散列码，与桶的总数取余，得到保存该元素的桶的索引。根据索引就可以得到对应的值。</p>
<p>有的时候会遇到桶被占用的情况，我们称之为<strong>散列冲突</strong>（hash collision）；此时需要将新对象与桶中的所有对象进行比较，查看是否已经存在了这个对象。<br>如果存在了相同的 key 的元素，就将其 value 更新；否则将该元素作为新的<strong>头元素</strong>加入桶中（头插法）。</p>
<p>若散列表太满，散列表需要再散列（rehash）：创建一个桶更多的表，并将所有元素插入到新表中，再丢弃原来的表。<br>散列表的<strong>负载因子</strong>（<strong>load factor</strong>）决定何时对散列表进行再散列。比如将 load factor 设为 0.75（默认值），而表中超过 75% 位置已经填入了元素，那么在 rehash 的时候，会用双倍的桶数自动进行再散列。</p>
<p>如果散列码设计合理且随机分布，桶的数目足够大，比较次数就会减少。<br>想更多地控制散列表的运行性能，则需要指定一个初始的桶数，用于收集具有相同散列值的桶的数目：</p>
<ul>
<li>如大致知道最终会有多少个元素要插入到散列表中，便可设置桶数，通常为预计元素个数的 75% - 150%。</li>
</ul>
<h1 id="HashMap-的实现"><a href="#HashMap-的实现" class="headerlink" title="HashMap 的实现"></a>HashMap 的实现</h1><p>Map 接口继承自 AbstractMap，迭代时不保证元素顺序，线程不安全。</p>
<p>当散列冲突过于频繁的时候，HashMap 会退化为链表，或红黑树（Java 8+）。</p>
<h2 id="Java-7-的-HashMap-实现"><a href="#Java-7-的-HashMap-实现" class="headerlink" title="Java 7 的 HashMap 实现"></a>Java 7 的 HashMap 实现</h2><p>桶的实现：桶中的元素以<strong>链表</strong>形式组织起来（数组+链表）。</p>
<p><img src="/2022/05/08/java-hashmap/hashmap-java7.jpg" alt></p>
<h3 id="元素类-HashMap-Entry"><a href="#元素类-HashMap-Entry" class="headerlink" title="元素类 HashMap.Entry"></a>元素类 <code>HashMap.Entry</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Entry 直接实现了 Map 接口的 Entry 内部接口，没有使用 AbstractMap 提供的 SimpleEntry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> K key;  <span class="comment">// key 设值后不可变</span></span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;  <span class="comment">// 各个 Entry 之间以单向链表组织</span></span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它方法</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键方法：</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如对象为 null：返回 0，否则调用 native 的 hashCode() 求值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());  <span class="comment">// key 散列码和 value 的散列码按位异或</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map.Entry e = (Map.Entry) o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;  <span class="comment">// 比较当前对象和目标对象的 key</span></span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2))) &#123;</span><br><span class="line">                <span class="comment">// 比较当前对象和目标对象的 value</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常量及变量（数据结构）"><a href="#常量及变量（数据结构）" class="headerlink" title="常量及变量（数据结构）"></a>常量及变量（数据结构）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">// a.k.a. 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的最大容量，2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 0.75 在时间和空间成本之间提出了一个很好的折衷方案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放元素</span></span><br><span class="line"><span class="comment">// 每一个索引存放一个桶（链表）的头元素，根据需要可以扩容，其长度只能为 0 或 2^n</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 Set 的方式对 Entry 进行缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示 HashMap 中有实际多少个 Key-Value 对的元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示下次变容后的 size 大小，即实际容量 * loadFactor</span></span><br><span class="line"><span class="comment">// 初始 threshold 可在构造方法内指定（initialCapacity）</span></span><br><span class="line"><span class="comment">// 若没有指定则为 DEFAULT_INITIAL_CAPACITY</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子，可在构造方法中指定，如没有指定则为 DEFAULT_LOAD_FACTOR</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><p><strong><code>hash()</code></strong></p>
<p>其实我们无需纠结于如何 hash，只需知道根据不同的 key 会将 entry 分配到不同或者相同的数组索引下，且分配均匀。</p>
<p>但是循例还是看一看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>indexFor()</code></strong></p>
<p>根据散列值和数组长度计算数组索引，从而确定 Entry 将要，或者已经被放在哪一个桶：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">// 取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容 <strong><code>resize()</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">     ...  <span class="comment">// 其它代码</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当新容量与负载因子的乘积（newCapacity * loadFactor）小于默认的最大容量时，新阈值 threshold 会变为这个乘积；否则变为默认的最大容量，并不再扩容。</p>
<p><strong><code>addEntry()</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">// 若当前容量达到了 threshold，且元素将要添加进去的桶不为空（出现了哈希冲突）：</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);  <span class="comment">// 先将容量扩为原来两倍</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;  <span class="comment">// 计算散列值</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);  <span class="comment">// 再确定 Entry 将要分配到哪个索引下的桶</span></span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];  <span class="comment">// 定位桶，取出目前桶的头元素 e</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);  <span class="comment">// 头插法，e 变为新头元素的 next</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存放-put"><a href="#存放-put" class="headerlink" title="存放 put()"></a>存放 <strong><code>put()</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ...  <span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);  <span class="comment">// 将 key-value 放在索引为 0 的桶内</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  <span class="comment">// 确定 Entry 的桶，也就是数组的索引</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  <span class="comment">// 遍历桶内元素</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  <span class="comment">// 找到了相同元素</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;  <span class="comment">// 返回旧元素的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到相同元素的话：</span></span><br><span class="line">    ...  <span class="comment">// 先执行其他代码</span></span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 将新键值对插入头部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取-get"><a href="#获取-get" class="headerlink" title="获取 get()"></a>获取 <strong><code>get()</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 indexFor() 确定 key 对应的元素所在的桶，如果桶不为空则遍历桶上的元素</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 找到对应的元素，返回 Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))</span><br><span class="line">           )</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 Key 的 hash 值找不到桶：则不存在该 Key 对应的 Entry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// 获取 Entry 后返回其 Value</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java-8-的-HashMap-实现"><a href="#Java-8-的-HashMap-实现" class="headerlink" title="Java 8 的 HashMap 实现"></a>Java 8 的 HashMap 实现</h2><p>桶的实现：首先以链表形式组织；当元素数量超过阈值时，变成<strong>红黑树</strong>的形式组织（数组+链表/红黑树）。</p>
<p><img src="/2022/05/08/java-hashmap/hashmap-java8.jpg" alt></p>
<p>在当前版本，<code>HashMap.Node</code> 替代了原来的 Entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);  <span class="comment">// 与 7- 区别不大</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))  <span class="comment">// 与 7- 区别不大</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 7- 相似的是：</p>
<ul>
<li>Node 直接实现了 Map.Entry，没有使用 AbstractMap 提供的对 Entry 的内部实现类；</li>
<li>一个 Node 的 key 值被设置之后不可变（final）；</li>
<li>每个 Node 之间以单向链表的形式组织起来，前一个 Node 持有下一个 Node 的引用</li>
<li>hashCode() 计算方法 一致</li>
<li>Node 的 equals() 同样调用了 Objects 类的 equals()，分别比对当前对象和目标对象的 Key 和 Value<ul>
<li>Objects 的 equals() 中，只有当两个对象均为 null 或 “==” 成立时才返回 true</li>
</ul>
</li>
</ul>
<h3 id="常量及变量（数据结构）-1"><a href="#常量及变量（数据结构）-1" class="headerlink" title="常量及变量（数据结构）"></a>常量及变量（数据结构）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 Node 数组存放桶及元素，根据需要可以扩容，长度只能为 0 或者 2^n</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  <span class="comment">// 与 7- 区别不大，只是类型变了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当一个桶中的元素数达到该值时，就将该桶从链表（若仍是链表）转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当一个桶中的元素被移除时，若其中的元素数达到该值时，将桶从红黑树（若已是红黑树）转化为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表只有当数组的长度（桶的数量）达到该值时，链表转换为红黑树的情况才会发生</span></span><br><span class="line"><span class="comment">// 为避免扩容和树形化的冲突，至少为 TREEIFY_THRESHOLD 的 4 倍</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量及常量与 Java 7 相同</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="关键方法-1"><a href="#关键方法-1" class="headerlink" title="关键方法"></a>关键方法</h3><p><strong><code>hash()</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 key 为 null 时返回 0；否则将 key 的 hashCode 与其 hashCode 无符号右移 16 位（忽略符号位，空位以 0 补齐）的结果进行按位异或运算。</p>
<h3 id="存放-put-1"><a href="#存放-put-1" class="headerlink" title="存放 put()"></a>存放 <code>put()</code></h3><p>与 Java 7 相比发生了很大变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>putVal()</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  <span class="comment">// 注：后两个参数在这次源码分析中没用到</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;  <span class="comment">// 定位桶的数量</span></span><br><span class="line">    Node&lt;K,V&gt; p;  <span class="comment">// 定位桶中的头元素</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是空的 HashMap（table 为 null 或空）：</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 先 resize 为默认初始容量，并得到扩容后的数组长度</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组最大索引（n-1）同 key 的 hash 值按位与运算，得到存放元素的索引（i）</span></span><br><span class="line">    <span class="comment">// 取头元素 p = tab[i]，如果该索引没有元素（tab[i] == null），则在该索引处新建元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  <span class="comment">// 此处判断与 Java 7 的 indexFor() 一样</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该索引已经存在元素（tab[i] != null），说明存在哈希冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 入参 key 与该索引头元素（p）的相同，即入参元素为新的头元素，将更新该元素的 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 注：由此可知 key 对象需重写 hash() 和 equals()</span></span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，若与头元素不同：</span></span><br><span class="line">        <span class="comment">// 如果该索引的元素（头元素）已经是红黑树结构：</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 调用红黑树的 putTreeVal()，获取元素（遍历找不到入参 key 对应的元素时，用于更新）</span></span><br><span class="line">            <span class="comment">// 或直接新建元素返回 null（遍历找不到入参 key 对应的元素时）</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 如果该索引的元素是链表结构：</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从该索引的头元素开始，遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果：当前元素的下一个元素为 null，即当前元素为该索引下链表的尾元素</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 则新建入参 key 和 value 的元素，同时处理好链条关系（尾插法）</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 插入元素后的重整：</span></span><br><span class="line">                    <span class="comment">// 如果当前链表的节点数不小于阈值（8），则将该链表转为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)  <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果：当前元素的下一个元素不为 null：</span></span><br><span class="line">                <span class="comment">// 成功获取到了需要更新的元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 没获取到元素，元素还不存在，继续找</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for 循环结束，此时 e 无论如何都已经被定位到，或者被添加到 map 中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了入参 key 对应的元素 e，更新其 value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">              e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 put 后的容量大于 threshold，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    ...  <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="comment">// 如果是新建元素，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知当桶内元素达到一定值（8）时，桶中元素的数据结构从链表变为<strong>红黑树</strong>。以下是树化的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> hash)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)  <span class="comment">// 桶容器为空，或者桶的数量不大于 64</span></span><br><span class="line">        resize();  <span class="comment">// 优先扩容</span></span><br><span class="line">    <span class="comment">// 通过 hash 求出桶的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>)  <span class="comment">// 桶的数量大于或等于 64，且桶元素不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将每个节点包装成 TreeNode</span></span><br><span class="line">            TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将所有 TreeNode 连接在一起，此时只是链表结构</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 对 TreeNode 链表进行树化</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知树化的条件有两个：</p>
<ul>
<li>一个桶（链表形态）中的元素数量不小于 8</li>
<li>HashMap 中不少于 64 个桶（数组长度不小于 64）</li>
</ul>
<p>需要两个条件约束的原因在于：因为如果桶数量过少，又发生了严重的 hash 冲突，则根本原因是因为<strong>桶的数量太少了</strong>，此时进行树化的意义不大，需要优先扩容（resize()）。</p>
<h3 id="获取-get-1"><a href="#获取-get-1" class="headerlink" title="获取 get()"></a>获取 <code>get()</code></h3><p>实现相比 Java 7 的会复杂一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合并了 Java 7- 的 indexFor()，直接传入 key 的散列值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数组不为空，且根据 key 的 hash 值获取的桶不为空（头元素非 null）</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 key 对应的元素是该桶的头元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;  <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是头元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该桶已经是红黑树结构</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 调用获取红黑树节点的方法 getTreeNode()</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果该桶仍是链表结构，遍历该链表，如果找到则返回该 Node</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 去掉了 indexFor()，这里直接计算 key 的 hash 值，并传给 getNode()</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不同 JDK 下对于 HashMap 的实现有以下不同之处：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + <b>红黑树</b></td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：<code>inflateTable()</code></td>
<td>直接集成到扩容函数 <code>resize()</code> 中</td>
</tr>
<tr>
<td>hash 值的计算方式</td>
<td>扰动处理 = 9 次扰动 = 4 次位运算 + 5 次异或运算</td>
<td>扰动处理 = 2 次扰动 = 1 次位运算 + 1 次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放于数组；<br>有冲突时，存放于链表</td>
<td>无冲突时，存放于数组；<br>有冲突且链表长度 &lt; 8，存放于单链表；<br>有冲突且链表长度 &gt; 8，树化并存放于红黑树</td>
</tr>
<tr>
<td>插入数据的规则</td>
<td>头插法（先将原位置数据后移一位，再将数据插入到该位置）</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法进行计算（hashChde -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>按照扩容后的规律计算（扩容后的位置 = 原位置 / (原位置 + 旧容量)）</td>
</tr>
</tbody>
</table>
</div>
<h1 id="HashMap-ConcurrentHashMap-v-s-Hashtable"><a href="#HashMap-ConcurrentHashMap-v-s-Hashtable" class="headerlink" title="HashMap / ConcurrentHashMap v.s. Hashtable"></a>HashMap / ConcurrentHashMap v.s. Hashtable</h1><h2 id="HashMap-v-s-Hashtable"><a href="#HashMap-v-s-Hashtable" class="headerlink" title="HashMap v.s. Hashtable"></a>HashMap v.s. Hashtable</h2><p><strong>相近之处</strong></p>
<p>HashMap 和 Hashtable 均实现了 Map 接口，元素存放都是无序的。</p>
<p><strong>区别</strong></p>
<ul>
<li>Hashtable 继承自 <code>Dictionary</code> 类；而 HashMap 继承自 <code>AbstractMap</code> 抽象类</li>
<li>Hashtable 是线程安全的类，所有元素操作都是 synchronized 修饰的；HashMap 非线程安全<ul>
<li>因此在执行单线程操作的时候 Hashtable 比 HashMap 慢</li>
</ul>
</li>
<li>Hashtable 不可接受键或值为 null 的项；HashMap 可以接受 null 的键值对（key 和 value 为 null）</li>
<li>Hashtable 保留了 HashMap 已经去除的 contains() 方法</li>
<li>Hashtable 除了 HashMap 同样拥有的 Iterator 实现方式之外，还保留了 Enumeration 方式<ul>
<li>HashMap 提供 keySet 视图的 fail-fast 遍历：当其他线程往 HashMap 增加或删除元素时，会抛出 ConcurrentModificationException</li>
<li>Hashtable 提供对 key 的 Enumeration 遍历：不支持 fail-fast</li>
</ul>
</li>
<li>求 hashCode 的方法不同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hashtable 的 put：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap-v-s-Hashtable"><a href="#ConcurrentHashMap-v-s-Hashtable" class="headerlink" title="ConcurrentHashMap v.s. Hashtable"></a>ConcurrentHashMap v.s. Hashtable</h2><p><strong>相同</strong>：线程安全</p>
<p><strong>不同</strong></p>
<p>Hashtable 每次操作都会锁住整个表结构，导致每次只能有一个线程访问 Hashtable 对象；<br>而 ConcurrentHashMap 只锁住某个节点，只有在涉及到 size 的操作才会锁住整个表结构。</p>
<p>ConcurrentHashMap 为 HashTable 的替代集合类。</p>
<h1 id="HashMap-v-s-TreeMap"><a href="#HashMap-v-s-TreeMap" class="headerlink" title="HashMap v.s. TreeMap"></a>HashMap v.s. TreeMap</h1><p>HashMap 在插入、删除和定位元素等操作占优；</p>
<p>而 TreeMap 在遍历有序的 key 集合时占优。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合类</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程执行器（Executor 框架）</title>
    <url>/2021/09/02/java-executors/</url>
    <content><![CDATA[<p>Java 绝不只是通过几个零散的基础类来实现多线程编程，就能给并发场景提供强大的保障的。</p>
<span id="more"></span>
<p>在并发编程的应用场景中，总不能每需要并发管理的时候就去 <code>new Thread()</code>，毕竟创建新线程有一定的代价。</p>
<p>如应用程序会有大量生命期很短的线程出现，我们应该使用<strong>线程池</strong>（thread pool）去管理线程：</p>
<ul>
<li>线程池中包含很多准备运行的空闲线程</li>
<li>将 <code>Runnable</code> 对象交给线程池，就会有一个线程去调用它的 <code>run()</code> 方法</li>
<li>run() 方法退出后，线程不会死亡，而是在池中准备为下一个请求提供服务</li>
</ul>
<p>使用线程池能提高线程的可管理性以及响应的速度，而且能减少并发线程数目，降低资源消耗。</p>
<p><br></p>
<p>Java 线程池相关的接口和类集中在 <code>java.util.concurrent</code>（JUC）包中。</p>
<h1 id="基础：Executor-amp-ExecutorService"><a href="#基础：Executor-amp-ExecutorService" class="headerlink" title="基础：Executor &amp; ExecutorService"></a>基础：<code>Executor</code> &amp; <code>ExecutorService</code></h1><p>接口概况：</p>
<p><img src="/2021/09/02/java-executors/executor-class-diagram.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.5 引入 Executor 接口的初衷是为了解耦任务本身和任务的执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NotNull</span> Runnable command)</span></span>;  <span class="comment">// 根据实现不同，具体执行任务的方式也会不一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Executor 的增强</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交 Callable 对象</span></span><br><span class="line">    <span class="comment">// 返回 Future 对象中包含 Callable 的执行结果</span></span><br><span class="line">    <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交 Runnable 对象</span></span><br><span class="line">    <span class="comment">// 通过 Future.get() 获取 Runnable 完成后指定的 result 对象</span></span><br><span class="line">    <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Future.get() 完成时简单返回 null</span></span><br><span class="line">    <span class="comment">// 提交指定的任务并执行</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭服务，将线程池状态设置为 shutdown</span></span><br><span class="line">    <span class="comment">// 先完成已提交的任务，中断所有没在执行的任务，不再接受新任务</span></span><br><span class="line">    <span class="comment">// 当所有任务完成：线程死亡</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程池状态设置为 stop</span></span><br><span class="line">    <span class="comment">// 取消尚未开始的所有任务，并试图中断正在运行的线程</span></span><br><span class="line">    <span class="comment">// 返回等待执行任务的列表</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown() 和 shutdownNow() 都是逐个调用线程的 interrupted() 终止线程的，因此不响应中断的线程，线程池永远不会被 shutdown</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行给定的任务列表，返回其中一个任务的结果</span></span><br><span class="line">    <span class="comment">// 无法确切知道返回的是哪个任务</span></span><br><span class="line">    <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;Callable&lt;T&gt;&gt; tasks)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;  <span class="comment">// 超时则抛出 TimeoutException 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行给定的任务列表，以 List 方式返回所有任务的结果</span></span><br><span class="line">    List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;Callable&lt;T&gt;&gt; tasks);</span><br><span class="line">    List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TineUnit unit);  <span class="comment">// 超时则抛出 TimeoutException 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起阻塞，直至所有 task 在请求 shutdown 后完成</span></span><br><span class="line">    <span class="comment">// 若在完成前超时，返回 false</span></span><br><span class="line">    <span class="comment">// 若线程被中断，抛出 InterruptedException</span></span><br><span class="line">    <span class="comment">// 调用 shutdown 之后应该调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，相对于 Executor，ExecutorService 增强了对任务的控制和生命周期管理：</p>
<ul>
<li>关闭执行器，禁止任务的提交（<code>shutdown|Now()</code>）</li>
<li>监视执行器的状态（<code>isShutDown()</code>, <code>isTerminated()</code>）</li>
<li>提供对异步任务的支持（<code>submit()</code>）</li>
<li>提供对批处理任务的支持（<code>invoke|[All|Any]()</code>）</li>
</ul>
<p>由上述可见线程池的执行方法：</p>
<ul>
<li><code>execute()</code>：异步方法，不返回运行结果，用于提交不需要返回值的任务</li>
<li><code>submit()</code>：异步方法，返回运行结果，用于提交需要返回值的任务</li>
<li><code>invoke()</code>：同步方法，返回运行结果</li>
</ul>
<h2 id="使用方法小结"><a href="#使用方法小结" class="headerlink" title="使用方法小结"></a>使用方法小结</h2><ol>
<li>调用 <code>submit()</code> / <code>execute()</code> 提交 Runnable 或 Callable 对象</li>
<li>如想取消任务，或如果提交 Callable 对象，则需保存好返回的 Future 对象</li>
<li>当不再提交任何任务时调用 <code>shutdown()</code></li>
</ol>
<p>使用例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span> (Future&lt;T&gt; result : results)</span><br><span class="line">    processFurther(result.get());</span><br></pre></td></tr></table></figure></p>
<p>同步执行任务的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步执行任务的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();  <span class="comment">// 线程池的雏形</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现类概况：ThreadPoolExecutor"><a href="#实现类概况：ThreadPoolExecutor" class="headerlink" title="实现类概况：ThreadPoolExecutor"></a>实现类概况：<code>ThreadPoolExecutor</code></h2><p><code>ThreadPoolExecutor</code> 是 Java 并发编程中最常用的线程池执行器，是了解 Java 并发编程的重点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractExecutorService 实现了 ExecutorService 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> taskCount; <span class="comment">// 任务数量</span></span><br><span class="line">    <span class="keyword">int</span> completedTaskCount;  <span class="comment">// 已完成的任务数量</span></span><br><span class="line">    <span class="keyword">int</span> largestPoolSize;  <span class="comment">// 曾经创建的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 设置 core 线程是否超时</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 返回当前活跃的线程数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 返回线程池当前最大的线程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展线程池：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造参数</strong>：</p>
<p><strong>1</strong>. <code>corePoolSize</code>：保留在线程池内的最小线程数，确定线程池的基本大小</p>
<ul>
<li>线程池内的线程可以全都是 idle 状态；</li>
<li>当前线程（无论是否在工作）数量若少于 corePoolSize，线程池会新建一个线程执行任务；</li>
<li>可通过 setter 方法改变；</li>
<li>可通过 <code>preStartCoreThread()</code> 或 <code>preStartAllCoreThreads()</code> 提前启动一个或多个线程，使其进入等待状态，成功则返回 true</li>
</ul>
<p><strong>2</strong>. <code>maximumPoolSize</code>：线程池所允许的最大线程数</p>
<ul>
<li>corePoolSize = maximumPoolSize 时，创建的是固定大小的线程池；</li>
<li>可通过 setter 方法改变，可以设为 <code>Integer.MAX_VALUE</code></li>
<li>如果使用的阻塞队列是无界队列的话，这个参数就不会起到什么效果了</li>
</ul>
<p><strong>3</strong>. <code>keepAliveTime</code>：超过 corePoolSize 数量的其他 idle 线程所能存活的最长时间</p>
<ul>
<li>超过这个时间的 idle 线程会被销毁</li>
<li>可以设置为最大长整型值 <code>Long.MAX_VALUE</code>（TimeUnit 为纳秒），可通过 setter 调整</li>
<li>一般应用在 corePoolSize 数目之外的线程，allowCoreThreadTimeOut() 也会采用此值</li>
<li>如果任务多，执行时间短，可以将这个值调大，以节省资源</li>
</ul>
<p><strong>4</strong>. <code>unit</code> idle 线程的存活时间单位</p>
<p><strong>5</strong>. <code>workQueue</code>：存放等待执行的 task 的<a href="/2021/10/02/java-concurrent-collections/#阻塞队列">阻塞队列</a>；只保存 runnable 对象</p>
<ul>
<li>如果线程池中的核心线程数少于 corePoolSize：线程池会直接增加一个线程</li>
<li>若多于或等于 corePoolSize，多出来的部分会进入队列；若不能进入队列，则在 maximumPoolSize 规定的最大范围内新建</li>
</ul>
<p>队列分发的方式：</p>
<ol>
<li>直接分发：使用 SynchronousQueue 将 task 立即分发给线程池中的线程</li>
<li>无界队列：线程池最多只有 corePoolSize 个线程工作，最大值无效</li>
<li>有界队列：比如 <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code></li>
</ol>
<p><strong>6</strong>. <code>handler</code>：饱和策略（拒绝策略）</p>
<ul>
<li>设置线程池或者队列空间满载导致阻塞的时候，线程池所要采用的拒绝（reject）handler 对象</li>
<li>默认值是 <code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务，并抛出 <code>RejectedExecutionException</code> 异常</li>
</ul>
<p>其他可以设置的 handler：</p>
<ul>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：如线程池未关闭，则直接在调用者线程完成这个任务</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：取消队列头（最老）的 task，放入新任务再执行</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新的任务，直接丢弃</li>
<li>可自定义其他的 handler</li>
</ul>
<p><strong>7</strong>. <code>threadFactory</code>：用来设置创建新线程的工厂对象</p>
<ul>
<li>通过传入指定工厂对象来设置线程的名称、线程组、优先级等</li>
<li>如果传入的是 null，则采用默认的 <code>Executors.defaultThreadFactory()</code></li>
</ul>
<p><strong>工作流程</strong>：</p>
<p><strong>使用者</strong>提交任务</p>
<p><img src="/2021/09/02/java-executors/threadpoolexecutor-execution.png" alt></p>
<ol>
<li>如线程池中的线程数小于 corePoolSize：创建新线程（需要获取全局锁），直接执行任务</li>
<li>如线程池中的线程数大于 corePoolSize：暂时将任务存储到 workQueue 中等待执行</li>
</ol>
<p>到了 workQueue 也满了的时候：</p>
<ol>
<li>线程数小于最大线程池数 maximumPoolSize 时，会创建新线程（需要获取全局锁）执行任务</li>
<li>线程数大于或等于最大线程池数 maximumPoolSize 时，会执行设置的饱和策略</li>
</ol>
<p>再结合实现原理解释一下上面的步骤：</p>
<p><img src="/2021/09/02/java-executors/threadpoolexecutor-p1.png" alt></p>
<p>制定这一系列流程的原因是为了减少线程的创建，避免获取全局锁的操作。</p>
<p>以上为新任务提交到线程池时的步骤，而线程池执行任务的步骤如下：</p>
<p><img src="/2021/09/02/java-executors/threadpoolexecutor-p2.png" alt></p>
<ol>
<li>执行 execute() 的时候，线程池的线程会执行任务；</li>
<li>与此同时，空闲线程也会不断去阻塞队列中取任务执行（take(), poll()）。</li>
</ol>
<p>源码简析（基于 Java 8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span>  // 扩展 <span class="title">AQS</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">// 循环获取工作队列里的任务来执行</span></span><br><span class="line">                w.lock();</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mainLock.lock();  <span class="comment">// 获取全局锁</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  <span class="comment">// 线程数 &lt; 核心线程数</span></span><br><span class="line">            <span class="comment">// 创建一个线程</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))  <span class="comment">// 线程池创建线程时，会将线程封装成工作线程 Worker</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();  <span class="comment">// 创建失败，获取当前线程池状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程创建失败，或当前工作线程数不小于 corePoolSize：</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <span class="comment">// 当前线程池运行正常且阻塞队列添加任务成功</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))  <span class="comment">// 二次确认（有可能存在线程池状态发生了变化的情况）</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  <span class="comment">// 当前没有工作线程</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);  <span class="comment">// 创建一个非核心线程</span></span><br><span class="line">                <span class="comment">// 保证有一个 worker 线程可以从 queue 中消费任务就行了，所以 command 可以设置为 null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))  <span class="comment">// 创建一个非核心线程执行任务</span></span><br><span class="line">            reject(command);  <span class="comment">// 创建非核心线程失败，执行饱和策略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p><strong>1</strong>. 根据任务的性质确定参数：</p>
<ul>
<li>CPU 密集型：配置比较小的线程池，如 N CPU + 1</li>
<li>IO 密集型：线程不一定在执行任务，因此要尽可能多地配置线程，如 2 * N CPU</li>
<li>混合型：拆分</li>
</ul>
<p>其中 N = <code>Runtime.getRuntime().availableProcessors()</code></p>
<p><strong>2</strong>. 如果任务存在优先级，则使用 PriorityBlockingQueue 作为线程池的阻塞队列。</p>
<p><strong>3</strong>. 如果需要考虑任务的执行时间，可以创建不同规模的线程池来处理；或者使用 PriorityBlockingQueue 优先处理<strong>执行时间短的任务</strong>。</p>
<p><strong>4</strong>. 如果执行的任务之间存在依赖性，应该按需增大线程池，以免在等待依赖的过程中 CPU 存在空闲时间过长的情况；同时应该采用有界的阻塞队列（特别是依赖外部系统的情况下），避免执行任务过多撑爆内存的风险。</p>
<p><br></p>
<h1 id="扩展：ScheduledExecutorService"><a href="#扩展：ScheduledExecutorService" class="headerlink" title="扩展：ScheduledExecutorService"></a>扩展：<code>ScheduledExecutorService</code></h1><p>接口概况：</p>
<p><img src="/2021/09/02/java-executors/scheduledexecutorservice.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定在指定的等待时间之后执行任务</span></span><br><span class="line">    <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; task, <span class="keyword">long</span> time, TimeUnit unit)</span></span>;</span><br><span class="line">    ScheduledFuture&lt;?&gt; schedule(Runnable task, <span class="keyword">long</span> time, TineUnit unit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定在初始延迟结束后，周期性运行给定的任务</span></span><br><span class="line">    <span class="comment">// 周期长度为 period，单位为 unit</span></span><br><span class="line">    ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定在初始延迟结束后，周期性运行给定的任务</span></span><br><span class="line">    <span class="comment">// 在前一次调用完成和下一次调用开始之间会有 delay 的延迟</span></span><br><span class="line">    ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类概况：扩展了 <code>ThreadPoolExecutor</code> 类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), factory);</span><br><span class="line">        <span class="comment">// 这里的 Integer.MAX_VALUE 没多大意义，因为 DelayedWorkQueue 本身就是无界的队列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本运行机制"><a href="#基本运行机制" class="headerlink" title="基本运行机制"></a>基本运行机制</h2><p><img src="/2021/09/02/java-executors/scheduledthreadpoolexecutor-execute.png" alt></p>
<p>通过调用接口方法来定期/延时执行任务，将 Future 对象添加到 DelayQueue 中，核心线程池从阻塞队列中获取 Future 对象执行。</p>
<p>比 <code>java.util.Timer</code> 单个的线程更灵活，功能也更多。</p>
<h2 id="执行周期性任务的过程"><a href="#执行周期性任务的过程" class="headerlink" title="执行周期性任务的过程"></a>执行周期性任务的过程</h2><p>先说一下被执行的周期性任务 <code>ScheduledFutureTask</code>。主要有以下属性：</p>
<ul>
<li>long <code>time</code>: 下一次任务将要被执行的具体时间</li>
<li>long <code>sequenceNumber</code>: 任务被提交到线程池时被编的序号</li>
<li>long <code>period</code>: 任务重复被执行的周期</li>
</ul>
<p>假设 ScheduledThreadPoolExecutor 实例中存在了线程 1，它要执行任务的顺序如下：</p>
<p><img src="/2021/09/02/java-executors/scheduledthreadpoolexecutor-p.png" alt></p>
<p><strong>1</strong>. 首先从阻塞队列中获取一个已经到期（time &lt;= 当前时间）的任务 ScheduledFutureTask（<code>DelayQueue.take()</code>）<br><strong>2 &amp; 3</strong>. 线程池执行任务后，修改 time 变量的值为下次任务执行的时间（<code>time</code> + <code>period</code>）<br><strong>4</strong>. 将修改了 time 变量的任务实例重新放回阻塞队列（<code>DelayQueue.add()</code>），等待下一次被执行。</p>
<p>DelayQueue 封装了 PriorityQueue，以 time -&gt; sequenceNumber 为标准将时间小，序号靠前的任务排到队列前面：因此时间点更靠近的会先被运行。</p>
<p><strong>获取任务的逻辑</strong>：</p>
<p><img src="/2021/09/02/java-executors/scheduledthreadpoolexecutor-get.png" alt></p>
<p>获取任务：调用 <code>DelayQueue.take()</code></p>
<ol>
<li>获取 lock</li>
<li>在循环中获取周期任务<ul>
<li>如阻塞队列为空，则线程在 Condition 中等待</li>
<li>如阻塞队列中任务 task 的时间点 time &gt; 当前时间，则线程还是在 Condition 中等待</li>
<li>否则唤醒 Condition 上等待的线程，从队列中获取任务</li>
</ul>
</li>
<li>释放 lock</li>
</ol>
<p><strong>放回任务的逻辑</strong>：</p>
<p><img src="/2021/09/02/java-executors/scheduledthreadpoolexecutor-add.png" alt></p>
<p>放回任务：调用 <code>DelayQueue.add()</code></p>
<ol>
<li>获取 lock</li>
<li>在循环中添加周期任务<ul>
<li>如阻塞队列头节点存在元素，则唤醒在 Condition 中等待的线程</li>
</ul>
</li>
<li>释放 lock</li>
</ol>
<p><br></p>
<h1 id="补充：泛型类-ExecutorCompletionService"><a href="#补充：泛型类-ExecutorCompletionService" class="headerlink" title="补充：泛型类 ExecutorCompletionService"></a>补充：泛型类 <code>ExecutorCompletionService</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCompletionService</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">CompletionService</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个实例，来收集已提交任务的执行结果</span></span><br><span class="line"><span class="comment">     * 该服务管理 Future 对象的阻塞队列</span></span><br><span class="line"><span class="comment">     * 如果没有指定队列：默认为 LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ExecutorCompletionService(Executor e)</span><br><span class="line">    ExecutorCompletionService(Executor e, BlockingQueue&lt;Future&lt;v&gt;&gt; completionQueue)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个任务给底层执行器</span></span><br><span class="line">    <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">    Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 从 completionQueue 移除下一个已完成结果</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 如无任何已完成结果，则阻塞</span></span></span><br><span class="line"><span class="function">    Future&lt;T&gt; <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 移除下一个已完成结果</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 如无任何已完成结果，则返回 null</span></span></span><br><span class="line"><span class="function">    Future&lt;T&gt; <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    Future&lt;T&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> time, TimeUnit init)</span>  <span class="comment">// 等待给定的时间</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService service = <span class="keyword">new</span> ExecutorCompletionService(executor);</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; task : tasks)</span><br><span class="line">    service.submit(task);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++)</span><br><span class="line">    processFurther(service.take().get());</span><br></pre></td></tr></table></figure></p>
<p>与 ExecutorService 相比，ExecutorCompletionService 对于 invokeAny() 和 invokeAll() 有具体的实现，其将结果按照可获得的顺序保存起来显得更有意义。</p>
<p><br></p>
<h1 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a><code>Executors</code></h1><p>JUC 包还提供了 Executors 工厂类，包含了上面提到的 <code>Executor</code>, <code>ExecutorService</code>, <code>ScheduledExecutorService</code>, <code>ThreadFactory</code> 和 <code>Callable</code> 等接口类，及其实现类的工厂方法。</p>
<ul>
<li><code>Executor</code>：提交普通的可执行任务</li>
<li><code>ExecutorService</code>：提供对线程池生命周期的管理、异步任务的支持</li>
<li><code>ScheduledExecutorService</code>：提供对任务的<strong>周期性</strong>执行支持</li>
</ul>
<p>主要的工厂方法概述如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>newCachedThreadPool()</code></td>
<td>必要时创建新线程：空闲线程会保留 60 秒<br>如线程池大小超过处理任务所需要线程：回收部分空闲线程</td>
</tr>
<tr>
<td><code>newFixedThreadPool()</code></td>
<td>该池包含固定数量的线程：空闲线程会一直保留<br>如某线程因执行异常而结束：线程池补充一个新线程</td>
</tr>
<tr>
<td><code>newSingleThreadExecutor()</code></td>
<td>只有一个线程的“池”：该线程按照顺序执行每一个提交的任务</td>
</tr>
<tr>
<td><code>newScheduledThreadPool()</code></td>
<td>用于定时或周期性执行而构建的固定线程池，替代 <code>java.util.Timer</code></td>
</tr>
<tr>
<td><code>newSingleThreadScheduledThreadExecutor()</code></td>
<td>用于定时或周期性执行而构建的单线程执行器（“池”）</td>
</tr>
<tr>
<td><code>newWorkStealingPool()</code></td>
<td>创建一个 ForkJoin 线程池</td>
</tr>
</tbody>
</table>
</div>
<p>从上述方法命名可以看出：只有一个线程的“池”，叫 <code>-Executor</code>；否则都叫 <code>-Pool</code>。</p>
<p><code>Executors</code> 工具类中的工厂方法概述：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回带缓存（线程可重用）线程池，线程数不限</span></span><br><span class="line"><span class="comment">     * 必要时创建线程，在线程空闲 60 秒后终止线程</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 场景比较少，一般用在任务数量大但执行时间短的场景</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个线程池，池中的线程数由参数指定</span></span><br><span class="line"><span class="comment">     * 如某一时刻提交的服务数多于空闲的线程数，那将暂时未能获取服务的任务放置到等待池中，其他任务完成后再执行它们</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 一般用于需要限制线程数量的并发场景</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory factory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 返回一个执行器，在单个线程中依次执行各个提交进来的任务</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 保证顺序，避免多个任务同时执行</span></span></span><br><span class="line"><span class="comment"><span class="function">     */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), factory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上构造函数调用的均为 ThreadPoolExecutor 的构造方法</span></span><br><span class="line">    <span class="comment">// 返回的是实现了 ExecutorService 接口的 ThreadPoolExecutor 类对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为 ScheduledExecutorService 相关工厂方法：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个线程池，使用给定线程数调度任务</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 应用于多个线程运行周期性任务的场景（需要满足系统性能需求）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个执行器，在一个单独线程中调度任务</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 单个线程依序执行周期性任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, factory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Runnable 包装成 Callable 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdaptor&lt;Object&gt;(task, <span class="keyword">null</span>);  <span class="comment">// 没有结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdaptor&lt;Object&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h2><p>阿里巴巴编程手册不提倡使用工厂方法创建线程池，而是通过 <code>new ThreadPoolExecutor()</code> 更灵活地配置。</p>
<ul>
<li>特别是 <code>newCachedThreadPool()</code>：因其没有边界，使用起来比较危险</li>
</ul>
<p><br></p>
<h1 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h1><p>上面所提到的接口类和实现类构成了 Executor 框架的主体：</p>
<ul>
<li>被执行的任务所需接口：<a href="/2021/08/24/java-multi-threads-basic-classes/#Runnable-%E6%8E%A5%E5%8F%A3"><code>Runnable</code></a> <a href="/2021/08/24/java-multi-threads-basic-classes/#Callable-amp-Future"><code>Callable</code></a></li>
<li>执行任务所需要的 <code>Executor</code> 和 <code>ExecutorService</code> 接口及实现类</li>
<li>异步计算结果：<a href="/2021/08/24/java-multi-threads-basic-classes/#Callable-amp-Future"><code>Future</code></a> 接口，<a href="/2021/08/24/java-multi-threads-basic-classes/#Callable-amp-Future"><code>FutureTask</code></a> 类</li>
</ul>
<p><img src="/2021/09/02/java-executors/executor-framework.png" alt></p>
<p>简单来说，主线程创建任务（<code>Runnable</code> 或 <code>Callable</code> 实例），提交（<code>submit()</code> / <code>execute()</code>）到线程池中执行，主线程可以获取（<code>get()</code>）返回的结果（<code>FutureTask</code>），或取消（<code>cancel()</code>）当前执行任务。</p>
<p>Executor 框架的两级调度模型和操作系统中线程的关系：</p>
<p><img src="/2021/09/02/java-executors/executor-model.png" alt></p>
<p>Java 线程一一对应于本地操作系统的线程，每创建/销毁一个 Java 线程，对应就会创建/回收一个本地操作系统的线程。</p>
<p>应用程序的任务经由 Executor 框架映射到线程池中的线程执行（上层调度），操作系统的内核也会将线程映射到对应的 CPU 中（下层调度）。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的锁实现</title>
    <url>/2021/08/22/java-lock/</url>
    <content><![CDATA[<p>锁是控制多个线程访问共享资源的方式，是实现多线程同步的重要思想。在 <code>java.util.concurrent</code> 包中有很多相关的 API 和组件。</p>
<span id="more"></span>
<p>一般来说，锁能够防止多个线程同时访问一个共享资源；个别锁允许并发访问共享资源，如读写锁等。<br>悲观锁（包括独占锁和共享锁）估计很多人都很熟悉。在开始之前，先简要说一下乐观锁的内容。</p>
<h1 id="乐观锁与-CAS"><a href="#乐观锁与-CAS" class="headerlink" title="乐观锁与 CAS"></a>乐观锁与 CAS</h1><p>乐观锁从严格的意义来看，并不是锁；它的每一次操作，是在假设数据没有冲突的情况下进行的，如果因为数据冲突导致失败，就开始重试，直至成功为止。<br>因此乐观锁是<strong>无锁编程</strong>的范畴。</p>
<p>CAS 是一种实现乐观锁的方式，全称 Compare And Set，使用到三个操作数：<strong>变量内存地址</strong>，<strong>预期值</strong>，<strong>新值</strong>。<br>这种算法让 CPU 去比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新的值，不相同则不做更新。<br>CAS 是 CPU 指令，其读写都具有原子性，其实现方式是通过 C/C++ 调用 CPU 指令完成的：我们只能通过 JNI 与操作系统交互。</p>
<p>因此，CAS 可以保证并发安全，但<strong>并不会保证线程同步</strong>，而是“乐观”地认为数据在更新期间没有收到其它线程的影响。</p>
<h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>正是因为 CAS 的这份“乐观”，会导致一个数据同步的<strong>过程问题</strong>。</p>
<p>比如此时有两个线程同时对同一个值进行 CAS 操作，从初始值 A 更新到 B：</p>
<ul>
<li>线程 1 抢先获得时间片，线程 2 被阻塞；线程 A 发现期望值的确是 A，将其替换为 B；</li>
<li>在线程 2 恢复之前，线程 3（或者继续是线程 1）过来进行 CAS 操作：期望值为 B，更新到 A；线程 3 抢先获得了时间片，因为条件刚好符合，所以值被更新回 A；</li>
<li>线程 2 恢复后，发现初始值和期望值相同，又将值更新到 B。</li>
</ul>
<p>由此：虽然线程 2 完成了更新的操作，但是它并不知道值从 A-&gt;B-&gt;A 的变化过程。</p>
<p>ABA 场景表面上不会造成问题，但是在对过程敏感的业务中，我们需要解决 ABA 问题。</p>
<p><br></p>
<p>讲完了 CAS，我们就来简单来介绍一下这些 API 和组件的实现细节和使用方式。</p>
<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p>在 Lock 接口之前，Java 使用 <code>synchronized</code> 关键字隐式地获取和释放对象同步锁。<br>在随后的 Lock 接口中，虽然使用的时候需要显式地获取和释放锁，没有 synchronized 来得便捷；但是 Lock 增加了获取和释放锁的<strong>可操作性</strong>、<strong>可中断</strong>地获取锁、<strong>超时获取锁</strong>等功能，使用更灵活，扩展性更强：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>尝试非阻塞地获得锁</td>
<td>当前线程尝试获取锁，如果此刻锁没被其它线程获得，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁</td>
<td>与 synchronized 不同：获得锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常会被抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁</td>
<td>在指定时间内获得锁，如果截止时间到了依旧无法获得锁，则返回</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>    <span class="comment">// 获取锁</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 如锁同时被另一线程拥有，则发生阻塞</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;  <span class="comment">// 获得锁，但不确定地发生阻塞</span></span><br><span class="line">    <span class="comment">// 相当于一个超时设为无限的 tryLock()</span></span><br><span class="line">    <span class="comment">// 与 lock() 不同：lockInterruptibly() 会响应中断，即在锁的获取中可以中断当前线程</span></span><br><span class="line">    <span class="comment">// 如线程被中断：抛出 InterruptedException</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  <span class="comment">// 尝试获得锁而不发生阻塞</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 抢夺可用的锁，获得成功返回 true，否则返回 false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 尝试获得锁，阻塞时间不超过给定时间的值</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 以下 3 种情况会返回：</span></span></span><br><span class="line"><span class="comment"><span class="function">     *  1. 当前线程在超时时间内获得了锁，返回 true</span></span></span><br><span class="line"><span class="comment"><span class="function">     *  2. 当前线程在超时时间内被中断</span></span></span><br><span class="line"><span class="comment"><span class="function">     *  3. 超时时间结束，返回 false</span></span></span><br><span class="line"><span class="comment"><span class="function">     * </span></span></span><br><span class="line"><span class="comment"><span class="function">     * TimeUnit：枚举类型，可取 SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS</span></span></span><br><span class="line"><span class="comment"><span class="function">     */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 使用 tryLock 场景：如一个线程在等待锁时被中断，且占有锁的线程也被中断，这会产生死锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>    <span class="comment">// 释放锁</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    Condition <span class="title">newCondition</span><span class="params">()</span>  <span class="comment">// 返回一个与该锁相关的条件对象</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 一个锁对象可有一个或多个相关的条件对象；一个条件对象与当前锁绑定</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 当前线程获得了锁，才能调用条件对象的 wait() 方法；调用后锁会被释放</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 命名习惯：给每个条件对象命名为可反映出所表达条件的名字</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上虽然也是 synchronized 的原理解释代码，但是 synchronized 是上述这一套加锁解锁的固化，而单纯使用 Lock 接口能更灵活地实现业务。</p>
<p><br></p>
<h2 id="基础：AQS"><a href="#基础：AQS" class="headerlink" title="基础：AQS"></a>基础：<strong>AQS</strong></h2><p><code>AbstractQueuedSynchronizer</code>，抽象队列同步器，是用于构建锁或其它同步组件的基础框架。</p>
<p>AQS 使用一个整型（<code>int</code>）成员变量 <code>state</code> 来表示同步状态，通过<strong>内置 FIFO 双向队列</strong>完成资源获取线程的排队工作。</p>
<p><img src="/2021/08/22/java-lock/aqs.png" alt></p>
<p>显然，AQS 采用了模版方法设计模式（抽象类），自身并没有实现任何同步接口，仅仅定义了若干个同步状态获取和释放的方法。<br>AQS 既可以支持独占式地获取同步状态，也可以支持共享式获取状态，方便不同类型同步组件的实现。<br>使用者必须要继承<strong>同步器</strong>（某个 <code>Sync</code>），重写指定的方法（如上图中的 <code>#</code> 方法），或者继承 AQS 的一些实体类来实现具体的锁。</p>
<p>自定义的 Lock 在使用时，一般被定义为静态内部类。<br>自定义的 Lock 在调用 lock() 时，会调用 AQS 的 <code>acquire()</code> 方法。</p>
<p>大概的区别是：<br>AQS 面向<strong>锁的实现者</strong>，简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队、等待、唤醒等操作；锁面向<strong>锁的使用者</strong>，定义了使用者和锁的交互接口。</p>
<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a><strong>基本数据结构</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  <span class="comment">// 代表 FIFO 队列的数据结构</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点代表的线程被取消等待状态（超时或者被中断）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中间状态，表示当前的节点已经有后继节点的线程在尝试获取状态。</span></span><br><span class="line">        <span class="comment">// 当前节点如果释放了同步状态，将会通知后继节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点在等待池中；节点线程等待在 Condition 中</span></span><br><span class="line">        <span class="comment">// 当其他线程调用 Condition 的 signal() 方法后，线程从等待池转移到同步队列，加入到对同步状态的获取。</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享式状态，无条件地将行为传播下去</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;  <span class="comment">// 等待状态（默认为 0）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步队列中的前后节点</span></span><br><span class="line">        <span class="comment">// 双向链表，每个节点需要保存⾃⼰的前驱节点和后继节点的引⽤</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;  <span class="comment">// 节点所代表的线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待池中的后续节点</span></span><br><span class="line">        <span class="comment">// 该属性⽤于 Condition 条件队列或者共享锁，独占锁模式下永远是 null</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">        <span class="comment">// 由此可以得知，等待池是 FIFO 单向队列，由 Condition 内部实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步队列头节点，不代表任何线程，是⼀个哑节点（dummy node）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步队列尾节点，每⼀个请求锁的线程会加到队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  <span class="comment">// 大于 0 为没被占用状态，小于 0 为已被占用状态：相当于计数器</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;  <span class="comment">// 记录当前持有锁的线程</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的锁利用以下已实现的方法来实现各自需要的业务：</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  <span class="comment">// CAS 方法</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注：CAS 操作基本都是由 Unsafe 工具类的 compareAndSetXxx() 实现的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为常用的可以重写的方法：</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 独占式获取同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现时需要查询当前状态，且判断当前同步状态是否符合预期</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 独占式释放同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;  <span class="comment">// 判断当前同步器是否被当前线程所独占</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 以下为模板方法，主要有三类：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 独占式获取 / 释放同步状态</span></span><br><span class="line"><span class="comment">     * 2. 共享式获取 / 释放同步状态</span></span><br><span class="line"><span class="comment">     * 3. 查询并获取同步队列中的等待线程的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式获取，忽略中断。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;   <span class="comment">// 保证线程安全地去获取同步状态，需要自己实现</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="comment">// 以“死循环”的方式获取同步状态</span></span><br><span class="line">            selfInterrupt();  <span class="comment">// 设置中断标识位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式获取，响应中断。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式获取，有超时时间控制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式释放同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 调用实现的方法释放锁，随后唤醒后继节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unpackSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;  <span class="comment">// 调用实现的方法释放锁，随后唤醒后继节点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取同步队列中等待的所有线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">            Thread t = p.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a><strong>同步队列</strong></h3><p>AQS 通过同步队列完成对同步状态的管理。</p>
<p>同步队列里的每一个节点，都代表着一个获取同步状态失败的线程，用来保存该线程的引用、等待状态、前驱后驱节点等信息。</p>
<p>头节点永远是一个哑节点，不代表任何线程；但有的时候可以被看作代表当前持有锁的线程。<br>因此 head 指向的 Node 对象中的 thread 属性永远是 <code>null</code>。</p>
<p><img src="/2021/08/22/java-lock/aqs-queue.png" alt></p>
<p><strong>a. 加入队列</strong></p>
<p>当前线程获取同步状态失败（AQS 的 <code>state</code> &lt; <code>0</code>）时：同步器将当前线程的等待状态等信息构造成一个独占式节点，随后添加到同步队列里面；<br>此时当前线程会被阻塞。</p>
<p>很多个线程进行操作的话，同步队列很有可能在一个时间点不只有一个线程的加入。<br>因此代表线程的节点需要添加进同步队列的时候，需要<strong>保证线程安全性</strong>：所以才会使用 <code>compareAndSetTail()</code> 这样的 CAS 方法进行操作。</p>
<p><strong>b. 离开队列</strong></p>
<p>当同步状态被释放（<code>state</code> &gt; <code>0</code>）的时候：唤醒头节点代表的线程，该线程会尝试再次获取同步状态。</p>
<p>头节点在获取同步状态成功，释放同步状态的时候，会唤醒后面的节点。<br>后继节点被唤醒之后，意味着<strong>它是持有该同步锁的线程</strong>，它也就是同步队列中的<strong>新的头节点</strong>。</p>
<p>相对于加入队列（设置队列尾节点），离开队列的永远都是头节点，只有一个线程：头节点的后继节点才能够成为下一个头节点；因此头节点的设置会比尾节点简单。</p>
<p><br></p>
<h2 id="实现：独占式同步状态获取与释放"><a href="#实现：独占式同步状态获取与释放" class="headerlink" title="实现：独占式同步状态获取与释放"></a>实现：独占式同步状态获取与释放</h2><p><strong><big>1. 获取同步状态</big></strong>：调用 <code>acquire()</code></p>
<p>该方法对中断<strong>不敏感</strong>；也就是说，线程获取同步状态失败后被添加到同步队列中，后续对该线程进行<strong>中断操作</strong>的话，<strong>线程不会被移出同步队列</strong>。</p>
<p><strong><big>2. 释放同步状态</big></strong></p>
<p>调用 <code>tryRelease(arg)</code> 释放同步状态，然后唤醒头节点非 CANCELLED 状态的后继节点。</p>
<p>相关的实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据自定义的独占锁重写 tryAquire()：</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 要保证线程能安全地去获取同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        <span class="comment">// 提示：实现时采用 CAS 相关的方法，如 compareAndSetState(expect, update)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据自定义的独占锁重写 tryRelease()：</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 独占式释放同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        <span class="comment">// 提示：setState(0)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式获取，忽略中断。</span></span><br><span class="line">    <span class="comment">// This method can be used to implement method Lock.lock.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 对每一个请求过来的线程，无论它先前是否请求过该同步状态，先基于它构造独占式节点（EXCLUSIVE）；</span></span><br><span class="line"><span class="comment">             * 再将该节点添加至同步队列的尾节点；</span></span><br><span class="line"><span class="comment">             * 后以“死循环”的方式获取同步状态</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="comment">// 线程在尝试获取同步状态的过程中如果被中断，该方法返回 true；否则返回 false</span></span><br><span class="line">            <span class="comment">// 设置中断标识位</span></span><br><span class="line">            selfInterrupt();  <span class="comment">// 由此可看出，线程如果被中断过，随后获得了同步状态，是不会马上响应中断的；而是在随后补上标识位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式获取，响应中断。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式释放同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 调用实现的方法释放锁，随后唤醒后继节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)  <span class="comment">// head 状态不为 0（初始值）就可以唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 承上：将构造的独占式节点放入到同步队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 第一次先尝试快速加入（fast path）队列；第一遍失败后才进入 enq()（full enq）中</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;  <span class="comment">// 尾节点不为空：同步队列中已经有在等待的线程</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;  <span class="comment">// 确保节点能够被线程安全地添加</span></span><br><span class="line">                <span class="comment">// 通常这个 if block 在并发量不高的情况下会成功</span></span><br><span class="line">                pred.next = node;  <span class="comment">// 完成双向链表的构建</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾节点为空，或者 CAS 添加失败：</span></span><br><span class="line">        enq(node);  <span class="comment">// “死循环”将 node 非独占式地插入到同步队列的尾部</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在队列中的线程独占地、非中断式（不受中断影响）地获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">aquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 自旋：&quot;死循环&quot;中尝试获取同步状态</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 只有其前驱节点是头节点的线程，才有资格尝试获取同步状态</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);  <span class="comment">// 新的头节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>;  <span class="comment">// 让 GC 去回收线程代表的节点</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;  <span class="comment">// 双反，即获取同步状态成功 succeed</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;  <span class="comment">// 返回当前线程在等待获取同步状态时是否被中断过</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果不是头节点，或是获取失败：</span></span><br><span class="line">                <span class="comment">// 先：跳过已经被 cancell 的节点</span></span><br><span class="line">                <span class="comment">// 设置前驱节点状态为 SIGNAL，以便当前线程阻塞后，前驱节点能根据 SIGNAL 状态唤醒自己</span></span><br><span class="line">                <span class="comment">// 前驱节点获取同步状态成功后，会唤醒后续的线程</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 后：阻塞（LockSupport.park()）节点代表的线程</span></span><br><span class="line">                    <span class="comment">// 使线程进入 waiting 状态，等待前驱节点唤醒</span></span><br><span class="line">                    <span class="comment">// 且检查当前线程是否可以被中断</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)  <span class="comment">// 获取失败</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程在等待过程中如果被中断了，该方法返回 true；否则返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先看看快速加入行不行，行就不用进入下面这个死循环里面了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">// “死循环”</span></span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t = <span class="keyword">null</span>) &#123;  <span class="comment">// 尾节点为空：它是同步队列中的第一个线程</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;  <span class="comment">// 第一个线程：tail 和 head 是同一个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 尾节点不为空，快速加入失败：CAS 方法将节点添加至同步队列尾部</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;  <span class="comment">// 只有添加成功才能从该方法返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 将非 cancelled 状态的线程设为 0</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// head 状态为 0（初始值），代表 head 为新入队的节点，其后继节点即将被唤醒，或已经被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环找到当前头节点的非空后继节点，或者从尾节点前溯找到的最接近头节点的后继节点</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);  <span class="comment">// 唤醒操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析源码可知：</p>
<p><strong>线程获取同步状态策略</strong>：</p>
<ol>
<li>同步器维护一个同步队列，队列中每一个节点代表一个线程；</li>
<li>每当节点的<strong>前驱节点出队</strong>，或者自身被中断、或从等待状态返回时：检查自己的前驱节点是否为头节点；如果是，则节点代表的线程会去尝试获取同步状态；</li>
<li>前驱节点不是头节点的线程并不能去获取同步状态；它们会保持在同步队列中；</li>
<li>所有获取同步状态失败了的线程都在队列中进行<strong>自旋</strong>。各自在自旋的时候不会相互通信；</li>
<li>移出队列（停止自旋）的条件是前驱节点为头节点，且成功获取了同步状态。</li>
</ol>
<p>如此符合 FIFO，并且便于对过早的通知进行处理，比如对一些前驱节点不是头节点的线程节点的通知。</p>
<p><img src="/2021/08/22/java-lock/aqs-acquire.png" alt></p>
<p><img src="/2021/08/22/java-lock/aqs-flow.png" alt></p>
<p><strong>线程释放同步状态策略</strong>：</p>
<ul>
<li>调用 <code>tryRelease(arg)</code> 释放同步状态，然后唤醒头节点非 CANCELLED 状态的后继节点。</li>
</ul>
<p><br></p>
<h2 id="实现：共享式同步状态获取和释放"><a href="#实现：共享式同步状态获取和释放" class="headerlink" title="实现：共享式同步状态获取和释放"></a>实现：共享式同步状态获取和释放</h2><p>共享式获取与独占式获取的区别在于：同一时刻能否允许多个线程同时获取到同步状态。<br>资源在被共享状态时，共享的线程都可以访问资源，独占式的不能访问；资源在被独占式访问时，其他所有类型的线程都不能访问资源。</p>
<p>共享式释放与独占式释放的区别在于：共享式释放必须要保证同步状态 / 资源<strong>被线程安全地释放</strong>。</p>
<p>相关的实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据自定义的共享锁重写 tryAquireShared()：</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据自定义的共享锁重写 tryReleaseShared()：</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  <span class="comment">// 尝试获取同步状态，&gt;= 0 表示获取成功，&lt; 0 表示获取失败，进入自旋</span></span><br><span class="line">            doAcquireShared(arg);  <span class="comment">// 进入自旋</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;  <span class="comment">// 调用实现的方法释放锁，随后唤醒后继节点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式获取同步状态，代码结构类似于 acquireQueued()</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);  <span class="comment">// 此时添加的是共享式节点</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 自旋</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;  <span class="comment">// 同样：还是只有头节点才有资格获取同步状态</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);  <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);  <span class="comment">// 将 head 指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>;  <span class="comment">// 让 GC 回收</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupted();  <span class="comment">// 中断状态随后补上</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;  <span class="comment">// 从自旋中退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        setHead(node);  <span class="comment">// head 指向自己</span></span><br><span class="line">        <span class="comment">// 如果条件符合，继续唤醒下一个后继节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式释放同步状态，逻辑类似于 unparkSuccessor()，但代码逻辑不同</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;  <span class="comment">// 头节点非空且非尾节点：同步队列中有共享节点在等待获取同步状态</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;  <span class="comment">// head 的状态为 SIGNAL</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))  <span class="comment">// 保证同步状态能被线程安全地释放</span></span><br><span class="line">                        <span class="keyword">continue</span>;  <span class="comment">// 重试</span></span><br><span class="line">                    unparkSuccessor(h);  <span class="comment">// head 状态从 SIGNAL 成功被设置为 0：唤醒后继节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;  <span class="comment">// 重试</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)  <span class="comment">// 头节点非 SIGNAL 或初始状态</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 取消释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过比较模板方法可知，共享式获取同步状态会立刻相应中断，而独占式获取同步状态不会马上响应。</p>
<p>即使是共享式获取，AQS 也是严格按照同步队列的入队顺序唤醒自旋的线程。</p>
<p><br></p>
<h2 id="实现：超时获取同步状态"><a href="#实现：超时获取同步状态" class="headerlink" title="实现：超时获取同步状态"></a>实现：超时获取同步状态</h2><p>也属于独占式的同步状态更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 独占式获取同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// 独占式释放同步状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占式获取，有超时时间控制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doAcquireNanos()</code> 实现与 <code>aquireQueued()</code> 相差无几，只是多了一些超时的处理；同时会相应中断，线程被中断的时候会抛出异常。<br>因此 <code>doAcquireNanos(int, long)</code> 也是 <code>acquireInterruptibly(int)</code> 的升级版。</p>
<p><img src="/2021/08/22/java-lock/aqs-timed-flow.png" alt></p>
<p><br></p>
<h2 id="应用：自定义"><a href="#应用：自定义" class="headerlink" title="应用：自定义"></a>应用：自定义</h2><p>有一个设计：只允许最多两个线程同时访问，超过两个线程的访问将被阻塞。</p>
<p><strong>1. 确定访问模式</strong></p>
<p>应该采用共享式访问模式，实现 <code>tryAcquireShared()</code> 和 <code>tryReleaseShared()</code> 等共享式方法。</p>
<p><strong>2. 定义资源数</strong></p>
<p>资源数定为 <code>2</code>，即设置 <code>state</code> 为 2；每当一个线程获得资源时，<code>state</code> 减 1，直至减到 0 时，说明已经有两个线程访问到了资源，其他访问线程将会被阻塞。<br>因此 <code>state</code> 的值范围是 [0, 1, 2]。</p>
<p>可以使用 <code>compareAndSetState()</code> 等 CAS 设置方法保证原子性。</p>
<p><strong>3. 组合自定义同步器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwinLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);  <span class="comment">// 资源数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Count should large than 0.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="应用：ReentrantLock-可重入锁"><a href="#应用：ReentrantLock-可重入锁" class="headerlink" title="应用：ReentrantLock 可重入锁"></a>应用：ReentrantLock 可重入锁</h2><p>顾名思义，这是能够重入的锁：即同一个线程可重复获得已经持有的锁（对资源重复加锁）。</p>
<p>可重入锁基于独占式的同步器进行设计。</p>
<ul>
<li>加锁的时候，判断当前请求同步状态的线程和当前占有锁的线程是否为同一个；如果是的话就会再次获取；</li>
<li>另外维护了一个锁被持有的计数（hold count），用于跟踪对 <code>lock()</code> 的嵌套调用；因此被一个锁保护的代码块可调用另一个使用相同锁的方法。<ul>
<li>如：Block A 中代码调用 method B，B 与 A 持有相同的锁对象，则锁的持有计数累加至 2</li>
<li>调用 B 执行完后，锁被释放一次，因此计数减为 1</li>
</ul>
</li>
</ul>
<p>可重入锁支持公平和非公平的选择。</p>
<ul>
<li>公平性是针对于锁的获取顺序来说的，先进先出符合公平性</li>
</ul>
<p><br></p>
<p>我们现在回过头来看前面提到的独占式获取同步状态：</p>
<p>如果一个已经占有锁的线程尝试再次获得同一个锁，那么按照代码逻辑，它自己会被自己阻塞；因为上述的独占式基本结构没有考虑这个场景。</p>
<p>可重入锁相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合同步器</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平的 tryLock，默认实现</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// 当前没有线程获得同步状态</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;  <span class="comment">// 只要 CAS 成功，线程就能获得锁，没有 FIFO 的概念</span></span><br><span class="line">                    setExclusiveOwnerThread(current);  <span class="comment">// 设置同步状态成功的话，设置独占线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再次获得同步状态的处理逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <span class="comment">// 判断当前的线程是否就是已经获得同步状态的线程：</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;  <span class="comment">// 计算新的 state</span></span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  <span class="comment">// 必须是当前线程才能释放同步状态</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// 持有线程数是 0，完全释放</span></span><br><span class="line">                free = <span class="keyword">true</span>;  <span class="comment">// 返回 true</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公平性同步器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <span class="comment">// 当前节点是否有前驱节点</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;  <span class="comment">// 设置同步状态成功</span></span><br><span class="line">                    setExclusiveOwnerThread(current);  <span class="comment">// 设置独占线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同 nonfairTryAcquire()：再次获得同步状态的处理逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建可重入锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonFairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建带公平策略的锁</span></span><br><span class="line"><span class="comment">     * 默认为 false</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 锁的公平性：先发起的对锁获取的请求一定会先被满足，这样才是公平的；反过来是不公平的</span></span><br><span class="line"><span class="comment">     * 公平锁说明锁的获取是顺序的，它偏爱等待时间最长的线程，但会大大降低性能</span></span><br><span class="line"><span class="comment">     * 非公平锁在对 TPS 要求高的场景中效率更高</span></span><br><span class="line"><span class="comment">     * 而公平锁能减少饥饿发生的概率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonFairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本结构的使用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小结：</p>
<ul>
<li>确保任何时候只有一个线程进入 critical section</li>
<li>当其他线程调用 <code>lock()</code> 时将会被阻塞，直到第一个线程释放该锁对象</li>
</ul>
<p><code>synchronized</code> 也“隐式”地实现了可重入性，因为在每次的 <code>monitorenter</code> 和 <code>monitorexit</code> 之间维护了一个计数器。</p>
<p>注意：</p>
<ul>
<li>锁不能使用在 <code>try-with-resource</code> 语句<ul>
<li>首先，“解锁”的方法名不是 close</li>
<li>try-with-resource 在使用时希望声明新变量；而锁是<strong>多个线程共享的变量，不能随便新建</strong></li>
</ul>
</li>
<li>如在临界区之前抛出异常，finally 将会释放锁，但数据可能会受损</li>
</ul>
<p><br></p>
<h2 id="应用：读写锁"><a href="#应用：读写锁" class="headerlink" title="应用：读写锁"></a>应用：读写锁</h2><p>与独占锁和可重入锁不同，读写锁是共享式获取同步状态的实现：读操作可以并行执行，写操作将其它所有操作阻塞。<br>写操作完成之后，新状态要立即对读操作可见。</p>
<p>因此读写锁维护的是<strong>一对锁</strong>。通过分离读锁和写锁，使得并发性相对于其他的排它锁有更大的提升；且简化了读写交互场景的编程方式。</p>
<p>在没有读写锁的实现的时候（before JDK 1.5），要实现读多写少的数据同步场景，我们需要：</p>
<ul>
<li>当写操作开始时，所有晚于该写操作的操作都会进入等待状态；</li>
<li>写操作完成，释放同步状态并通知后续线程，等待的读操作才能继续执行；</li>
<li>写操作之间使用 <code>synchronized</code> 关键字进行同步。</li>
</ul>
<p>这样读操作就不会发生脏读。</p>
<p>java.util.concurrent 包中的 <code>ReentrantReadWriteLock</code> 就是对读写锁的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span>  <span class="comment">// 得到一个可被多个读操作共用的读锁</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 排斥所有写操作</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    Lock <span class="title">writeLock</span><span class="params">()</span>  <span class="comment">// 获得写锁</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 排斥所有其他读操作和写操作</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>基本数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonFairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriterLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前读锁被获取的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getReadLockCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getReadLockCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断写锁是否被获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWriteLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isWriteLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于可重入锁的外部方法：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程持有写锁的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWriteHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程持有读锁的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getReadHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法和可重入锁的使用结构是一样的，读操作时获取读锁，写操作时获取写锁就可以了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平性选择</td>
<td>支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</td>
</tr>
<tr>
<td>重进入</td>
<td>支持重进入，以读写线程为例：读线程获取锁后，能再次获得读锁；写线程获得写锁后能再次获得写锁，也能获取读锁</td>
</tr>
<tr>
<td>锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的次序，写锁能降级为读锁</td>
</tr>
</tbody>
</table>
</div>
<p>常应用于大多数时间为读，少数时间为写的场景。这样的场景比较多见，此时读写锁比其他一般的独占锁性能要高，提供更好的并发性和吞吐量。</p>
<p><br></p>
<h3 id="实现与设计（以-ReentrantReadWriteLock-为例）"><a href="#实现与设计（以-ReentrantReadWriteLock-为例）" class="headerlink" title="实现与设计（以 ReentrantReadWriteLock 为例）"></a><strong>实现与设计（以 <code>ReentrantReadWriteLock</code> 为例）</strong></h3><p><strong>1</strong>. 读写状态的设计</p>
<p>万变不离其宗，还是以 <code>state</code> 来定义资源，记录同步器的状态：在 <code>ReentrantReadWriteLock</code> 中代表的是读写状态。<br>往细了说，就是读锁和写锁<strong>被获取的次数</strong>，记录着多个读线程的状态和一个写线程的状态。</p>
<p>单单一个 <code>int</code> 类型的变量，怎么能记录这么多状态？<br>只能说，<code>ReentrantReadWriteLock</code> 对于读写状态的设计的确是巧妙。</p>
<p><img src="/2021/08/22/java-lock/reentrantreadwritelock-state.png" alt></p>
<p>上图显然已经给出答案了：将 state <strong>按位切割</strong>，高 16 位表示读状态，低 16 位表示写状态。<br>这样，读写状态的记录就变成了整型的<strong>位运算</strong>：</p>
<ul>
<li>当前状态 state = S 时，写状态取 S 低位 S &amp; <code>0x0000FFFF</code>，读状态取 S 高位 S &gt;&gt;&gt; 16；</li>
<li>写锁重入时，计数直接累加 S + 1；读锁被获取时，计数累加 S + (1 &lt;&lt; 16) = S + <code>0x00010000</code>。</li>
</ul>
<p>上图的示例表示，当前线程获得了写锁，且重进入了两次；该线程又获取了读锁，且重入了一次。<br>当写锁被获取时，如果读锁不为 0，那么读锁一定同时被获取了写锁的那个线程持有。</p>
<p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合自定义同步器</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);  <span class="comment">// 读状态 + 1</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  <span class="comment">// 能记录的最多读/写锁分别是 65535 个</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  <span class="comment">// 高位掩码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 state 高位中获取共享数（读锁被获取的次数）</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT;  <span class="comment">// （无符号右移，高位补 0）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 state 低位中获取独占数（写锁被获取的次数）</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个线程持有的读锁数量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ThreadLocal 记录当前线程持有的读锁数量</span></span><br><span class="line">        <span class="comment">// 每个线程都需要维护自己的 HoldCounter</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存最后一个获取读锁的线程的读锁重入次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个获取读锁的线程，以及持有的读锁数量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">        ...  <span class="comment">// 获取锁和释放锁的相关方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 写锁的获取与释放</p>
<p>写锁相关操作属于<strong>独占式</strong>同步状态的获取和释放：</p>
<ol>
<li>如果读锁数量不为 0；或写锁数量不为 0，并且不是可重入操作（当前持有读锁/写锁的线程不是请求写锁的线程），则获取失败；</li>
<li>如果当前锁数量为 0，线程有资格获得写锁</li>
</ol>
<p>读锁被获取的时候不能获取写锁的原因：需要保证写操作对所有读操作可见；<br>如果在读锁被占用的时候写锁还能够被获取，那么该写操作就无法对这一次读操作可见了。</p>
<p>因此获取写锁需要实现 <code>tryAcquire(arg)</code>，写锁的释放需要实现 <code>tryRelease(arg)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合自定义同步器</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);  <span class="comment">// 获取独占锁（写锁）数量</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;  <span class="comment">// 不等于 0，存在读锁或者写锁</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="comment">// 1. 写锁为 0，说明存在读锁</span></span><br><span class="line">                    <span class="comment">// 或：2. 写锁不为 0，且当前线程不是占有着写锁的线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 获取写锁失败</span></span><br><span class="line">                <span class="comment">// 写锁不为 0，且满足可重入条件：</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);  <span class="comment">// overflow</span></span><br><span class="line">                setState(c + acquires);  <span class="comment">// 因为没有竞争，直接设置状态，不需要 CAS 操作</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 所有锁均没有被占用</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                <span class="comment">// 非公平模式直接返回 false；</span></span><br><span class="line">                <span class="comment">// 公平模式则如果同步队列存在等待线程（hasQueuedPredecessors()），则返回 true，否则返回 false</span></span><br><span class="line">                !compareAndSetState(c, c + acquires))  <span class="comment">// 前面返回 false：竞争写锁，需要使用 CAS 方法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 抢不到就乖乖排队</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();  <span class="comment">// 非独占：抛出异常</span></span><br><span class="line">            <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)  <span class="comment">// 写锁没有被占用</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3</strong>. 读锁的获取与释放</p>
<p>读锁相关操作则是属于<strong>共享式</strong>同步状态的获取和释放。</p>
<p>因此获取读锁需要实现 <code>tryAcquireShared(arg)</code>，读锁的释放需要实现 <code>tryReleaseShared(arg)</code>。</p>
<p>相对于写锁，读锁操作的实现会复杂一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合自定义同步器</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;  <span class="comment">// 有写锁被占用，且</span></span><br><span class="line">                getExclusiveOwnerThread() != current)  <span class="comment">// 占有着写锁的线程不是当前线程</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 失败</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写锁没被占用，或者当前线程占用了写锁：</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);  <span class="comment">// 获取读状态</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;  <span class="comment">// 是否需要阻塞读线程</span></span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;  <span class="comment">// CAS 设定读状态</span></span><br><span class="line">                <span class="comment">// ===========================</span></span><br><span class="line">                <span class="comment">// 从这儿开始，当前线程成功获取读锁</span></span><br><span class="line">                <span class="comment">// ===========================</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;  <span class="comment">// 读锁目前没被任何线程获取</span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;  <span class="comment">// 占有读锁的线程是请求读锁的线程自身</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="comment">// 缓存为空（之前没有过任何线程获得过读锁），或最后一个获得读锁的线程不是当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        <span class="comment">// 将当前线程的 HoldCounter 缓存到 cachedHoldCounter 中</span></span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  <span class="comment">// 缓存中为当前线程，count 为 0：缓存刚初始化</span></span><br><span class="line">                        readHolds.set(rh);  <span class="comment">// 保存至 ThreadLocal 中</span></span><br><span class="line">                    <span class="comment">// count 加一</span></span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 成功</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跑到这里来，意味着需要阻塞读线程（当前线程占用写锁），或者 CAS 设定读状态失败（和写锁或读锁竞争失败）</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算是补偿（redundant，冗余）方法：再给 !readerShouldBlock() 的线程一个 CAS 的机会</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 进入自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;  <span class="comment">/* 注意：进入自旋里面的逻辑，跟 tryAcquireShared() 大差不差 */</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;  <span class="comment">// 同上，有写锁被占用，且</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)  <span class="comment">// 占有着写锁的线程不是当前线程</span></span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到这里：没有写锁被占用</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;  <span class="comment">// 需要阻塞读线程</span></span><br><span class="line">                    <span class="comment">// 因此能进入这个 block 的：有其它线程在队列中等待</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* </span></span><br><span class="line"><span class="comment">                     * 按理说，有其它线程在队列中等待，自身是需要阻塞的</span></span><br><span class="line"><span class="comment">                     * 但是我们需要处理重进入的情况</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;  <span class="comment">// 当前线程为第一个获取读锁的线程</span></span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0</span></span><br><span class="line">                        <span class="comment">// 可重入，直接跳到下面的 CAS 操作</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;  <span class="comment">// 取最近一个获得读锁的线程</span></span><br><span class="line">                            <span class="comment">// 缓存为空（之前没有过任何线程获得过读锁），或最后一个获得读锁的线程不是当前线程</span></span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHold.get();  <span class="comment">// 获取当前线程的 HoldCounter</span></span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  <span class="comment">// 当前线程没有获得过读锁</span></span><br><span class="line">                                    readHolds.remove();  <span class="comment">// 将它从 ThreadLocal 中去掉</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  <span class="comment">// 当前线程没有获得过读锁</span></span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 获取读锁失败了，排队去吧</span></span><br><span class="line">                        <span class="comment">// 否则（rh.count != 0），重入读锁</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在自旋中成功获得读锁了：</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="comment">// 以下逻辑和 线程直接获取读锁成功 那一块基本一样</span></span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先清理 ThreadLocal 中对应的信息</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))  <span class="comment">// 缓存的不是当前线程</span></span><br><span class="line">                    rh = readHolds.get();  <span class="comment">// 从 ThreadLocal 中取</span></span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;  <span class="comment">// 该线程持有的读锁被释放完毕</span></span><br><span class="line">                    readHolds.remove();  <span class="comment">// 从 ThreadLocal 中移除</span></span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;  <span class="comment">// 减少持有数量</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// CAS 修改同步状态，确保线程安全</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;  <span class="comment">// nextc == 0 说明读锁写锁都空了；帮助唤醒同步队列后继节点中获取写锁的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 1：<code>readerShouldBlock()</code> 方法用来判定获取读锁的线程是否要被阻塞。</p>
<ul>
<li>非公平状态下，写锁获取的优先级会更高，因此如果存在要读取写锁的线程，则读锁需要让步，<code>readerShouldBlock() = true</code>；</li>
<li>公平状态下则按照先进先出的顺序：有线程在排队，你新来的不能直接获得锁</li>
</ul>
<p>注 2：<code>cachedHoldCounter</code> 有什么用？其实用处不大，主要是用来提升性能。<br>将最后一次获取读锁的线程缓存到这里，比 ThreadLocal 的 map 结构性能好一些。</p>
<p>同理，设置 <code>firstReader</code> 和 <code>firstReaderHoldCount</code> 也一样，虽然用处不大，但是可以提升性能，使得在读锁不产生竞争的情况下，记录读锁的重入次数会非常方便快捷。<br>如果一个线程使用了 <code>firstReader</code>，那么它就不需要占用 <code>cachedHoldCounter</code>。</p>
<p><br></p>
<p><strong>4</strong>. 锁降级</p>
<p>并没有任何一篇文档中写明写锁比读锁更高级，不过从上述源码浅析中可以看到，在同步状态操作的时候，的确会对写锁一些照顾。（参照<strong>写锁的获取</strong>）</p>
<p>读写锁中的“锁降级”，指的是线程持有锁的变化：持有写锁的线程，去获得读锁，随后再释放写锁。<br>感兴趣可以读一下 <code>ReentrantReadWriteLock</code> 的 javadoc 给出的示例。</p>
<p>由此定义反推的“升级”是不可以的，试想一下，获取读锁之后，线程再次获得写锁就会将自己阻塞掉了，而且可能就没有其他线程唤醒它了，很容易造成死锁。</p>
<p><br></p>
<h1 id="Condition-接口"><a href="#Condition-接口" class="headerlink" title="Condition 接口"></a>Condition 接口</h1><p>有的时候根据业务，某些线程进入临界区 critical section 后，还需要满足一定条件才能执行。<br>注：不能在多线程中简单使用判定后读写的方法 —— 有可能在 if 判断后被中断。</p>
<p>可以使用 Condition 的实现对象来管理已获得锁但还不能做有用工作的线程。</p>
<p>等待池是由 Condition 内部实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将线程放入该条件等待池里面</span></span><br><span class="line"><span class="comment">     * 调用后当前线程被阻塞，持有锁的话，放弃锁</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 与当前在等待获得锁的线程不同：</span></span><br><span class="line"><span class="comment">     *  - 当锁可用时，该线程需等待另一线程调用同一条件的 signalAll() 才可解除阻塞</span></span><br><span class="line"><span class="comment">     *  - 如没有其他线程激活等待线程：死锁</span></span><br><span class="line"><span class="comment">     *  - 如没有任何线程解除其他线程的阻塞：程序挂起</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注：调用应在循环体中：</span></span><br><span class="line"><span class="comment">     *     while (!okToBeProceed()) &#123; condition.await(); &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 进入该条件的等待池，直至线程从等待池里面移出，或到指定时间才解除阻塞</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 超时期限到：返回 false，否则为 true</span></span></span><br><span class="line"><span class="comment"><span class="function">     */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 进入该条件等待池，直到线程从等待池中被移出才解除阻塞</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 不响应中断：如线程被中断，不会抛出 InterruptedException 异常</span></span></span><br><span class="line"><span class="comment"><span class="function">     */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 解除该条件的等待池里面所有线程的阻塞状态</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 不会立即激活线程：解除阻塞的线程还需通过竞争访问数据</span></span></span><br><span class="line"><span class="comment"><span class="function">     */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 从该条件的等待池中随机选择一个线程，解除其阻塞状态</span></span></span><br><span class="line"><span class="comment"><span class="function">     * 如随机选择线程仍不能运行：再次被阻塞</span></span></span><br><span class="line"><span class="comment"><span class="function">     */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>看着上面的方法名，是不是觉得很熟悉？</p>
<p>没错，Condition 方法的命名（<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>）分别与 Object 同样功能的方法（<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>）区分开。</p>
<p>Object 监视器（Monitor）方法和 <code>synchronized</code> 关键字配合使用；而 Condition 接口和 <code>Lock</code> 配合使用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th>Object Monitor Methods</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置条件</td>
<td>获取对象的锁</td>
<td>调用 Lock.lock() 获取锁<br>调用 Lock.newCondition() 获取 Condition 对象</td>
</tr>
<tr>
<td>调用方式</td>
<td>直接调用<br>如 object.wait()</td>
<td>直接调用<br>如 condition.await()</td>
</tr>
<tr>
<td>等待队列个数</td>
<td>一个（Object 只有一个 wait() / notify()）</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态，在等待状态中不响应中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态到超时时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
</div>
<p>注：锁和条件都不是面向对象的设计</p>
<p>关键点：</p>
<ul>
<li>锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码</li>
<li>锁可管理试图进入被保护代码段的线程</li>
<li>锁可拥有一个或多个相关的 Condition 条件对象</li>
<li>每个条件对象管理着已进入被保护代码段但未能运行的线程</li>
</ul>
<p><br></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>等待池的实现（结合同步队列）</p>
<p><img src="/2021/08/22/java-lock/condition-wait-queue.png" alt></p>
<p>等待（<code>Condition.await()</code>）</p>
<p><img src="/2021/08/22/java-lock/condition-wait.png" alt></p>
<p>通知（<code>Condition.signal()</code>）</p>
<p><img src="/2021/08/22/java-lock/condition-notify.png" alt></p>
<p>AQS 对 Condition 相关方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);  <span class="comment">// 保存线程后将其阻塞</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)  <span class="comment">// clear up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 与其平台体系</title>
    <url>/2023/06/21/java/</url>
    <content><![CDATA[<p>作为一名 Java 开发者，今天唠一唠 Java 开发平台的一点基本情况。</p>
<span id="more"></span>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>根据创始公司 Sun Microsystems 的描述，Java 是一门：</p>
<pre><code>简单、完全面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的编程语言。

我们关心的是，减少开发健壮代码所需的时间以及困难。
</code></pre><p>Java 最初被称为 Oak，是 1991 年为消费类电子产品的嵌入型芯片而设计的开发平台。1995 年 5 月更名，并重新应用于开发 Internet 应用程序。</p>
<p>2010 年，Sun 被甲骨文（Oracle）收购，Java 随即归于 Oracle 旗下。</p>
<p>Java 除了我们熟知的 Java 程序设计语言之外，还有一块大头是 Java 平台。</p>
<h2 id="Java-开发平台"><a href="#Java-开发平台" class="headerlink" title="Java 开发平台"></a>Java 开发平台</h2><p>Java 平台（software platform）是由 Java 程序语言编写的软件赖以开发的平台，是 Java 软件和电脑系统的中介。<br>最初被设计用在 Applet 等桌面端程序开发，不过后来逐渐转移到服务端的运用。<br>主要分三类：</p>
<ul>
<li>Java SE（<strong>J2SE</strong>, Java 2 Platform Standard Edition）：Java 平台标准【基础】版，即 Java 桌面版</li>
<li>Java EE（<strong>J2EE</strong>, Java 2 Platform Enterprise Edition）：Java 平台企业版，基于 J2SE 打造，用于构建大型网站；后来重命名为 Jakarta EE </li>
<li>Java ME（<strong>J2ME</strong>, Java 2 Platform Micro Edition）：Java 平台微型版，基于 J2SE 打造，用于构建手机移动终端。</li>
</ul>
<p>当今最流行的 Java 开发环境：</p>
<ul>
<li>Eclipse</li>
<li>IntelliJ IDEA</li>
<li>Jbuilder</li>
<li>JCreator</li>
<li>Jdeveloper</li>
<li>MyEclipse</li>
<li>Netbeans</li>
</ul>
<p>就拿 Eclipse 来说：Eclipse 是一款开放源代码的、基于 Java 的可扩展开发平台，其实是 Visual Age for Java</p>
<ul>
<li>Eclipse 本身只是一个框架和一组服务</li>
<li>Eclipse 中每一样东西都是插件，用户通过不同的插件组件来构建开发环境；所以可以通过添加插件实现强大的功能</li>
<li>同时还附带了一个标准的插件集，包括 Java 开发工具</li>
</ul>
<p>因此 Eclipse 可以支持多种语言的开发，如 C/C++，PHP 等；而许多软件开发商也以 Eclipse 为框架开发自己的 IDE。</p>
<p>IBM 提供了最初的 Eclipse 代码基础，包括 Platform、JDT 和 PDE。</p>
<p>Eclipse 分支（Eclipse 标准版 + 功能插件）如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Eclipse Standard</td>
<td style="text-align:left">标准版</td>
</tr>
<tr>
<td style="text-align:left">Eclipse IDE for Java EE Developers</td>
<td style="text-align:left">面向 J2EE</td>
</tr>
<tr>
<td style="text-align:left">Eclipse IDE for Java Developers</td>
<td style="text-align:left">面向 J2SE</td>
</tr>
<tr>
<td style="text-align:left">Eclipse IDE for C/C++ Developers</td>
<td style="text-align:left">面向 C/C++</td>
</tr>
<tr>
<td style="text-align:left">Eclipse for PHP Developers</td>
<td style="text-align:left">面向 PHP</td>
</tr>
<tr>
<td style="text-align:left">Eclipse for RCP and RAP Developers</td>
<td style="text-align:left">面向 Eclipse 插件开发</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Java-特性"><a href="#Java-特性" class="headerlink" title="Java 特性"></a>Java 特性</h1><p><strong>Object Oriented</strong></p>
<p>以对象为基本粒度，对象的属性定义了这个对象，对象的方法可用来操作对象</p>
<ul>
<li>使代码 human-being-like，利于代码扩展和复用</li>
</ul>
<p><strong>Platform Independent</strong></p>
<p>Java 源代码编译后的字节码与平台无关，与底层应用打交道的事情都交给了 JVM，真正做到 write / compile once, run everywhere</p>
<p><strong>Safe</strong></p>
<p>包括：</p>
<ul>
<li>语言级安全性（对象的封装）</li>
<li>编译时安全性（语法意义检查）</li>
<li>运行时安全性（类装载器装载及字节码校验器校验）</li>
<li>可执行代码安全性（网络访问类的时候进行了权限设置）</li>
<li>当然，总有安全漏洞躺在人们意想不到的地方</li>
</ul>
<p><strong>Threading</strong></p>
<p>多线程提高了程序对硬件的利用率。</p>
<p>由此，Java 技术具有卓越的通用性、高效性、平台移植性和安全性。</p>
<p>Java 不同于一般的编译语言和直译语言：它首先将源代码编译成<strong>字节码</strong>，然后依赖各种不同平台上的虚拟机来解释执行字节码，从而实现 write / compile once, run everywhere。</p>
<p>至于语法糖更是数不胜数了：</p>
<ul>
<li>泛型和类型擦除</li>
<li>自动装箱与拆箱</li>
<li>变长参数</li>
<li>增强 for 循环</li>
<li>内部类</li>
<li>枚举类</li>
<li>…</li>
</ul>
<h2 id="Java-v-s-C"><a href="#Java-v-s-C" class="headerlink" title="Java v.s. C++"></a>Java v.s. C++</h2><p>Java 很大程度上沿袭了 C++ 的一些实用结构，因此风格十分接近 C++，继承了 C++ 语言面向对象技术的核心。</p>
<p>Java 与 C++ 的区别在于：</p>
<ol>
<li>Java 运行于 <a href="/2021/07/07/jvm-basics">JVM</a> 上面，可移植性强，且 JVM 几乎可以安装到任何的系统；C++ 如果要在不同的系统中运行，需要不同的编码；<ul>
<li>也正因如此，Java 在桌面程序应用上面不如 C++ 实用，因为 C++ 可以直接编译成 .exe 文件；</li>
</ul>
</li>
<li>指针是 C++ 的优势，可直接对内存操作，因此 C++ 利用于<strong>底层程序的编程</strong>以及控制方面的编程<strong>更灵活</strong>；<ul>
<li>但指针编程同时具有危险性；Java 舍弃了 C++ 中容易引起错误的指针，改用<strong>引用</strong>取代；</li>
</ul>
</li>
<li>关于垃圾回收：C++ 利用析构函数，Java 是<strong>自动启动垃圾回收</strong>机制；因此相比起 C++，java 运行速度会<strong>慢</strong>一些；</li>
<li>Java 移除原 C++ 的操作符重载，也移除了多重继承特性，改用<strong>接口</strong>取代；</li>
<li>Java 在 web 前端的应用上具有 C++ 无法比拟的优势；</li>
<li>Java 具有异常处理机制</li>
</ol>
<h2 id="Java-v-s-C-1"><a href="#Java-v-s-C-1" class="headerlink" title="Java v.s. C#"></a>Java v.s. C#</h2><ol>
<li>Java 不允许操作符重载</li>
<li>Java 没有类似于 LINQ 的特性</li>
<li>Java 内部类可以直接访问外部类的实例成员，C# 不行</li>
<li>C# 能被重写的方法必须添加 <code>virtual</code> 关键字声明为虚方法；Java 对于方法的默认行为都可以被重写</li>
<li>C# 没有匿名内部类</li>
</ol>
<h1 id="Java-程序生命周期"><a href="#Java-程序生命周期" class="headerlink" title="Java 程序生命周期"></a>Java 程序生命周期</h1><ol>
<li><p>编译：源文件（<code>.java</code>） -&gt; 编译器（javac） -&gt; 字节码 byte code（<code>.class</code>）</p>
<ul>
<li>注：<strong>JVM 只能运行字节码文件</strong></li>
</ul>
</li>
<li><p>装载：字节码（<code>.class</code>） -&gt; JVM <a href="/2021/07/08/class-loader/#类加载过程">类加载器</a> -&gt; JVM 中装载的类</p>
</li>
<li><p>校验：JVM 中装载的类 -&gt; JVM 字节码校验器 -&gt; 进行校验</p>
</li>
<li><p>解释：JVM 中装载的类 -&gt; JVM 解释器（根据 OS 解释） -&gt; 机器码</p>
</li>
<li><p>运行：机器码 -&gt; OS -&gt; 运行的程序</p>
</li>
<li><p>回收：内存垃圾 -&gt; JVM <a href="/2021/07/09/garbage-collection">垃圾回收器</a> -&gt; 不定期垃圾回收</p>
</li>
<li><p>终止：JVM 卸载程序</p>
</li>
</ol>
<p>注意：编写好的 Java 程序不能够直接在操作系统中运行，而是运行在 <strong>JVM</strong> 中。</p>
<p>每一种 Java 平台的解释器可能有不同，但实现的 JVM 是一样的：这也是 Java 为何能跨平台的重要原因之一原因。</p>
<h1 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h1><p>Java 的注释风格有单行注释、多行注释、类和方法注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 看看，</span></span><br><span class="line"><span class="comment"> 这是多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档/类/方法的注释</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Java 的工程包 packages 命名一般遵循以下层次：<code>com.公司名.项目名.模块名</code>。</p>
<p>Java 变量和方法的命名有以下要求：</p>
<ul>
<li>不与 Java 关键字冲突</li>
<li>不以数字开头</li>
<li>可包含 <code>$</code> 和 <code>_</code>，此外不能有其他符号</li>
<li>可以用 <code>$</code> 和 <code>_</code> 开头</li>
<li>一般遵循伪驼峰命名习惯：userName, myAccount</li>
</ul>
<p>常量命名：建议全大写，final 修饰，常配以 static 修饰符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141593</span>;</span><br></pre></td></tr></table></figure>
<p>对于项目 / 类 / 接口的命名，除了使用驼峰命名（MyClass, MyInterface）之外，其它基本与变量 / 方法名相同。</p>
<h1 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h1><p><a href="/2021/07/07/jvm-basics">JVM</a> 是 Java 运行环境（Java Runtime Environment, <strong>JRE</strong>）的一部分。</p>
<p>JRE 是运行 Java 程序所<strong>必需的环境集合</strong>，包含 JVM 的标准实现及 Java 核心类库</p>
<ul>
<li>JRE 仅仅能够完成 Java 的运行，无法对 Java 进行编译、调试</li>
<li>它面向的是 Java 程序使用者，而非开发者</li>
<li>JRE 有独立版本，如果只需要运行 Java 程序，安装 JRE 即可。</li>
</ul>
<p>JRE 的组成：</p>
<ul>
<li>Java 的类库，包含了编译 Java 程序所需要的最核心文件<ul>
<li>核心库文件，其中有<ul>
<li>数据结构的库，包括列表、字典和树等</li>
<li>XML 分析库</li>
<li>安全方面应用库</li>
<li>国际化和本地化应用库</li>
</ul>
</li>
<li>综合库文件，包含了程序员和其他系统通信的功能文件<ul>
<li>JDBC，即 Java 数据库连接的 API</li>
<li>JNDI，即 Java 命名和目录接口</li>
<li>RMI 和 CORBA，用于重新分发软件</li>
</ul>
</li>
<li>用户界面库文件，包含：<ul>
<li>AWT，即抽象窗口开发包，提供了产生图形用户界面所需要的功能</li>
<li>Swing 库</li>
<li>其他用于回访媒体文件、录音、截图的库</li>
</ul>
</li>
</ul>
</li>
<li>一个用于执行软件的 JVM 实现</li>
<li>插件，可以在浏览器里面使用</li>
<li>JWS（Java Web Service），可以让终端用户连接到互联网</li>
<li>许可文件和文档</li>
</ul>
<p>如果要进行 Java 开发，需要安装 JDK。</p>
<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><p><strong>JDK</strong>（Java Development Kit）是 Java 语言的开发包，包含了 JRE，可以将 <code>.java</code> 文件编译为可执行 Java 程序，通过加载到 JVM 然后运行。</p>
<p>完整的 JDK 包括以下基本组件：</p>
<ul>
<li><code>/bin</code> 目录，包括<ul>
<li>编译器（javac）</li>
<li>解释器（java）</li>
<li>jdb 调试器（java debugger）</li>
<li>文档生成器（javadoc）</li>
</ul>
</li>
<li><code>/demo</code> 目录，包括一些代码的演示</li>
<li><code>/include</code> 目录：用于编译本地方法的文件，如 JNI 调用时所需的 C 语言头文件</li>
<li><code>/JRE</code> 目录，包含JVM 运行环境，JDK 类库，与所在平台相关</li>
<li><code>/lib</code> 目录，包含除 <code>/JRE</code> 下之外 JDK 额外所需的类库</li>
<li><code>src.zip</code>，里面是 JDK 的源代码</li>
<li>jar 打包工具</li>
<li>头文件生成器</li>
<li>javap 反汇编器</li>
<li>监控工具</li>
<li>…</li>
</ul>
<p><img src="/2023/06/21/java/j2se.png" alt></p>
<p>JDK 中常用的 package：</p>
<ul>
<li><code>java.lang</code>：系统基础类，如 String；该 package 是唯一不需要 <code>import</code> 的 package</li>
<li><code>java.io</code>：所有与输入输出有关的类</li>
<li><code>java.net</code>：所有与网络连接有关的类</li>
<li><code>java.util</code>：系统辅助类，包括 <a href="/2022/04/30/java-collection">Collection</a>, <a href="/2022/04/30/java-collection/#List-接口">List</a>, <a href="/2022/05/06/java-map">Map</a> 等</li>
<li><code>java.sql</code>：数据库操作类，Connection, Statement, ResultSet 等</li>
<li><code>java.servlet</code>：JSP、Servlet 等使用到的类</li>
</ul>
<p>下面介绍几个长期支持（LTS）的 JDK 版本。</p>
<h2 id="JDK-1-5"><a href="#JDK-1-5" class="headerlink" title="JDK 1.5"></a>JDK 1.5</h2><p>Java 5 最重要的一个支持是泛型（generics），为了参数化类型，或者说可以将类型当作参数传递给一个类或者方法。</p>
<ol>
<li>与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。</li>
<li>当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。所以说，它是一种类型安全检测机制，一定程度上提高了软件的安全性防止出现低级的失误。</li>
<li>泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换，在定义或者实例化阶段，因为 <code>Cache&lt;String&gt;</code> 这个类型显化的效果，程序员能够一目了然猜测出代码要操作的数据类型。</li>
</ol>
<p>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，这叫做<strong>类型擦除</strong>。</p>
<p>类型擦除容易带来强制类型转换和引用传递的问题。</p>
<h2 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h2><p>Java 7（JDK 1.7）于 2011 年 7 月推出，是 Java 史上最大的一次更新。主要更新内容有：</p>
<ol>
<li>定义二进制（<code>byte</code>）为基本类型变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)<span class="number">0b00000001</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0b00000001</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>下划线分隔数字</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> aLongDecimal = <span class="number">1234_5678_9012L</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>switch 语句判断 String 类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (dayName) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Monday"</span>: recover();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Tuesday"</span>: work(hard);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Wednesday"</span>: work(notThatHard);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Thursday"</span>: work(lazily);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Friday"</span>: work(withoutPatience);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Saturday"</span>: party(hard);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Sunday"</span>: party(hard);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 本质上还是对 int 的支持：编译时候是对 string 的 hashcode 做 switch</span></span><br></pre></td></tr></table></figure>
<ol>
<li>泛型实例化自动推断类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ol>
<li>推出 <code>try-with-resource</code>：不需要手动关闭资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java 6-</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    FileReader fr = <span class="keyword">new</span> FileReader(path)</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">    <span class="keyword">return</span> br.readLine();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span>) {</span><br><span class="line">        br.close();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (fr != <span class="keyword">null</span>) {</span><br><span class="line">        fr.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// java 7+</span></span><br><span class="line"><span class="comment">// try-with-resource can make sure the resources are closed before returning</span></span><br><span class="line"><span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(path)</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);) {</span><br><span class="line">    <span class="keyword">return</span> br.readLine();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol>
<li>单个 catch 子句可以捕获多个异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java 6-</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    ... <span class="comment">// block in which exceptions to be caught</span></span><br><span class="line">} <span class="keyword">catch</span> (NoSuchFileException e1) {</span><br><span class="line">    logger.log(e1);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(e1);</span><br><span class="line">} <span class="keyword">catch</span> (IOException e2) {</span><br><span class="line">    logger.log(e2);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(e2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// java 7+</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    ... <span class="comment">// block in which exceptions to be caught</span></span><br><span class="line">} <span class="keyword">catch</span> (NoSuchFileException | IOException ex) {</span><br><span class="line">    logger.log(ex);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(ex);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h2><p>Java 8 于 2014 年 3 月发布。主要更新内容：</p>
<p><strong>1</strong>. 移除位于 JVM 内存中的 PermGen，新增位于本地内存中的 <code>Metaspace</code>；</p>
<p><strong>2</strong>. 接口扩展：给接口方法添加<strong>默认</strong>（default 关键字）或<strong>静态</strong>实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认实现</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Example</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Example</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>3</strong>. 函数式接口的定义：任何接口，如果<strong>只含一个抽象方法</strong>，就是一个函数式接口。其本质上来说，是<a href="/2022/02/07/fp">函数式编程</a>的应用。</p>
<p>可以给接口添加 <code>@FunctionalInterface</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function&lt;T, R&gt; - 输入 T, 输出 R</span></span><br><span class="line">Function&lt;String,String&gt; function = (x) -&gt; {</span><br><span class="line">    System.out.print(x + <span class="string">": "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Function"</span>;</span><br><span class="line">};</span><br><span class="line">System.out.println(function.apply(<span class="string">"hello world"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Predicate&lt;T&gt; - 输入 T, 返回一个 boolean 值</span></span><br><span class="line">Predicate&lt;String&gt; pre = (x) -&gt;{</span><br><span class="line">    System.out.print(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">};</span><br><span class="line">System.out.println(<span class="string">": "</span> + pre.test(<span class="string">"hello World"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer&lt;T&gt; - 输入 T, 执行动作无输出</span></span><br><span class="line">Consumer&lt;String&gt; con = (x) -&gt; {</span><br><span class="line">    System.out.println(x);</span><br><span class="line">};</span><br><span class="line">con.accept(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supplier&lt;T&gt; - 无输入, 输出 T</span></span><br><span class="line">Supplier&lt;String&gt; supp = () -&gt; {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Supplier"</span>;</span><br><span class="line">};</span><br><span class="line">System.out.println(supp.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryOperator&lt;T&gt; - 输入两个 T，输出 T，think about reduce of map-reduce</span></span><br><span class="line">BinaryOperator&lt;String&gt; bin = (x, y) -&gt;{</span><br><span class="line">    System.out.print(x + <span class="string">" "</span> + y);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"BinaryOperator"</span>;</span><br><span class="line">};</span><br><span class="line">System.out.println(<span class="string">" "</span> + bin.apply(<span class="string">"hello "</span>, <span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// hello world: Function</span></span><br><span class="line"><span class="comment">// hello World: false</span></span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line"><span class="comment">// Supplier</span></span><br><span class="line"><span class="comment">// hello world BinaryOperator</span></span><br></pre></td></tr></table></figure>
<p>另外就是 <a href="/2022/02/07/fp/#进阶应用：Optional">Optional</a> 类（<code>java.util.Optional</code>）的应用</p>
<ul>
<li>一个可以包含 null 值的容器对象，可用来代替 <code>xx != null</code> 的判断</li>
</ul>
<p><strong>4</strong>. 方法引用</p>
<ul>
<li>Reference to constructor, 构造方法引用</li>
<li>Reference to static method, 类静态方法引用</li>
<li>Reference to methods of an instance, 某个对象的方法引用</li>
<li>Reference to methods of a specific class for any instance, 特定类的任意对象的方法引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先定义一个基本的 entity 类 Person, nothing special</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person a, Person b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().compareTo(p.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再定义一个 PersonFactory，注意此处有一个 java.util.function.Supplier，无输入，单个输出。</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;Person&gt; supplier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonFactory</span><span class="params">(Supplier&lt;Person&gt; supplier)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后是测试类</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReference</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 引用构造函数</span></span><br><span class="line">        PersonFactory factory = <span class="keyword">new</span> PersonFactory(Person::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Person p1 = factory.getPerson();</span><br><span class="line">        p1.setName(<span class="string">"Kobe"</span>);</span><br><span class="line">        personList.add(p1);</span><br><span class="line">        Person p2 = factory.getPerson();</span><br><span class="line">        p2.setName(<span class="string">"James"</span>);</span><br><span class="line">        personList.add(p2);</span><br><span class="line">        Person p3 = factory.getPerson();</span><br><span class="line">        p3.setName(<span class="string">"Paul"</span>);</span><br><span class="line">        personList.add(p3);</span><br><span class="line"></span><br><span class="line">        Person[] persons1 = personList.toArray(<span class="keyword">new</span> Person[personList.size()]);</span><br><span class="line">        System.out.print(<span class="string">"before: "</span>);</span><br><span class="line">        printArray(persons1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用静态方法</span></span><br><span class="line">        Arrays.sort(persons1, MethodReference::myCompare);</span><br><span class="line">        System.out.print(<span class="string">"after: "</span>);</span><br><span class="line">        printArray(persons1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Person[] persons2 = personList.toArray(<span class="keyword">new</span> Person[personList.size()]);</span><br><span class="line">        System.out.print(<span class="string">"before: "</span>);</span><br><span class="line">        printArray(persons2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用特定对象的实例方法</span></span><br><span class="line">        Arrays.sort(persons2, p1::compare);</span><br><span class="line">        System.out.print(<span class="string">"after: "</span>);</span><br><span class="line">        printArray(persons2);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Person[] persons3 = personList.toArray(<span class="keyword">new</span> Person[personList.size()]);</span><br><span class="line">        System.out.print(<span class="string">"before: "</span>);</span><br><span class="line">        printArray(persons3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用特定类型的任意对象的实例方法</span></span><br><span class="line">        Arrays.sort(persons3, Person::compareTo);</span><br><span class="line">        System.out.print(<span class="string">"after: "</span>);</span><br><span class="line">        printArray(persons3);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Person[] persons)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (Person p : persons) {</span><br><span class="line">            System.out.print(p.getName() + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myCompare</span><span class="params">(Person p1, Person p2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>5</strong>. Lambda Expression</p>
<ul>
<li>a.k.a. clousure, 闭包</li>
<li>把函数当成方法参数，可以替代匿名对象</li>
</ul>
<p>应用于数组的 foreach：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>);</span><br><span class="line">String sep = <span class="string">","</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本</span></span><br><span class="line">names.forEach( e -&gt; {</span><br><span class="line">    System.out.println(e + sep);  <span class="comment">// sep 变为 final</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化, 指定迭代类型,</span></span><br><span class="line">names.forEach((String e) -&gt; System.out.println(e));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再简化, 类型自动推断</span></span><br><span class="line">names.forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>
<p>应用于字符串数组排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统匿名对象</span></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通 lambda</span></span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; {</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化只有一句的方法</span></span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; a.compareTo(b));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步简化，类型自动推断</span></span><br><span class="line">Collections.sort(names, (a, b) -&gt; a.compareTo(b));</span><br></pre></td></tr></table></figure>
<h2 id="JDK-1-11"><a href="#JDK-1-11" class="headerlink" title="JDK 1.11"></a>JDK 1.11</h2><p>Java 11 于 2018 年 9 月发布，主要的增强有：</p>
<ol>
<li>增加了一些字符串的处理方法；</li>
<li>用于 Lambda 参数的局部变量语法；</li>
<li>Http Client 重写，支持 HTTP/1.1 和 HTTP/2 ，也支持 websockets</li>
<li>可运行单一的 Java 源码文件，如：java Test.java</li>
<li>新的垃圾回收器 ZGC：可伸缩低延迟垃圾收集器；ZGC 可看作是 G1 之上更细粒度的内存管理策略；</li>
<li>支持 TLS 1.3 协议</li>
<li>Flight Recorder（飞行记录器），基于 OS、JVM 和 JDK 的事件产生的数据收集框架</li>
<li>对 Stream、Optional、集合 API 进行增强。</li>
</ol>
<p>挑重点：对于 JDK 1.9 和 JDK 1.10（局部变量类型 <code>var</code> 推断等）的完善，主要是对于 Stream、集合等 API 的增强、新增 ZGC 垃圾收集器。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存异常处理</title>
    <url>/2021/07/15/jm-errors/</url>
    <content><![CDATA[<p>Java 程序中常见的内存毛病就是<strong>内存溢出</strong>和<strong>内存泄漏</strong>了。本帖专门来聊聊这俩毛病，以及做一下比较。</p>
<span id="more"></span>
<h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1><p>内存溢出（Out Of Memory, <strong>OOM</strong>），对应的是 <code>java.lang.OutOfMemoryError</code> 这一非运行时异常。</p>
<ul>
<li>继承自 <code>java.lang.VirtualMachineError</code>。</li>
</ul>
<p>常见原因：</p>
<ul>
<li>内存中加载的数据量过于庞大，如一次过从数据库取出过多数据</li>
<li>集合类中有对对象的引用，使用完之后未清空，使得 JVM 不能回收</li>
<li>代码中存在死循环或循环产生过多重复的对象实体</li>
<li>启动参数内存值设定得过小</li>
<li>使用的第三方软件中的 BUG</li>
</ul>
<p>常见的错误提示：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tomcat: </span></span><br><span class="line">java.lang.OutOfMemoryError: PermGen space  <span class="comment"># Java 8-</span></span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"></span><br><span class="line"><span class="comment"># web logic:</span></span><br><span class="line">Root cause of ServletException java.lang.OutOfMemoryError</span><br><span class="line"></span><br><span class="line"><span class="comment"># resin: </span></span><br><span class="line">java.lang.OutOfMemoryError</span><br><span class="line"></span><br><span class="line"><span class="comment"># java:</span></span><br><span class="line">java.lang.OutOfMemoryError</span><br></pre></td></tr></table></figure></p>
<h2 id="需要重点排查的原因"><a href="#需要重点排查的原因" class="headerlink" title="需要重点排查的原因"></a>需要重点排查的原因</h2><ul>
<li>检查代码中是否有死循环或者递归调用</li>
<li>检查是否存在重复产生新对象实体的大循环</li>
<li>检查对数据库查询中，是否有一次获得全部数据的查询：<ul>
<li>一般来说，如果一次取 10 万条数据到内存，就可能引起内存溢出。这属于比较隐蔽的问题，在上线前数据较少，不容易出问题，上线后数据增加，就可能会有问题</li>
<li>对于数据库查询，尽量使用分页的方式查询</li>
</ul>
</li>
<li>检查 List、Map 等集合对象是否有使用完之后，未清除的问题<ul>
<li>List、Map 等集合对象会始终存有对对象的引用，使得这些对象不能被 GC 回收</li>
</ul>
</li>
</ul>
<h2 id="主要的解决方法"><a href="#主要的解决方法" class="headerlink" title="主要的解决方法"></a>主要的解决方法</h2><p><strong>1. 增加 JVM 内存大小</strong></p>
<ul>
<li>执行某个 .class 文件之后，可以使用 <code>java -Xmx256M xxx.class</code> 来设置运行该 .class 时 JVM 所允许占用的最大内存是 256M</li>
<li>对于 Tomcat：启动时对 JVM 设置内存限度，在 <code>catalina.bat</code>（<code>catalina.sh</code>）中添加<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> CATALINA_OPTS=-Xms128M -Xmx256M</span><br><span class="line"><span class="built_in">set</span> JAVA_OPTS=-Xms128M -Xmx256M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将 `%CATALINA_OPTS%` 和 `%JAVA_OPTS%` 代替为 `-Xmx128M -Xmx256M`</span></span><br></pre></td></tr></table></figure></li>
<li>对于 Resin 容器：启动时对 JVM 设置内存限度，在 <code>bin</code> 文件夹下创建一个 <code>startup.bat</code><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">call</span> &quot;httpd.exe&quot; &quot;-Xms128M&quot; &quot;-Xmx256M&quot;</span><br><span class="line">:end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2. 优化程序、释放垃圾（避免死循环）</strong></p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>Memory Leak，指程序在申请内存后，无法释放已经申请的空间。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>内存泄漏可分为以下四类：</p>
<p><strong>1. 常发性内存泄漏</strong>：发生内存泄漏的代码会被多次执行，每次被执行的时候都会导致一块内存泄漏</p>
<p><strong>2. 偶发性内存泄漏</strong>：发生内存泄漏的代码只在特定环境或操作过程下才发生</p>
<ul>
<li>常发性和偶发性是相对的：对于特定环境，偶发性也许会变成常发性</li>
<li>测试环境和测试方法对检测内存泄漏至关重要</li>
</ul>
<p><strong>3. 一次性内存泄漏</strong>：发生内存泄漏的代码只被执行一次</p>
<ul>
<li>可能性：算法缺陷</li>
<li>如：在类的构造函数分配内存，在析构函数没有释放内存 —— 泄漏一次</li>
</ul>
<p><strong>4. 隐式内存泄漏</strong>：程序在运行过程中不停分配内存，但直到结束时才释放内存</p>
<ul>
<li>严格说并没发生内存泄漏：因为最终释放了所有申请的内存</li>
<li>但对于服务器程序：运行几周、几天或几个月，不及时释放可能会导致最终耗尽系统所有内存</li>
</ul>
<p>内存泄漏最终会导致内存溢出。</p>
<h2 id="经典场景"><a href="#经典场景" class="headerlink" title="经典场景"></a>经典场景</h2><p><strong>1. 静态集合类中的元素失去了外部引用：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HashMap&lt;String, Object&gt; map;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">map.put(<span class="string">&quot;o&quot;</span>, o);</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">null</span>;  <span class="comment">// map 仍然持有该对象的引用，不能被 GC</span></span><br><span class="line">System.out.println(<span class="keyword">null</span> == map.get(<span class="string">&quot;o&quot;</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. Hash 集合添加元素引发的内存泄漏：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Person dummyKey = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可重复添加，导致内存泄漏</span></span><br><span class="line">    map.put(dummyKey, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入 Hash 集合的类如果不实现 hashCode()，集合每次将该类的对象视为新的对象，因此导致可以重复添加</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如示例：Person 类需实现 hashCode() 方法，且 hashCode() 的返回值与属性相关</span></span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 监听器/各种连接：</strong></p>
<ul>
<li>调用 addListener() 后忘记释放</li>
<li>建立 DB Connection，Socket Connection，I/O Stream 后忘记调用相应的 close() 方法<ul>
<li>不仅需要调用 Connection::close()，还需关闭查询到的 ResultSet 和 Statement</li>
</ul>
</li>
<li>…</li>
</ul>
<p><strong>4. 单例对象 HAS-A 另外一个对象的引用：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">B</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B INSTANCE = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;<span class="keyword">this</span>.a = a;&#125;</span><br><span class="line">    <span class="comment">// 对象 a 不能被垃圾回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="内存溢出和内存泄漏的区别"><a href="#内存溢出和内存泄漏的区别" class="headerlink" title="内存溢出和内存泄漏的区别"></a>内存溢出和内存泄漏的区别</h1><p><strong>内存溢出</strong>是指程序在申请内存时，<strong>没有足够内存空间</strong>供其使用</p>
<ul>
<li>如申请了一个 Integer 的内存，却存了 Long 才能存下来的数</li>
</ul>
<p><strong>内存泄漏</strong>则是指程序在申请内存后，<strong>无法释放</strong>已经申请的空间</p>
<ul>
<li>一次内存泄露或许可以忽略，但内存泄漏堆积后果很严重，内存迟早会被占光</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存模型 JMM</title>
    <url>/2021/07/10/jmm/</url>
    <content><![CDATA[<p>在 JSR-133 规范中提出的 Java 内存模型（Java Memory Model, <strong>JMM</strong>），是一个用来定义一个一致性、跨平台的内存模型，是<strong>缓存一致性协议</strong>，用来定义数据读写的规则。</p>
<span id="more"></span>
<p>JMM 定义了在虚拟机中如何将变量存储进内存，以及从内存取出来的细节，其目标就是去规范 JVM 与计算机内存如何协同工作：</p>
<ul>
<li>规定了一个线程如何，以及何时能看到由其他线程修改过后的共享变量的值；</li>
<li>必须如何同步地访问共享变量。</li>
</ul>
<p>另外，JMM 屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台都能达到一致的并发效果。</p>
<p>JMM 的设计意图：</p>
<ul>
<li><strong>强内存模型</strong>：内存模型要为程序员提供足够强的内存可见性保证（代码要执行正确），易于程序员理解和使用</li>
<li><strong>弱内存模型</strong>：内存模型对编译器和处理器的限制要尽可能放松，这样编译器和处理器就可以做尽可能多的优化来提高性能</li>
</ul>
<p>因此，设计 JMM 的时候就需要找到一个平衡点。</p>
<p><br></p>
<h1 id="内存模型基础"><a href="#内存模型基础" class="headerlink" title="内存模型基础"></a>内存模型基础</h1><p>包括<strong>通信</strong>和<strong>同步</strong>。</p>
<p>通信，指的是线程之间以何种方式交换信息，通常有两种：</p>
<ul>
<li>隐式通信通过<strong>共享内存</strong>（线程之间共享程序的公共状态，通过读/写内存公共状态进行通信）</li>
<li>显式通信通过<strong>消息传递</strong>（线程之间没有公共状态）</li>
</ul>
<p>而同步，指的是程序中用于控制不同线程间<strong>操作发生的相对顺序</strong>的机制。显式同步通过<strong>共享内存</strong>，隐式同步通过<strong>消息传递</strong>。</p>
<p><br></p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>首先简单回顾一下不同 Java 对象的存储位置：</p>
<ul>
<li>一个局部变量如果是原始类型：它总是存储在线程栈上</li>
<li>一个局部变量如果是指向一个对象的引用：引用存放在线程栈，对象本身在堆上</li>
<li>一个对象的成员变量（全局变量）不管是原始类型还是引用类型，都可能跟随该对象自身放在堆上</li>
<li>静态成员变量跟随类定义一起存放到堆上</li>
<li>堆上的对象可被所有持有对该对象引用的线程访问<ul>
<li>当一个线程可访问一个对象时，它也可以访问该对象的成员变量</li>
<li>如两个线程同时调用同一对象的同一方法：都将会访问该对象的成员变量，但每个线程会各自拥有一份该成员变量的私有拷贝</li>
</ul>
</li>
</ul>
<p>大概的对应图如下图左所示：</p>
<p><img src="/2021/07/10/jmm/jmm-bridge.png" alt></p>
<p>再如图右及红色虚线框部分：对于硬件内存架构来说，是没有区分栈和堆的，所有线程的栈和堆都分布于主存，部分线程栈和堆有时出现在 CPU 缓存和内部寄存器中。  </p>
<p><br></p>
<p>下图展示了 JMM 定义的线程和主存间的抽象关系：</p>
<ul>
<li>线程之间的<strong>共享变量</strong>，也就是堆和方法区的数据，存储在<strong>主存</strong>中；</li>
<li>每个线程都各自保存一份<strong>本地内存</strong>（Local Memory，也叫<strong>工作内存</strong> Working Memory）<ul>
<li>“内存”范围涵盖了缓存、写缓冲区、寄存器等硬件，以及编译器优化</li>
<li>除了<strong>局部变量</strong>外，还存储了该线程已读/写共享变量的拷贝副本</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/10/jmm/relationship.png" alt></p>
<p>主存是硬件的内存。为获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。<br>因此，JMM 中的“本地内存”是对 CPU 的寄存器和高速缓存的抽象描述，并不真实存在。</p>
<p>而整个 JMM 所定义的，是 JVM 与硬件内存架构之间的桥接。JMM 通过控制主内存和每个线程的本地内存之间的<strong>交互</strong>，提供<strong>内存可见性</strong>的保证。</p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>JMM 协议中的线程间通信：<big><strong>共享内存</strong></big>，即<strong>隐式通信，显式同步</strong>。</p>
<p><img src="/2021/07/10/jmm/communication.jpeg" alt></p>
<p>如上：</p>
<ul>
<li>线程 A 将本地内存 A 中更新过的共享变量刷新回主内存</li>
<li>线程 B 到主内存读取线程 A 之前已更新过的共享变量</li>
</ul>
<p><br></p>
<h1 id="同步操作及规则"><a href="#同步操作及规则" class="headerlink" title="同步操作及规则"></a>同步操作及规则</h1><p>至于桥接的具体交互协议，JMM 定义了 <strong>8</strong> 种操作完成主内存与工作内存之间的具体交互细节：</p>
<p><img src="/2021/07/10/jmm/jmm-operation.png" alt></p>
<big>主内存操作：</big>

<p><strong>lock</strong>（锁定）</p>
<ul>
<li>作用于主内存的变量</li>
<li>将一个变量标识为被一条线程独占的状态</li>
</ul>
<p><strong>unlock</strong>（解锁）</p>
<ul>
<li>作用于主内存的变量</li>
<li>将一个处于锁定状态的变量释放，变量要被释放后才可被其他线程锁定</li>
</ul>
<p><br></p>
<big>取值操作：</big>

<p><strong>read</strong>（读取）</p>
<ul>
<li>作用于主内存的变量</li>
<li>将一个变量值从主内存传输到线程的工作内存中，以便随后的 load 操作使用</li>
</ul>
<p><strong>load</strong>（载入）</p>
<ul>
<li>作用于工作内存的变量</li>
<li>将 read 操作从主内存得到的变量值放入工作内存的变量副本中</li>
</ul>
<p><strong>use</strong>（使用）</p>
<ul>
<li>作用于工作内存的变量</li>
<li>将工作内存的一个变量值按需传递给执行引擎</li>
<li>每当 JVM 遇到一个需要使用变量值的字节码指令时，Java 线程会执行该操作</li>
</ul>
<p><br></p>
<big>写值操作：</big>

<p><strong>assign</strong>（赋值）</p>
<ul>
<li>作用于工作内存的变量</li>
<li>将一个从执行引擎（Java Execution）接收到的值赋值给工作内存的变量</li>
<li>每当 JVM 遇到一个给变量赋值的字节码指令时，Java 线程会执行该操作</li>
</ul>
<p><strong>store</strong>（存储）</p>
<ul>
<li>作用于工作内存的变量</li>
<li>将工作内存中一个变量值传送回主内存，以便随后的 write 操作</li>
</ul>
<p><strong>write</strong>（写入）</p>
<ul>
<li>作用于主内存的变量</li>
<li>将 store 操作送回来的工作内存变量值写回主内存变量的值</li>
</ul>
<h2 id="同步规则"><a href="#同步规则" class="headerlink" title="同步规则"></a>同步规则</h2><ol>
<li>如果要将变量从主内存复制到工作内存，需要<strong>按序执行 read 和 load</strong> 操作；</li>
<li>如果要将变量从工作内存同步回主内存，需要<strong>按序执行 store 和 write</strong> 操作</li>
</ol>
<p>注：JMM 只要求上述操作必须按顺序执行，没有保证必须连续执行</p>
<ol>
<li>不允许 read 和 load 二者、store 和 write 二者之一单独出现</li>
<li>不允许一个线程丢弃它最近的一次 assign 操作；也就是说，变量在工作内存中被改变了之后，必须同步回主内存</li>
<li>相应地，不允许一个线程无理由地（没发生任何 assign 操作）将数据从工作内存同步回主内存</li>
<li>一个<strong>新变量只能在主内存诞生</strong>，不允许在工作内存直接使用一个未被初始化（load 或 assign）的变量<ul>
<li>对一个变量实施 use 操作之前，必须先执行过了 load 操作</li>
<li>对一个变量实施 store 操作之前，必须先执行过了 assign 操作</li>
</ul>
</li>
<li>一个变量在同一个时刻，只允许一条线程对其进行 lock 操作：独占锁<ul>
<li>lock 操作可被同一线程重复执行多次</li>
<li>多次执行 lock 后，只有再执行相同次数的 unlock 操作才会解锁变量</li>
<li>即：lock 和 unlock 需成对出现，否则就死锁了</li>
</ul>
</li>
<li>如果一个线程需要锁住（lock）一个变量，需要先清空该线程工作内存中这个变量的值<ul>
<li>执行引擎（Java Execution）在使用该变量前，需要重新执行 load 或 assign 操作来初始化变量的值</li>
</ul>
</li>
<li>如一个变量事先没被 lock 锁定，不允许执行 unlock 操作；而且绝对不允许 unlock 一个被其他线程锁定的变量</li>
<li>对一个变量 unlock 前：需将此变量同步到主内存中（执行 store 和 write 操作）。</li>
</ol>
<p><br></p>
<h1 id="JMM-解决的问题"><a href="#JMM-解决的问题" class="headerlink" title="JMM 解决的问题"></a>JMM 解决的问题</h1><p>主要围绕着两点展开：<big><strong>指令重排</strong></big>，<big><strong>内存可见</strong></big>。</p>
<h2 id="线程缓存导致的可见性问题"><a href="#线程缓存导致的可见性问题" class="headerlink" title="线程缓存导致的可见性问题"></a>线程缓存导致的可见性问题</h2><p>问题一：在没有正确使用 volatile 声明或同步的时候，多个线程共享一个对象。</p>
<p>问题二：一个线程更新一个共享变量的时候，该操作可能对其他线程不可见：</p>
<ul>
<li>首先，共享对象在主内存被初始化</li>
<li>跑在 CPU 上的一个线程将该共享对象读到 CPU 缓存，然后修改</li>
<li>只要 CPU 缓存中被修改的值没被刷新回主内存，对象修改后的状态对于跑在其它 CPU 上的线程均不可见。</li>
</ul>
<p>这会导致当每个线程拥有该共享对象的私有拷贝的时候，每份拷贝都停留在不同的 CPU 缓存中。<br>如下图，左线程读取 count 之后加一到了 2，右线程读取 count 后无操作，它们都是 count 在主存中的副本，且相互不可见。</p>
<p><img src="/2021/07/10/jmm/cache-visible.jpg" alt></p>
<h2 id="重排序导致的可见性问题"><a href="#重排序导致的可见性问题" class="headerlink" title="重排序导致的可见性问题"></a>重排序导致的可见性问题</h2><p>在讲这个问题之前，先展开介绍一下重排序以及相关规则。</p>
<h3 id="啥是重排序？"><a href="#啥是重排序？" class="headerlink" title="啥是重排序？"></a>啥是重排序？</h3><p>从 Java 程序中的 有序性 这玩意儿入手：</p>
<p>在本地线程内观察，Java 程序（线程）内所有操作都是有序的，在线程内的表现为串行语义（Within-Thread <strong>As-If-Serial</strong> Semantics）：</p>
<ul>
<li>编译器和处理器为了增强并行度，从而提高性能，有的时候会重新安排语句执行顺序</li>
<li>但是不管怎样重排序，在单线程环境下，程序执行结果是不能被改变的，从而既保护了单线程程序，也保证了内存可见性</li>
<li>编译器、runtime 和处理器必须要遵守 as-if-serial 语义。</li>
</ul>
<p>这个语义所基于的，是<strong>数据依赖</strong>的概念：<br>假设两个操作访问到了同一个变量，且两个操作中有一个是<strong>写</strong>操作，即两个操作之间存在着数据依赖。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名 称</th>
<th style="text-align:center">代码示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">写后读</td>
<td style="text-align:center">a = 1; <br>b = a;</td>
</tr>
<tr>
<td style="text-align:center">写后写</td>
<td style="text-align:center">a = 1; <br>a = 2;</td>
</tr>
<tr>
<td style="text-align:center">读后写</td>
<td style="text-align:center">a = b; <br>b = 1;</td>
</tr>
</tbody>
</table>
</div>
<p>以上情况只要指令发生了重排序，程序的执行结果就会被改变；因此编译器和处理器在进行重排序的时候，会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>举两个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;        <span class="comment">// 1</span></span><br><span class="line">f = <span class="keyword">true</span>;     <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1 和 2 无依赖，执行顺序可能为：12 或 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;     <span class="comment">// 2</span></span><br><span class="line">a = a + <span class="number">3</span>;     <span class="comment">// 3</span></span><br><span class="line">r = a * a;     <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 由于 3 和 4 对 1 有依赖，所以编译期在进行指令重排序的时候，会确保 3 和 4 在 1 后面执行</span></span><br><span class="line"><span class="comment">// 可能的顺序 1234, 1324, 2134</span></span><br></pre></td></tr></table></figure></p>
<p>然而，如果从一个线程出发去观察另一个线程，所有操作又都是无序的；其中有线程工作内存与主内存同步延迟的原因，也有上述提到的<strong>指令重排序</strong>的因素。</p>
<p>指令序列重排序包括以下步骤：</p>
<p><strong>1. 编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可重新安排语句执行顺序。</p>
<p><strong>2. 指令级并行的重排序</strong>：</p>
<ul>
<li>背景：现代处理器采用指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行</li>
<li>如指令之间<strong>不存在数据依赖性</strong>，处理器可改变语句对应机器指令的执行顺序</li>
</ul>
<p><strong>3. 内存系统的重排序</strong>：</p>
<ul>
<li>背景：由于处理器使用缓存和读/写缓冲区，使得程序在运行的时候，相关的加载和存储操作看上去可能是乱序执行的；</li>
<li>每个处理器上的写缓冲区仅对它所在的处理器可见<ul>
<li>所以：导致处理器执行内存操作的顺序可能会与内存实际操作执行顺序不一致</li>
</ul>
</li>
<li>由于现代处理器都会使用写缓冲区，因此都会允许对写-读操作进行重排序</li>
</ul>
<p><img src="/2021/07/10/jmm/reorder.png" alt></p>
<p><br></p>
<p>另外：<br>编译器和处理器在进行重排序的时候，除了在单线程内遵守 As-If-Serial 语义之外，还需接受 JMM <strong>happens-before</strong> 规则的约束：</p>
<h3 id="什么是-happens-before？"><a href="#什么是-happens-before？" class="headerlink" title="什么是 happens-before？"></a>什么是 <strong>happens-before</strong>？</h3><p>happens-before 是从 Java 5 就引入的 JSR-133 规范中的规则，是 JMM <strong>最核心的概念</strong>。</p>
<pre><code>    如果⼀个操作 happens-before 另⼀个操作，那么第⼀个操作的执⾏结果将对第⼆个操作可⻅，⽽且第⼀个操作的执⾏顺序排在第⼆个操作之前；（JMM 对程序员的承诺）
    两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执⾏。（没有数据依赖的指令就不一定会完全按照顺序执行）
</code></pre><p>在 JMM 中，如果一个操作执行的结果需要对另一操作<strong>可见</strong>，那么这两个操作之间必须存在 happens-before 关系：</p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before 于该线程中任意的后续操作（包含了 as-if-serial 语义）</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before 于随后对该锁的加锁</li>
<li><strong>volatile 变量规则</strong>：对一个 volatile 域的写，happens-before 于任意后续对该 volatile 域的读</li>
<li><strong>传递性</strong>：如果 A happens-before B，且 B happens-before C，则 A happens-before C</li>
<li><strong>start() 规则</strong>：如果线程 A 执行操作 <code>ThreadB.start()</code>（启动线程 B），那么线程 A 中的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作<ul>
<li>因为线程 A 在启动线程 B 之前，它所做的所有对共享变量的修改结果必须要对线程 B 可见，要不启动新线程之后带来同步问题就麻烦了</li>
</ul>
</li>
<li><strong>join() 规则</strong>：如果线程 A 执行操作 <code>ThreadB.join()</code> 并成功返回，那么线程 B 中任意操作 happens-before 于线程 A 从 ThreadB.join() 操作的那一次成功返回<ul>
<li>因为线程 B 的所有操作和对共享变量的修改必须要对线程 A 可见，线程 A 才能在执行 join() 的时候拿到正确的返回结果</li>
</ul>
</li>
<li><strong>线程中断规则</strong>：对线程的 interrupt() 方法的调用，happens-before 于该被中断线程的代码检测到中断事件的发⽣<ul>
<li>发起中断一定要发生在响应中断之前</li>
</ul>
</li>
<li><strong>对象终结规则</strong>：一个对象的初始化的完成（构造函数执行结束），一定 happens-before 于它的 finalize() 方法</li>
</ul>
<p>以上规则中的两个操作可发生在同一线程内，也<strong>可在不同线程</strong>内。</p>
<p><br></p>
<p>总的来说，JMM 允许不会改变程序执行结果的重排序，但禁止会改变程序执行结果的重排序。在不改变程序运行结果的前提下，允许部分指令重排序，最大程度地提升指令执行的效率。</p>
<p>原则就是，对于单线程程序以及正确同步的多线程程序，只要能保证执行结果正确，怎么优化都行。</p>
<ul>
<li>比如：在编译器确定一个锁只会被单线程访问到的时候，JMM 会允许该锁被优化掉。</li>
<li>或：编译器确定一个 volatile 变量只会被单线程访问到的时候，JMM 允许其变成普通变量</li>
</ul>
<p><strong>as-if-serial 语义保证单线程程序的执行结果不会被改变；happens-before 语义主要被用来保证正确同步的多线程程序的执行结果不会被改变。</strong></p>
<p>所以程序中所谓的“有序性”其实是<strong>幻觉</strong>。无论是单线程程序，还是正确同步了的多线程程序，它们的执行语句都会有一定的重排序，但是给我们的错觉是在按顺序执行（包括在调试的时候）。</p>
<p><br></p>
<p>不同处理器的重排序规则如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">处理器</th>
<th style="text-align:center">Load-Load 规则</th>
<th style="text-align:center">Load-Store 规则</th>
<th style="text-align:center">Store-Store 规则</th>
<th style="text-align:center">Store-Load 规则</th>
<th style="text-align:center">数据依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SPARC-TSO</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">x86</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">IA64</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">PowerPC</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
</div>
<p><code>N</code> 表示处理器不允许两个操作重排序，<code>Y</code> 表示允许重排序。</p>
<p>因为 JMM 已经规范了 JVM 与计算机协同工作的细节，且屏蔽各种硬件和操作系统的内存访问差异，我们在编写 Java 程序的时候，并不需要去过于关注各个处理器的复杂的重排序规则，只需要了解 happens-before 语义即可。</p>
<p>因此 happens-before 就是<strong>对不同处理器的重排序规则的抽象</strong>，一个 happens-before 规则对应于一个或多个编译器和处理器的重排序规则。</p>
<p><br></p>
<h3 id="重排序导致了啥问题？"><a href="#重排序导致了啥问题？" class="headerlink" title="重排序导致了啥问题？"></a>重排序导致了啥问题？</h3><p>需要注意的是：</p>
<ul>
<li>重排序所遵守的数据依赖性，仅限于<strong>单个处理器</strong>中的执行指令序列，和<strong>单个线程</strong>中执行的操作；</li>
<li>不同处理器之间和不同线程之间的数据依赖性，是不会被编译器和处理器所考虑的。</li>
</ul>
<p>举个简单的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a;  <span class="comment">// 4</span></span><br><span class="line">            ... </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中 flag 用于标记变量 a 是否被写入。<br>简单分析代码段后可知，在 <code>writer()</code> 中，操作 1 和操作 2 没有数据依赖关系，编译器和处理器可对这两个操作重排序；<br>同理，在 <code>reader()</code> 中，操作 3 和操作 4 也没有数据依赖关系，编译器和处理器也可对这两个操作重排序。</p>
<p>假设有线程 A 首先去执行 <code>writer()</code>，紧接着线程 B 执行 <code>reader()</code> 方法。<br>线程 B 在执行操作 4（<code>int i = a * a;</code>）的时候，能否看到线程 A 在操作 1 对共享变量 a 的写入（<code>writer()</code> 对 a 的操作是否对 <code>reader()</code> 可见）？</p>
<p><strong>不一定。</strong></p>
<p>因为刚刚说到，1 和 2 在 writer() 中可能会重排序，3 和 4 在 reader() 中可能会重排序，因此时间片可能出现以下组合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>flag = true;</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td></td>
<td>if (flag)</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td></td>
<td>int i = a * a;</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td>a = 1;</td>
</tr>
</tbody>
</table>
</div>
<p>执行结果下来，就可能会有 a = 1，i = 0 的结果。</p>
<p>以上就是<strong>没有正确同步的代码</strong>出现的问题。在大规模运行的程序里面，这种问题非常难以排查。</p>
<p><br></p>
<h2 id="多线程竞争（Race-Conditions）带来的同步问题"><a href="#多线程竞争（Race-Conditions）带来的同步问题" class="headerlink" title="多线程竞争（Race Conditions）带来的同步问题"></a>多线程竞争（Race Conditions）带来的同步问题</h2><p>两个或更多个线程共享一个对象，多个线程在该共享对象上更新变量：</p>
<p><img src="/2021/07/10/jmm/race-condition.jpg" alt></p>
<p>如上图：线程 A 和 B 均读取了共享变量的值 1，且均加了 1；这两个操作是被并发执行的，如果此时都写回去的话，最终只添加了 1，而不是 2。</p>
<p><br></p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p><strong>1. 解决线程缓存导致的可见性问题</strong></p>
<ul>
<li><a href="/2021/07/14/keywords/#final">final</a>：初始化之后才可见</li>
<li><a href="/2021/07/14/keywords/#synchronized">synchronized</a>：通过锁来保证线程之间的通信</li>
<li><a href="/2021/07/14/keywords/#volatile">volatile</a>（重点）：保证新值能立即同步到主内存</li>
</ul>
<p><strong>2. 保证线程之间操作有序性</strong></p>
<ul>
<li>synchronized：通过锁来保证有序性</li>
<li>volatile：限制指令重排序</li>
</ul>
<p>如：上述 <code>ReorderExample</code> 的解决方案：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;  <span class="comment">// 获取对象锁</span></span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 2</span></span><br><span class="line">    &#125;  <span class="comment">// 释放对象锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  <span class="comment">// 获取对象锁</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a;  <span class="comment">// 4</span></span><br><span class="line">            ... </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 释放对象锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由 <code>synchronized</code> 原理可知，线程 A 和线程 B 获得的都是这个 ReorderExample 对象的对象锁（<code>this.intrinsicLock</code>）。</p>
<p>此时运行时间片如下：</p>
<table>
    <tr>
        <th>时间</th>
        <th>在 JMM 中的执行</th>
        <th>备注</th>
    </tr>
    <tr>
        <td></td>
        <td>A 获取锁</td>
        <td></td>
    </tr>
    <tr>
        <td>T1</td>
        <td>flag = true;</td>
        <td rowspan="2">临界区内可以重排序</td>
    </tr>
    <tr>
        <td>T2</td>
        <td>a = 1;</td>
    </tr>
    <tr>
        <td></td>
        <td>A 释放锁</td>
        <td rowspan="2">（happens-before 监视器锁规则）</td>
    </tr>
    <tr>
        <td></td>
        <td>B 获取锁</td>
    </tr>
    <tr>
        <td>T3</td>
        <td>int i = a * a;</td>
        <td rowspan="2">临界区内可以重排序</td>
    </tr>
    <tr>
        <td>T4</td>
        <td>if (flag)</td>
    </tr>
    <tr>
        <td></td>
        <td>B 释放锁</td>
        <td></td>
    </tr>
</table>

<p><strong>3. 使用原子性保证多线程写同步问题</strong></p>
<p>首先，synchronized 加锁保证操作原子性；</p>
<p>再者，<a href="/2021/09/04/java-concurrent-utils/#原子类-Atomic*"><code>java.util.concurrent.atomic</code></a> 包中有很多类方法保证了操作的原子性，执行过程中不会被其他线程中断。</p>
<p>什么时候使用悲观锁效率更高，什么使用使用乐观锁效率更高，要根据实际情况来判断选择。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 常用参数</title>
    <url>/2021/07/11/jvm-params/</url>
    <content><![CDATA[<p>JVM 的具体实现和调优纷繁复杂，本帖主要记录一些开发和测试过程中经常用到的一些参数。</p>
<span id="more"></span>
<p>至于更详细的参数介绍和配置，可以参考<a href="https://docs.oracle.com/cd/E22289_01/html/821-1274/configuring-the-default-jvm-and-java-arguments.html">官方文档</a>来学习。</p>
<p><br></p>
<p>JVM 的启动参数共分为三类：</p>
<ol>
<li>标准参数（-）：所有的 JVM 实现都必须实现这些参数的功能，而且向后兼容；</li>
<li>非标准参数（-X）：默认的 JVM 实现这些参数的功能，但是并不保证所有 JVM 的实现都满足，且不保证向后兼容；</li>
<li>非 Stable 参数（-XX）：此类参数各个 JVM 的实现会有所不同，将来可能会随时取消，需要慎重使用。</li>
</ol>
<p><br></p>
<h1 id="修改虚拟机栈大小"><a href="#修改虚拟机栈大小" class="headerlink" title="修改虚拟机栈大小"></a>修改虚拟机栈大小</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xss&lt;heap_size&gt;[unit]  <span class="comment"># 设置 JVM 栈的大小。每个线程设置一个值，一般设置几百 k</span></span><br></pre></td></tr></table></figure>
<h1 id="修改堆的大小"><a href="#修改堆的大小" class="headerlink" title="修改堆的大小"></a>修改堆的大小</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xmx&lt;heap_size&gt;[unit]  <span class="comment"># 设置堆的最大值</span></span><br><span class="line">-Xms&lt;heap_size&gt;[unit]  <span class="comment"># 设置初始化堆的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example:</span></span><br><span class="line">-Xmx5g</span><br><span class="line">-Xms512m</span><br></pre></td></tr></table></figure>
<p>注：JVM 启动后并不会将堆扩展到指定最大值，而是：</p>
<ol>
<li>先开辟指定的最小值；</li>
<li>如经过数次 GC 之后仍不能满足程序执行：逐步扩容，而不是立即扩容到最大值。</li>
</ol>
<p>具体到修改堆中某些区域的指令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅限 JDK 1.3 及 1.4 使用</span></span><br><span class="line">-XX:NewSize=&lt;young_gen_size&gt;[unit]  <span class="comment"># 设置 YoungGen 的大小，最小值默认是 1310 MB</span></span><br><span class="line">-XX:MaxNewSize=&lt;max_young_gen_size&gt;[unit]  <span class="comment"># 设置 YoungGen 的最大值，默认没有限制</span></span><br><span class="line"></span><br><span class="line">-Xmn&lt;heap_size&gt;[unit]  <span class="comment"># 设置新生代 YoungGen 的内存大小，JDK 1.4 及之后使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:PermSize=&lt;perm_gen_size&gt;[unit]  <span class="comment"># 设置初始永久区的大小</span></span><br><span class="line">-XX:MaxPermSize=&lt;perm_gen_size&gt;[unit]  <span class="comment"># 设置永久区的最大值</span></span><br><span class="line"><span class="comment"># 注：因永久区在 Java 8 已被取消，上述两个参数仅适用于 Java 7 及之前版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅适用于 Java 8 及以后版本</span></span><br><span class="line">-XX:MaxMetaspaceSize=&lt;max_metaspace_size&gt;[unit]  <span class="comment"># 设置 Metaspace 元空间最大值，默认没有限制</span></span><br><span class="line"><span class="comment"># 设置了值之后，每当元空间达到阈值之后，方法区开始内存回收。</span></span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio=&lt;ratio&gt;  <span class="comment"># 设置 Survivor 区与 Eden 区的比例，默认为 0.25</span></span><br><span class="line"><span class="comment"># 如: -XX:SurvivorRatio=0.25</span></span><br><span class="line"></span><br><span class="line">-XX:NewRatio=&lt;ratio&gt;  <span class="comment"># 设置 YoungGen 区与 OldGen 区的比例，默认比例为 1:2</span></span><br><span class="line"><span class="comment"># 如：-XX:NewRatio=0.25</span></span><br></pre></td></tr></table></figure></p>
<h1 id="GC-相关"><a href="#GC-相关" class="headerlink" title="GC 相关"></a>GC 相关</h1><p>可调用的 GC：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">-XX:+USeParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure></p>
<p>GC 输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">verbose:gc  <span class="comment"># 启动 JVM 时，输出 JVM 里面的 GC 信息</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [Full GC] 178K-&gt;99K(1984K), 0.0253877 secs]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># Full GC：执行了一次 Full GC</span></span><br><span class="line"><span class="comment"># 178K, 99K：执行 GC 前后内存容量</span></span><br><span class="line"><span class="comment"># 1984K：内存总容量</span></span><br><span class="line"><span class="comment"># ... secs：执行本次 GC 耗时</span></span><br><span class="line"></span><br><span class="line">-XX:+printGC  <span class="comment"># 同上</span></span><br><span class="line">-XX:+PrintHeapAtGC  <span class="comment"># 每一次 GC 发生前后都打印堆的信息，格式同上</span></span><br><span class="line">-XX:+PrintReferenceGC  <span class="comment"># 打印对象引用信息</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails  <span class="comment"># 打印 GC 的详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">–Heap</span><br><span class="line">– def new generation   total 13824K, used 11223K [0x27e80000, 0x28d80000, 0x28d80000)</span><br><span class="line">–  eden space 12288K,  91% used [0x27e80000, 0x28975f20, 0x28a80000)</span><br><span class="line">–  from space 1536K,   0% used [0x28a80000, 0x28a80000, 0x28c00000)</span><br><span class="line">–  to   space 1536K,   0% used [0x28c00000, 0x28c00000, 0x28d80000)</span><br><span class="line">– tenured generation   total 5120K, used 0K [0x28d80000, 0x29280000, 0x34680000)</span><br><span class="line">–   the space 5120K,   0% used [0x28d80000, 0x28d80000, 0x28d80200, 0x29280000)</span><br><span class="line">– compacting perm gen  total 12288K, used 142K [0x34680000, 0x35280000, 0x38680000)</span><br><span class="line">–   the space 12288K,   1% used [0x34680000, 0x346a3a90, 0x346a3c00, 0x35280000)</span><br><span class="line">–    ro space 10240K,  44% used [0x38680000, 0x38af73f0, 0x38af7400, 0x39080000)</span><br><span class="line">–    rw space 12288K,  52% used [0x39080000, 0x396cdd28, 0x396cde00, 0x39c80000)</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<ul>
<li><code>new generation</code> 是新生代</li>
<li><code>tenured generation</code> 是老年代</li>
<li><code>compacting perm gen</code> 是永久区</li>
<li>三个地址值分别为该片内存的起始点，当前使用到的地方，和最大的内存地点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-X:loggc:<span class="built_in">log</span>/gc.log  <span class="comment"># 指定输出 gc.log 的文件位置</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCTimeStamps  <span class="comment"># 输出 GC 发生的时间</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime  <span class="comment"># GC 产生停顿的时间</span></span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  <span class="comment"># GC 应用执行的时间</span></span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:StringTableSize=66666  <span class="comment"># 设定 StringTable 的长度</span></span><br><span class="line"></span><br><span class="line">-XX:+UseStringDeduplication  <span class="comment"># 去掉重复字符串</span></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment"># 只适用于 G1 收集器，且只适用于长期存活的对象</span></span><br><span class="line"><span class="comment"># 默认：一个字符串经过 3 次 GC 后还存活才会被列为去重的候选</span></span><br><span class="line"><span class="comment"># 可能会增加 GC 停顿时间</span></span><br><span class="line"><span class="comment"># 不会消除重复字符串的引用本身，只会替换底层的 char[]，即：aStr.value = anotherStr.value</span></span><br><span class="line"></span><br><span class="line">-XX:StringDeduplicationAgeThreshold=6  <span class="comment"># 设置经历 GC 的次数</span></span><br><span class="line"></span><br><span class="line">-XX:+DoEscapeAnalysis  <span class="comment"># 开启逃逸分析（Server 模式），默认开启</span></span><br><span class="line">-XX:-DoEscapeAnalysis  <span class="comment"># 关闭逃逸分析</span></span><br><span class="line">-XX:+PrintEscapeAnalysis  <span class="comment"># 显示分析结果</span></span><br><span class="line">-XX:+EliminateAllocations  <span class="comment"># 开启标量替换（默认开启）</span></span><br><span class="line">-XX:+TraceClassLoading  <span class="comment"># 跟踪类的加载</span></span><br><span class="line">-XX:+TraceClassUnloading  <span class="comment"># 跟踪类的卸载</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintReferenceGC  <span class="comment"># 打印对象引用信息</span></span><br><span class="line">-XX:+PrintVMOptions  <span class="comment"># 打印虚拟机参数</span></span><br><span class="line">-XX:+PrintCommandLineFlags  <span class="comment"># 打印虚拟机显式和隐式参数</span></span><br><span class="line">-XX:+PrintFlagsFinal  <span class="comment"># 打印所有系统参数</span></span><br><span class="line">-XX:+PrintTLAB  <span class="comment"># 打印 TLAB 相关分配信息</span></span><br><span class="line">-XX:+UseTLAB  <span class="comment"># 打开 TLAB，默认开启</span></span><br><span class="line">-XX:TLABSize  <span class="comment"># 设置 TLAB 大小</span></span><br><span class="line">-XX:+ResizeTLAB  <span class="comment"># 自动调整 TLAB 大小</span></span><br><span class="line">-XX:TLABWasteTargetPercent  <span class="comment"># 设置 TLAB 所占用 Eden 空间的百分比</span></span><br><span class="line">-XX:+DisableExplicitGC  <span class="comment"># 禁用显式 GC（System.gc()）</span></span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent  <span class="comment"># 使用并发方式处理显式 GC</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 容器编排</title>
    <url>/2022/05/28/kubernetes-pod-management/</url>
    <content><![CDATA[<p>Kubernetes Node 通过 <a href="/2023/05/09/kubernetes-pod">Pod</a> 来管理自己所承载的容器。至于 Pod 怎么管理容器，涉及到 Kubernetes 容器编排的概念。</p>
<span id="more"></span>
<p>Kubernetes 结合的是 Google 数十年对大规模应用容器技术的经验的积累和升华。它对容器的编排管理包括且不仅限于：</p>
<ul>
<li>上线下线</li>
<li>扩展集群</li>
<li>弹性伸缩</li>
<li>滚动升级 &amp; 回滚</li>
<li>自动治愈 &amp; 重启</li>
<li>服务发现</li>
<li>…</li>
</ul>
<p>Kubernetes 不仅具有大规模运行容器编排所需的组件（Master &amp; Node），还具有使用自定义组件交换内部和外部不同组件的灵活性。</p>
<h1 id="容器编排组件"><a href="#容器编排组件" class="headerlink" title="容器编排组件"></a>容器编排组件</h1><p>Kubernetes 针对不同的应用场景，定义了不同的容器编排方式，以满足不同需求。<br>在之前介绍 <a href="/2022/05/18/kubernetes-overview#kube-controller-manager">kube-controller-manager</a> 的时候提起过，针对于不同的方式，Kubernetes 有各种对应的 service controller 完成编排。</p>
<p>常用的编排方式有下面几种：</p>
<h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>创建，并管理给定的一个或多个 Pod 的副本。<br>如 Pod 因某种原因死亡，replication controller 会立即介入，重新创建新的 Pod。</p>
<p>我们并不会直接去使用 ReplicaSet。</p>
<p><code>Replication Controller</code>：通过 ReplicaSet 控制 Pod 的动态扩容和缩放</p>
<ul>
<li>为每个 Pod 设置一个期望的副本数</li>
<li>需要时复制多份 Pod，不需要后缩减 Pod 至指定份数</li>
<li>期望值可通过手动更新，或自动扩容代理完成</li>
</ul>
<p><img src="/2022/05/28/kubernetes-pod-management/replicaset.jpg" alt></p>
<p>同时，Replication Controller 还可以：</p>
<ul>
<li>确保 pod 健康：终止不健康、运行出错或者无法提供服务的 pod，再创建新的实例；</li>
<li>弹性伸缩：在业务波峰波谷的时候动态调整 pod 的数量，提高资源利用率；同时配置相应的 HPA 监控能定时自动从监控平台获取 replication controller 关联 pod 的整体资源使用，做到自动伸缩</li>
<li>滚动升级 Rolling Update</li>
</ul>
<p>水平扩容/缩容：</p>
<p><img src="/2022/05/28/kubernetes-pod-management/scaling.png" alt></p>
<p>修改 replicaSet 控制的 pod 副本数量即可。比如从 2 改到 3 -&gt; 水平扩容，反之则是水平收缩。</p>
<h3 id="Rolling-Update"><a href="#Rolling-Update" class="headerlink" title="Rolling Update"></a>Rolling Update</h3><p>应用更新的时候，Kubernetes 每次只更新一小部分，成功之后再去更新更多的副本，最终完成所有副本的更新。</p>
<p>比如某个拥有 3 个 replica 的 deployment 需要从 v1 更新至 v2：</p>
<ul>
<li>先成功启动 v2 版本的 ReplicaSet 控制下的一个 pod，同时完全关闭 v1 版本控制下的一个 pod</li>
<li>上述操作完成后，逐渐增加 v2 版本控制的 pod 数量至 3；同时 v1 版本控制的 pod 数量减到 0</li>
</ul>
<p><img src="/2022/05/28/kubernetes-pod-management/rolling-update.png" alt></p>
<p>应用的回滚则与上述过程相反。而且在每一次新版本的安装需要 —record 做好记录，之后调用 <code>kubectl rollout undo</code> 的时候才能指定已记录的版本（<code>--to-revision</code>）进行回滚。</p>
<p>最大好处：<strong>零停机</strong>，更新过程中保证业务连续性。</p>
<p>实际应用：配置 <code>RollingUpdateStrategy</code> 控制滚动更新策略</p>
<ul>
<li><code>maxSurge</code>: deployment 还可以创建多少个新 pod</li>
<li><code>maxUnavailable</code>: deployment 可删除多少个旧 pod</li>
</ul>
<p>更新/回滚完成后，另一版本的 ReplicaSet <strong>并不会被删除</strong>，其 pod 数量减为 0。</p>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>最常用的编排方式，由 <code>Deployment Controller</code> 控制，用于编排无状态应用。</p>
<p>Deployment 基于并使用 ReplicaSet 管理 pod 副本：通过放大新的 ReplicaSet 和缩小（最终删除）现有 ReplicaSet 提供滚动升级。</p>
<p>正因如此，Deployment Controller 包括了 Replication Controller 的<strong>所有功能</strong>。<br>并且存在着这样的传递关系：<strong>deployment 控制 replicaSet 的版本属性，replicaSet 控制 pod 的数量</strong>。</p>
<p><img src="/2022/05/28/kubernetes-pod-management/deployment.jpg" alt></p>
<p>由于 Kubernetes 中对象的命名方式是：子对象名 = 父对象名 + 随机字符串/数字，所以从 deployment pod 的名字就可以看出来：<br>比如要创建的 deployment 是 <code>nginx-deployment</code>，那么创建出来的 ReplicaSet 是 <code>nginx-deployment-xxx</code>，最终创建出来的 pod 就是 <code>nginx-deployment-xxx-yyy</code>。</p>
<h3 id="访问-Deployment"><a href="#访问-Deployment" class="headerlink" title="访问 Deployment"></a>访问 Deployment</h3><ol>
<li>通过 ServiceName 访问</li>
<li>CoreDNS 解析 ServiceName，返回 clusterIp</li>
<li>clusterIp 根据机器上 iptables / ipvs 的配置，转发到指定的 pod</li>
</ol>
<h3 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h3><p><img src="/2022/05/28/kubernetes-pod-management/deployment-create.png" alt></p>
<ol>
<li><code>kubectl</code> 发起创建 deployment 的请求到 apiserver</li>
<li>apiserver 接收到请求后，将相关资源写入 etcd</li>
<li>apiserver 通知 kube-controller-manager 中对应的 controller 进行操作：<ol>
<li><code>deployment controller</code> 会 list / watch 资源变化，并发起创建 replicaSet 请求</li>
<li>请求发送至 <code>replicaSet controller</code> 处理，list / watch 资源变化并发起创建 pod 请求</li>
</ol>
</li>
<li><code>scheduler</code> 检测到未绑定的（新建的或游离的）pod 资源</li>
<li>scheduler 通过一系列匹配以及过滤（通过 Node 的标签 Label 和 Pod 的 nodeSelector 属性进行匹配等），选择合适的 node 进行绑定<ul>
<li>master 对 pod 的调度完成</li>
</ul>
</li>
<li>分发到具体的 node 后，<code>kubelet</code> 发现自己的 node 需创建新的 pod，便开始 pod 的创建及后续生命周期管理</li>
<li><code>kube-proxy</code> 负责初始化 service 相关的资源：服务发现、负载均衡等网络规则</li>
</ol>
<p>以上全过程的每一步，各组件<strong>都通过 apiserver / etcd 进行交互和信息存储</strong>（即步骤 2）。</p>
<p>其它编排方式的 pod 的创建过程与此类似。</p>
<h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>用于编排有状态（保存数据）的应用。保证副本按照固定的顺序启动/更新/删除。</p>
<p>由于 StatefulSet 没有 clusterIp，无法通过 iptables 指定转发规则和负载均衡（loadbalance），因此访问时只能返回所有待转发对象（pod）的请求方式。</p>
<p>访问 StatefulSet 通过 HeadlessServiceName 访问：</p>
<ul>
<li>命名规则：<code>$(podName).$(headlessServiceName).$(namespace).$(clusterDomainName)</code>，一般指定到 headlessServiceName 即可。</li>
</ul>
<p><br></p>
<p>以上的 Deployment，ReplicaSet，DaemonSet 等管理<strong>服务类容器</strong>的编排方式，管理的是 HTTP 服务、Daemon 等<strong>持续</strong>的服务。</p>
<h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>顾名思义，用于编排守护进程。不同于 Deployment 的随机按需分布，每个 <strong>node 最多运行 DaemonSet 的一个副本</strong>，所有（或者特定）的 node 运行同一个 DaemonSet 的 pod。</p>
<p><code>DaemonSet Controller</code>：能让特定或所有节点运行同一个 pod</p>
<ul>
<li>节点被加入 Kubernetes 集群后：pod 会被 DaemonSet 调度到该节点执行</li>
<li>节点被移出 Kubernetes 集群后：被 DaemonSet 调度的 pod 会被移除</li>
<li>删除 DaemonSet：所有与其相关的 pod 都会被移除</li>
</ul>
<p>典型应用场景：</p>
<ul>
<li>在每个节点上运行<strong>存储</strong> Daemon（glusterd, ceph 等）</li>
<li>在每个节点上运行<strong>日志收集</strong> Daemon（fluentd, <strong>logstash</strong> 等）</li>
<li>在每个节点上运行<strong>监控</strong> Daemon（<strong>Prometheus Node Exporter</strong>, <strong>collectd</strong> 等）</li>
</ul>
<p>kube-proxy 就是 Kubernetes 用于在每个 node 上运行系统组件的 DaemonSet。</p>
<h2 id="Job-CronJob"><a href="#Job-CronJob" class="headerlink" title="Job/CronJob"></a>Job/CronJob</h2><p>不同于以上编排方式，Job 编排的是<strong>一次性</strong>的<strong>工作类容器</strong>，比如批处理任务，完成后容器就直接退出。</p>
<p>Job 重启策略：</p>
<ul>
<li>Never：永不重启，如果 Job 执行失败，则每次重新启动一个 pod 再次执行</li>
<li>OnFailure：失败时重启容器</li>
</ul>
<p>Job 可通过配置 parallelism 设置并行执行，通过设置 completions 设置运行个数。</p>
<p>CronJob：概念同 Linux 的 cronjob，意为<strong>定时任务</strong>。CronJob 比普通的 Job 多了一个 schedule:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>上述编排方式对应的 controller 会通过动态创建和销毁 pod 来保证应用整体的健壮性。换句话说，<strong>pod 是脆弱的，但应用是健壮的</strong>。</p>
<p>除了上述的编排方式，Kubernetes 还抽象出来了 <a href="/2023/05/10/kubernetes-service">Service</a> 的概念。</p>
<h1 id="运行时调度"><a href="#运行时调度" class="headerlink" title="运行时调度"></a>运行时调度</h1><p>默认配置下，scheduler 会将 pod 自动调度到所有可用的 node 上；但当集群中每个节点配置有所区别时，我们有多种方法将特定功能的 pod 调度到指定 node 上。</p>
<p>区别于全局调度 —— 设置 Kubernetes 启动调度器，我们可以通过打标签（<strong>Label</strong>）或设置亲和性（<strong>Affinity</strong>），在运行时进行调度。</p>
<h2 id="设置-Label"><a href="#设置-Label" class="headerlink" title="设置 Label"></a>设置 Label</h2><p>给 node 添加标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl label node k8s-node1 prod=sit</span><br></pre></td></tr></table></figure>
<p>给 pod 设置 nodeSelector：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pod 文件：</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="string">prod=sit</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 如指定 node 标签不存在，pod 会一直 pending，不会被分配到任何的 node 上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或：</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">k8s-node1</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>给 node 删除标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl label node k8s-node1 prod-</span><br></pre></td></tr></table></figure>
<h2 id="设置亲和度-Affinity"><a href="#设置亲和度-Affinity" class="headerlink" title="设置亲和度 Affinity"></a>设置亲和度 Affinity</h2><p>为 node 或 pod 设定亲和性，能够匹配更多的逻辑组合，而不只是字符串的完全相等。亲和度主要分为三类：</p>
<h3 id="nodeAffinity"><a href="#nodeAffinity" class="headerlink" title="nodeAffinity"></a><code>nodeAffinity</code></h3><p>主机亲和性，处理的是 <strong>pod 和主机之间</strong>的关系，让 pod 部署/不要部署在哪些主机上。</p>
<p>规则包括：</p>
<p>硬亲和性 <code>requiredDuringSchedulingIgnoredDuringException</code></p>
<ul>
<li>强制性规则，pod 调度时必须满足的规则，否则就不停重试，pod 一直 pending</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span>  <span class="comment"># nodeSelector 组</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>软亲和性 <code>preferredDuringSchedulingIgnoredDuringException</code></p>
<ul>
<li>柔性调度规则，pod 调度时可满足其规则（“更倾向于”部署在指定 node 上）</li>
<li>若无法满足规则，可调度到一个不匹配规则的 node 上。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">60</span>  <span class="comment"># 权重</span></span><br><span class="line">        <span class="attr">preference:</span>  <span class="comment"># 偏好</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">30</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone2</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>解释一下上述两种亲和性的后缀 <code>-IgnoredDuringException</code>：</p>
<ul>
<li>字面上的理解：“有异常的时候忽略”</li>
<li>表示 pod 资源在基于 nodeAffinity 被调度到某个 node 后，如果 node 的label 发生改变（“有异常”），调度器不会将 pod 从 node 上移除（“忽略”）</li>
<li>该规则仅对新创建的 pod 有效</li>
</ul>
<p>与之相对的，是后缀为 <code>-RequiredDuringException</code> 的亲和性：</p>
<ul>
<li>字面上的理解：“有异常的时候需要（改动）”</li>
<li>如 node label 发生改变（“有异常”），pod 会重新选择符合要求的节点（“需要”）。</li>
</ul>
<h3 id="podAffinity"><a href="#podAffinity" class="headerlink" title="podAffinity"></a>podAffinity</h3><p>pod 亲和性，主要解决 <strong>pod 与 pod 之间</strong>的关系：哪些 pod 可以部署在同一拓扑域。规则与 nodeAffinity 相同。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子1：</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">labelSelector:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">prod</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子2:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">60</span></span><br><span class="line">        <span class="attr">podAffinityTerm:</span></span><br><span class="line">          <span class="attr">labelSelector:</span> </span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">prod</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">30</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone2</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>拓扑域（topologyKey）：根据 node 上的标签划分范围，范围内的 pod 即在一个域里面。</p>
<p><img src="/2022/05/28/kubernetes-pod-management/topologykey.png" alt></p>
<h3 id="podAntiAffinity"><a href="#podAntiAffinity" class="headerlink" title="podAntiAffinity"></a>podAntiAffinity</h3><p>顾名思义，pod 反亲和性，也是解决集群内部 <strong>pod 与 pod 之间</strong>的关系</p>
<ul>
<li>主要解决 pod <strong>不可以</strong>和哪些 pod 部署在同一拓扑域的问题</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>匹配目标</th>
<th>操作符</th>
<th>调度目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodeAffinity</td>
<td>主机标签</td>
<td>In, NotIn, Exists, DoesNotExist, Gt, Lt</td>
<td>指定主机</td>
</tr>
<tr>
<td>podAffinity</td>
<td>pod 标签</td>
<td>In, NotIn, Exists, DoesNotExist</td>
<td>pod 和指定的 pod 在同一拓扑域</td>
</tr>
<tr>
<td>podAntiAffinity</td>
<td>pod 标签</td>
<td>In, NotIn, Exists, DoesNotExist</td>
<td>pod 和指定的 pod 不在同一拓扑域</td>
</tr>
</tbody>
</table>
</div>
<p>亲和性的应用：应用 A 和 B 之间交互频繁，有必要利用亲和性将两个应用尽可能靠近，甚至分配在同一 node 上，减少网络通信带来的性能损耗</p>
<p>反亲和性的应用：应用采用<strong>多副本</strong>部署，使用反亲和性将应用实例打散分布在各个 node 上，提高 HA</p>
<p>各种匹配规则的叠加：</p>
<ul>
<li>同时指定 nodeSelector 和 nodeAffinity，pod 必须都满足才能被分配到 node 上</li>
<li>nodeAffinity 如果有多个 nodeSelectorTerms，那么 pod 只需满足一个就能分配到 node 上</li>
<li>nodeSelectorTerms 如果有多个 matchExpressions，pod 必须都满足才能分配到 node 上</li>
</ul>
<h2 id="Taint（污点）-amp-Toleration（容忍度）"><a href="#Taint（污点）-amp-Toleration（容忍度）" class="headerlink" title="Taint（污点） &amp; Toleration（容忍度）"></a>Taint（污点） &amp; Toleration（容忍度）</h2><p>我们知道，具有节点亲和性的 node 和 pod 之间是相吸的；<br>与亲和性作用相反的是，具有“污点”的 node 和 pod 之间是<strong>互斥</strong>的。</p>
<p>通过配置 Taint 和 Toleration，可以避免 pod 被分配到不合适的节点上</p>
<ul>
<li>每个 node 可被应用一个或多个 taint，表示这个 node 不会接受那些不能容忍这些 taint 的 pod</li>
<li>每个 pod 可被应用一个或多个 toleration，表示这些 pod 可以（但不要求）被调度到具有相应 taint 的 node 上</li>
</ul>
<p>设置污点 taint：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node [node] key=value:[effect]</span><br><span class="line"><span class="comment"># effect=[NoSchedule | PreferNoSchedule | NoExecute]</span></span><br></pre></td></tr></table></figure></p>
<p>去除污点：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node [node] key:[effect]-</span><br></pre></td></tr></table></figure></p>
<p>与之相对，pod 上的 toleration 里面声明的 key 和 effect 需要跟 taint 的设置保持一致。</p>
<p>举例：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key&quot;</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或：</span></span><br><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key&quot;</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>operator 为 Exists：无需指定 value</li>
<li>operator 为 Equal：value 需跟 taint 的值相等才生效</li>
<li>不指定 operator：默认为 Equal</li>
<li>空的 key 配合 Exists 能匹配所有键值对</li>
<li>空的 effect 匹配所有的 effect</li>
</ul>
<p>toleration 中的 <code>effect</code> 值：</p>
<p><code>NoSchedule</code>：一定不要被调度</p>
<ul>
<li>如果一个 pod 没有声明容忍（toleration）该 taint，则系统不会将该 pod 调度到有这个 taint 的 node 上</li>
<li>应用：节点独占</li>
</ul>
<p><code>PreferNoSchedule</code>：尽量不要调度</p>
<ul>
<li>如果一个 pod 没有声明容忍该 taint，则系统尽量避免将该 pod 调度到有这个 taint 的 node 上</li>
<li>NoSchedule 的软限制版本</li>
</ul>
<p><code>NoExecute</code>：不仅不会调度，还会驱逐 node 上已有的 pod</p>
<ul>
<li>没有声明该容忍的 pod 会被立刻驱逐</li>
<li>配置对应的 toleration 的 pod，如没有为 tolerationSeconds 赋值，则会一直留在该 node 中</li>
<li>配置对应的 toleration 且指定 tolerationSeconds 的 pod，则会在指定时间后被驱逐</li>
<li>应用：定义 pod 驱逐行为，应对节点故障</li>
</ul>
<h3 id="多污点与多容忍配置"><a href="#多污点与多容忍配置" class="headerlink" title="多污点与多容忍配置"></a>多污点与多容忍配置</h3><p>Kubernetes 调度器处理<strong>多个 taint 和 toleration 能匹配的部分</strong>，剩下的没被忽略的 taint 就是对 pod 的效果</p>
<ul>
<li>如果剩余 taint 存在 effort=NoSchedule：调度器不会将该 pod 调度到该节点上</li>
<li>如果剩余 taint 没有 NoSchedule，但有 PreferNoSchedule：调度器会尝试不将 pod 调度到该节点</li>
<li>如果剩余 taint 有 effort=NoSchedule，且 pod 已经在该 node 运行，则 pod 会被驱逐；如不在该 node 运行，则 pod 不会被调度到该节点</li>
</ul>
]]></content>
      <tags>
        <tag>容器化</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 概述</title>
    <url>/2022/05/18/kubernetes-overview/</url>
    <content><![CDATA[<p>Kubernetes 是 Google 在 2014 年发布的 Omega 开源版本，是全球发展最快、市场占有率最高的容器编排引擎产品。</p>
<span id="more"></span>
<p>Kubernetes 源于 Google 开发的 Borg，最初用于调度公司内部近 20 亿个容器，属于云原生的一部分，相当于容器的“操作系统”。</p>
<p>云原生其它内容还包括 <strong>ConfigMap</strong>（配置中心）、<strong>etcd</strong>（发现中心，负责存储和通知）、<strong>service mesh</strong>（网格服务，别称 <strong>sidecar</strong>，为每个服务提供非业务的逻辑，如网关、鉴权等，是<em>去中心化</em>的象征）、CI/CD。</p>
<p>在介绍 Kubernetes 本身之前，先来了解一下它赖以生存的 CNCF。</p>
<h1 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a><a href="https://www.cncf.io/">CNCF</a></h1><p>全称 Cloud Native Computing Foundation（云原生计算基金会），口号是“坚持和整合开源技术来编排容器作为微服务架构的一部分”。</p>
<p>CNCF 作为一个厂商中立的基金会，其致力于 Github 上的快速成长的云原生应用推广和普及，如Kubernetes、Prometheus、Envoy 等，帮助开发人员更快更好的构建出色的产品。</p>
<h1 id="CoreOS"><a href="#CoreOS" class="headerlink" title="CoreOS"></a>CoreOS</h1><p>CoreOS 是一个基于 Linux 内核的轻量级操作系统，为计算机集群的基础设施建设而生，专注于自动化，轻松部署，安全，可靠，规模化。作为一个操作系统，CoreOS 提供了在应用容器内部署应用所需要的基础功能环境以及一系列用于服务发现和配置共享的内建工具。</p>
<p>CoreOS 已被 Redhat 收购，并基于此推出了自己的 PaaS 方案：OpenShift</p>
<h1 id="主要构成"><a href="#主要构成" class="headerlink" title="主要构成"></a>主要构成</h1><p>既然是基于容器技术的分布式集群管理系统，Kubernetes 也应该有集群（Cluster），有主（Master）从（Node）的概念。<br>除此之外还包括 Kubernetes 的指令系统（kubectl）和存储管理（etcd）等。</p>
<p>简图如下：</p>
<p><img src="/2022/05/18/kubernetes-overview/kubernetes-structure.jpg" alt></p>
<ul>
<li>Master 统一管理 Node 节点，在工作程序运行有效负载（应用程序）的地方控制和监视集群</li>
<li>Node 在分布式系统中可以是物理主机，也可以是虚拟机</li>
<li>Node 节点和 Master 节点共同组成分布式集群的 Cluster</li>
</ul>
<p>一个 Kubernetes 集群最好能拥有 3 个 Master 节点，以实现高可用（HA Cluster）。</p>
<h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>Kubernetes 集群是计算、存储和网络资源的集合。Kubernetes 利用这些资源运行各种基于容器的应用。</p>
<h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>Cluster 的司令部，因此<strong>调度</strong>是它的主要任务。</p>
<p>Master 各组件如图：</p>
<p><img src="/2022/05/18/kubernetes-overview/kubernetes-master.png" alt></p>
<p>Master 各系统组件都被划分到 <code>kube-system</code> 的 namespace 中。</p>
<h3 id="kube-apiserver-进程"><a href="#kube-apiserver-进程" class="headerlink" title="kube-apiserver 进程"></a><strong>kube-apiserver 进程</strong></h3><p>为一基于 HTTP/HTTPS 的 RESTful 服务器，是集群内各个功能模块之间数据交互和通信的中心枢纽</p>
<ul>
<li>提供了集群管理各类资源对象（Pod、service 等）及 watch 等的 API 接口，也即 Kubernetes 的统一接口</li>
<li>所有模块之前并不会之间互相调用，而是通过和 kube-apiserver 打交道来完成自己那部分的工作</li>
<li>提供了完备的集群安全机制（验证，授权），同时也对集群外部暴露服务</li>
<li>用户可通过 REST 接口或 kubectl 命令行工具进行集群管理；因此 kubectl 本质上也是与 kube-apiserver 进行通信</li>
<li>每一个 Node 都有对应的一个 kube-apiserver 进程（<a href="/2023/05/09/kubernetes-pod">Pod</a>）。</li>
</ul>
<p>Master 和 Node 中几乎所有的组件都需要和 apiserver 通信，以执行所需要的职责。<br>这样模块之间不会直接互相调用，而是统一通过 apiserver 打交道完成通信；并且屏蔽了与 etcd 的直接交互。</p>
<h3 id="kube-scheduler-调度程序"><a href="#kube-scheduler-调度程序" class="headerlink" title="kube-scheduler 调度程序"></a><strong>kube-scheduler 调度程序</strong></h3><p>调度程序通过执行一系列复杂的算法（比如轮询调度 RR），为<strong>每个 Pod 匹配到一个最佳的目标 node</strong>，然后分发任务。</p>
<ul>
<li>将 Pod 调度到指定的 node 上，这一过程也叫绑定（bind）：<ul>
<li>输入为需要调度的 Pod 和可以被调度的节点 node 的信息</li>
<li>输出为调度算法选择的 node，并将该 pod bind 到这个 node</li>
</ul>
</li>
<li>每一个 Node 都有对应的一个 kube-scheduler 进程（Pod）。</li>
</ul>
<h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a><strong>kube-controller-manager</strong></h3><p>顾名思义，是 Kubernetes 管理各个 service controller 的控制中心。</p>
<p>Controller 管理着集群中的各种资源。<br>每个 controller 本质上是一个控制循环，它通过 apiserver 监视集群的共享状态，对服务进行监控和恢复，尝试改变某个服务与期望不符的实际情况。<br>当某个 Node 意外宕机时，Controller Manager 会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p>
<p><img src="/2022/05/18/kubernetes-overview/controller.png" alt></p>
<p>Kubernetes 内部的 service controller 包括：</p>
<ul>
<li><code>Cronjob Controller</code></li>
<li><code>DaemonSet Controller</code></li>
<li><code>Deployment Controller</code></li>
<li><code>Endpoints Controller</code></li>
<li><code>HPA</code>(Horizontal Pod Autoscaling) <code>Controller</code></li>
<li><code>Job Controller</code></li>
<li><code>Namespace Controller</code></li>
<li><code>NodeLifecycle Controller</code></li>
<li><code>PV-binder Controller</code></li>
<li><code>PV-expander Controller</code></li>
<li><code>Replication Controller</code></li>
<li><code>ResourceQuota Controller</code></li>
<li><code>ServiceAccount Controller</code></li>
<li><code>Service Controller</code>：管理 service</li>
<li><code>StatefulSet Controller</code></li>
<li><code>Token Controller</code>：对 API server 访问进行认证</li>
</ul>
<p>每一个 Node 都有对应的一个 kube-controller-manager 进程（Pod）。</p>
<h3 id="etcd-组件"><a href="#etcd-组件" class="headerlink" title="etcd 组件"></a><strong>etcd</strong> 组件</h3><p>作为高可用强一致性的存储仓库，<a href="https://etcd.io">etcd</a> 存储集群上包括 Kubernetes 对象，node, pod, service, replicaset, namespace 等<strong>集群所有的网络配置信息</strong>和<strong>对象的状态信息</strong>。</p>
<p>简单说，etcd 集群是一个分布式系统，由多个节点相互通信构成整体对外服务，每个节点都存储了完整的数据，并且通过 Raft 协议保证每个节点维护的数据是一致的。</p>
<p><img src="/2022/05/18/kubernetes-overview/simple-interface.png" alt="交互简单"> <img src="/2022/05/18/kubernetes-overview/kv-storage.png" alt="键值存储"> <img src="/2022/05/18/kubernetes-overview/watch-changes.png" alt="监测变化"></p>
<p>如果数据发生了变化，etcd 会快速通知相关的组件做出调整。</p>
<p>etcd 组件可内置于 Kubernetes，也可于集群外部搭建供 Kubernetes 使用。</p>
<p>etcd 的增删改查也是统一通过 kube-apiserver 进行调用的。</p>
<h3 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h3><p>Flannel 是由 CoreOS 团队针对 Kubernetes 设计的一个网络规划服务。</p>
<p>由 Pod 的<a href="/2023/05/09/kubernetes-pod#网络通信">内部结构</a>可知，Pod 内部的各个容器如应用程序在宿主机的通信一样，能够通过 <code>localhost:port</code> 的方式通信。</p>
<p>至于 Pod 和 Pod 之间的通信，有以下原则：</p>
<ul>
<li>一个 Node 上的 Pod 和其它 Node 的 Pod 通信不需要通过网络地址转换（NAT）；</li>
<li>一个 Node 上所有的 agent 控制程序（如 deamon 和 kubelet）可以和该 Node 的 Pod 通信；</li>
<li>Node 主机网络中的 Pod 可以与其它所有 Node 上的所有 Pod 通信，无需 NAT。</li>
</ul>
<p>而 Flannel 通过覆盖网络（overlay network），将数据包封装在另外一个网络再转发，让集群中不同 Pod（包括其容器）<strong>具有全集群唯一的 IP</strong>。</p>
<h3 id="CoreDNS"><a href="#CoreDNS" class="headerlink" title="CoreDNS"></a>CoreDNS</h3><p>CoreDNS 是“一个灵活可扩展的 DNS 服务器”，可以作为 Kubernetes 集群的 DNS，为集群提供<strong>服务发现</strong>的功能。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>承载运行中的容器，负责监控和汇报容器状态。可以按照主从概念中的 slave / worker 来理解。</p>
<p>Node 包含以下状态信息：</p>
<ul>
<li>地址：地址组合用法取决于云服务商或者 bare metal 的配置</li>
<li>状态：<code>OutOfDisk</code>, <code>Ready</code>, <code>MemoryPressure</code>, <code>DiskPressure</code></li>
<li>容量：node 上的可用资源，包括 CPU、内存和可以调度到 node 上的 pods 的最大数量</li>
<li>通用信息：包括内核版本、Kubernetes 版本（kubelet, kube-proxy 版本），容器版本，操作系统名等</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Node 状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>OutOfDisk</td>
<td><code>True</code>：node 的空闲空间不足以添加新 pod</td>
</tr>
<tr>
<td>Ready</td>
<td><code>True</code>：node 是健康的，并已经准备好接收 pod<br><code>False</code>：node 不健康，且不能接收 pod<br><code>Unknown</code>：node 控制器在最近 40 秒内没有接收到 node 的消息</td>
</tr>
<tr>
<td>MemoryPressure</td>
<td><code>True</code>：node 不存在内存压力：内存用量低</td>
</tr>
<tr>
<td>DiskPressure</td>
<td><code>True</code>：node 不存在磁盘压力：磁盘用量低</td>
</tr>
</tbody>
</table>
</div>
<p>Node 各组件如图：</p>
<p><img src="/2022/05/18/kubernetes-overview/kubernetes-node.png" alt></p>
<p>更动画化的示意图：</p>
<p><img src="/2022/05/18/kubernetes-overview/kubernetes-worker.png" alt></p>
<p>一个 Node 的生态如下：</p>
<p><img src="/2022/05/18/kubernetes-overview/kubernetes-node-env.png" alt></p>
<p>除 kubelet（<strong>唯一没有以容器形式运行的组件</strong>）外，Node 各系统组件都被划分到 <code>kube-system</code> 的 namespace 中。</p>
<p><img src="/2022/05/18/kubernetes-overview/kube-system.png" alt></p>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a><strong>kubelet</strong></h3><p>kubelet 组件是 Node 的心脏，用于管理容器生命周期（创建、修改、监控、删除等）。</p>
<ul>
<li>每个 Node 节点会运行一个 kubelet 进程，与 apiserver 通信，并运行为该 Node 安排的容器</li>
<li>结合 cAdvisor 负责向 Master 汇报自身节点运行情况：Node 节点注册、终止、定时上报健康状况等</li>
<li>接收 Master 发出的命令，创建相应的 pod</li>
</ul>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a><strong>kube-proxy</strong></h3><p>负责请求的转发。</p>
<ul>
<li>使用 IP 表（iptables）/ IPVS 将对 pod 的网络请求重定向到本地端口</li>
<li>为每个 service 建立服务代理对象（VIP），完成服务地址到 Pod 地址的代理</li>
<li>维护 node 上的防火墙规则和路由规则等信息，监听 apiserver 中 service / endpoints 的变化，并刷新对应规则，实现负载均衡</li>
<li>实现了集群内部从 Pod 到 Service，以及集群外部从 NodePort 到 Service 的访问</li>
</ul>
<p><img src="/2022/05/18/kubernetes-overview/kubeproxy.png" alt></p>
<p>kube-proxy 的实现模式主要有三种：</p>
<p><code>userspace</code>：最早的默认负载均衡方案（Kubernetes v1.0）</p>
<ol>
<li>Client pod 发起访问服务 service 的请求</li>
<li>请求到达 node 后，通过 service 的 IP 先进入<strong>本地内核</strong>的 iptables</li>
<li>随后请求转到 userspace，被转发给用户空间监听的 kube-proxy 端口</li>
<li>kube-proxy 处理请求后，将请求封装，再根据内核空间 iptables 中的规则，将请求转发给后端的 service(backend) pod</li>
</ol>
<p><img src="/2022/05/18/kubernetes-overview/node-userspace.png" alt></p>
<p>不过，流量从 userspace 进出内核带来的性能损耗是不可接受的。</p>
<p><code>iptables</code>：happen since Kubernetes v1.1，基于 netfilter 实现，是目前默认的代理模式（Default since Kubernetes v1.2）。</p>
<p>当客户端请求 service IP 时，本地内核的 iptables 会根据规则，将请求直接路由到各个 service pod 上。</p>
<p><img src="/2022/05/18/kubernetes-overview/node-iptables.png" alt></p>
<p>与 userspace 模式最大区别是：</p>
<ul>
<li>iptables 使用 NAT 模块实现 service 入口地址到 pod 实际地址的转换，采用随机数实现负载均衡，免去一次内核态到用户态的切换</li>
<li>如果 iptables 代理最初选择的那个 pod 没有响应，则<strong>不会自动重试</strong>其他 pod</li>
</ul>
<p>iptables 的性能问题：</p>
<ul>
<li>使用 NAT 转发，存在不可忽视的性能损耗</li>
<li>如集群中存在成千上万的 service / endpoints，则 node 上的 iptables rules 将非常庞大。</li>
</ul>
<p><code>ipvs</code>：since Kubernetes v1.9-alpha, default since v1.11</p>
<p>请求方式、路由建立与刷新与 iptables 相同，不一样的是，规则载体由 iptables 变成了 ipvs。</p>
<p><img src="/2022/05/18/kubernetes-overview/node-ipvs.png" alt></p>
<p>ipvs（基于哈希表）的性能优于 iptables（基于链表），其支持的轮询算法包括：</p>
<ul>
<li>DR: Direct Routing</li>
<li>NAT</li>
<li>Tunneling，也称 ipip 模式</li>
<li>RR: round-robin / 轮询</li>
<li>LC: least connection / 最少连接</li>
<li>DH: destination hashing / 目标哈希</li>
<li>SH: source hashing / 源哈希</li>
<li>SED: shortest expected delay / 预计延迟时间最短</li>
<li>NQ: never queue / 从不排队</li>
</ul>
<h3 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h3><p>日志收集功能。</p>
<h3 id="Failover"><a href="#Failover" class="headerlink" title="Failover"></a>Failover</h3><p>多节点（node）的集群环境中，倘若某个 deployment 控制的 ReplicaSet 拥有 3 个副本（pod），分布在不同的节点上：</p>
<ul>
<li>当 Node1 发生异常，原本在其上运行的 pod 状态无法被检测（status = UNKNOWN），这时 Kubernetes 会在其它正常运行的节点上<strong>启动新的 pod</strong> 来维护 deployment 的 replicas = 3</li>
<li>当 Node1 恢复正常，原本无法被检测状态的 pod <strong>会被移除</strong>；在其它 node 已创建的 replica（pod）也依然会在新的运行节点上，不会发生迁移。</li>
</ul>
<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><p>Kubernetes 一共使用三种资源管理存储：</p>
<p>Persistent Volume（持久化卷，<strong>PV</strong>）</p>
<ul>
<li>属于对 Kubernetes 底层共享存储的抽象，由管理员进行创建和配置</li>
<li>通过<strong>插件</strong>机制完成与实际共享存储的对接</li>
<li>其生命周期与使用它的 pod 相互独立</li>
</ul>
<p>Persistent Volume Claim（<strong>PVC</strong>）</p>
<ul>
<li>属于 namespace 里的资源，描述一个用户对 PV 的请求 claim</li>
<li>请求信息包含存储大小、访问模式等</li>
<li>PVC 直接与 pod 绑定</li>
</ul>
<p><strong>StorageClass</strong></p>
<ul>
<li>PV 的创建模板，为管理员创建 PV 的时候提供一种描述存储“类型”的方法</li>
<li>不同的 StorageClass 可映射到服务质量级别、备份策略、或群管理员确定的任意策略的 PV 上</li>
<li>在其他存储系统上会被称为 profiles</li>
</ul>
<p><img src="/2022/05/18/kubernetes-overview/pv-pvc-storageclass.png" alt></p>
<p>应用场景：用户提交 PVC，在 PVC 中指定存储类型（storageClassName），如果符合已经定义好的 StorageClass，则会为其自动创建 PV 并进行绑定。</p>
<p><img src="/2022/05/18/kubernetes-overview/pv-pvc-creation.png" alt></p>
]]></content>
      <tags>
        <tag>容器化</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 服务 Service</title>
    <url>/2023/05/10/kubernetes-service/</url>
    <content><![CDATA[<p>Service 是 Kubernetes 里面另一种非常常见的容器编排方式。</p>
<span id="more"></span>
<p>每个 pod 的 IP 地址是不稳定的，会随着 pod 销毁和创建发生变化；然而服务调用需要对不同 pod 进行负载均衡，利用非固定的 IP 进行网络调用并不现实。</p>
<p>Kubernetes 专门<strong>抽象</strong>了一组 pod 的<strong>逻辑定义</strong>来解决这个问题。</p>
<h1 id="Service-概况"><a href="#Service-概况" class="headerlink" title="Service 概况"></a>Service 概况</h1><p>Pod 是不稳定的，但是服务可以保证稳定。<br>区别于 service controller / endpoints controller 负责容器运行和编排，service 负责 Kubernetes 集群中<strong>容器的访问</strong>。</p>
<p>Service 的定义：</p>
<pre><code>An abstract way to expose an application running on a set of Pods as a network service.
</code></pre><p>Service 的职责：与每个 node 的 <a href="/2022/05/18/kubernetes-overview#kube-proxy">kube-proxy</a> 进程相结合，<strong>提供固定的 IP 和端口</strong>，在将数据包分发到相应服务节点时充当代理，进行负载均衡。</p>
<p>工作原理：根据 service 的每个 pod 所设置的标签 label</p>
<ul>
<li>比如某些 pod 被打上了 “app=xxx” 的标签</li>
<li>Service controller 通过 <code>serviceSelector</code> 选择 label 同样为 “app=xxx” 的 pod</li>
<li>列举所有被选中的 pod 的 IP，构建出一个负载均衡列表 <strong>endpoints</strong><ul>
<li>这些 endpoints 可被包装成一个完整的 service 对外提供服务</li>
<li>endpoints 所有 IP 和 pod 的端口通过 service controller 和 endpoints controller 共同选择并配置完成</li>
<li>如果某个 pod 出现故障，脱离服务集群，它的 IP 会自动在 endpoints 中被移除</li>
<li>如 serviceSelector 匹配到新的 pod，则 pod 的 IP 会自动加入各自对应的 endpoints 对象中</li>
</ul>
</li>
<li>Service 的信息会通过 apiserver 存入 etcd 中</li>
</ul>
<p>kube-proxy 通过 iptables / ipvs 为每一个 service 对象实现固定的 IP，称之为 VIP 或者 <code>cluster IP</code>。</p>
<p>在 Kubernetes v1.0 版本，Service 是 <strong>4 层</strong>（TCP / UDP over IP）概念，从 Kubernetes v1.1 新增 Ingress API，用来表示 7 层服务。</p>
<p><small>注：<code>iptables-save</code> 指令可以查看 iptables。</small></p>
<p>因此每一个 service 都有固定的 IP 和一些 endpoints。即使 pod 因为不稳定导致 ip 发生变化，但是面向客户端的是 service 的<strong>固定 IP 和端口</strong>。</p>
<p><img src="/2023/05/10/kubernetes-service/service.gif" alt></p>
<p><img src="/2023/05/10/kubernetes-service/service.png" alt></p>
<p>值得注意的是，并不是所有的 service pod 都带有 selector，也不是只有带着 selector 的才能组建 service。</p>
<p>对于那些带 selector 的 service，endpoints controller 根据 selector 筛选出属于该 service 的所有 pod，依此创建出 endpoints 记录，并修改 DNS 配置，返回指向这些 pod 的记录（地址）；</p>
<p>对于那些不带 selector 的 service，它们无法直接创建出 endpoints，只能通过以下方式配置 DNS：</p>
<ul>
<li>手动添加 endpoints</li>
<li>其他 service 的共享 endpoints</li>
<li>ExternalName 类型的 service 提供的 CNAME</li>
</ul>
<h1 id="端口和-IP"><a href="#端口和-IP" class="headerlink" title="端口和 IP"></a>端口和 IP</h1><p>Service 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span>    <span class="comment"># 会自动生成对应的 endpoint 对象，如不配置则不会自动生成，需要手动指定</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30036</span></span><br></pre></td></tr></table></figure>
<p>对应的 Endpoints 对象：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.42</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9376</span>    <span class="comment"># 配置相对应的 port，使其能对应上相应的 service</span></span><br></pre></td></tr></table></figure>
<p>可以看到，service 的配置 yaml 文件中定义了很多种端口：</p>
<p><strong>port</strong>：service 暴露在 clusterIP 上的接口</p>
<ul>
<li><code>clusterIP:port</code> 是提供给<strong>集群内部</strong>访问 Kubernetes 服务的入口。</li>
</ul>
<p><strong>nodePort</strong></p>
<ul>
<li><code>nodeIP:nodePort</code> 是提供给<strong>集群外部</strong>访问 Kubernetes 服务的入口</li>
<li>一般来说从 30000-32767 中选择一个端口赋给 nodePort。</li>
</ul>
<p><strong>targetPort</strong>：与 containerPort 一样是 pod 上的端口</p>
<ul>
<li>从 port 和 nodePort 过来的数据，经过 kube-proxy 从后端 pod 的 targetPort 进入容器</li>
</ul>
<p>也就是说，port 和 nodePort 都是 service 的端口，前者暴露给从集群内访问服务的方式，后者则暴露给集群外访问服务的方式；<br>这两个端口的流入数据均需经过反向代理 kube-proxy 流入后端具体 pod 的 targetPort，从而进入到 pod 上的 container 内。<br>一般来说，在同一个集群中的 port 和 targetPort 会配置相同的端口。</p>
<p>再来说说不同 IP 的概念：</p>
<p><strong>Pod IP</strong>：顾名思义，是 Pod 的 IP，其实就是 pause 容器的 IP，通常是一个虚拟的二层网络。</p>
<p><strong>Cluster IP</strong>：service 对象的 IP。</p>
<p>不同于 Pod IP 地址实际存在于某个网卡（或虚拟设备）上，Cluster IP 并没有一个网络设备去承载它：它其实是一个虚拟地址。</p>
<p><strong>Node IP</strong>：节点的 IP，即物理网卡（虚拟网卡）的 IP。</p>
<p>结合直接指定的或者 Kubernetes 分配的 nodePort，外部可以通过 <code>nodeIP:nodePort</code> 直接访问该服务。</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>Kubernetes 的 service 主要有四种不同类型：</p>
<h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a><strong>ClusterIP</strong></h2><p>默认的 Service 类型，只用于集群内部通信。service 之间只需通过访问 VIP 即可负载均衡地访问到对方 service 中的 pod。</p>
<p>根据 service 是否生成 Cluster IP，又可细分为：</p>
<ul>
<li>普通 service：最常见的 service。通过 kube-proxy 实现的 Cluster IP 实现集群内的访问</li>
<li>Headless Service：为该 service 在集群内部的每个成员提供一个唯一的 <strong>DNS 域名</strong>作为每个成员的网络标识</li>
</ul>
<p>普通的 service 必须要与 kube-proxy 相结合。</p>
<p>Headless Service 在集群内部各成员之间使用域名通信，其创建取决于 service 的 selector 配置。</p>
<p>可应用于直接访问某个 pod 提供的服务，比如 StatefulSet。具有以下特征：</p>
<ul>
<li>Kubernetes 不会为其分配 Cluster IP（<code>.spec.clusterIP: None</code>）</li>
<li>不通过 kube-proxy 做反向代理和负载均衡，而是通过 DNS 提供稳定的网络 ID 访问</li>
<li>DNS 将 headless service 的后端直接解析为 pod IP 列表</li>
</ul>
<h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a><strong>NodePort</strong></h2><p>可由集群外部通过 <code>nodeIP:nodePort</code> 访问的服务。</p>
<p>指定 service 类型为 NodePort 后，Kubernetes 控制台默认会从 30000-32767 中分配一个端口来代理服务</p>
<ul>
<li>或：在 yaml 配置文件的 <code>.spec.ports[*].nodePort</code> 配置指定的端口值</li>
<li>从 Kubernetes v1.10 开始，亦可调整 kube-proxy 中的 <code>--nodeport-addresses</code> 来配置指定的代理 IP</li>
</ul>
<h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a><strong>LoadBalancer</strong></h2><p>与 NodePort 类似，不过实现起来需要结合外部公有云（GCP / Azure / …）。</p>
<p>除了使用一个 Cluster IP 和 nodePort 外，还通过所使用的公有云申请一个负载均衡器，实现从集群外通过 LoadBalancer 访问对应的服务。<br>负载均衡器后端映射到各节点的 nodePort，流量会直接到后端的 pod 中。</p>
<h2 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a><strong>ExternalName</strong></h2><p>Service 的特例，主要面向集群外部的服务。</p>
<p>ExternalName 可将外部独立服务映射进 Kubernetes 集群，且具备 Kubernetes 内服务的一些特征（如 namespace 等），为集群提供服务。</p>
<p>不像上述三种类型服务通过 kube-proxy 路由，该种映射依赖于 DNS 实现（kube-dns version &gt;= 1.7）</p>
<p><img src="/2023/05/10/kubernetes-service/nodeport.png" alt></p>
<p>小结：</p>
<ul>
<li>前三种类型的 service 通过 selector 指定服务对应的 pod，根据所有 pod 地址创建出 endpoints 对象作为服务后端<ul>
<li>Endpoint Controller 监测 service 和 pod 的状态，维护对应 endpoints 信息</li>
<li>kube-proxy 根据 service 和 endpoints 维护本地路由规则</li>
<li>pod 发生变化 <code>-&gt;</code> service 发生变化 <code>-&gt;</code> endpoints 发生变化 <code>-&gt;</code> kube-proxy 在每个 node 上更新 iptables / ipvs，实现一层负载均衡</li>
</ul>
</li>
<li>而 ExternalName 不通过 kube-proxy 重定向，也不指定 selector，因此没有 port 和 endpoints 的概念</li>
</ul>
<p>ExternalName 与 ClusterIP 的 Headless Service <strong>同属 Headless Service</strong>，Kubernetes 不给它们分配 service IP，且不通过 kube-proxy 给它们做反向代理和负载均衡。</p>
<h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>Kubernetes 支持两种基本的服务发现模式：</p>
<p>DNS：默认形式</p>
<ul>
<li>可在集群中部署 <a href="/2022/05/18/kubernetes-overview#CoreDNS">CoreDNS</a> 服务（旧版本 Kubernetes 使用的是 kubeDNS），让集群内部的 pod 通过 DNS 方式实现集群内部各个服务之间的通信</li>
</ul>
<p>环境变量</p>
<ul>
<li>pod 创建完成后，kubelet 会在该 pod 中注册该集群已创建的所有 service 相关的环境变量</li>
<li>注意：service 创建之前的所有 pod 并不会注册该环境变量</li>
</ul>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 常用关键字（keywords）整理</title>
    <url>/2021/07/14/keywords/</url>
    <content><![CDATA[<p>本帖用来整理一些常见的 Java 语言中的关键字（保留字）。</p>
<span id="more"></span>
<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><ul>
<li>修饰抽象类或方法</li>
</ul>
<p><br></p>
<h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>断言（Since Java 4），用于查找内部程序错误</p>
<p><br></p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final 关键字在 Java 中被称为“完结器”，表示最终的意思。<br>它能声明类、方法、属性（方法参数和变量）。</p>
<pre><code>Java classes declared as final cannot be extended. 
</code></pre><p>final 声明的类不能被继承。</p>
<pre><code>Methods declared as final cannot be overridden. 
</code></pre><p>final 声明的方法不能被重写，但不影响被继承。</p>
<pre><code>The variable declared as final should be initialized only once and cannot be changed. 
</code></pre><p>final 声明的变量<strong>只能被赋值一次</strong>，不可被修改（Java 虚拟机为变量设定的默认值，并不计作一次赋值）。</p>
<ul>
<li>修饰基本类型：值不可变，即常量</li>
<li>修饰对象：该变量被赋予的引用不可变</li>
</ul>
<p>对于被 final 修饰的对象，不可改变的只是该变量所保存的引用，并不是该引用指向的对象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuilder s = <span class="keyword">new</span> StringBuilder();  <span class="comment">// final 修饰的是 s，即 s 保存的地址不能变</span></span><br><span class="line">s.append(<span class="string">&quot;a&quot;</span>);    <span class="comment">// 无误，s 指向的对象是可以被修改的</span></span><br><span class="line">s = <span class="keyword">null</span>;         <span class="comment">// 报错，s 的值不能被修改</span></span><br></pre></td></tr></table></figure></p>
<p>被 final 修饰的变量必须要被初始化：</p>
<ul>
<li>定义时初始化</li>
<li>初始化块中初始化</li>
<li>类的构造器（Constructor）中初始化</li>
<li>静态变量也可在静态初始化中初始化</li>
</ul>
<p>注：使用 final 修饰的共享数据结构，<strong>在它的对象构造函数完成后才能对其他线程可见（其他线程在其初始化完成后才能看到这个对象）</strong>。</p>
<p>一个小的知识点：一个被 final 定义并同时指定了初始值，且初始值为编译时就被确定的变量，被称作<strong>宏变量</strong>。编译器会将程序所有用到该变量的地方直接替换成该变量的值，这叫做<strong>宏替换</strong>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String a = <span class="string">&quot;hello&quot;</span>;    <span class="comment">// 宏变量</span></span><br><span class="line"><span class="keyword">final</span> String b = a;          <span class="comment">// 非宏变量，编译时会替换成 b = &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="final-的内存语义"><a href="#final-的内存语义" class="headerlink" title="final 的内存语义"></a>final 的内存语义</h2><p>限定了一些指令重排序：</p>
<ul>
<li>在构造函数里面对 final 域的写操作，和随后将这个被构造出来的对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;  <span class="comment">// 写普通域</span></span><br><span class="line">        j = <span class="number">2</span>;  <span class="comment">// 写 final 域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();  <span class="comment">// 先创建，再赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FinalExample object = obj;  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;  <span class="comment">// 2. 不会和 object 被赋值重排序：有数据依赖</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;  <span class="comment">// 3. 不会和 object 被赋值重排序：有数据依赖</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 final 域，JMM 禁止编译器将 final 域的写操作重排序到构造函数之外。编译器通过在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障来实现。</p>
<p>假设有线程 A 首先去执行 <code>writer()</code>，紧接着线程 B 执行 <code>reader()</code> 方法。时间片如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>构造函数开始执行</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td>写 final 域 j = 2;</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>StoreStore 屏障</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>构造函数执行结束</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td>将构造函数执行所返回对象的那个引用，赋值给引用对象 obj</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td></td>
<td>该对象引用 obj</td>
</tr>
<tr>
<td style="text-align:center"><strong>T5</strong></td>
<td></td>
<td>读对象的普通域 i</td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td></td>
<td>读对象的 final 域 j</td>
</tr>
<tr>
<td style="text-align:center"><strong>T7</strong></td>
<td>写普通域 i = 1;</td>
</tr>
</tbody>
</table>
</div>
<p>如上，因为变量 i 不是 final 域，编译的时候会被优化到构造函数之外，线程 A 在执行的过程中就会出问题。<br>而对于 final 域 j，因为刚刚提到，需要等到它<strong>所属的对象构造函数完成后，final 域才能对其他线程可见</strong>。所以 final 域的写操作不会被重排序到构造函数之外。</p>
<p>讨论读 final 域的内存语义时，我们再来举同样的例子，假设时间片如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>构造函数开始执行</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>T2</strong></td>
<td></td>
<td>读对象的普通域 i</td>
</tr>
<tr>
<td style="text-align:center"><strong>T3</strong></td>
<td>写普通域 i = 1;</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td>写 final 域 j = 2;</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>StoreStore 屏障</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>构造函数执行结束</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td>将构造函数执行所返回对象的那个引用，赋值给引用对象 obj</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td></td>
<td>该对象引用 obj</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td>LoadLoad 屏障</td>
</tr>
<tr>
<td style="text-align:center">T7</td>
<td></td>
<td>读对象的 final 域 j</td>
</tr>
</tbody>
</table>
</div>
<p>对于线程 B 访问 reader()，绝大多数处理器不会对 1 和 2，或者 1 和 3 重排序，但是极少数处理器仍然会进行重排序。<br>对于 final 域的读操作，JMM 在读引用与读 final 域之间<strong>插入 LoadLoad 屏障</strong>。即读一个 final 域不能被重排序到读对象引用之前。<br>而非 final 域就容易出问题。</p>
<h2 id="实现-final-的可见性"><a href="#实现-final-的可见性" class="headerlink" title="实现 final 的可见性"></a>实现 final 的可见性</h2><p>要实现 final 域初始化后才能被其他线程可见，需要保证构造函数内部的对于被构造对象的引用不能被其他线程看到；也就是说，对象引用（<code>this</code>）不能在构造函数中“逸出”。</p>
<p>举一个错误的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;  <span class="comment">// 1. 写 final 域</span></span><br><span class="line">        obj = <span class="keyword">this</span>;  <span class="comment">// 2. this 引用在此逸出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;  <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;  <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还是一样的假设，线程 A 首先去执行 <code>writer()</code>，紧接着线程 B 执行 <code>reader()</code> 方法。时间片如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>构造函数开始</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>T2</strong></td>
<td>obj = this;<br>2. 被构造对象的引用在这里“逸出”</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td></td>
<td>if (obj != null)<br>3. 读取不为 null 的对象引用</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td></td>
<td>int temp = obj.i;<br>4. 读取了 final 域初始化之前的值</td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td>i = 1;<br>1. 对 final 域初始化</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>构造函数结束</td>
</tr>
</tbody>
</table>
</div>
<p>因此 obj 会在对象还没完成初始化的时候被线程 B handle 了，导致应该被其他线程可见的 final 域初始化反而不可见。</p>
<p>小结：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），则不需要使用同步（synchronized 或 volatile）就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p>
<p>这是经过 JSR-133 增强过的语义，因为在旧的 JMM 中，一个比较严重的问题是，线程可能会看到 final 域的改变，这会导致 String 对象的值可能会被改变。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> ... </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  <span class="comment">// 在旧的 JMM 中可能会被改变</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p>只能被用在 <code>try</code> / <code>catch</code> 语句中</p>
<pre><code>The finally block always executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. 
</code></pre><p><code>return</code>, <code>continue</code>, <code>break</code> 都不能阻止 finally 语句块的执行</p>
<ul>
<li><code>return</code>, <code>continue</code>, <code>break</code> 所在语句块的内容会先输出，然后轮到 finally</li>
<li>但 finally 块是在他们被执行之前执行的</li>
</ul>
<p><br></p>
<h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h1><p><code>finalize()</code> 方法为 Object 类的方法：</p>
<pre><code>Before an object is garbage collected, the runtime system calls its finalize() method. 
</code></pre><p>对象在被回收之前，其 finalize() 方法会被调用，但只会被调用一次。</p>
<p><br></p>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul>
<li>修饰静态类、类成员方法、类成员变量以及 static 静态代码块</li>
<li>不能修饰局部变量</li>
</ul>
<p>static 变量与普通变量区别：也就是<strong>类</strong>与<strong>对象</strong>层面的区别</p>
<ul>
<li>所属目标不同：静态变量属于类的变量，普通变量属于对象的变量</li>
<li>存储区域不同：静态变量存储在方法区的静态区，普通变量存储在堆</li>
<li>加载时间不同：<ul>
<li>静态变量随着类的加载而加载，随着类的消失而消失</li>
<li>普通变量随着对象的加载而加载，随着对象的消失而消失</li>
</ul>
</li>
<li>调用方式不同：静态变量只能通过类名调用，普通变量只能通过对象调用</li>
</ul>
<p><br></p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>用来修饰一个方法或者一个代码块，能够保证在同一时刻最多只有一个线程执行这段代码，相当于让线程拥有了一把“锁”。</p>
<p>使用 synchronized 去同步方法，利用的是 Java 对象的对象锁（<code>Object.lock()</code>）来保护整个方法。</p>
<ul>
<li>可声明静态方法</li>
</ul>
<p>应用背景（多线程修改同一变量）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        test.inc();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        test.inc();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        test.inc();</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>注：三个线程执行完毕后：<code>test.x</code> 的值不一定就是 <code>30000</code>，有可能是 <code>[10000, 30000]</code> 之间的一个值。</p>
<p>这是因为，由于三个线程在同时访问一个变量，每个线程中 x 的自增操作<strong>并不是原子性的</strong>，它会被分解为：</p>
<ol>
<li>从主内存中将 <code>x</code> 的值读取到该线程的工作内存中；</li>
<li><code>x++</code>；</li>
<li>将 <code>x++</code> 的值写回工作内存及主内存。</li>
</ol>
<p>然而，实际的情况可能是：（以 <code>x = 0</code> 为例）</p>
<ol>
<li><code>x = 0</code></li>
<li>T1 从主内存读取 <code>x</code> 的值并写入其工作内存</li>
<li>T1 计算 <code>x</code> 的值为 1</li>
<li>T2 从主内存读取 <code>x</code> 的值并写入其工作内存，此时 T2 读取到的 <code>x</code> 的值<strong>仍为 0</strong></li>
<li>T2 计算 <code>x</code> 的值仍为 1</li>
<li>T1 将 <code>x = 1</code> 写入工作内存及主内存</li>
<li>T2 将 <code>x = 1</code> 写入工作内存及主内存</li>
<li>事实上 T1 和 T2 一共计算了<strong>两次</strong>，但 <code>x</code> 的值只增加了 1</li>
</ol>
<p><br></p>
<h2 id="关键字的应用"><a href="#关键字的应用" class="headerlink" title="关键字的应用"></a>关键字的应用</h2><h3 id="同步某个方法"><a href="#同步某个方法" class="headerlink" title="同步某个方法"></a>同步某个方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> 数据返回类型 方法名(参数) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>使用 synchronized 修饰的某个方法，被称为<strong>同步方法</strong>。</p>
<p>同步方法无需显式地指定同步监视器（Monitor），因为同步方法的 Monitor 是 this：也就是调用该同步方法的对象。</p>
<ul>
<li>可将某类变成线程安全的类 —— 该类相当于 Monitor</li>
<li>线程需获得内部对象锁，才能真正调用这个方法；而且锁只会加在访问同一个对象的这个方法的那些线程上<ul>
<li>比如类 Klass 有一个同步方法，分别有两个对象 klassA 和 klassB，调用它们俩的那个同步方法所获得的对象锁就不是一回事。</li>
</ul>
</li>
</ul>
<p>所以，上述应用背景可作如下改进：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test(), test2 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        test.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        test.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        test2.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        test2.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line"><span class="comment">// t1, t2 共享 test.inc() 的锁，t3, t4 共享 test2.inc() 的锁</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>所有访问同一 <code>test</code> 对象 inc() 方法的线程共用一把锁</li>
<li>其他线程如果访问其他对象的 inc() 方法，使用的是另外的锁</li>
</ul>
<p><code>synchronized</code> 修饰静态方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        Test.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        Test.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        Test.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        Test.inc();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line"><span class="comment">// 以上，所有线程共享 Test.inc() 的锁</span></span><br></pre></td></tr></table></figure></p>
<p>因为静态方法是独立于对象的存在，所以所有访问该静态方法的线程共享一把锁。</p>
<p><br></p>
<h3 id="同步代码块（同步阻塞）"><a href="#同步代码块（同步阻塞）" class="headerlink" title="同步代码块（同步阻塞）"></a>同步代码块（同步阻塞）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (同一个数据) &#123; ... &#125; </span><br></pre></td></tr></table></figure>
<p>这里说的“同一个数据”，是指多线程并发访问的数据，暂且称为<strong>锁芯</strong>。</p>
<p>通过锁住某一块代码，比锁住整个方法更有效率；因为这样能同时允许多个线程进入到方法中，进行那些无需上锁的操作。</p>
<p>锁芯可以为固定的 this 对象或类的 class 对象，也可更换为其他对象，但不能为 null。</p>
<ul>
<li>原因：锁芯应该是所有访问该方法的线程均能访问到的同一个对象，这样才能确保其线程互斥</li>
<li>所以选用 <code>this</code>、<code>class</code> 及其他 <code>final</code> 对象能防止锁芯被更换，从而避免各线程获得的对象锁不一样。</li>
</ul>
<p><strong>1. 普通方法中的同步代码块：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是代码块范围为整个方法里的代码，且锁住 this 对象</span></span><br><span class="line"><span class="comment">// 等价于 public synchronized void inc() &#123; x++; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();  <span class="comment">// 注意这个 final</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 静态方法中的同步代码块：</strong></p>
<p>静态方法通常只与<strong>类</strong>有关，凌驾于该类的任何对象之上；这时，锁芯通常由所有直接或间接调用该类<strong>静态方法</strong>的线程共享。</p>
<p>所以，此时的锁芯显然<strong>不能是 this 对象</strong>或任何非静态对象，只能是静态对象或类的 class 对象。</p>
<ul>
<li>通常添加 <code>final</code> 关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于 public static synchronized void inc() &#123; x++; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部对象锁只有一个相关条件，其局限性为：</p>
<ul>
<li>不能中断一个正在试图获得锁的线程</li>
<li>试图获得锁时不能设定超时</li>
<li>每个锁仅有单一条件</li>
</ul>
<p><strong>另：客户端锁定（client-side locking）</strong>：锁定某对象，将读写操作放入同一代码块中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (accounts) &#123;</span><br><span class="line">        accounts.set(from, accounts.get(from) - amount);</span><br><span class="line">        accounts.set(to, accounts.get(to) + amount);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>十分脆弱，不推荐使用。</p>
<p>注：<code>synchronized</code> 修饰的方法在子类中不会继承同步性</p>
<ul>
<li>即：多个线程调用该子类所继承的父类的方法时，不会加锁</li>
<li>除非重写并加上关键字</li>
</ul>
<p>线程同步代码块通用规则：<br>（以下规则以 synchronized 关键字为例，对其他对象锁同样适用）</p>
<ol>
<li>两个并发线程访问同一对象 object 中的 <code>synchronized(this)</code> 代码块时：<strong>一个时间内只能有一个线程得到执行</strong>。另一线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li>
<li>然而，当一个线程访问 object 的一个 <code>synchronized(this)</code> 代码块时，其他线程仍可以访问该 object 中的<strong>非</strong> synchronized(this) 代码块。</li>
<li>关键：当一个线程访问 object 的一个 <code>synchronized(this)</code> 代码块时，其他线程对 object 中所有其他 synchronized(this) 代码块的访问将被<strong>阻塞</strong>。</li>
<li>一个线程访问 object 的一个 <code>synchronized(this)</code> 代码块，便获得了该 object 的对象锁；其他线程对该 object 所有同步代码部分的访问都被暂时阻塞。</li>
</ol>
<p><br></p>
<h2 id="synchronized-原理：可重入性"><a href="#synchronized-原理：可重入性" class="headerlink" title="synchronized 原理：可重入性"></a>synchronized 原理：<strong>可重入性</strong></h2><p>基本的实现原理是基于进入和退出管程（Monitor）对象来实现同步的，monitor 对象通过计数器实现可重入性。在实现同步方法和同步代码块这两者之间有一些实现细节不一样。</p>
<p><strong>同步方法</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; doSomething(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>等同于<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intrinsicLock.lock();  <span class="comment">// this 对象的锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsicLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译后产生的指令集中，该同步方法对应指令中的方法表结构里面会设置 <code>ACC_SYNCHRONIZED</code> 标志：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void syncTask();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>当方法被调用时，调用指令会去检查 <code>ACC_SYNCHRONIZED</code> 标志，有的话，执行到这里的这个线程就会持有同步方法所在对象的 monitor 对象，monitor 对象的计数器加 1；执行完了方法之后再释放，计数器减 1.</p>
<p><br></p>
<p><strong>同步代码块</strong>的原理，在于编译之后，字节码文件会对应生成 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令，两者所在行号之间是代码块所要执行的方法被编译过后的指令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> 3: monitorenter</span><br><span class="line"> 4: getstatic     #2</span><br><span class="line"> 7: 1dc           #3</span><br><span class="line"> 9: invokevirtual #4</span><br><span class="line">12: aload_1</span><br><span class="line">13: monitorexit</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>某个线程执行同步代码块的时候，就需要获取锁，也就是获得该代码块所在对象所持有的 Monitor 对象（监视器锁）的持有权。<br>根据以上例子可知，<code>monitorenter</code> 是线程获得锁的指令，<code>monitorexit</code> 是线程释放锁的指令。</p>
<p>了解了 synchronized 的原理，我们就能知道，一个线程从一个对象的 synchronized 方法调用相同对象的另一个 synchronized 方法，线程在执行两个方法时获得的是<strong>一把</strong>对象锁：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">    System.out.println(t + <span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    m2(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">    System.out.println(t + <span class="string">&quot;m2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>即：调用同一对象的 m1 或 m2 方法时，所有线程共享一把锁</li>
<li>锁被获得（进入）了两次，monitor 对象被持有了两次，记数 2</li>
<li>进入该对象 m1 的线程在进入 m2 时可直接获得该锁，这也体现了“可重入性”</li>
<li>锁被释放一次，即 monitor 对象被释放一次，计数器就减 1，直到计数器为 0，锁就被释放掉了，先到先得。</li>
</ul>
<p>注意：</p>
<ul>
<li>非持有锁的线程在计数器大于 0 的时候访问该对象，线程只能等待</li>
<li>可重入的代码不能使用静态或全局变量作为锁芯，同时不会调用不可重用的代码</li>
<li>当 synchronized 方法 A 调用某方法 B，B 没有上锁，且可被其他线程直接调用<ul>
<li>等于开了免锁操作 B 方法的后门，造成线程不安全</li>
</ul>
</li>
<li>调用不同对象的 synchronized 方法：线程不共享对象锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t + <span class="string">&quot;m1&quot;</span>);</span><br><span class="line">        m2(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t + <span class="string">&quot;m2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncTest t = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        SyncTest t2 = <span class="keyword">new</span> SyncTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            t.m1(Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            t.m1(Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            t.m1(Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            t2.m1(Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   可能的情况：</span></span><br><span class="line"><span class="comment">    Thread-0m1</span></span><br><span class="line"><span class="comment">    Thread-0m2</span></span><br><span class="line"><span class="comment">    Thread-1m1</span></span><br><span class="line"><span class="comment">    Thread-1m2</span></span><br><span class="line"><span class="comment">    Thread-3m1    // t2对象的锁：这是另一把锁</span></span><br><span class="line"><span class="comment">    Thread-3m2    // 另一把锁</span></span><br><span class="line"><span class="comment">    Thread-2m1</span></span><br><span class="line"><span class="comment">    Thread-2m2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="synchronized-锁的级别"><a href="#synchronized-锁的级别" class="headerlink" title="synchronized 锁的级别"></a>synchronized 锁的级别</h2><p>在 Java 6 之前，synchronized 使用的是重量级锁。<br>在此版本之后进行了优化，拥有了<strong>无锁</strong> -&gt; <strong>偏向锁</strong> -&gt; <strong>轻量级锁</strong> -&gt; <strong>重量级锁</strong>的升级过程。</p>
<p>锁的升级是针对于不同同步场景进行的优化：</p>
<ol>
<li>在不存在锁竞争的时候，线程进入同步方法或代码块，使用偏向锁</li>
<li>存在竞争时升级为轻量级锁，其采用自旋锁的实现</li>
<li>如果同步方法或代码块执行时间很短的话，采用轻量级锁虽然会占用 CPU 资源，但是相对比使用重量级锁还是更高效的；</li>
<li>但是如果同步方法或代码块执行的时间很长，则使用轻量级锁自旋带来的性能消耗就远比使用重量级锁要大，这时候就需要升级为重量级锁了。</li>
</ol>
<h2 id="synchronized-在-JMM-的语义"><a href="#synchronized-在-JMM-的语义" class="headerlink" title="synchronized 在 JMM 的语义"></a>synchronized 在 JMM 的语义</h2><p>通过锁的<strong>释放</strong>和<strong>获取</strong>而建立起来的 happens-before 关系（监视器锁规则）。</p>
<p>假如有如下代码，俩线程 A 和 B 分别访问 writer() 和 reader()：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;  <span class="comment">// 1</span></span><br><span class="line">        a++;  <span class="comment">// 2</span></span><br><span class="line">    &#125;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a * a;  <span class="comment">// 5</span></span><br><span class="line">        ... </span><br><span class="line">    &#125;  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>1. 获得锁</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td>2. 执行临界区中的代码</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td>3. 释放锁</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td></td>
<td>4. 获得同一个锁</td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td></td>
<td>5. 执行临界区的代码</td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td></td>
<td>6. 释放锁</td>
</tr>
</tbody>
</table>
</div>
<p>程序顺序规则（1 + 2 + 3，4 + 5 + 6）和监视器锁规则结合之后，提供的 happens-before 保证，就是 2 happens-before 5。</p>
<p>释放锁对应的内存语义：将加锁操作（临界区代码）对本地内存中共享变量的修改<strong>写回</strong>主内存的共享变量中。<br>实质上是线程向接下来将要获取这个锁的某个线程<strong>发出了消息</strong>，消息是该线程对共享变量所做的修改。</p>
<p>获取锁对应的内存语义：先将本地内存中的共享变量<strong>置为无效</strong>，再去主内存中<strong>读取</strong>加锁操作所需要的共享变量到本地内存的副本中。<br>实质上是线程<strong>接收</strong>了先前某个线程发出的消息，消息是先前线程对共享变量所做的修改。</p>
<p>结合以上解释，我们可以得知，线程 A 释放锁，线程 B 获得锁，实质上就是线程 A 通过主内存向线程 B 发送消息的过程。</p>
<p><br></p>
<h1 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h1><p><code>transient</code> 只能用于修饰变量，用来标识非永久性（不能被序列化）的数据。</p>
<ul>
<li>当对象被序列化/反序列化时，被 transient 关键字修饰的变量不会被持久化/恢复<ul>
<li>如：类中有一个 InputStream 对象</li>
<li>对其序列化/反序列化是不合适的，因为序列化和反序列化的位置可能不同，从而导致恢复时对象不可用</li>
</ul>
</li>
</ul>
<p><br></p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>在了解 <a href="/2021/07/10/jmm">Java 内存模型</a>的时候，我们知道，编译器为了加快程序运行速度，对一些变量的写操作会先在寄存器或 CPU 缓存进行，在高速缓存中拥有一份抽象的工作内存，操作完成后最后再写入主内存。</p>
<p>工作内存中的变量是从主内存中读取拷贝，被修改后再写回主内存的；在这个过程中，变量新的值，即某次操作的工作内存变量值对其他操作线程是不可见的。</p>
<p>多个线程并发操作想要正常工作，所必须满足的三个条件如下：</p>
<p><strong>1. 可见性</strong></p>
<ul>
<li>一个线程修改了变量，其他线程要立即看得到</li>
<li>一般情况下，工作内存的变量被修改后不会立即写入主内存，这就会产生脏读</li>
</ul>
<p><strong>2. 原子性</strong></p>
<ul>
<li>do it all OR don’t do it at all</li>
<li>只有最基本的赋值是原子操作；变量互相赋值、自增减均非原子操作</li>
</ul>
<p><strong>3. 有序性</strong></p>
<ul>
<li>指令重排序：处理器为提高效率，会对代码的执行顺序进行优化</li>
<li>但会根据 as-if-serial 和 happens-before 来保证执行结果和顺序执行的结果相同</li>
</ul>
<p>如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;     <span class="comment">// 2</span></span><br><span class="line">a = a + <span class="number">3</span>;     <span class="comment">// 3</span></span><br><span class="line">r = a * a;     <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 由于 3 和 4 对 1 有依赖，所以编译期在进行指令重排序的时候，会确保 3 和 4 在 1 后面执行</span></span><br><span class="line"><span class="comment">// 可能的顺序 1234, 1324, 2134</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>但是多线程时，当依赖某个变量来判断语句的执行时，可能会因为指令重排序而出错<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread1</span></span><br><span class="line">context = loadContext();    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">boolean</span> inited = <span class="keyword">true</span>;      <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread2</span></span><br><span class="line"><span class="keyword">while</span>(!inited) sleep();     <span class="comment">// 1</span></span><br><span class="line">postInit(context);          <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错：Thread1.2 -&gt; Thread2.1 -&gt; Thread2.2 -&gt; Thread1.1（即有可能 context 还没被初始化，为空值）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="volatile-与并发"><a href="#volatile-与并发" class="headerlink" title="volatile 与并发"></a>volatile 与并发</h2><p>volatile 的特性：把单个 volatile 变量的读和写，看作是使用同一个锁对单次读写操作做的同步。</p>
<p><strong>1. 可见性</strong></p>
<p>volatile 可以保证变量的可见性</p>
<ul>
<li>被修饰的成员变量在每次被线程访问时，都强迫其从共享内存中直接重读该成员变量的值<ul>
<li>且：当成员变量发生变化时，强迫操作线程将变化值写回共享内存</li>
</ul>
</li>
<li>由此可知，在该机制下，任何时刻的两个不同的线程总是会看到某个成员变量的同一个值（看到其他线程对某个变量的写入）</li>
<li>只能用来修饰变量</li>
</ul>
<p>例 1：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> v1 = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        v1 = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        v1++;  <span class="comment">// 复合多个变量的读写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无需给方法加锁</span></span><br></pre></td></tr></table></figure></p>
<p>相当于以下实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v1 = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;  <span class="comment">// 写加锁</span></span><br><span class="line">        v1 = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> temp = get();    <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>;           <span class="comment">// 普通写操作</span></span><br><span class="line">        set(temp);            <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  <span class="comment">// 读加锁</span></span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：<code>getAndIncrement()</code> 并没有加锁，因为就如下面将要说到的：volatile <strong>并不能保证操作的原子性</strong>。</p>
<p>上述例子采用 <code>long</code> 来举例，是想通过 <code>long</code>（64 位）数据的赋值来说明：如果程序在 32 位系统执行，则变量是会（Java 鼓励，不强求）分成高 32 位和低 32 位写入的，而且不是原子性的操作。</p>
<p><strong>2. 原子性</strong></p>
<ul>
<li>volatile 变量不能提供原子性，不会主动发起阻塞</li>
<li>操作对于非原子操作，会将单句代码拆解，分别执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10 个线程均执行以上循环，结果可能小于 1000*10</span></span><br></pre></td></tr></table></figure>
<p>解析：因为 inc++ 并不是原子性操作，包括三步：</p>
<ol>
<li>主内存读取 inc</li>
<li>计算 inc` = inc + 1</li>
<li>写回主内存 inc = inc`</li>
</ol>
<p>出错的情况：</p>
<ol>
<li>T1 从主内存读 inc = 10，写入 T1 工作内存</li>
<li>T2 从主内存读 inc = 10，写入 T2 工作内存</li>
<li>T1 计算 inc` = 11 并将其写进工作内存和主内存</li>
<li>T2 计算 inc` = 11 并将其写进工作内存和主内存</li>
</ol>
<p>注意：</p>
<ul>
<li>加锁才保证操作的原子性，volatile 只保证操作的可见性。</li>
<li>对 volatile 变量的赋值和取值是原子性的，复合操作并不保证原子性</li>
</ul>
<p><strong>3. 有序性</strong></p>
<ul>
<li>volatile 保证有序性：JMM 会<strong>限制指令重排序</strong></li>
<li>确保本条指令不会因为编译器和虚拟机的优化而被省略</li>
</ul>
<p>原则：<br>指令优化时，不能把对 volatile 写的前置操作放在它的后面，也不能把 volatile 读的后续操作放在它的前面：</p>
<ul>
<li>当第⼆个操作是 volatile 写时，不管第⼀个操作是什么，都不能重排序。</li>
<li>当第⼀个操作是 volatile 读时，不管第⼆个操作是什么，都不能重排序。</li>
<li>当第⼀个操作是 volatile 写，第⼆个操作是 volatile 读时，不能重排序。</li>
</ul>
<table>
    <tr>
        <th>是否能重排序</th>
        <th colspan="3">第二个操作</th>
    </tr>
    <tr>
        <th>第一个操作</th>
        <th>普通读/写</th>
        <th>volatile 读</th>
        <th>volatile 写</th>
    </tr>
    <tr>
        <td>普通读/写</td>
        <td></td>
        <td></td>
        <td>NO</td>
    </tr>
    <tr>
        <td>volatile 读</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>volatile 写</td>
        <td></td>
        <td>NO</td>
        <td>NO</td>
    </tr>
</table>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x、y 为非 volatile 变量</span></span><br><span class="line"><span class="comment">// flag 为 volatile 变量</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> f;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;       <span class="comment">// 1</span></span><br><span class="line">y = <span class="number">0</span>;       <span class="comment">// 2</span></span><br><span class="line">f = <span class="keyword">true</span>;    <span class="comment">// 3</span></span><br><span class="line">x = <span class="number">4</span>;       <span class="comment">// 4</span></span><br><span class="line">y = -<span class="number">1</span>;      <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可能的顺序：1或2 在 3 后面；4或5 在 3 前面</span></span><br><span class="line"><span class="comment">// 可能的顺序只有：12345, 12354, 21345, 21354</span></span><br></pre></td></tr></table></figure>
<p>保证有序性的前提下，对前面的例子作修改：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1</span></span><br><span class="line">context = loadContext();  <span class="comment">// 1</span></span><br><span class="line">inited = <span class="keyword">true</span>;            <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// T2</span></span><br><span class="line"><span class="keyword">while</span>(!inited) sleep();   <span class="comment">// 1</span></span><br><span class="line">postInit(context);        <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// T1.1 必在 T1.2 前执行，以此来避免出错</span></span><br></pre></td></tr></table></figure></p>
<h2 id="实现：内存屏障"><a href="#实现：内存屏障" class="headerlink" title="实现：内存屏障"></a>实现：内存屏障</h2><p>volatile 所能保证的可见性，是根据它所能提供的有序性而来；而volatile 的有序性的实现，靠的是内存屏障（Memory Barrier）。</p>
<p>对于处理器重排序，JMM 的重排序规则会要求 Java 编译器生成指令序列时，在指令之间插入特定类型的内存屏障指令，由此来禁止特定类型的处理器重排序。</p>
<ul>
<li>通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证</li>
</ul>
<p>以下为不同的屏障类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">屏障类型</th>
<th style="text-align:center">指令示例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LoadLoad Barriers</td>
<td style="text-align:center">Load1;<em>LoadLoad</em>;Load2</td>
<td style="text-align:left">确保 Load1 数据的装载先于 Load2 及所有后续装载指令的执行</td>
</tr>
<tr>
<td style="text-align:center">StoreStore Barriers</td>
<td style="text-align:center">Store1;<em>StoreStore</em>;Store2</td>
<td style="text-align:left">确保 Store1 数据对其他处理器的可见（刷新到内存）先于 Store2 及所有后续存储指令的存储</td>
</tr>
<tr>
<td style="text-align:center">LoadStore Barriers</td>
<td style="text-align:center">Load1;<em>LoadStore</em>;Store2</td>
<td style="text-align:left">确保 Load1 数据的装载先于 Store2 及所有后续的存储指令刷新到内存</td>
</tr>
<tr>
<td style="text-align:center"><strong>StoreLoad Barriers</strong></td>
<td style="text-align:center">Store1;<em>StoreLoad</em>;Load2</td>
<td style="text-align:left">确保 Store1 数据对其他处理器可见（刷新到内存）先于 Load2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
</div>
<p>说明：“指令示例”里面，分号中间的就是屏障。</p>
<p>StoreLoad Barriers 是全能型屏障，同时具有其他三种内存屏障的效果；但是执行的代价很大，因为需要将所有工作内存变量刷新回主内存。<br>绝大多数处理器都支持 StoreLoad Barriers，不一定支持其它屏障。</p>
<p>通过最小化内存屏障数目来实现有序性是很难的，几乎不可能。<br>JMM 在实现指令排序的时候先会保证正确性，在此基础上才考虑效率。由此有 volatile 在 JMM 的<strong>保守</strong>的屏障策略：</p>
<ul>
<li>在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障<ul>
<li>（即：当第⼆个操作是 volatile 写时，不管第⼀个操作是什么，都不能重排序）</li>
</ul>
</li>
<li>在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障<ul>
<li>（即：当第⼀个操作是 volatile 写，第⼆个操作是 volatile 读时，不能重排序）</li>
</ul>
</li>
<li>在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障 &amp; LoadStore 屏障<ul>
<li>（即：当第⼀个操作是 volatile 读时，不管第⼆个操作是什么，都不能重排序）</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>操作线程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>普通读</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td>普通写</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td>StoreStore 屏障</td>
<td>禁止上面的普通写和下面的 volatile 写重排序</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td><strong>volatile 写</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td>StoreLoad 屏障</td>
<td>禁止上面的 volatile 写与下面可能有的 volatile 读/写重排序</td>
</tr>
</tbody>
</table>
</div>
<p>T5 插入 StoreLoad 屏障的原因：以防万一，为了能正确实现语义。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>操作线程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td><strong>volatile 读</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td>LoadLoad 屏障</td>
<td>禁止下面所有的普通读操作和上面的 volatile 读重排序</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td>LoadStore 屏障</td>
<td>禁止下面所有的普通写操作和上面的 volatile 读重排序</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td>普通读</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td>普通写</td>
</tr>
</tbody>
</table>
</div>
<p>同时，JMM 还会对一些内存屏障作优化处理。</p>
<p>比如以下的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarriersExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = v1;  <span class="comment">// 第一个 volatile 读</span></span><br><span class="line">        <span class="keyword">int</span> j = v2;  <span class="comment">// 第二个 volatile 读</span></span><br><span class="line">        a = i + j;   <span class="comment">// 普通写</span></span><br><span class="line">        v1 = i + <span class="number">1</span>;  <span class="comment">// 第一个 volatile 写</span></span><br><span class="line">        v2 = j * <span class="number">2</span>;  <span class="comment">// 第二个 volatile 写</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在保证 volatile 读/写内存语义的前提下，可以省略一些不必要屏障：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>操作线程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>第一个 volatile 读</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td>LoadLoad 屏障</td>
<td>禁止上面的 volatile 读和下面的 volatile 读重排序</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td>（省略了 LoadStore 屏障：下面的普通写不可能越过在它上面的 volatile 读）</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td>第二个 volatile 读</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td>（省略了 LoadLoad 屏障：下面没有普通读操作）</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td>LoadStore 屏障</td>
<td>禁止下面的普通写操作和上面的 volatile 读重排序</td>
</tr>
<tr>
<td style="text-align:center">T5</td>
<td>普通写</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td>StoreStore 屏障</td>
<td>禁止上面的普通写和下面的 volatile 写重排序</td>
</tr>
<tr>
<td style="text-align:center">T7</td>
<td>第一个 volatile 写</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td>（省略了 StoreLoad 屏障：下面紧接着一个 volatile 写）</td>
</tr>
<tr>
<td style="text-align:center">T8</td>
<td>StoreStore 屏障</td>
<td>禁止上面的 volatile 写和下面的 volatile 写重排序</td>
</tr>
<tr>
<td style="text-align:center">T9</td>
<td>第二个 volatile 写</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T10</td>
<td>StoreLoad 屏障</td>
<td>禁止上面的 volatile 写与下面可能有的 volatile 读/写重排序</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h2 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a>volatile 内存语义</h2><p>还是拿上面一段读写代码做例子，用 volatile 改一下，俩线程 A 和 B 分别访问 writer() 和 reader()：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a;  <span class="comment">// 4</span></span><br><span class="line">            ... </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前提过，volatile 能禁止指令重排序，因此 1 和 2 之间不会重排序，3 和 4 之间不会重排序。因此根据分析可知：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>1. 修改共享变量 a</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td>2. 写 volatile 变量</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td></td>
<td>3. 读取 volatile 变量</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td></td>
<td>4. 读取共享变量 a，并写入 i</td>
</tr>
</tbody>
</table>
</div>
<p>由程序顺序规则（1 在 2 之前，3 在 4 之前）和 volatile 变量规则（volatile 写在读之前，即 2 在 3 之前）结合之后，提供的 happens-before 保证，就是 1 happens-before 4。</p>
<p>volatile 写对应的内存语义：写 volatile 变量时，JMM 将本地内存中共享变量的值直接刷新到主内存的共享变量中。<br>实质上是这个操作线程向接下来将要读取这个 volatile 变量的某个线程<strong>发出了消息</strong>，消息是该线程对共享变量所做的修改。</p>
<p>volatile 读对应的内存语义：先将本地内存中的共享变量<strong>置为无效</strong>，再去主内存中<strong>读取</strong>共享变量的值到本地内存的副本中。<br>实质上是这个操作线程<strong>接收</strong>了先前某个线程发出的消息，消息是先前线程对 volatile 变量所做的修改。</p>
<p>结合以上解释，我们可以得知，线程 A 写一个 volatile 变量，线程 B 读取这个 volatile 变量，实质上就是线程 A 通过主内存向线程 B 发送消息的过程。</p>
<p><br></p>
<h2 id="使用场景：状态标记"><a href="#使用场景：状态标记" class="headerlink" title="使用场景：状态标记"></a>使用场景：状态标记</h2><ul>
<li>利用有序性及可见性，规避非原子性操作</li>
</ul>
<p>例：多线程环境开发下，单例模式的 double check<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; x = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由于instance = new Singleton() 非原子操作，会被拆成三步，利用 volatile 避免指令重排序避免出错</span></span><br><span class="line"><span class="comment"> 三步分别是：</span></span><br><span class="line"><span class="comment">     1. 为对象分配内存</span></span><br><span class="line"><span class="comment">     2. 调用构造函数初始化成员变量（如有）</span></span><br><span class="line"><span class="comment">     3. 将 instance 指向新对象</span></span><br><span class="line"><span class="comment"> 可能的顺序：123, 132，若 instance 为 volatile 则只能为 123</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 出错的情况（instance 不为 volatile）：</span></span><br><span class="line"><span class="comment"> 1. T1 调用，instance == null, 通过判断拿到锁，开始初始化对象</span></span><br><span class="line"><span class="comment"> 2. 指令重排序为 132</span></span><br><span class="line"><span class="comment">     a. 为对象分配内存</span></span><br><span class="line"><span class="comment">     b. 将 instance 指向新对象, instance != null</span></span><br><span class="line"><span class="comment">     c. T1 阻塞</span></span><br><span class="line"><span class="comment">     d. 调用 instance 构造方法，初始化成员变量，等</span></span><br><span class="line"><span class="comment"> 3. T2 在 2.b 与 2.d 之间调用，由于 instance != null，直接返回 instance，指向已经分配内存但未调用构造方法的对象，此时成员变量未初始化，可能出错</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 容器管理 - Pod</title>
    <url>/2023/05/09/kubernetes-pod/</url>
    <content><![CDATA[<p>Pod 是 Kubernetes 工作节点中最基本的操作单元，是集群中运行的一个进程，能够实现可管理性，通用和资源共享。</p>
<span id="more"></span>
<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>作为 Kubernetes 计算的最小可部署单元，一个 Pod 可能包含一个或多个容器（可以是 docker 容器）：</p>
<ul>
<li>运行单一容器（one-container-per-Pod）：最常见模型，Kubernetes 通过管理 pod 直接管理容器</li>
<li>运行多个容器：将应用程序的不同模块分离并分别部署到单独的容器中，加载时将所有容器视为一个容器加载，一起启动，一起停止；<ul>
<li>适合资源共享紧密的容器，但因为存在容器（服务）的职责粘连，并不多见（如数据拉取+清理存储+生成报表）</li>
</ul>
</li>
</ul>
<p>类似于一个 Servlet 容器完成部署 war 包、日志收集等功能。</p>
<p>Pod 有多种模式，包括 Sidebar，Proxy 等。</p>
<p>Pod 的状态（status）有五种：</p>
<ul>
<li><strong>Pending</strong>：创建 pod 的请求被 Kubernetes 接受，但容器还没启动成功<ul>
<li>可能正处于写数据到 etcd、调度、pull 镜像、启动容器四个状态中的一个</li>
<li>通常伴随这 ADDED, Modified 两个事件</li>
</ul>
</li>
<li><strong>Running</strong>：pod 已经绑定到 node 节点，所有容器已经启动成功 / 至少一个容器在运行或重启</li>
<li><strong>Succeed</strong>：pod 中所有容器已正常自行退出，且 Kubernetes 永远不会重启这些容器，一般会在部署 job 时候出现</li>
<li><strong>Failed</strong>：pod 中所有容器已终止，且至少一个容器以失败告终（非零退出或被系统停止）</li>
<li><strong>Unknown</strong>：某种原因无法获取 pod 状态，通常由于与 pod 的主机通信错误</li>
</ul>
<p><img src="/2023/05/09/kubernetes-pod/pod-status.png" alt></p>
<p>yaml 格式的 pod 定义文件完整内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>        　　<span class="comment">#必选，版本号，例如 v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       　　　　　　<span class="comment">#必选，Pod/Deployment/ReplicationController/Service/Job/...</span></span><br><span class="line"><span class="attr">metadata:</span>       　　　　　　<span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>        　　<span class="comment">#必选，Pod 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>     　　<span class="comment">#必选，Pod 所属的命名空间</span></span><br><span class="line">  <span class="attr">labels:</span>       　　　　　　<span class="comment">#自定义标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">value</span>      　<span class="comment">#自定义标签名字</span></span><br><span class="line">  <span class="attr">annotations:</span>        　　<span class="comment">#自定义注释列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>         　　　　　　　<span class="comment">#必选，Pod 中容器的详细定义（specification）</span></span><br><span class="line">  <span class="attr">containers:</span>       　　　　<span class="comment">#必选，Pod 中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　<span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>     　　<span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">IfNotPresent</span>]  <span class="comment">#获取镜像的策略 </span></span><br><span class="line">        <span class="comment">#Alawys 表示下载镜像 IfnotPresent 表示优先使用本地镜像，否则下载镜像，Never 表示仅使用本地镜像</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]     　　<span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]      　　 <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>      <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>     　　　　<span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　　<span class="comment">#引用 pod 定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span>     <span class="comment">#存储卷在容器内 mount 的绝对路径，应少于 512 字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span>     <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span>        　　　　　　<span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　　<span class="comment">#端口号名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>    <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>     　　 <span class="comment">#容器所在主机需要监听的端口号，默认与 Container 相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>      <span class="comment">#端口协议，支持 TCP 和 UDP，默认 TCP</span></span><br><span class="line">    <span class="attr">env:</span>        　　　　　　<span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　　<span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span>     　　<span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span>        　　<span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>       　　　　<span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     　　<span class="comment">#Cpu 的限制，单位为core数，将用于 docker run --cpu-shares 参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>      <span class="comment">#内存限制，单位可以为 Mib/Gib，将用于 docker run --memory 参数</span></span><br><span class="line">      <span class="attr">requests:</span>       　　<span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     　　<span class="comment">#Cpu 请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>      <span class="comment">#内存清楚，容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>      　　<span class="comment">#对 Pod 内个容器健康检查的设置，当探测无响应几次后将自动重启该容器</span></span><br><span class="line">            <span class="comment">#检查方法有 exec、httpGet 和 tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class="line">      <span class="attr">exec:</span>       　　　　　　<span class="comment">#对 Pod 容器内检查方式设置为 exec 方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]   <span class="comment">#exec 方式需要指定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>        　　　　<span class="comment">#对 Pod 内各容器健康检查方法设置为 HttpGet，需要制定 Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>      　　　　　　<span class="comment">#对 Pod 内各容器健康检查方式设置为 tcpSocket 方式</span></span><br><span class="line">         <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>   <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">0</span>    　　<span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认 1 秒</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">0</span>     　　<span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认 10 秒一次</span></span><br><span class="line">       <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">securityContext:</span></span><br><span class="line">         <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>] <span class="comment">#Pod的重启策略，Always 表示一旦不管以何种方式终止运行，kubelet 都将重启，OnFailure 表示只有 Pod 以非 0 退出码退出才重启，Never 表示不再重启该 Pod</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">object</span>   　　<span class="comment">#设置 NodeSelector 表示将该Pod调度到包含这个 label 的 node 上，以 key：value 的格式指定</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span>     　　　　<span class="comment">#Pull 镜像时使用的 secret 名称，以 key：secretkey 格式指定</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>      　　<span class="comment">#是否使用主机网络模式，默认为 false，如果设置为 true，表示使用宿主机网络</span></span><br><span class="line">  <span class="attr">volumes:</span>        　　　　　　<span class="comment">#在该 pod 上定义共享存储卷列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>     　　 　　<span class="comment">#共享存储卷名称 （volumes类型有很多种，以下为其各类型的描述：）</span></span><br><span class="line">    <span class="attr">emptyDir:</span> {}      　　　　<span class="comment">#类型为 emptyDir 的存储卷，与 Pod 同生命周期的一个临时目录。为空值</span></span><br><span class="line">    <span class="attr">hostPath:</span> <span class="string">string</span>      　　<span class="comment">#类型为 hostPath 的存储卷，表示挂载 Pod 所在宿主机的目录</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">string</span>      　　<span class="comment">#Pod 所在宿主机的目录，将被用于同期中 mount 的目录</span></span><br><span class="line">    <span class="attr">secret:</span>       　　　　　　<span class="comment">#类型为 secret 的存储卷，挂载集群与定义的 secret 对象到容器内部</span></span><br><span class="line">      <span class="attr">secretname:</span> <span class="string">string</span>  </span><br><span class="line">      <span class="attr">items:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">configMap:</span>      　　　　<span class="comment">#类型为 configMap 的存储卷，挂载预定义的 configMap 对象到容器内部</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>
<p>在容器编排的时候，可根据 pod 的标签（<strong>labels</strong>）区分这个 pod 要运行在哪台主机（node）上。</p>
<p>每个 pod 就像一个受 node 管理的机器人一样，接收路由过来的请求，做着自己的事情。</p>
<p><img src="/2023/05/09/kubernetes-pod/pod-machine.png" alt></p>
<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>每个 Pod 会被分配到属于自己的 <strong>IP 地址</strong>，该 IP 仅在 cluster 中可见，kube-proxy 将使用该 IP 来路由流量。</p>
<p>每个 pod 启动时，内部会启动一个 <strong>infra container</strong>（由 Google 的一个镜像：<code>gcr.io/google_containers/pause</code> 启动而来，也叫 <strong>pause 容器</strong>）。<br>pause 容器使用默认网络模式；</p>
<p>pod 中的其它容器的网络模式为 container 模式，并会被指定为 pause 容器的 ID：<code>network_mode: "container:{pauseContainerID}"</code>。<br>由此，pod 内部所有容器可<strong>共享 pause 容器的网络</strong>，通过 pause 容器统一识别外部网络空间，跟集群内其它 pod 进行通信。</p>
<p>由此完成了对 pod 中所有内部容器的共享设置：共享资源，共享配置；各个容器之间可通过 <code>localhost</code> 相互访问，对外则总是<strong>被同时调度</strong>。</p>
<p><img src="/2023/05/09/kubernetes-pod/pod-network.png" alt></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>初始化阶段：在 pod 主容器启动前，可以启动一些 init 容器来完成必要的初始化工作；这些 init 容器串行化执行，执行完后便会退出。</p>
<p>主容器启动后和结束前可分别指定操作 post start 和 pre stop，用来执行一些操作。</p>
<p>主容器启动后，可设置探针（probe）监测 pod 的状态：</p>
<ul>
<li><strong>liveness probe</strong>：检查 pod 是否为 running 状态</li>
<li><strong>readness probe</strong>：判断容器是否可以接收 service 的请求：容器的 ready 是否为 True</li>
<li>每类探针支持三种探测方法：exec, httpGet, tcpSocket</li>
<li>探针的返回结果：success, failure, unknown</li>
</ul>
<p><img src="/2023/05/09/kubernetes-pod/pod-lifecycle.png" alt></p>
<p><img src="/2023/05/09/kubernetes-pod/pod-booming.png" alt></p>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a><strong>Namespace</strong></h1><p>在 Kubernetes 集群内，可将资源对象（controller、pod 等）分配到不同的命名空间 namespace 中，以实现多租户的资源隔离。</p>
<p>集群默认的 namespace 是 <code>default</code>，<code>kube-*</code> 都是 Kubernetes 系统的命名空间。</p>
<p>在一个 pod 中，所有容器共享的资源包括：</p>
<ul>
<li>PID namespace（命名空间）：pod 中不同应用程序可看到其他应用程序的进程 ID</li>
<li>网络 namespace：pod 中多个容器能访问同一个 IP 和端口范围</li>
<li>IPC namespace：pod 中多个容器能使用 SystemV IPC 或 POSIX 消息队列进行通信（属于进程间通信）</li>
<li>UTS namespace：pod 中多个容器共享一个主机名（localhost）</li>
<li>Volumes：共享存储卷，pod 中各个容器可访问在 pod 级别定义的 Volumes</li>
</ul>
]]></content>
      <tags>
        <tag>容器化</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2023/02/25/merge-sort/</url>
    <content><![CDATA[<p>归并排序属于稳定的比较排序算法。</p>
<span id="more"></span>
<p>归并排序由冯诺依曼于 1945 年首次提出，是基于分治法的一个非常典型的应用。</p>
<p>在归并排序每一层的基本步骤如下：</p>
<ol>
<li><strong>分解（Divide）</strong>：将 n 个元素分成两个含 n/2 个元素的子序列</li>
<li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归地进行排序</li>
<li><strong>归并（Merge）</strong>：合并两个已排序的子序列，得到排序结果</li>
</ol>
<h1 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h1><p>实现逻辑分两种：“自上而下”的递归法和“自下而上”的迭代法。</p>
<p><strong>递归法（Top-down）</strong></p>
<ol>
<li>申请空间，大小为两个已经排好序的序列之和；该空间用来存放合并后的序列；</li>
<li>设定两个指针，初始位置分别为两个已经排序的序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对较小（升序）/大（降序）的元素放入到上述的合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3，直至其中一个指针到达该序列尾；</li>
<li>将另一序列剩下所有元素直接复制到合并空间尾。</li>
</ol>
<p><strong>迭代法（Bottom-up）</strong></p>
<p>假设序列中有 n 个元素：</p>
<ol>
<li>将序列中每相邻的两个数字进行归并操作，形成 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.869ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3920 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(433,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(899,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1244,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(1542,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1931,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2531,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(3031,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(3531,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 个序列，排序后每个序列包含一个或两个元素；</li>
<li>如果此时序列数不为 1，则将上述的序列再次合并，形成 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.869ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3920 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(433,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(899,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1244,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(1542,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1931,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2531,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(3031,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g><g data-mml-node="mo" transform="translate(3531,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 个序列，每个序列包含三个或四个元素；</li>
<li>重复步骤 2，直到所有元素排序完毕，即序列数为 1。</li>
</ol>
<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T E, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 对 E 中的 n 个元素进行排序，k 为全局变量</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= k) {</span><br><span class="line">        <span class="comment">// 分成两个子序列</span></span><br><span class="line">        i = n/k;</span><br><span class="line">        j = n-i;</span><br><span class="line">        <span class="comment">// 令 A 包含 E 中的前 i（n/k）个元素</span></span><br><span class="line">        <span class="comment">// 令 B 包含 E 中余下 j 个元素</span></span><br><span class="line">        sort(A, i);  <span class="comment">// 传入下标，开始递归</span></span><br><span class="line">        sort(B, j);  <span class="comment">// 传入下标，开始递归</span></span><br><span class="line">        merge(A, B, E, i, j);  <span class="comment">// 将 A 和 B 合并到 E</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 使用插入排序算法对 E 进行排序</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>merge()</code> 的时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>而整个算法所花费时间：</p>
<script type="math/tex; mode=display">
Time(n) = 
\begin{cases}
d & \quad \text{$n < k$}\\
t(\frac{n}{k})+t(n-\frac{n}{k})+cn & \quad n \geq k
\end{cases}</script><p>可知当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="1.955ex" height="2.397ex" role="img" focusable="false" viewbox="0 -706.5 864.3 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(247.9,-345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><rect width="624.3" height="60" x="120" y="220"/></g></g></g></svg></mjx-container> 约等于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="6.079ex" height="2.397ex" role="img" focusable="false" viewbox="0 -706.5 2686.7 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mfrac" transform="translate(1822.4,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(247.9,-345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><rect width="624.3" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.327ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2354.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(798.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1854.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container> 的时候，时间耗费最少。<br>此时的分解方法为<strong>对半分</strong>，平均复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p><img src="/2023/02/25/merge-sort/merge-sort-dynamic.gif" alt></p>
<p>当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.327ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2354.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(798.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1854.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>，归并排序又被称为<strong>二路归并排序</strong>。</p>
<h1 id="二路归并代码实现"><a href="#二路归并代码实现" class="headerlink" title="二路归并代码实现"></a>二路归并代码实现</h1><p>思路：</p>
<ol>
<li>首先将每两个相邻的大小为 1 的子序列归并</li>
<li>然后对上一次归并所得到的大小为 2 的子序列进行相邻归并</li>
<li>直至最后归并到一个序列</li>
</ol>
<p><img src="/2023/02/25/merge-sort/merge-2.jpg" alt></p>
<p>C++：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自上而下</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="title">MergeSort</span><span class="params">(T a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="comment">// 对 a[left:right] 中的元素进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) {  <span class="comment">// 至少两个元素</span></span><br><span class="line">        <span class="keyword">int</span> i = (left + right) / <span class="number">2</span>;  <span class="comment">// 中心位置</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(a, left, i);  <span class="comment">// 左半部</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(a, i+<span class="number">1</span>, right);  <span class="comment">// 右半部</span></span><br><span class="line"></span><br><span class="line">        T *b = <span class="keyword">new</span> T [n];</span><br><span class="line">        <span class="built_in">Merge</span>(a, b, left, i, right);  <span class="comment">// 从 a 合并到 b</span></span><br><span class="line">        <span class="built_in">Copy</span>(b, a, left, right);  <span class="comment">// 结果放回 a</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自下而上</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">// Sort a[0:n-1] using merge sort.</span></span><br><span class="line"></span><br><span class="line">    T *b = <span class="keyword">new</span> T [n];  <span class="comment">// empty new array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;  <span class="comment">// segment size</span></span><br><span class="line">    <span class="keyword">while</span> (s &lt; n) {</span><br><span class="line">        <span class="built_in">MergePass</span>(a, b, s, n);  <span class="comment">// merge from a to b</span></span><br><span class="line">        s += s;</span><br><span class="line">        <span class="built_in">MergePass</span>(b, a, s, n);  <span class="comment">// merge from b to a</span></span><br><span class="line">        s += s;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(T x[], T y[], <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">// Merge adjacent segments of size s from x to y.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - <span class="number">2</span> * s) {</span><br><span class="line">        <span class="comment">// merge two adjacent segments of size s</span></span><br><span class="line">        <span class="built_in">Merge</span>(x, y, i, i+s<span class="number">-1</span>, i+<span class="number">2</span>*s<span class="number">-1</span>);</span><br><span class="line">        i = i + <span class="number">2</span> * s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fewer than 2s elements remain</span></span><br><span class="line">    <span class="keyword">if</span> (i + s &lt; n) {</span><br><span class="line">        <span class="built_in">Merge</span>(x, y, i, i+s<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n<span class="number">-1</span>; j++) {</span><br><span class="line">            <span class="comment">// copy last segment to y</span></span><br><span class="line">            y[j] = x[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归法，核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T c[], T d[], <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">// Merge c[l:m] and c[m:r] to d[l:r].</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l,  <span class="comment">// cursor for first segment</span></span><br><span class="line">    j = m+<span class="number">1</span>,  <span class="comment">// cursor for second</span></span><br><span class="line">    k = l;  <span class="comment">// cursor for result</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge until i or j exits its segment</span></span><br><span class="line">    <span class="keyword">while</span> ((i &lt;= m) &amp;&amp; (j &lt;= r)) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类似于选择排序</span></span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt;= c[j]) {</span><br><span class="line">            d[k++] = c[i++];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            d[k++] = c[j++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take care of left overs</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; m) {  <span class="comment">// left boundary exceeds</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = j; q &lt;= r; q++) {</span><br><span class="line">            d[k++] = c[q];</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {  <span class="comment">// right boundary meets r</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = i; q &lt;= m; q++) {</span><br><span class="line">            d[k++] = c[q];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortTD</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">        mergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Top-down merge sort</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) {</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(a, start, mid);</span><br><span class="line">            mergeSort(a, mid + <span class="number">1</span>, end);</span><br><span class="line">            merge(a, start, mid, end);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bottom-up merge sort</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBU</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i *= <span class="number">2</span>) {  <span class="comment">// 类似于 步长</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i; j += <span class="number">2</span> * i) {</span><br><span class="line">                merge(a, j, j + i - <span class="number">1</span>, Math.min(j + <span class="number">2</span> * i - <span class="number">1</span>, a.length - <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] tmp = Arrays.copyOf(a, a.length);</span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= middle &amp;&amp; right &lt;= high) {</span><br><span class="line">            a[curr++] = tmp[left] &lt;= tmp[right] ? tmp[left++] : tmp[right++];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// take care of the left-overs</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= middle) {</span><br><span class="line">            a[curr++] = tmp[left++];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= high) {</span><br><span class="line">            a[curr++] = tmp[right++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中，自下而上的方法如下图所示：</p>
<p><img src="/2023/02/25/merge-sort/merge-1.png" alt></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/2023/06/10/micro-service/</url>
    <content><![CDATA[<p>微服务是单体服务（SOA）演变至今，对于分布式、可维护性，解耦等思想的新的应用组织模式。</p>
<span id="more"></span>
<p>微服务的“微”，指的是业务功能小。</p>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>微服务除了服务们本身之外，要想维护整个应用的运行，以下组件必不可少：</p>
<ul>
<li>网关</li>
<li>服务注册与发现</li>
<li>服务治理，包括限流、熔断与降级</li>
<li>负载均衡</li>
<li>链路追踪</li>
<li>配置中心</li>
<li>…</li>
</ul>
<p>微服务之间的通信方式一般有 HTTP 和 RPC 两种。</p>
<p>一般来讲会偏向于采用 HTTP：因为在生态中各个微服务独立开发的原因，对开发语言无强要求，所以倾向于对语言更解耦的 HTTP，而不是对服务之间通信格式有强要求的 RPC。</p>
<p>接下来简单介绍一下重要的一些组件需要注意的地方。</p>
<p><br></p>
<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>网关在微服务中不显山不露水。</p>
<p>没网关，也能访问服务，但是问题在于：</p>
<ul>
<li>如果服务多起来了，客户端需要实现访问不同服务的逻辑，会增加客户端复杂度；</li>
<li>另外如果服务需要鉴权，则每个服务的鉴权处理都需要分别实现和维护；</li>
<li>而且流量控制不好做</li>
</ul>
<p>另外，如果服务想同时支持 HTTP 和 RPC 或另外的多种通信方式，client 要分别维护不同语言的 SDK。</p>
<p>以上的问题都可以通过网关的功能覆盖，也就是说，网关的好处在于：</p>
<ul>
<li>针对所有请求进行统一鉴权、限流、缓存、日志（打点）</li>
<li>协议转化。针对后端多种不同的协议，在网关层统一处理之后，以 HTTP 对外提供服务</li>
<li>提供统一的错误码</li>
<li>请求转发，且可以基于网关实现内网和外网的隔离</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>网关鉴权</strong>：与统一的认证中心进行交互，实现身份认证和访问权限控制</p>
<p><strong>灰度发布</strong>：网关与分流引擎交互，将不同比例的流量分发到新/旧不同的服务中；前期切小部分（如 10%）流量至新服务，如效果不好/存在 bug 就回退，否则就会增大流量比例</p>
<h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在 Spring Cloud 中，各种类型的微服务组件实现服务注册的原理是一样的：</p>
<ul>
<li>实现 <code>spring-cloud-commons</code> 包的 <code>ServiceRegistry</code> 接口方法；</li>
<li>加载自动配置类的时候（在 <code>spring-cloud-commons</code> 的 <code>spring.factories</code> 中加载）：<ul>
<li><code>AutoServiceRegistrationAutoConfiguration</code> 实现了接口 <code>AutoConfiguration</code>；</li>
<li>另一个抽象类 <code>AbstractAutoServiceRegistration</code> 又实现了 <code>AutoServiceRegistrationAutoConfiguration</code>；</li>
<li><code>AbstractAutoServiceRegistration</code> 同时还实现了 <code>ApplicationListener</code> 接口，接收到 WebServiceInitializedEvent 后，对 event 进行绑定（被废弃的方法）；</li>
<li>通过以上继承关系加载具体的自动配置类。</li>
</ul>
</li>
<li>“绑定”服务：调用 ServiceRegistry 的 <code>register()</code> 接口方法</li>
</ul>
<h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>在传统系统部署中，服务运行在一个固定的已知 IP 和端口上。如果一个服务需要调用另一个服务，可以通过地址直接调用。<br>但在虚拟化或容器化环境中，服务实例的启动和销毁非常频繁，因此服务地址也在动态变化。<br>这种情况就需要服务发现机制。</p>
<p>此时服务间的调用不是通过直接调用具体的实例地址，而是通过服务名发起调用。调用方需要向服务注册中心咨询服务，获取服务的实例清单，从而访问具体的服务实例。</p>
<p>调用流程：</p>
<ul>
<li>各个服务将自己的 ip 和端口发送至注册中心，注册中心维护服务注册表；</li>
<li>某个服务要调用另外的服务的时候，从注册中心获取服务列表并查询，最终执行想要的服务调用；</li>
<li>同时每个服务会保留一份服务注册表的本地缓存，定期更新；</li>
<li>下次访问的时候会先请求本地缓存，没有的话才会请求注册中心。</li>
</ul>
<p>服务发现有两种实现方式：</p>
<p><strong>基于客户端的服务发现</strong>：由客户端提供负载均衡算法，根据获得的注册表进行服务访问</p>
<ul>
<li>优点：客户端知道所有可用服务的实际网络地址，可非常方便地实现负载均衡，从而请求对应的服务；</li>
<li>缺点：耦合性强，针对不同语言，每个服务的客户端都得实现一套服务发现的功能</li>
</ul>
<p><strong>基于服务端的服务发现</strong>：由服务端的负载均衡组件提供负载均衡算法，负载均衡组件查询注册表并进行负载均衡的访问</p>
<ul>
<li>优点：服务发现逻辑对客户端不透明。客户端不需要知道服务列表，只需向负载均衡组件发送请求即可；</li>
<li>缺点：必须要关心负载均衡组件的高可用性</li>
</ul>
<h1 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h1><p>微服务面对高并发请求的时候，当大量请求突然涌入时，如果有一个服务失败，也许导致整条服务链路的服务都失败，这就是<strong>服务雪崩</strong>。</p>
<p><strong>服务熔断</strong>和<strong>服务降级</strong>可视为解决服务雪崩的手段。</p>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>当某个服务无法正常为调用者提供服务时，为防止服务雪崩，暂时将出现故障的接口<strong>隔离开</strong>，后续一段时间内该服务调用者的请求会<strong>直接失败</strong>，直到目标服务恢复正常。</p>
<p>如何知道恢复正常？可以设定 reset timeout，过后进入半开合状态并放行部分流量以便重新检测服务；如果服务仍未恢复，则保持链接断开，直到下一次 timeout。</p>
<p>熔断是框架级别的处理，基本会采用<strong>断路器</strong>模式实现，达到熔断阈值才会触发熔断。</p>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>相对于熔断，服务降级多是业务级别的处理。</p>
<ul>
<li>下游服务因某些原因响应过慢：下游可以停掉不重要业务，释放服务器资源，提高响应速度；</li>
<li>下游服务因某些原因不可用：上游可主动调用本地降级逻辑，避免卡顿，迅速反馈给用户；</li>
</ul>
<p>实现上多数是在配置中心给非核心业务配上开关，一旦系统扛不住则关闭开关，结束次要进程。</p>
<p>熔断降级常见方案：</p>
<ul>
<li><strong>平均响应时间</strong>：设定响应时间阈值，如果连续 N 个请求对应时刻的平均响应时间均超过阈值，那在往后一个固定时间窗口内，访问会被熔断</li>
<li><strong>异常比例</strong>：每秒调用所获得的异常总数比例超过设定阈值：资源自动降级，往后一个固定时间窗口，方法调用会自动返回</li>
<li><strong>异常数量</strong>：每秒调用所获得的异常总数超过设定阈值：资源自动降级，往后一个固定时间窗口，方法调用会自动返回</li>
</ul>
<h2 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h2><p>通过限制并发访问数或限制一个时间窗口内允许处理的请求数量来保护系统。<br>一旦达到限制流量，则对当前请求进行处理采取对应拒绝策略，如跳转错误页面、排队、服务降级等。</p>
<h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><p>主流的限流算法如下：</p>
<p><strong>计数器算法</strong>：指定周期内（如 3 秒）的累计访问次数达到设定阈值（如 150）时，触发限流策略。进入下一个时间周期后，访问次数清零。</p>
<p>一个很明显的缺陷就是临界问题：如果在第 2 - 3 秒进入 150 个请求，3 - 4 秒进入 150 个请求，相当于两秒内进入 300 个请求，完全达不到限流效果。</p>
<p><strong>滑动窗口</strong>：固定窗口改良版，解决固定窗口在窗口切换时可能受到两倍于阈值数量的请求的问题：</p>
<ul>
<li>将一个窗口分为若干等分的小窗口，每个小窗口对应不同时间点，拥有独立的计数器</li>
<li>当请求时间点大于当前窗口最大时间点时，则向前平移一个小窗口，第一个小窗口数据舍弃，整个窗口所有请求数相加不能大于阈值</li>
</ul>
<p><strong>令牌桶限流</strong>：网络流量整形（traffic shaping）和速率控制（rate limiting）中最常用的方法：</p>
<ul>
<li>匀速往桶里面扔令牌，桶大小固定的话，桶满了就会丢弃多余的令牌；</li>
<li>请求速度大于令牌生成速度：令牌被取空后，会被限流；</li>
<li>请求速度等于令牌生成速度：流量趋于平稳；</li>
<li>请求速度小于令牌生成速度，请求可被正常处理</li>
</ul>
<p><strong>漏桶限流</strong>：不管来的请求数量和并发有多快，请求到达服务的速度是一致的，就像是不管水龙头来的水有多猛，漏桶水滴的速度是恒定的。</p>
<p>主要作用：控制数据注入网络的速度，平滑网络的突发流量。</p>
<p>应用：消息中间件。</p>
<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>在没有配置中心的时候：</p>
<p>在微服务架构中，当系统从一个单体应用被拆分成为分布式系统上的一个个服务节点之后，配置文件（<code>application.yml</code> / <code>application.properties</code>）也必须跟着迁移甚至切割。<br>因此，多个微服务拆分后产生多份配置文件，容易造成配置分散，不好管理，还会伴随着冗余。</p>
<p>我们需要这么一个组件，能够：</p>
<ul>
<li>发布、修改、删除配置，实现不改动代码就能实现新需求；</li>
<li>中心化，服务从配置中心获得配置信息，应用就没有配置信息了：实现无状态</li>
<li>当配置信息发生变更，可发起通知服务：实现热加载</li>
</ul>
<p>甚至，我们还希望在配置中心中配置 bean，应用可以通过获取 bean 定义创建不同的服务。</p>
<p>因此配置中心应运而生。</p>
<p>另外，我们还希望配置中心能够满足：</p>
<ul>
<li>隔离性：配置对于程序来说是只读的，独立于程序存在</li>
<li>配置中心应该能够影响整个服务的生命周期</li>
<li>配置中心的配置应该能支持多种加载方式（SDK、编码、配置文件）</li>
<li>实现环境治理，不同类型环境有不同的配置集</li>
</ul>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 概述</title>
    <url>/2021/07/07/jvm-basics/</url>
    <content><![CDATA[<p>JVM 作为 Java 程序的容器，是所有 Java 程序依赖的平台。</p>
<span id="more"></span>
<p>JVM 执行 Java 程序的过程：</p>
<ol>
<li>通过类加载器加载各个 <code>.class</code> 文件</li>
<li>为程序管理并分配内存</li>
<li>在适当的时候执行垃圾回收</li>
</ol>
<p>多一些阅读<a href="https://docs.oracle.com/javase/specs/jvms/se13/html/index.html">官方文档（Java 13）</a>，涉猎 JVM 的原理，有助于 Java Developer 们避开开发过程中的许多陷阱。</p>
<p><br></p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>顶层：<a href="/2021/07/08/class-loader"><strong>类加载器</strong></a> <strong>Class Loader</strong></p>
<ul>
<li>加载 JVM .class 文件</li>
</ul>
<p>中间：Java 虚拟机内存（<strong>Runtime Data Area</strong>, <strong>运行时数据区</strong>，重点关注），即 JVM 在系统中能掌控到的内存部分，主要包括 5 部分：</p>
<ul>
<li><font color="#548235"><strong>方法区</strong></font> (Method Area)</li>
<li><font color="#548235"><strong>堆</strong></font> (Heap, 存放 Java 对象和数组实例)</li>
<li><font color="#FFC000"><strong>本地方法栈</strong></font> (Native Method Stack)</li>
<li><font color="#FFC000"><strong>程序计数器</strong></font> (Program Counter Registers)</li>
<li><font color="#FFC000"><strong>虚拟机栈</strong></font> (VM Stack，也有理解为 Java 方法栈的)</li>
</ul>
<p>底层：运行引擎 (Execution Engine)</p>
<ul>
<li>通过本地方法接口（Native Interfaces）与本地方法库（Native Libraries）交互</li>
</ul>
<p><img src="/2021/07/07/jvm-basics/jvm-overview.png" alt></p>
<p>JVM 在初始运行的时候，会分配好 <font color="#548235">Method Area</font>（方法区）和 <font color="#548235">Heap</font>（堆）；在为程序管理并分配内存的时候，每遇到一个线程，就会为其分配一个 <font color="#FFC000">Program Counter Register</font>（程序计数器），一个 <font color="#FFC000">Native Method Stack</font>（本地方法栈） 和一个 <font color="#FFC000">VM Stack</font>（虚拟机栈）。</p>
<ul>
<li>即：<strong>线程私有</strong>的三块（<font color="#FFC000">程序计数器</font>、<font color="#FFC000">本地方法栈</font>和<font color="#FFC000">虚拟机栈</font>）区域的生命周期与 Java 程序中的某个所属线程相同；<strong>线程共享</strong>的<font color="#548235">方法区</font>和<font color="#548235">堆</font>与 Java 程序运行的生命周期相同。</li>
<li>所以：这也是系统垃圾回收只发生在线程共享的区域（大部分只发生在<strong>堆</strong>中）的原因。</li>
</ul>
<p>当线程终止时：线程私有的程序计数器、本地方法栈和虚拟机栈所占用的空间会被释放掉。</p>
<p><br></p>
<p>我们知道，计算机存储数据主要利用三个空间：<strong>寄存器</strong>、<strong>栈</strong>和<strong>堆</strong>。</p>
<ul>
<li>Java 不能直接控制和处理寄存器，只能操作栈空间和堆空间。</li>
<li>对于每一个运行在内存中的 Java 程序，Java 虚拟机都为其分配好相应的栈空间和堆空间。</li>
</ul>
<p>栈空间（Stack）：</p>
<ul>
<li>存储空间较小，不能存放大量的数据</li>
<li>JVM 将 Java 方法、基本类型的数据，以及对对象（包括数组和字符串）的引用存放在栈空间</li>
<li>存取数据效率高，仅次于寄存器</li>
<li>管理数据：先进后出（LIFO）</li>
</ul>
<p>堆空间（Heap）：</p>
<ul>
<li>存储数据的空间大，能存放大容量的数据（数组、字符串、对象等）</li>
<li>但存取数据的效率最低</li>
<li>在堆空间中，数据存放的位置随机分配</li>
</ul>
<p>注：以上 JVM 的<strong>静态内存储模型</strong>（JVM 内存模型）只是一种对内存的划分，只局限在 JVM 内存。</p>
<p><br></p>
<h2 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a><font color="#548235">线程共享区域</font></h2><p>包括<strong>方法区</strong>和<strong>堆</strong>。</p>
<p><img src="/2021/07/07/jvm-basics/jvm-shared.png" alt></p>
<h3 id="1-堆-Heap"><a href="#1-堆-Heap" class="headerlink" title="1. 堆 Heap"></a><strong><big>1. 堆 Heap</big></strong></h3><p>JVM 只有一个堆区，在 JVM 启动的时候被创建，被所有线程共享，更是垃圾回收的主要战场。</p>
<p>堆用于存储对象（包括数组，因为数组也是一种对象），是 JVM 的内存数据区。分为以下几个部分：</p>
<ul>
<li><strong>新生代</strong>（<code>YoungGen</code>, Y）<ul>
<li>= <code>Eden</code>(4/5) + <code>From Survivor</code>(S0, 1/10) + <code>To Survivor</code>(S1, 1/10)</li>
<li>Eden 空间不足时，存活的对象转移到 Survivor，两个 Survivor 区用于交换</li>
<li>JVM 每次只会使用 Eden 和其中一块 Survivor 来为对象服务，所以无论什么时候，总会有另一块 Survivor 是空闲着的</li>
<li>因此，新生代实际可用的内存空间为 9/10（即 90%）的新生代空间。</li>
</ul>
</li>
<li><strong>老年代</strong>（<code>OldGen</code>, O）<ul>
<li>存放生命周期长的对象</li>
</ul>
</li>
</ul>
<p>另：<strong>永久区</strong>（<code>PermGen</code>, P）</p>
<ul>
<li>存在于 Java 8 之前的 HotSpot 虚拟机中，其他类型 JVM 没有这个概念</li>
<li>从 Java 8 开始，PermGen 被取消，以 <strong>Metaspace 元空间</strong>代替</li>
<li>内存的永久保存区域，存放 Class 和 Meta 信息等，GC 时不清理。</li>
</ul>
<p>实际上，堆只保存对象实例的<strong>属性类型</strong>、<strong>属性值</strong>（多数在常量池中）、<strong>运行时数据</strong>和<strong>对象本身类型标记</strong>（在<a href="/2021/07/16/object-header">对象头</a>中）等，并不保存对象的方法（方法等保存在栈里）。</p>
<p>要注意的是，在创建一个对象的时候：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class a = <span class="keyword">new</span> Class();</span><br></pre></td></tr></table></figure><br>此时 a 叫<strong>实例</strong>，不能说 a 是对象。在这里，<strong>实例保存在栈中</strong>，指的是指向对象的<strong>指针</strong>；而<strong>对象则是保存在堆中</strong>。操作实例实际上是通过实例指针间接操作对象，且多个实例可以指向同一个对象。<br>因此 a 所指向的堆内存中的具体空间，才是对象。<br>对象实例在堆中被分配好之后，保存到实例中的是一个 4 字节的<strong>堆内存地址</strong>。</p>
<p>堆处于<strong>物理不连续</strong>的内存空间中，只要逻辑上连续即可。</p>
<p><br></p>
<h3 id="2-方法区-Method-Area"><a href="#2-方法区-Method-Area" class="headerlink" title="2. 方法区 Method Area"></a><strong><big>2. 方法区 Method Area</big></strong></h3><p>方法区是 JVM 的一个<strong>概念</strong>，不同的 JVM 会有不一样的具体实现，不同版本的 JDK 对应的 JVM 也会根据设计规范有不一样的实现。</p>
<p>对于每一个要加载的<strong>类型</strong>（类 Class、接口、枚举、注解），方法区存放的东西有很多，主要包括：</p>
<p><strong>1</strong>. Object Class Data（类的类定义数据，即类型信息），包括：</p>
<ul>
<li>类的类型（<code>class</code> / <code>interface</code>）</li>
<li>类的全限定名</li>
<li>类的直接父类的全限定名（接口和 <code>java.lang.Object</code> 除外：它们没有父类）</li>
<li>访问修饰符（<code>public</code> / <code>abstract</code> / <code>final</code>）</li>
<li>实现的接口的全限定名的有序列表</li>
<li>指向 ClassLoader 的引用：JVM 在动态链接的时候需要这个信息</li>
<li>指向 Class 实例的引用</li>
</ul>
<p><strong>2</strong>. 所有域（Field，又称字段、变量）信息，包括：</p>
<ul>
<li>域的名称</li>
<li>域的类型</li>
<li>域的修饰符（<code>public</code>, <code>private</code>, <code>protected</code>, <code>static</code>, <code>final</code>, <code>volatile</code>, <code>transient</code>）</li>
<li>以及所有域的声明顺序</li>
</ul>
<p><strong>3</strong>. 所有方法（Method）信息，包括：</p>
<ul>
<li>方法名称</li>
<li>方法返回类型，或 <code>void</code></li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法修饰符（<code>public</code>, <code>private</code>, <code>protected</code>, <code>static</code>, <code>final</code>, <code>synchronized</code>, <code>native</code>, <code>abstract</code>）</li>
<li>方法的字节码、局部变量表及大小、操作数栈及大小（抽象方法和本地方法 native method 除外）</li>
<li>方法异常表（抽象方法和本地方法 native method 除外）：记录了每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
<li>以及所有方法的声明顺序</li>
</ul>
<p><strong>4</strong>. 即时编译器 JIT 编译后的代码缓存（CodeCache）</p>
<p>Java 6 及之前版本的 JVM 方法区还包括：</p>
<ul>
<li><a href="/2021/07/18/constant-pool">常量池</a>（Java 6 及之前版本）</li>
<li>除常量外的静态变量（Java 6 及之前版本）</li>
</ul>
<p>从 Java 7 开始，它们就被放进堆里面了。</p>
<p><br></p>
<p>和堆一样，方法区可以由不连续的区域组成，并且可以设置固定大小，也可设置为可扩展。</p>
<p>方法区的大小决定了系统<strong>可以保存多少个类</strong>，如果类太多导致方法区溢出，则会抛出异常：  </p>
<ul>
<li>Until Java 7：<code>java.lang.OutOfMemoryError: PermGen Space</code></li>
<li>Since Java 8：<code>java.lang.OutOfMemoryError: Metaspace</code></li>
</ul>
<p>正是因为方法区所存储的数据与堆有一种类比关系，而且方法区不属于堆的一部分，所以也被称为“非堆” No-Heap。<br>正因为方法区不属于堆，所以它很少会触发垃圾回收，发生内存回收的目的主要是针对<strong>常量池的回收</strong>和<strong>类的卸载</strong>。</p>
<p><img src="/2021/07/07/jvm-basics/method-area.png" alt></p>
<p><strong><big>随 JDK 版本变迁的方法区实现（对于 HotSpot 虚拟机而言）</big></strong></p>
<ul>
<li>Until Java 6：PermGen 被分配在 JVM 堆中，与堆相互隔离，大小在启动 JVM 时固定</li>
<li>Java 7：将 PermGen 中的静态变量、字符串常量池等移到堆中，其他不变<ul>
<li>原因：开发中会有大量字符串创建，PermGen 永久区回收效率低，容易导致内存不足。</li>
</ul>
</li>
<li>Since Java 8：取消 PermGen，改为 Metaspace（元空间，顾名思义，即存储类相关的<strong>元数据</strong>）实现，与堆共同分配在本地内存（使用本地内存），大小可以动态调整。</li>
</ul>
<p><img src="/2021/07/07/jvm-basics/jvm-shared-6.png" alt></p>
<p><img src="/2021/07/07/jvm-basics/jvm-shared-7.png" alt></p>
<p><img src="/2021/07/07/jvm-basics/jvm-shared-8.png" alt></p>
<p>元空间和永久区最大的区别是：元空间不存在虚拟机设置的内存中，而是直接使用<strong>本地内存</strong>。</p>
<ul>
<li>好处：64 位的系统就能取很大的内存，基本上杜绝了方法区溢出；如果还报 <code>OutOfMemoryError</code>，那就是启动的时候设置得太小。</li>
</ul>
<p>Java 8 使用元空间替换 Java 7 及以前的永久区的原因：</p>
<ol>
<li>设置的永久区空间大小，不太好确定，更容易遇到内存溢出的问题</li>
<li>垃圾回收的时候会扫描永久区：耗时</li>
<li>而且对永久区的调优是比较困难的</li>
<li>HotSpot 为了能与 Oracle JRockit（没有永久区）合并而做的改动</li>
</ol>
<p><br><br><br></p>
<h2 id="线程私有区域"><a href="#线程私有区域" class="headerlink" title="线程私有区域"></a><font color="#FFC000">线程私有区域</font></h2><p>包括<strong>程序计数器</strong>、<strong>本地方法栈</strong>和<strong>虚拟机栈</strong>。</p>
<p><strong><big>1. 程序计数器 Program Counter Register</big></strong></p>
<p>存储当前线程下一条需要执行的 JVM 字节码指令的地址</p>
<ul>
<li>字节码的<strong>行号位置指示器</strong>，类似于操作系统的计数器</li>
<li>指示执行哪条指令、分支、循环、跳转、异常等情况，以及线程恢复等基础功能均依赖其指示来实现；</li>
<li>由于 Java 多线程由时间片轮转实现，因此每个线程私有程序计数器，以便切换后线程内的代码能恢复执行；</li>
<li>比较小，是唯一没有规定 OOM 的区域。</li>
</ul>
<p>native 方法的字节码是空的，因此不会存储在程序计数器中。</p>
<p><strong><big>2. 虚拟机栈 VM Stack</big></strong></p>
<p>又叫<strong>栈</strong>内存。线程创建时被创建，线程结束后，内存就被释放。有的翻译会译作“Java 方法栈”的，大概是因为它描述的是 Java <strong>方法执行</strong>时的内存模型。</p>
<p>我们都知道，Java 指令是由<strong>操作码</strong>（方法本身）和<strong>操作数</strong>（方法内部变量）组成的。<br>操作码保存在栈内存中；而操作数跟在操作码之后，具体有<strong>两种</strong>：基本类型变量保存在栈中；对象类型变量将地址保存在栈中，将值保存在堆中。</p>
<p>也就是说，Java 对象<strong>方法本身</strong>、<strong>基本类型变量</strong>和<strong>对象地址</strong>都存储在虚拟机栈里。</p>
<ul>
<li>每个方法开始执行时创建栈帧（stack frame），压入虚拟机栈；执行结束时栈帧出栈<ul>
<li>返回至返回地址（Return Address，即指针）</li>
<li>每个<strong>方法使用时才会被压入栈</strong>，方法不被使用时则不占用内存</li>
<li>栈顶对应于<strong>正在执行</strong>的方法</li>
</ul>
</li>
<li>每个栈帧对应于一个方法名，就是一个方法的内存模型<ul>
<li>包括 main() 方法：main 栈帧</li>
<li>栈帧中只保存原生数据类型（primitive）和对对象的引用（reference）</li>
</ul>
</li>
<li>考虑到可能的多线程环境，虚拟机栈是每个线程<strong>私有</strong>的</li>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，则抛出 <code>StackOverflowError</code>。</li>
</ul>
<p>注意区分：<font color="#548235">方法区</font>存储的是<strong>常量和静态变量</strong>，而<font color="#FFC000">栈</font>存储的是<strong>方法内部（局部）变量</strong>，即：类的方法是该类的所有对象共享的，而类的成员变量在不同对象中各不相同。</p>
<p>每个虚拟机栈的栈帧存储了：</p>
<p><strong>a. 局部变量表 Local Variables</strong></p>
<ul>
<li>是一个以一个字节长度（8 bits）为单位、从 0 开始计数的<strong>数组</strong><ul>
<li>数组可以通过 index 索引访问</li>
<li>数组的每一行被称为<strong>槽位</strong>（Slot）</li>
</ul>
</li>
<li>存放了编译期可知（作用域）的各种基本数据类型，以及对象的引用</li>
<li><code>short</code>、<code>byte</code>、<code>char</code> 和 <code>boolean</code> 等类型变量值在存入该数组前要被转换成 <strong><code>int</code></strong> 值</li>
<li>而 <code>long</code> 和 <code>double</code> 因为在数组中会占据连续的两项，即两个槽位：<ul>
<li>在访问局部变量中的 <code>long</code> 或 <code>double</code> 时，只需取出连续两项的第一项的索引值即可</li>
<li>即：如某个 <code>long</code> 值在局部变量区中占据的索引为 3、4 项，取值时指令只需取索引为 3 的 <code>long</code> 值即可</li>
</ul>
</li>
<li>其内存空间在编译期完成分配，运行时也不会被改变</li>
</ul>
<p>局部变量表的每一个槽位是可以被复用的，称为<strong>槽位复用</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  <span class="comment">// a 和 b 分别位列不同的槽位中</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  <span class="comment">// a 超过了作用域，失效了；b 复用了 a 的槽位，达到了节省资源的目的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>b. 操作数栈 Operand Stack</strong></p>
<ul>
<li>结构与局部变量表一致，但顾名思义，对它的访问是通过 push 和 pop 操作来进行的，而不是通过索引；</li>
<li>可以被看成是栈帧所对应的方法的计算过程中，<strong>数据的临时存储区域</strong>，可以保存中间结果</li>
</ul>
<p><strong>c. 帧数据 Frame Data</strong>，包括：</p>
<ul>
<li>解析方法内引用的常量池中的数据</li>
<li>保存动态链接（指向下一条字节码指令的地址）</li>
<li>保存方法出口，用于方法执行完后返回，恢复调用方的现场</li>
<li>保存异常表，用于方法执行过程中抛出异常时的异常处理<ul>
<li>当出现异常时，虚拟机查找相对应的异常表看是否有对应的 catch 语句</li>
<li>如没有就抛出异常终止该方法调用</li>
</ul>
</li>
</ul>
<p><strong><big>3. 本地方法栈 Native Method Stack</big></strong></p>
<ul>
<li>与虚拟机栈作用类似</li>
<li>区别在于：虚拟机栈为 JVM 提供执行 Java 方法的服务，而本地方法栈则是为 JVM 提供执行 native 方法的服务</li>
</ul>
<p><br></p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackFrameTest test = <span class="keyword">new</span> StackFrameTest();</span><br><span class="line">        test.method1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1 i = &quot;</span> + i);</span><br><span class="line">        method2(i, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2 i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">        method3(i, j, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3 i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j + <span class="string">&quot;, x = &quot;</span> + x);</span><br><span class="line">        method4(i, j, x, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3 i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j + <span class="string">&quot;, x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>执行 main() 方法时，对应栈帧的变量表、操作数栈、帧数据的变化，以及程序计数器、本地方法栈等如下图：</li>
</ul>
<p><img src="/2021/07/07/jvm-basics/vm-stack.png" alt></p>
<p><br></p>
<h1 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h1><p><img src="/2021/07/07/jvm-basics/memory-allocate.png" alt></p>
<p><img src="/2021/07/07/jvm-basics/object-allocate.png" alt></p>
<p>注：</p>
<ul>
<li>指针碰撞（Bump the Pointer）：Java 堆的内存<strong>绝对规整</strong>，所有用过的内存放一边，空闲的放另一边，中间保留一个指针作为分界点的指示器。在这个策略下，<strong>指示指针向靠近空闲内存方向挪动一段空间，该空间的距离与对象大小相等</strong>，这就是给对象分配的内存。</li>
<li>空闲列表（Free List）：Java 堆中内存<strong>不规整</strong>，已使用内存与空闲内存犬牙交错。JVM 通过维护一个列表，记录可用的内存块；在分配内存的时候从列表中取一块足够大的空间划分给实例，并更新列表。</li>
<li>系统如果使用了基于<font color="red">压缩（Compact）</font>算法的垃圾收集器，与之相匹配的内存分配策略是<font color="red">指针碰撞</font>；如果是基于<font color="blue">清理（Sweep）</font>算法的话，则对应采用<font color="blue">空闲列表</font>策略。</li>
</ul>
<p><br></p>
<p>内存分配规则<strong>并不是百分百固定的</strong>，其细节取决于当前使用的是哪一种垃圾回收器组合，以及 JVM 的参数配置。<br>大多数情况下，对象在 Eden 区分配，少数情况（如大对象）直接分配到老年代（视垃圾回收器的类型而定）。<br>然而，并不是所有的对象都会直接被分配到堆上。上述对 Java 对象分配的过程分析中，可以知道有另外两个地方：<strong>栈</strong>（与逃逸分析相关）和 <strong>TLAB</strong> 也是可以保存对象的。</p>
<h2 id="逃逸分析（Escape-Analysis）浅析"><a href="#逃逸分析（Escape-Analysis）浅析" class="headerlink" title="逃逸分析（Escape Analysis）浅析"></a>逃逸分析（Escape Analysis）浅析</h2><p>逃逸分析是 Java HotSpot 虚拟机能够分析新创建对象的使用范围，并决定是否要在 Java 堆上分配内存的一项技术（结合连通图做可达性分析）。</p>
<p>当一个对象被定义了之后，通过分析它的动态作用域，可以知道它的逃逸状态：</p>
<ol>
<li>全局逃逸：对象作用范围逃出了当前方法或当前线程，包括以下情况：<ol>
<li>对象是一个<strong>静态变量</strong></li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象为当前方法的<strong>返回值</strong></li>
</ol>
</li>
<li>参数逃逸：一个对象被作为方法参数传递或者被参数引用<ol>
<li>但在调用过程中（方法里面）不会发生全局逃逸</li>
<li>对象的状态由被调方法的字节码确定</li>
</ol>
</li>
<li>没有逃逸</li>
</ol>
<p>简单来说：不在作用域了，就会被视为逃逸。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();  <span class="comment">// 逃逸了的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Gc5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Student student = new Student();  // 没有逃逸</span></span><br><span class="line">    Gc1();</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个对象<strong>没有逃逸</strong>时，Java HotSpot 虚拟机可对其进行以下优化：</p>
<ol>
<li><strong>锁消除</strong>：编译器确定当前对象只有被当前线程使用，不会被外部访问的时候，会移除该对象的同步锁<ul>
<li>在这个对象上的操作可以不需要同步锁</li>
<li>如：移除当前线程的 StringBuffer 的同步锁</li>
</ul>
</li>
<li><strong>分离对象或标量替换</strong>：将聚合量（对象）打散、分解成标量（基本数据类型），将其成员变量分解为分散的变量<ul>
<li>如一个对象没有发生逃逸，此时该对象的部分可以不存储在内存，而是存储在寄存器中，节省内存空间</li>
</ul>
</li>
<li><strong>将对象分配在栈上</strong></li>
</ol>
<p>最大的好处：通常的应用中，没有逃逸的局部对象占的比例很大。如果使用栈上分配，大量对象会随着方法的结束（栈帧出栈）自动销毁，不用走 GC 了，大大减小了垃圾回收的负荷。</p>
<h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><p>全称为 <strong>Thread Local Allocation Buffer</strong>，线程本地分配缓存区，是线程专用的内存分配区域。</p>
<p>背景：多个线程在堆上申请空间，如果每次对象分配都必须进行同步（CAS + 失败重试保证操作原子性），当竞争激烈的时候，内存分配的效率会进一步下降。<br>因此 JVM 为每个 Java 线程在 <strong>Eden 区</strong>划出一块内存（仅占 Eden 空间的 1%）作为 TLAB，每个线程使用自己的 TLAB，在避免线程同步，发生冲突的同时提升了对象分配的效率。</p>
<p><br></p>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><p>JVM 的运行模式主要有两种：<strong>Client</strong> 和 <strong>Server</strong>。</p>
<p>Client 模式启动快，但是进入稳定期后运行速度不如 Server 快。</p>
<p>Server 启动慢，进入稳定期后运行速度优于 Client。Server 模式采用的是重量级的虚拟机，对程序会进行更多的优化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">raymond-mbp:~ aohuijun$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_161&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列与其实现</title>
    <url>/2021/07/20/mq/</url>
    <content><![CDATA[<p>消息队列是中间件的一种，是分布式系统中非常重要的组件。</p>
<span id="more"></span>
<p>消息队列（Message Queue, <strong>MQ</strong>）的通用场景可简单描述为：</p>
<pre><code>当不需要立即获得结果，但是又需要对并发量进行控制的时候。
</code></pre><p>消息队列是生产者-消费者模型的典型代表；除了实现高性能、高可用、可伸缩和最终一致性架构之外，还除去了接收和发送应用程序同时执行的要求。</p>
<p><br></p>
<h1 id="消息队列的消息传播模式"><a href="#消息队列的消息传播模式" class="headerlink" title="消息队列的消息传播模式"></a>消息队列的消息传播模式</h1><p><strong>推</strong>（<strong>push</strong>）模式：服务器主动将信息送到客户端</p>
<p>优点：</p>
<ul>
<li>对用户要求低，方便用户获取需要的信息</li>
<li>即时性好，服务器端及时向客户端推送更新的动态信息</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能确保发送成功<ul>
<li>push 采用广播方式，只有服务器端和客户端在同一频道上，推模式才有效，用户才能接收到信息</li>
</ul>
</li>
<li>没有信息状态跟踪<ul>
<li>push 采用开环控制技术，一个消息推送后的状态，如客户端是否接收等无从得知，针对性较差</li>
<li>推送的消息可能并不满足客户端的个性化需求</li>
</ul>
</li>
</ul>
<p><strong>拉</strong>（<strong>pull</strong>）模式：客户端主动发起获取信息</p>
<ul>
<li>该模式下消息不是自动推送给消费者（客户端）的，而是由消费者主动从队列中请求获得</li>
<li>如没有消费者在监听队列，消息将保留在队列中，直至消费者连接到队列，取到信息为止</li>
</ul>
<p>优点：</p>
<ul>
<li>针对性强，满足客户端个性化需求</li>
<li>信息传输量相对较小：网络中传输的只是客户端的请求和服务器端对请求的响应</li>
<li>服务器端任务轻：只是被动接受查询，对客户端的查询请求作出响应</li>
</ul>
<p>缺点：</p>
<ul>
<li>实时性差，针对服务器端实时更新的信息，客户端难以获取实时信息</li>
<li>对于客户端用户的要求较高，需要对服务器端具有一定的了解</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>消息队列的实现主要包括两种：<strong>AMQP</strong> 和 <strong>JMS</strong></p>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>全称 Advanced Message Queuing Protocol，高级消息队列协议，是计网中应用层协议的一个开放标准。<br>AMQP 是 <a href="/2021/07/21/rabbitmq/">RabbitMQ</a> 的基础，也是其所实现的其他协议的鼻祖。</p>
<p><strong>主要组件</strong>：</p>
<ol>
<li>交换器 Exchange</li>
<li>队列 Queue：消息（message）的载体</li>
<li>绑定 Binding：决定交换器将信息投递到队列的规则</li>
</ol>
<p><strong>基本模型</strong>：</p>
<p><img src="/2021/07/20/mq/amqp.webp" alt></p>
<ol>
<li>消息发布者（生产者，Publisher）利用接口，将消息发布（publish）到 Exchange 中<ul>
<li>消息一般包含消息体（payload）和标签（label）等信息</li>
</ul>
</li>
<li>消息订阅者（消费者，Consumer）利用接口创建 Queue，并绑定到 Exchange，接收所期望的消息</li>
<li>Exchange 会按照一定的路由规则（由 RoutingKey 定义）确定各种绑定（BindingKey 定义），将消息分发至对应的 Queue</li>
<li>Consumer 发现 Queue 中有消息，就会将消息消耗（consume）掉<ul>
<li>消耗时只消费消息体，丢弃标签</li>
</ul>
</li>
</ol>
<p>综上可知，发布-订阅模型 可以利用 AMQP 实现：</p>
<ul>
<li>Publisher 为发布者（生产者）</li>
<li>Consumer 为订阅者（消费者）</li>
<li>AMQP 协议扮演消息代理（Message Broker）的角色：维护生产-消费路线，保证数据按照指定的方式进行传输<ul>
<li>Exchange, Bindings 和 Queues 合起来就是消息队列服务器实体，也就是 Broker</li>
</ul>
</li>
</ul>
<h3 id="Exchange-的类型"><a href="#Exchange-的类型" class="headerlink" title="Exchange 的类型"></a>Exchange 的类型</h3><p><strong>1. Direct Exchange</strong></p>
<ul>
<li>采用轮询方式发送至 <code>RoutingKey = BindingKey</code> 的 Queue，类似于<strong>点对点</strong></li>
<li>其他配对不上的 RoutingKey 的消息会被丢弃</li>
</ul>
<p><img src="/2021/07/20/mq/direct-exchange.png" alt></p>
<p><strong>2. Fanout Exchange</strong></p>
<ul>
<li>发送（route）至与该 Exchange 绑定的所有 Queue，类似于<strong>广播</strong></li>
<li>最快的转发</li>
</ul>
<p><img src="/2021/07/20/mq/fanout-exchange.png" alt></p>
<p><strong>3. Topic Exchange</strong></p>
<ul>
<li>发送至 RoutingKey 与 BindingKey <strong>模糊匹配</strong>的 Queue</li>
<li>模糊匹配约定如下：<ul>
<li>RoutingKey 为用<strong>点号</strong>（.）分隔的字符串，BindingKey 与其模式相同 </li>
<li>BindingKey 可使用 <code>*</code>（匹配一个单词）和 <code>#</code>（匹配多个或 0 个单词）用于模糊匹配</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/20/mq/topic-exchange.png" alt></p>
<p>如上图的模糊匹配，比如有下面不同的 RoutingKey：</p>
<ul>
<li><code>RoutingKey = F.C.E</code>：路由到 Queue1</li>
<li><code>RoutingKey = A.C.E</code>：路由到 Queue1 和 Queue2</li>
<li><code>RoutingKey = A.F.B</code>：路由到 Queue2</li>
</ul>
<p><strong>4. Headers Exchange</strong></p>
<ul>
<li>采用轮询方式</li>
<li>不依赖于 RoutingKey 和 BindingKey 的匹配规则，而是通过<strong>消息头</strong>订阅<ul>
<li>消息发布前为消息定义一个或多个键值对的消息头</li>
<li>消费者在接收消息的同时，需要定义类似的键值对请求头</li>
<li>请求头与消息头匹配才可接收消息</li>
</ul>
</li>
<li>和 Direct 方式完全一致，但性能差很多，基本用不到</li>
</ul>
<p><br></p>
<p>AMQP 的三层协议：</p>
<p><strong>Module Layer</strong>：协议最高层</p>
<ul>
<li>主要定义一些客户端调用的命令</li>
<li>客户端可用这些命令实现自己的业务逻辑</li>
</ul>
<p><strong>Session Layer</strong>：中间层</p>
<ul>
<li>主要负责将客户端命令发送给服务器，再将服务端的 response 返回客户端</li>
<li>提供可靠性同步机制和错误处理</li>
</ul>
<p><strong>Transport Layer</strong>：最底层</p>
<ul>
<li>主要传输二进制数据流</li>
<li>提供帧的处理、信道复用、错误检测和数据表示等</li>
</ul>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>全称 Java Message Service，Java 消息服务，是 Java 平台中关于“面向消息中间件（MOM）”的技术规范。</p>
<ul>
<li>具体来说，JMS 是一个与具体平台无关的 API</li>
<li>绝大多数 MOM 提供商都对 JMS 提供支持</li>
<li>用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信</li>
</ul>
<p>JMS 规范目前支持两种消息模型：</p>
<p><strong>1</strong>. <strong>点对点</strong>（point to point, <strong>queue</strong>）：不可重复消费</p>
<ul>
<li>消息生产者生产消息发送到 queue 中，然后消息消费者从 queue 中取出并且消费消息</li>
<li>消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息</li>
<li>Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费</li>
</ul>
<p><img src="/2021/07/20/mq/jms-p2p.png" alt></p>
<p><strong>2</strong>. <strong>发布/订阅</strong>（publish/subscribe, <strong>topic</strong>）：可重复消费</p>
<ul>
<li>消息生产者将信息<strong>发布</strong>到 topic 中，同时有多个消息消费者消费（<strong>订阅</strong>）该消息</li>
<li>和点对点方式不同，发布到 topic 的消息会被<strong>所有</strong>订阅者消费</li>
</ul>
<p><img src="/2021/07/20/mq/jms-ps.png" alt></p>
<p>另：<strong>订阅组发布/订阅模式</strong>：</p>
<ul>
<li>发布/订阅模式下，当发布者消息量很大时，显然<strong>单个订阅者的处理能力是不足的</strong></li>
<li>更加现实的场景是：多个订阅者节点组成一个订阅组，负载均衡地消费 topic 消息，即分组订阅</li>
<li>可看成是一个 topic 下有多个 Queue，每个 Queue 是点对点的方式，Queue之间是发布/订阅方式。</li>
<li>这样订阅者很容易实现消费能力线性扩展</li>
</ul>
<p><img src="/2021/07/20/mq/jms-psg.png" alt></p>
<p>JMS 编程接口：</p>
<p><img src="/2021/07/20/mq/jms-api.png" alt></p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">JMS</th>
<th style="text-align:left">AMQP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">定义</td>
<td style="text-align:left">Java API</td>
<td style="text-align:left">协议</td>
</tr>
<tr>
<td style="text-align:left">跨语言</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">跨平台</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">模型</td>
<td style="text-align:left">2 + 1 种消息模型</td>
<td style="text-align:left">5 种消息模型</td>
</tr>
<tr>
<td style="text-align:left">支持消息类型</td>
<td style="text-align:left">多种</td>
<td style="text-align:left">byte[]</td>
</tr>
</tbody>
</table>
</div>
<p>JMS 提供的最主流的开源技术是 Apache ActiveMQ。</p>
<p><br></p>
<h1 id="选型依据"><a href="#选型依据" class="headerlink" title="选型依据"></a>选型依据</h1><p>生产环境使用较多的消息队列：ActiveMQ, <a href="/2021/07/21/rabbitmq/">RabbitMQ</a>, Kafka, RocketMQ, MetalMQ, ZeroMQ 等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">ActiveMQ</th>
<th style="text-align:center">RabbitMQ</th>
<th style="text-align:center">RocketMQ</th>
<th style="text-align:center">Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单机吞吐量</td>
<td style="text-align:center">万级，比 RocketMQ, Kafka 低一个数量级</td>
<td style="text-align:center">同 ActiveMQ</td>
<td style="text-align:center">10 万级，支撑高吞吐</td>
<td style="text-align:center">10 万级，高吞吐，一般配合大数据类的系统进行实时数据运算、日志采集等场景</td>
</tr>
<tr>
<td style="text-align:center">topic 数量对吞吐量的影响</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">topic 可达到几百/几千级别，吞吐量会有较小幅度下降 RocketMQ 优势：同等机器下可支撑大量 topic</td>
<td style="text-align:center">topic 从几十到几百时，吞吐量大幅下降，同等机器下 Kafka 尽量保证 topic 数量不要过多，如要支撑大规模 topic，需要增加更多机器资源</td>
</tr>
<tr>
<td style="text-align:center">时效性</td>
<td style="text-align:center">毫秒级</td>
<td style="text-align:center">微秒级，延迟最低（特点之一）</td>
<td style="text-align:center">毫秒级</td>
<td style="text-align:center">毫秒级</td>
</tr>
<tr>
<td style="text-align:center">可用性</td>
<td style="text-align:center">高，基于主从架构实现高可用</td>
<td style="text-align:center">同 ActiveMQ</td>
<td style="text-align:center">非常高，分布式架构</td>
<td style="text-align:center">非常高，分布式架构，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td style="text-align:center">消息可靠性</td>
<td style="text-align:center">有较低的概率丢失数据</td>
<td style="text-align:center">基本不丢</td>
<td style="text-align:center">经过参数优化配置可做到 0 丢失</td>
<td style="text-align:center">同 RocketMQ</td>
</tr>
<tr>
<td style="text-align:center">功能支持</td>
<td style="text-align:center">MQ 领域的功能极其完备</td>
<td style="text-align:center">基于 erlang 开发，并发能力极强，性能极好，延迟很低</td>
<td style="text-align:center">MQ 功能较为完善，还是分布式的，扩展性好</td>
<td style="text-align:center">功能较为简单，主要支持简单的 MQ 功能，在大数据领域实时计算以及日志采集被大规模采用</td>
</tr>
<tr>
<td style="text-align:center">优点</td>
<td style="text-align:center"></td>
<td style="text-align:center">轻量，迅捷，容易部署和使用，拥有灵活的路由配置</td>
<td style="text-align:center">性能好，稳定可靠，有活跃的中文社区，特点响应快</td>
<td style="text-align:center">拥有强大的性能及吞吐量，兼容性很好</td>
</tr>
<tr>
<td style="text-align:center">缺点</td>
<td style="text-align:center"></td>
<td style="text-align:center">性能和吞吐量较差，不易进行二次开发</td>
<td style="text-align:center">兼容性较差；但随意影响力的扩大，该问题会有改善</td>
<td style="text-align:center">延迟较高</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>消息队列的<strong>优点</strong>在于能够实现<strong>异步</strong>、<strong>解耦</strong>、流量<strong>削峰填谷</strong>，能解决相关特殊业务场景的问题。</p>
<p>而<strong>缺点</strong>在于其系统<strong>可用性</strong>较为敏感，万一 MQ 崩溃了，系统依靠它的相当一部分的功能会无法响应。<br>而且，消息队列提高了系统<strong>复杂性</strong>，需要考虑一些消息队列的常见问题和解决方案。<br>此外，消息队列还会带来一些<strong>一致性</strong>问题：</p>
<ul>
<li>多个消费者中，如果其中一个消费失败，会导致数据不一致的情况</li>
<li>带来消息重复消费、消息积压、消息顺序和消息事务的问题</li>
</ul>
<h2 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h2><p>根据队列结构来看，无非就是三种情况：</p>
<ol>
<li>生产者弄丢数据<ul>
<li>主流 MQ 都有确认机制或事务机制，可保证生产者将消息送达 MQ。如：<a href="/2021/07/21/rabbitmq/#消息确认机制">RabbitMQ</a> 就有事务模式和 confirm 模式；</li>
</ul>
</li>
<li>消息队列弄丢数据<ul>
<li>开启 MQ 的持久化磁盘配置；</li>
</ul>
</li>
<li>消费者弄丢数据<ul>
<li>一般是因为采用了自动确认消息模式，此时 MQ 收到消费者的确认消息后会删除消息；</li>
<li>如果发送确认信息之后消费者发生异常，导致消息操作没执行完，想再次消费消息就没了。</li>
<li>改用<strong>手动确认</strong>就能解决</li>
</ul>
</li>
</ol>
<h2 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h2><p>通常由网络原因造成。</p>
<p>正常情况：</p>
<ol>
<li>消息被成功消费后，消费者发送成功标志给 MQ</li>
<li>MQ 收到标志后，表示消息被成功消费，不会再将消息发送给其他消费者</li>
</ol>
<p>出问题的情况：</p>
<ol>
<li>因网络出现问题，成功标志在传输过程中丢失</li>
<li>MQ 没接收到该标志，认为该消息没有被成功消费</li>
<li>因此 MQ 会再次发送该消息给其他消费者，造成重复消费</li>
</ol>
<p><strong>解决方法</strong>：根据去重的原理，保证消费端幂等性</p>
<p>方法 1：</p>
<ul>
<li>每个消息生成一个 id</li>
<li>在第三方介质（如 Redis set）中准备类似于键值对的组合 <code>&lt;消息 id, 消息&gt;</code></li>
<li>开始消费前，在介质中查询有无该记录；如果存在该记录，说明已经发送过该消息，发送端就不再发送了</li>
</ul>
<p>方法 2 是方法 1 的升级，也是更常用的方法:</p>
<ul>
<li>生产消息时生成<strong>描述消息的 id</strong></li>
<li>组建消息体时针对业务，生成唯一的<strong>业务标识 buzId</strong></li>
<li>传输的时候判定两者是否均是唯一</li>
</ul>
<p>方法 3：针对数据库的插入操作</p>
<ul>
<li>以消息 id 等标识作为<strong>唯一主键</strong>或其它的<strong>唯一性约束</strong>，如果发生了重复消费，插入数据的时候会主键冲突</li>
</ul>
<h3 id="如何处理消费过程中的重复消息"><a href="#如何处理消费过程中的重复消息" class="headerlink" title="如何处理消费过程中的重复消息"></a>如何处理消费过程中的重复消息</h3><p>MQTT 协议给出了三种传递消息时能够提供的服务质量标准，从低到高依次是：</p>
<ul>
<li><strong>At most once</strong>: 消息在传递时，最多会被送达一次。也就是说没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</li>
<li><strong>At least once</strong>: 消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。</li>
<li><strong>Exactly once</strong>：消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。</li>
</ul>
<h2 id="消息积压问题"><a href="#消息积压问题" class="headerlink" title="消息积压问题"></a>消息积压问题</h2><p>有的时候，消息在 Broker 上大量堆积，无法被消费者及时消费，产生堆积的情况。</p>
<p>常见于以下几种情况：</p>
<ol>
<li>消费者功能存在 bug，消息无法被消费；</li>
<li>消费者实例宕机或因网络问题暂时无法与 Broker 建立连接；</li>
<li>生产者短时间内推送大量消息到 Broker，消费能力不足；</li>
<li>生产者未感知 Broker 消费堆积，而持续向 Broker 推送消息</li>
</ol>
<p>避免和解决问题的思路：</p>
<ol>
<li><strong>灰度发布</strong>。选取一定比例的消费实例做灰度，若出现问题，及时回滚；若消费者消费正常，平稳运行一段时间后，再升级其它实例。</li>
<li><strong>多活</strong>。</li>
<li><strong>增强消费能力</strong>。增加消费者线程数或者增加消费者实例个数。</li>
<li>一旦积压情况发生，要做好<strong>熔断与隔离</strong>，将新消息发送到其它队列。</li>
</ol>
<h3 id="检测消息丢失的方法"><a href="#检测消息丢失的方法" class="headerlink" title="检测消息丢失的方法"></a>检测消息丢失的方法</h3><p>可以利用消息队列的<strong>有序性</strong>来验证是否有消息丢失：<br>在 Producer 端给每个发出的消息附加一个<strong>连续递增的序号</strong>，然后在 Consumer 端来检查这个序号的连续性。</p>
<h2 id="消息顺序问题"><a href="#消息顺序问题" class="headerlink" title="消息顺序问题"></a>消息顺序问题</h2><p>常见的场景：电商平台的下单操作，下单后先减库存，然后生成订单</p>
<ul>
<li>首先生产者需要保证入队的顺序，比如<strong>一个 queue 只对应一个消费者</strong>；</li>
<li>另外，发送消息时对消息通过 hash 取模，确保同一操作的消息发送到同一个队列中<ul>
<li>一般的 MQ 中同一个队列都能保证 FIFO，由此确保出队时是顺序的</li>
</ul>
</li>
</ul>
<p>不过，如果多个消费者同时消费一个队列，一样可能出现顺序错乱的情况；<br>这时需要使用重试机制，根据期望的顺序，如果所期望的消息还未被消费，就重试等待。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>消息队列广泛应用于应用程序之间的通信方法，其应用场景包括：解耦、异步消息、流量削锋等问题。</p>
<p>消息延迟推送应用：</p>
<p><strong>1</strong>. 淘宝七天自动确认收货</p>
<ul>
<li>签收后，物流系统在七天后延时发送一个消息给支付系统，通知支付系统七天后将款项打给商家。</li>
</ul>
<p><strong>2</strong>. 12306 购票支付确认界面</p>
<ul>
<li>选好票点击确定跳转的页面往往会有倒计时</li>
<li>如 30 分钟内订单不确认将自动取消订单</li>
<li>如 30 分钟内完成订单，则根据逻辑代码确定忽略接收到的延时信息。</li>
</ul>
<p><br></p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://juejin.cn/post/7100506153137897480">八股文之MQ</a></p>
]]></content>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList 源码浅析</title>
    <url>/2021/06/12/linkedlist/</url>
    <content><![CDATA[<p>LinkedList 是 Collection 接口下对 List 的双向链表实现。</p>
<span id="more"></span>
<p>概述：</p>
<ul>
<li>同时实现了 <code>List</code> 接口和 <code>Deque</code> 接口</li>
<li>每次插入时可选择链表头或链表尾插入</li>
<li>读取时需从链式结构逐个遍历，删除则为断链-重链过程</li>
<li>非线程安全</li>
</ul>
<p>与 ArrayList 相比：</p>
<ul>
<li>优势：不需要预估容量及动态扩容，每次新增只需要新增一个链上的节点。</li>
<li>代价：遍历时需从链上逐个遍历，不支持随机访问。</li>
</ul>
<p><br></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;  <span class="comment">// 无参空构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);  <span class="comment">// 将集合所有元素添加进链表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="链表节点的数据结构"><a href="#链表节点的数据结构" class="headerlink" title="链表节点的数据结构"></a>链表节点的数据结构</h1><p>Java 中所有链表的实现均为双向链接：每个节点还存放着指向前驱节点的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 节点元素</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 后置节点指针</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前置节点指针</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表与泛型集合的区别：</p>
<p>链表为有序集合，每个对象的位置十分重要</p>
<ul>
<li>将元素添加至链表中间时，需要依赖链表的位置；而迭代器负责描述集合中位置</li>
<li>即：LinkedList.add() 由迭代器负责（只有对自然有序的集合使用迭代器添加元素才有实际意义）</li>
</ul>
<p>集合类库提供子接口 ListIterator，包含 add()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;    <span class="comment">// 其假定总能添加成功</span></span><br><span class="line">    <span class="comment">// 该方法不返回 boolean 值，与 Collection.add() 不同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为反向遍历链表的方法</span></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;    <span class="comment">// 返回越过的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素（尾插）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1: e = &quot;a1&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);  <span class="comment">// 尾插法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素 e 至链表尾部，作为其最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1: e = &quot;a1&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eg1: newNode     null&lt;--&quot;a1&quot;--&gt;null</span></span><br><span class="line">    <span class="comment">/* 创建一个值为 e 的 Node 节点，前置节点（prev）指向原 last 节点，后置节点（next）指向 null */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 LinkedList 维护的 last 节点指针指向至 newNode 节点 */</span></span><br><span class="line">    last = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eg1: l = null</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果是第一个添加的元素，则 first 指针指向该节点 */</span></span><br><span class="line">        first = newNode; <span class="comment">// eg1: first 指向 newNode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 如果不是第一个添加进来的元素，则更新 l 的后置节点指向新添加的元素节点 newNode */</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：elementData 中保存了 &#123;&quot;a1&quot;,&quot;a2&quot;,&quot;a3&quot;,&quot;a4&quot;&#125;，删除第一个元素，即：index = 0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 校验传入的参数 index 是否超出数组最大下标，且下标不为负数，如超出则抛出 IndexOutOfBoundsException 异常 */</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// eg1：node(index) 返回需要删除的节点，即：&quot;a1&quot;</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index)); <span class="comment">/* 断开与待删除节点的链接 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从链表中删除 x 节点的链接，并返回被删除的节点的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：x   null&lt;--&quot;a1&quot;--&gt;&quot;a2&quot;</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* x.prev 为 null，表示 x 节点为第一个元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;  <span class="comment">// 将 first 头指针改为指向 x 节点的后置节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 不是第一个 */</span></span><br><span class="line">        prev.next = next;  <span class="comment">// 将 x 的前置节点指向 x 的后置节点</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;  <span class="comment">// 断开 x 的前置指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* x.next 为 null，表示 x 节点为最后一个元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;  <span class="comment">// 将 last 尾指针改为指向 x 节点的前置节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 不是最后一个 */</span></span><br><span class="line">        next.prev = prev;  <span class="comment">// 将 x 的后置节点指向 x 的前置节点</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;  <span class="comment">// 断开 x 的后置指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结如下：</p>
<p><img src="/2021/06/12/linkedlist/linkedlist-add.png" alt></p>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定下标 index 的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>删除元素和获取元素中重要的算法：<code>node(int index)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据传入的 index 值，返回对应节点 node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// eg1：index = 0</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如 index 小于总长度 size 的一半，则从头部开始向后遍历查找 */</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            x = x.next;  <span class="comment">// 从 first 节点向后（next）查找，直到 index，返回 node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 大于总长度一半：从尾部开始向前遍历查找 */</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            x = x.prev;  <span class="comment">// 从 last 节点向前（prev）查找，直到 index，返回 node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">// 效率相对低下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知 LinkedList 继承了链表获取元素方法的缺点：<strong>不支持快速随机访问</strong>，查询需要从头查起。</p>
<p><br></p>
<h2 id="迭代元素"><a href="#迭代元素" class="headerlink" title="迭代元素"></a>迭代元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">linkedList.listIterator(<span class="keyword">int</span> index);  <span class="comment">// 返回一个实现了 ListIterator 接口的迭代器对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>多次调用 <code>listIterator.add(element)</code>：元素被依次添加到迭代器当前位置之前</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 注：初始化迭代器时，如果 index 是链表最后一位（index == size）：next = null；</span></span><br><span class="line"><span class="comment"> 否则 next = (index 下标对应的节点)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        linkBefore(e, next);  <span class="comment">// 将 e 添加到 index 对应节点之前</span></span><br><span class="line">    &#125;</span><br><span class="line">    nextIndex++;</span><br><span class="line">    expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>n 个元素的链表有 n+1 个位置可以添加新元素</p>
</li>
</ul>
<h3 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h3><ol>
<li>调用 next() 之后，再调用 remove() 会删除迭代器左侧元素，调用 previous() 会删除其右侧元素（改变迭代器中 next 的状态）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastReturned = next;  <span class="comment">// 记录迭代器左侧元素（最后一个被迭代的元素）</span></span><br><span class="line">    next = next.next;  <span class="comment">// next 指针指向下一个元素</span></span><br><span class="line">    nextIndex++;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasPrevious()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：next 指针不会指向前一个元素</span></span><br><span class="line">    lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">    nextIndex--;  <span class="comment">// nextIndex 对应减 1</span></span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">    unlink(lastReturned);  <span class="comment">// 将迭代器左侧元素从 linkedList 中移除</span></span><br><span class="line">    <span class="keyword">if</span> (next == lastReturned) &#123;</span><br><span class="line">        next = lastNext;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>set()</code>：用新元素取代 next() 或 previous() 返回的上一个元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    lastReturned.item = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但链表只负责跟踪对链表的结构性修改，如添加元素、删除元素；set() 不被视为结构性修改。<br>故可以将多个迭代器附加给一个链表，所有迭代器都调用 set() 对现有结点内容进行修改。</p>
<p>不过，依据原理，列表迭代器可返回迭代器所在位置前后两元素的索引</p>
<ul>
<li><code>nextIndex()</code> 返回下一次调用 next() 时返回的元素索引</li>
<li><code>previousIndex()</code> 返回下一次调用 previous() 时返回的元素索引（比 nextIndex 小 1）</li>
</ul>
<p>多线程访问链表时，需处理好非线程安全的操作；否则会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<h1 id="ArrayList-v-s-LinkedList"><a href="#ArrayList-v-s-LinkedList" class="headerlink" title="ArrayList v.s. LinkedList"></a>ArrayList v.s. LinkedList</h1><p>ArrayList 实现了基于<strong>动态数组</strong>的数据结构，由 Array 支持，提供对元素的随机访问，复杂度为 O(1)。</p>
<p>LinkedList 使用<strong>双向链表</strong>实现存储（实现 List 和 Deque 接口），虽然有使用索引获取元素的方法，但按照序号索引数据的实现，需要进行前向或后向遍历，复杂度为 O(n)；<br>LinkedList 插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>因为采用了双向链表，所以 LinkedList 会消耗更多的内存。</p>
<h2 id="操作对比"><a href="#操作对比" class="headerlink" title="操作对比"></a>操作对比</h2><ol>
<li>查找操作 indexOf()，lastIndexOf()，contains() 的性能，两者差不多；</li>
<li>对于随机访问 get 和 set，ArrayList 优于 LinkedList，因为 LinkedList 操作时要移动指针；</li>
<li>而对于新增和删除操作 add 和 remove，LinkedList 比较占优势，因为 ArrayList 操作时要移动数据<ul>
<li>若只对单条数据插入或删除，ArrayList 的速度反而优于 LinkedList；</li>
<li>若随机插入批量数据，LinkedList 的速度则大大优于 ArrayList：因为ArrayList 每插入一条数据，要移动插入点及以后的所有数据。</li>
</ul>
</li>
</ol>
<p>实际应用中怎么选？</p>
<ul>
<li>如链表仅含几个元素，完全没必要为 set() 和 get() 开销而烦恼，完全可使用 ArrayList</li>
<li>优先使用链表的情况，应该是尽可能减少在列表中间插入或删除元素开销的场景中</li>
<li>注：动态数组中可能使用 Vector 类，但该类所有方法均为同步，开销大</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合类</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>非比较排序算法</title>
    <url>/2023/03/11/non-compare-sort/</url>
    <content><![CDATA[<p>聊了那么多基于比较的排序算法，咱们今天来聊聊非比较排序。</p>
<span id="more"></span>
<p>计数排序、桶排序和基数排序都是常见的<strong>非比较</strong>排序算法。</p>
<p>首先来说说计数排序。</p>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>Counting sort，意为使用一个<strong>额外的数组</strong>，记录（counting）待排序集合的元素的数量（count），将待排序元素的值作为额外数组的索引（index），某一个值相同的元素的数量作为数组的值。通过遍历额外数组完成排序。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>找出待排序数组中最大和最小的元素（非必需）；</li>
<li>准备一个额外数组 C，大小为待排序集合的最大值 / 最大元素和最小元素的差值；</li>
<li>统计数组中每个值为 i 的元素的出现的次数，存入数组 C 的第 i 项；</li>
<li>遍历 C，找出元素值大于 0 的元素，将其对应的索引 i 作为元素值<strong>反向</strong>填充回待排序集合中，每放一个元素就从 C[i] 减去 1，直到减完为止；</li>
<li>返回结果数组。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] A = CountingSort.countingSort(<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">16</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>});</span><br><span class="line">        Utils.print(A);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] A) {</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="comment">// 假设 A 中的数据 a'，有：0 &lt;= a' &lt; k，且 k = 100</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">100</span>;</span><br><span class="line">        countingSort(A, B, k);</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] C = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = O; j &lt; A.length; j++) {</span><br><span class="line">            <span class="keyword">int</span> a = A[j];</span><br><span class="line">            C[a] += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 可简写为 C[A[j]] += 1;</span></span><br><span class="line">        }</span><br><span class="line">        Utils.print(C);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求计数和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; k; i++) {</span><br><span class="line">            C[i] = C[i] + C[i - <span class="number">1</span>];  <span class="comment">// 统计出数组 C 中小于或等于 i 的元素出现的次数</span></span><br><span class="line">        }</span><br><span class="line">        Utils.print(C);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A.length - <span class="number">1</span>; j &gt;= ; j--) {</span><br><span class="line">            <span class="keyword">int</span> a = A[j];  <span class="comment">// 从原数组中倒序取元素</span></span><br><span class="line">            B[C[a]-<span class="number">1</span>] = a;</span><br><span class="line">            <span class="comment">// Order[C[a]-1] = j+1;</span></span><br><span class="line">            C[a] -= <span class="number">1</span>;  <span class="comment">// 去掉数值相同的元素中已排好序的元素(确保稳定性)</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>当输入元素是 n 个从 0 到 k 之间的整数时：</p>
<ul>
<li>时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.788ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3884.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(3495.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>；</li>
<li>空间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.788ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3884.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(3495.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>计数排序属于非比较排序，速度快于任何比较排序算法，但是是通过牺牲空间换来的。</p>
<p>局限性：</p>
<ul>
<li>排序数组必须要是<strong>整数</strong>；</li>
<li>从<strong>额外数组</strong>这个特性可以看出，计数排序需要待排序数组在一定范围内，而且要比较集中；对于数据范围很大的数组（如：1, 2, 3, …, 5000），需要大量时间和内存。</li>
</ul>
<p>优化：</p>
<ol>
<li>根据待排序集合的最大值和最小值的差值，而不是从 0 开始到最大值确定计数数组，能够减少额外的空间浪费；</li>
<li>对计数数组变形，<strong>新元素的值是前面元素累加之和的值</strong>。</li>
</ol>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序（Bucket Sort, Bin Sort）将待排序节点中具有相同值，或者处于同一值域的元素放入同一个桶中，把桶链接起来就可以创建一个有序的链表。</p>
<ul>
<li>即：根据元素值特性将集合拆分成多个区域（桶）</li>
<li>拆分之后的多个桶，从值域上看是有序的</li>
<li>每个桶再使用别的算法或者递归调用桶排序再进行排序</li>
</ul>
<p>桶排序属于非比较排序，不受 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6F0" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 下限的影响。</p>
<p>以<strong>值域</strong>代替具体的值，是桶排序相对于计数排序的优化点。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>每次排序所用到的<strong>所有桶</strong>，可使用线性表来描述；</li>
<li>每个桶可以用<strong>链表</strong>描述；在进行节点分配之前，所有的桶都是空的。</li>
</ul>
<p>实现的关键点在于：</p>
<ol>
<li>元素值域的划分，即元素到桶的<strong>映射规则</strong>。如果过于宽松，则有可能所有元素全部映射到同一个桶中，向比较排序演进；如果过于严苛，则有可能每个桶只有一个元素，向计数排序演进；</li>
<li>排序算法的选择。桶排序算法的复杂度和稳定性，都会根据所选的排序算法不同而不同。</li>
</ol>
<p>过程：</p>
<ol>
<li>根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的<strong>桶的个数</strong>；</li>
<li><strong>遍历</strong>待排序集合，将每一个元素移动到对应的桶中；</li>
<li>对每一个桶的元素进行<strong>排序</strong>，并移动到已排序集合中。</li>
</ol>
<p>步骤 3 中的“已排序集合”即为步骤 1、2 中的待排序集合：与计数排序不同，桶排序的步骤 2 完成后，所有元素都在桶中，且桶排序时<strong>不再依赖原始集合</strong>。因此排序完毕之后将桶的元素移动回原始集合即可。</p>
<h2 id="v-s-快速排序"><a href="#v-s-快速排序" class="headerlink" title="v.s. 快速排序"></a>v.s. 快速排序</h2><p><a href="/2023/02/26/quick-sort">快速排序</a>根据支点元素将集合分成两部分分别递归排序，可以将这两个部分视作两个“桶”。</p>
<p>不同之处在于：</p>
<ul>
<li>快排是在集合自身进行排序，属于<strong>原地排序</strong>方式，且对每个“桶”的排序也是快排（递归）；</li>
<li>而桶排序则是提供了额外的操作空间，在<strong>额外空间</strong>对桶进行排序，避免构成桶的过程中的元素比较和交换操作，同时可以<strong>自主选择恰当的排序算法</strong>对桶中的元素进行排序。</li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketsort</span>(<span class="params">array, n</span>) <span class="title">is</span></span></span><br><span class="line"><span class="function">    <span class="title">buckets</span> &lt;- <span class="title">new</span> <span class="title">array</span> <span class="title">of</span> <span class="title">n</span> <span class="title">empty</span> <span class="title">lists</span> // 创建桶队列</span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">i</span> = 0 <span class="title">to</span> (<span class="params">length(array) - <span class="number">1</span></span>) <span class="title">do</span></span></span><br><span class="line"><span class="function">        <span class="title">insert</span> <span class="title">array</span>[<span class="title">i</span>] <span class="title">into</span> <span class="title">buckets</span>[<span class="title">msbits</span>(<span class="params">array[i], k</span>)]  // 按照映射规则将元素放到相对应桶中</span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">i</span> = 0 <span class="title">to</span> <span class="title">n</span> - 1 <span class="title">do</span></span></span><br><span class="line"><span class="function">        <span class="title">nextsort</span>(<span class="params">buckets[i]</span>)  // 对桶内元素进行排列</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">the</span> <span class="title">concatenation</span> <span class="title">of</span> <span class="title">buckets</span>[0], ..., <span class="title">buckets</span>[<span class="title">n</span>-1]  // 依序输出有序队列</span></span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>设需要排序的集合有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个数据，给提供的桶的数量是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>。那么均匀分配的情况下，平均每个桶里就会有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.475ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1978 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(600,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(1100,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个元素。</p>
<p>则将元素分配到桶的时间复杂度是确定的，为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>我们设 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.671ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3832.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(798.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(1854.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2454.6,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(2954.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个桶均进行排序的<strong>总时间复杂度</strong>为（假设桶内使用归并排序）：</p>
<script type="math/tex; mode=display">
O(n+m*k*logk)\\
=O(n+m*\frac{n}{m}*log\frac{n}{m})\\
=O(n+n*(logn-logm))</script><p>总的<strong>空间复杂度</strong>为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.596ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4241.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3852.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.361ex" height="1.505ex" role="img" focusable="false" viewbox="0 -583 2811.6 665"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(1933.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 时，时间复杂度达到最优 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，而空间复杂度为最差的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.975ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2641 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(1652,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2252,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，不过同样为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 级别；<br>当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.135ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2711.6 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2211.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 时，时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.175ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5823.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3574.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(3872.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(4357.4,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(4834.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5434.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，空间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>因此可以说，桶排序的效率是通过牺牲空间换来的。</p>
<p>当待排序集合的元素值相差过大的时候，对于桶映射规则的选择是一大挑战，可能会导致元素集中分布到某一个桶，或者绝大多数桶是空桶的情况。<br>因此同计数排序一样，桶排序适合<strong>元素值较为集中</strong>的集合。</p>
<h1 id="桶排序的改进：基数排序"><a href="#桶排序的改进：基数排序" class="headerlink" title="桶排序的改进：基数排序"></a>桶排序的改进：基数排序</h1><p>Radix sort，顾名思义，是把待排序的数按照某个基数（radix）分解成一串数字，然后对数字进行排序。</p>
<ul>
<li>一般以<strong>位数</strong>作为基数，即排序的时候是<strong>逐位排序</strong>；</li>
<li>如有数位较短的：前面补 0 再开始依次排序。<ul>
<li>可采用 LSD（Least Significant Digital，低位优先）或 MSD（Most Significant Digital，高位优先）</li>
<li>一般采用 LSD</li>
</ul>
</li>
</ul>
<p>基数排序是对桶排序的扩充：不仅适用于整数，还可以用于字符串和特定格式的浮点数。</p>
<p><img src="/2023/03/11/non-compare-sort/radix-sort.png" alt></p>
<p><small>注：</small></p>
<ul>
<li>r 为排序基数，在这里也就是数字位数的间隔：10；</li>
<li>d 为待排序数字的最高位数，也是排序次数。&lt;/small&gt;</li>
</ul>
<h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>由上面的例图可以知道：</p>
<ul>
<li>时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.781ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3439 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6F0" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mi" transform="translate(2530,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(3050,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为排序元素个数，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.176ex" height="1.593ex" role="img" focusable="false" viewbox="0 -694 520 704"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container> 为数字位数;</li>
<li>空间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.786ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3883.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6F0" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(3494.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li>
</ul>
<p>问题：</p>
<p><strong>为何要从低位开始向高位排序？</strong></p>
<ul>
<li>如果要从高位排序（MSD），那么次高位的排序会影响已经排好的大小关系。在数学中，<strong>数位越高，数位值对数的大小的影响就越大</strong>。从低位开始排序，就是对这种影响最小的排序。数位按照影响力从低到高的顺序排序，数位影响力相同则比较数位值。</li>
</ul>
<p><strong>为何同一数位的排序子排序要使用稳定排序？</strong></p>
<ul>
<li>稳定排序能够保证上一次的排序成果被保留，十位数的排序过程能保留个位数的排序结果，百位数的排序过程能保留十位数的排序结果，以此类推。</li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = a.length;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">// store how many elements are there in the bucket</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, factor = <span class="number">1</span>; i &lt; maxBit(a); i++, factor *= <span class="number">10</span>) {  <span class="comment">// start from LSD</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) {</span><br><span class="line">                <span class="keyword">int</span> digit = (a[j] / factor) % <span class="number">10</span>;</span><br><span class="line">                buckets[digit][bucket[digit]] = a[j];</span><br><span class="line">                bucket[digit]++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>, k = <span class="number">0</span>; m &lt; <span class="number">10</span>; m++) {</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == bucket[m]) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; bucket[m]; n++) {</span><br><span class="line">                    a[k] = buckets[m][n];</span><br><span class="line">                    k++;</span><br><span class="line">                }</span><br><span class="line">                bucket[m] = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxBit</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{  <span class="comment">// get the max bit from the array</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) {</span><br><span class="line">            <span class="keyword">int</span> size = Integer.toString(i).length();</span><br><span class="line">            maxLength = maxLength &gt;= size ? maxLength : size;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>因为三种非比较算法的平均时间复杂度均为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6E9" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM640 466Q640 523 625 565T583 628T532 658T479 668Q370 668 273 559T151 255Q150 245 150 213Q150 156 165 116T207 55T259 26T313 17Q385 17 451 63T561 184Q590 234 615 312T640 466ZM510 276Q510 278 512 288L515 298Q515 299 384 299H253L250 285Q246 271 244 268T231 265H227Q216 265 214 266T207 274Q207 278 223 345T244 416Q247 419 260 419H263Q280 419 280 408Q280 406 278 396L275 386Q275 385 406 385H537L540 399Q544 413 546 416T559 419H563Q574 419 576 418T583 410Q583 403 566 339Q549 271 544 267Q542 265 538 265H530H527Q510 265 510 276Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 级别的线性函数，因此它们又有一个称谓叫<strong>线性排序</strong>。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对象头</title>
    <url>/2021/07/16/object-header/</url>
    <content><![CDATA[<p>对象在 Hotspot 虚拟机中，除了对象本身的实例数据（Instance Data）之外，其在内存中的布局还包括了<strong>对象头</strong>（Object Header）和对齐填充（Padding）。</p>
<span id="more"></span>
<p>对齐填充的字节保留主要是出于 JVM 对 Java 对象内存占用的要求来考虑的。每个对象在 JVM 内存占用的大小应为 1 个字长（8 bits）的倍数，因此每个对象最后会有几个字节用于补全，没有特别的功能。<br>因此本帖不再赘述对齐填充，就专门来聊聊对象头。</p>
<p>Hotspot 虚拟机的对象头包括两（三）部分信息：</p>
<ol>
<li>对象自身的运行时数据</li>
<li>类型指针</li>
<li>数组长度（前提是该对象是数组）</li>
</ol>
<p><br></p>
<h1 id="运行时数据（Mark-Word）"><a href="#运行时数据（Mark-Word）" class="headerlink" title="运行时数据（Mark Word）"></a>运行时数据（Mark Word）</h1><p>包括哈希码（hash code）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。<br>Mark Word 的数据长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别是 32 bits 和 64 bits。</p>
<p>对象需要存储的运行时数据很多，其实已超出了 32、64 位 Bitmap 结构所能记录的限度；不过，对象头信息耗费的是<strong>与对象自身定义数据无关</strong>的额外存储成本。<br>基于这一点，再考虑到虚拟机的空间效率：Mark Word 被设计成一个<strong>非固定的数据结构</strong>，以便在极小的空间内存储尽量多的信息，且会根据对象的状态复用自己的存储空间。</p>
<p>比如：在 32 位 Hotspot 虚拟机中，如果对象未被锁定，那么 Mark Word 的 32 bits 的空间将被如下分配：</p>
<ul>
<li>25 bits 被用于存储对象的 hash code</li>
<li>4 bits 用于存储对象分代年龄</li>
<li>1 bit 固定为 0（因其未被锁定，不是偏向锁状态）</li>
<li>2 bits 用于存储锁标志位</li>
</ul>
<p>如下表的第一行所示。</p>
<p>而在其他状态下，对象的运行时数据存储内容如下：</p>
<table>
    <tr>
        <th>场景（状态）</th>
        <th colspan="5">存储内容占用的空间</th>
    </tr>
    <tr>
        <th rowspan="2" bgcolor="#CCCCCC">锁状态</th>
        <td colspan="2">25 bits</td>
        <td rowspan="2">4 bits</td>
        <td>1 bit</td>
        <td>2 bits</td>
    </tr>
    <tr>
        <td>23 bits</td>
        <td>2 bits</td>
        <td>是否是偏向锁（biased_lock）</td>
        <td>锁标志位</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">无锁</th>
        <td colspan="2">对象的 hash code</td>
        <td>age 分代年龄</td>
        <td>0</td>
        <td>01</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">偏向锁</th>
        <td>偏向锁记录的线程 ID</td>
        <td>epoch</td>
        <td>age 分代年龄</td>
        <td>1</td>
        <td>01</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">轻量级锁</th>
        <td colspan="4">pointer_to_lock_record 指向栈中锁记录的指针</td>
        <td>00</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">重量级锁</th>
        <td colspan="4">pointer_to_heavyweight_monitor 指向互斥量（重量级锁）的指针</td>
        <td>10</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">GC 标记</th>
        <td colspan="4">空</td>
        <td>11</td>
    </tr>
</table>

<p><br></p>
<p>在 64 位环境中，对象的运行时数据存储分布如下：</p>
<p><table>
    <tr>
        <th>场景（状态）</th>
        <th colspan="6">存储内容占用的空间</th>
    </tr>
    <tr>
        <th rowspan="2" bgcolor="#CCCCCC">锁状态</th>
        <td colspan="2" rowspan="2">56 bits</td>
        <td rowspan="2">1 bit</td>
        <td rowspan="2">4 bits</td>
        <td>1 bit</td>
        <td>2 bits</td>
    </tr>
    <tr>
        <td>是否是偏向锁（biased_lock）</td>
        <td>锁标志位</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">无锁</th>
        <td>未使用空间（25 bits）</td>
        <td>对象的 hash code（31 bits）</td>
        <td>cms_free</td>
        <td>age 分代年龄</td>
        <td>0</td>
        <td>01</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">偏向锁</th>
        <td>偏向锁记录的线程 ID（54 bits）</td>
        <td>epoch（2 bits）</td>
        <td>cms_free</td>
        <td>age 分代年龄</td>
        <td>1</td>
        <td>01</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">轻量级锁</th>
        <td colspan="5">pointer_to_lock_record 指向栈中锁记录的指针</td>
        <td>00</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">重量级锁</th>
        <td colspan="5">pointer_to_heavyweight_monitor 指向互斥量（重量级锁）的指针</td>
        <td>10</td>
    </tr>
    <tr>
        <th bgcolor="#CCCCCC">GC 标记</th>
        <td colspan="5">空</td>
        <td>11</td>
    </tr>
</table><br><br></p>
<p>一个对象在一个时间点总是处于其中的一个状态，只是状态之间可能会切换。</p>
<p><strong>参数说明</strong>：</p>
<p><code>biased_lock</code>：对象第一次被线程索取锁的时候，线程 ID 会写入 Mark Word 内（32 位系统的前 23 bits，或 64 位系统的前 54 bits）</p>
<ul>
<li>并且将 Mark Word 的“偏向锁”那一位设置为 1</li>
<li>下次该线程想要获取锁的时候，直接检查对象头中保存的 ID 是否等于自身线程 ID，如一致则认为当前线程获取了锁</li>
<li>这样就不需要再次获取锁了，略过了轻量级和重量级两种锁的加锁阶段，提高效率。</li>
</ul>
<p><code>epoch</code>：验证偏向锁有效性的时间戳。</p>
<p><code>cms_free</code>：说起来就跟内存分配策略有关系了。</p>
<ul>
<li>CMS 是基于清理算法的收集器（Concurrent Mark-Sweep），相应的内存分配策略就是空闲列表 free list；</li>
<li>内存碎片问题即是将不可达对象维护到一个列表 free list 里面，这些对象占用的空间为可用空间，随时分配给线程来使用；</li>
<li>因此，可以大概推断该占位是用来标记对象是否在列表中。</li>
</ul>
<p><code>age</code>：一共 4 位，最大值也就是 15：这就决定了为什么<strong>晋升到老年代的年龄</strong>设置（<code>-XX:MaxTenuringThreshold</code>，也是已完成的 GC 次数）不能超过 15 的原因。</p>
<p><code>pointer_to_heavyweight_monitor</code>：指向互斥量（重量级锁）的指针。</p>
<ul>
<li>在 Java 中，每个对象都持有一个属于自己的 Monitor 对象（在 Hotspot 虚拟机中由 C++ 类 <code>ObjectMonitor</code> 实现），指向它的指针就是 pointer_to_heavyweight_monitor</li>
<li>这也正好说明了：在 Java 中，任何一个对象都可以作为锁的存在</li>
<li>参数的名字带了 monitor，也是锁被称为“<strong>监视器锁</strong>”的原因。</li>
</ul>
<p>接下来聊聊 Mark Word 里面很重要的锁标志位。</p>
<h2 id="锁标志位"><a href="#锁标志位" class="headerlink" title="锁标志位"></a>锁标志位</h2><p>锁标志位 和 是否为偏向锁 两者共同对应到唯一的锁状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对象状态</th>
<th style="text-align:center">组合</th>
<th style="text-align:center">是否为偏向锁</th>
<th style="text-align:center">锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无锁</td>
<td style="text-align:center">001</td>
<td style="text-align:center">0</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">偏向锁</td>
<td style="text-align:center">101</td>
<td style="text-align:center">1</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">轻量级锁（CAS + 失败尝试）</td>
<td style="text-align:center">-00</td>
<td style="text-align:center">-</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">重量级锁（互斥）</td>
<td style="text-align:center">-10</td>
<td style="text-align:center">-</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">GC 标记</td>
<td style="text-align:center">-11</td>
<td style="text-align:center">-</td>
<td style="text-align:center">11</td>
</tr>
</tbody>
</table>
</div>
<p>所以说 <code>synchronized</code> 锁的是<strong>对象</strong>，而且分 4 种程度不同的锁。</p>
<p>锁只能升级不能降级，但是偏向锁可以被重置为无锁状态（也就是改一个位的值的事）。</p>
<p><br></p>
<h1 id="类型指针（Klass-pointer）"><a href="#类型指针（Klass-pointer）" class="headerlink" title="类型指针（Klass pointer）"></a>类型指针（Klass pointer）</h1><p>你没看错，就是这个 “klass”。</p>
<p>它用来存储对象的类型指针，该指针指向它所属类的元数据。JVM 通过这个指针来确定这个对象是哪一个类的实例。</p>
<p>举个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// p 是实例，保存在栈中，是对新的 Person() 对象的引用</span></span><br><span class="line"><span class="comment">// Person() 对象在堆中，保存了一个自己的类型指针 klass pointer</span></span><br><span class="line"><span class="comment">// Person() 对象要在元空间 metaspace 找到元数据 instanceKlass，靠的就是 klass pointer</span></span><br></pre></td></tr></table></figure></p>
<p>该指针的位长度为 JVM 的一个字大小，跟 Mark Word 的大小是一样的：32 位 JVM 的长度位 32 bits，64 位的则是 64 bits。<br>如果应用对象过多，使用 64 位的指针会浪费大量的内存。此时为了节约内存，可以开启指针压缩 <code>-XX:+UseCompressedOops</code> 将长度压缩为 32 位。</p>
<p><br></p>
<h1 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h1><p>如果对象是一个数组，那么对象头还需要有额外空间用于存储数组长度。</p>
<p>具体长度随 JVM 架构差别而不同，跟 Mark Word 和 klass pointer 的大小也是一样的：32 位 JVM 的长度位 32 bits，64 位的则是 64 bits。<br>如果在 64 位 JVM 上开启了指针压缩的话，该区域长度也会被压缩为 32 位。</p>
<p><br></p>
<p>最后问个小问题：</p>
<p>32 位的 Hotspot JVM 中，<code>Integer</code> 对象的大小是拆箱 <code>int</code> 的几倍？<br>解：Mark Word 32 bits，4个字节；类型指针同样 4 个字节；至于实例数据，<code>Integer</code> 只有一个 <code>int</code> 类型的成员变量 value，大小 4 字节：以上合起来 12 字节，加上补齐，一共 16 字节，是 int 的 4 倍。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式（Proxy）</title>
    <url>/2021/06/19/proxy/</url>
    <content><![CDATA[<p>顾名思义，代理模式就是给一个对象提供一个代理，由代理对象去控制对原对象的引用。</p>
<span id="more"></span>
<p>代理模式属于结构型模式，在《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“为其他对象提供一个代理，以控制对这个对象的访问”
</code></pre><p>在代理模式中，一个类代表另一个类的功能，代理对象是目标对象的代表。</p>
<p><br></p>
<h1 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h1><p>使得客户不能直接与真正的目标对象通信</p>
<p><br></p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2021/06/19/proxy/proxy-diagram.png" alt></p>
<p><img src="/2021/06/19/proxy/proxy-diagram-cn.png" alt></p>
<p>以上，可见代理模式包括以下角色：</p>
<p><code>Subject</code></p>
<ul>
<li>抽象角色</li>
<li>声明真实对象和代理对象的<strong>共同接口</strong></li>
</ul>
<p><code>Proxy</code></p>
<ul>
<li>代理</li>
<li>因为代理对象与真实对象实现了<strong>共同的接口</strong>（Subject），因此能在任何时刻代理真实对象</li>
<li>代理内部包含有对真实对象的引用：可操作真实对象，也可附加其它操作，相对于真实对象进行封装</li>
</ul>
<p><code>RealSubject</code></p>
<ul>
<li>真实角色</li>
<li>代表真实对象，为目标对象</li>
</ul>
<p><br></p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><ul>
<li>通过代理对象控制真实对象的访问，可以在这个真实对象调用方法之前，或者调用方法之后去处理 / 添加新的功能</li>
<li>代理对象也可以在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能</li>
</ul>
<p>以上均跟 Spring 的面向切面编程（AOP）有很大的关系。</p>
<p><br></p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>抽象角色：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真实角色：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态代理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject = <span class="keyword">null</span>;  <span class="comment">// 真实对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 除了代理真实角色做该做的事情，代理角色也可以提供附加操作</span></span><br><span class="line"><span class="comment">     * 如：preRequest() 和 postRequest()</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 类似于 AOP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preRequest();  <span class="comment">// 真实角色操作前的附加操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        realSubject.request();</span><br><span class="line"></span><br><span class="line">        postRequest();  <span class="comment">// 真实角色操作后的附加操作 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实角色操作前的附加操作 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实角色操作后的附加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = <span class="keyword">new</span> ProxySubject();</span><br><span class="line">subject.request();  <span class="comment">// 代理者代替真实者做事情</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p>
<ul>
<li>可以做到在不修改目标对象的功能前提下，对目标功能扩展</li>
</ul>
<p>缺点</p>
<ul>
<li>每一个代理类都必须实现一遍目标类的接口；如果接口增加方法，则代理类也必须跟着修改。</li>
<li>其次，代理类每一个接口对象对应一个目标对象，如果目标对象非常多，则静态代理类就非常臃肿，难以胜任。</li>
</ul>
<p><br></p>
<h1 id="已知应用"><a href="#已知应用" class="headerlink" title="已知应用"></a>已知应用</h1><p>Spring 的 AOP、日志打印、异常处理、事务控制、权限控制等</p>
<p><br></p>
<h1 id="Spring-中的变种应用"><a href="#Spring-中的变种应用" class="headerlink" title="Spring 中的变种应用"></a>Spring 中的变种应用</h1><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a><a href="/2022/03/18/spring-aop#Spring%20AOP">JDK 动态代理</a></h2><p>步骤：</p>
<ol>
<li>编写一个真实角色类的接口，即静态代理的 <code>Subject</code> 接口</li>
<li>实现真实角色类，即静态代理的 <code>RealSubject</code> 类</li>
</ol>
<p>（以上同静态代理的实现）</p>
<ol>
<li><p>代理的实现不同：创建动态代理类（<strong>核心</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心：实现 InvocationHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;  <span class="comment">// 真实对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ...  <span class="comment">// 前增强等代码</span></span><br><span class="line"></span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line"></span><br><span class="line">        ...  <span class="comment">// 后增强等代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成动态代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">DynamicProxy proxy = <span class="keyword">new</span> DynamicProxy(realSubject);  <span class="comment">// 生成代理对象</span></span><br><span class="line">ClassLoader classLoader = realSubject.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关键代码 Proxy.newProxyInstance()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 根据指定的参数动态创建代理对象，参数分别为：</span></span><br><span class="line"><span class="comment"> *   loader：指定代理对象的类加载器</span></span><br><span class="line"><span class="comment"> *   interfaces：获取代理类需要实现的所有接口</span></span><br><span class="line"><span class="comment"> *   invocationHandler：代理类（核心），代理类每一个方法执行时，将会调用一次 invoke()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123;Subject.class&#125;, proxy);</span><br><span class="line"><span class="comment">// interfaces 参数避免了接口过多带来的静态代理类臃肿的问题</span></span><br><span class="line"></span><br><span class="line">subject.request();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h2 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a><a href="/2022/03/18/spring-aop#Spring%20AOP">CGLib 动态代理</a></h2><p>创建代理对象的几个步骤：</p>
<ol>
<li>生成代理类的二进制字节码文件</li>
<li>加载二进制字节码（可修改字节码），生成 Class 对象（例如使用 <code>Class.forName()</code>）</li>
<li>通过反射机制获得实例构造，并创建代理类对象</li>
</ol>
<p>假定当前我们只有一个没有实现任何接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RealHello: &quot;</span> + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CGLib 动态代理实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现一个 MethodInterceptor，方法调用会被转发到该类实现的 intercept() 中：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  <span class="comment">// 等效于 JDK 中的 InvocationHandler</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// intercept() 等效于 JDK 中的 invoke()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;You said: &quot;</span> + Arrays.toString(args));</span><br><span class="line">        ...  <span class="comment">// 前增强</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注：此处执行的是 setSuperclass() 所确定的父类</span></span><br><span class="line"><span class="comment">         * 即：该代理类的父类，即真实角色类</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 真实角色与代理类为：父子关系</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object object = methodProxy.invokeSuper(proxy, args);   <span class="comment">// 将调用转发到原始对象</span></span><br><span class="line"></span><br><span class="line">        ...  <span class="comment">// 后增强</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类，以此创建目标类（真实角色）的子类，无需接口</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(RealHello.class);  <span class="comment">// 确定父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// create() 创建代理</span></span><br><span class="line">RealHello hello = (RealHello) enhancer.create();</span><br><span class="line">System.out.println(hello.sayHello(<span class="string">&quot;I love you!&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>两者优点</strong>：稳定，应用时间久，使用过程中不会出问题。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式（Observer）</title>
    <url>/2021/06/22/observer/</url>
    <content><![CDATA[<p>观察者模式属于对象行为型模式。</p>
<span id="more"></span>
<p>《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“定义对象之间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新”
</code></pre><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/2021/06/22/observer/observer-diagram.gif" alt></p>
<p>以上，可见观察者模式包括：</p>
<p><code>Subject</code></p>
<ul>
<li>观察目标（主题），发生改变的对象</li>
<li>将所有对观察者对象的引用保存到一个集合里</li>
<li>每一个主题都可以有多个观察者</li>
</ul>
<p><code>ConcreteSubject</code></p>
<ul>
<li>具体主题</li>
<li>将有关状态存入具体观察者对象</li>
<li>在具体主题发生改变时，给所有观察者发出通知</li>
</ul>
<p><code>Observer</code></p>
<ul>
<li>观察者，被通知的对象</li>
<li>为所有的具体观察者定义一个接口</li>
<li>在得到主题的通知时能及时更新自己</li>
</ul>
<p><code>ConcreteObserver</code></p>
<ul>
<li>具体观察者</li>
<li>实现抽象观察者角色所要求的更新接口</li>
<li>以便使本身状态与主题状态相协调</li>
</ul>
<p>一个观察目标对应多个观察者，而观察者之间没有相互联系。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>观察者抽象类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体观察者的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Binary String: &quot;</span> + Integer.toBinaryString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>目标实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();  <span class="comment">// setter 通知所有观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的观察者绑定该观察对象</span></span><br><span class="line"><span class="keyword">new</span> HexaObserver(subject);</span><br><span class="line"><span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line"><span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;First state change: 15&quot;</span>);</span><br><span class="line">subject.setState(<span class="number">15</span>);  <span class="comment">// setter 中会通知所有观察者</span></span><br><span class="line">System.out.println(<span class="string">&quot;Second state change: 10&quot;</span>);</span><br><span class="line">subject.setState(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>由上，感觉观察者模式非常像发布 - 订阅模式（或者说 M-V 模型-视图模式）。</p>
<p><br></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p>
<ol>
<li>观察者和被观察者是<strong>抽象耦合</strong>的。</li>
<li>建立一套触发机制。</li>
</ol>
<p>缺点</p>
<ol>
<li>如果一个观察目标有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ol>
<h1 id="观察者模式-v-s-中介者模式"><a href="#观察者模式-v-s-中介者模式" class="headerlink" title="观察者模式 v.s. 中介者模式"></a>观察者模式 v.s. 中介者模式</h1><p>观察者模式只从被观察对象单向通知观察者，而中介者模式可以从任一方发起通知，属于双向通知。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2023/02/26/quick-sort/</url>
    <content><![CDATA[<p>快速排序属于不稳定的比较排序算法，是<a href="/2022/11/08/bubble-sort">冒泡排序</a>的改进版本。</p>
<span id="more"></span>
<p>快速排序又称作<strong>分区交换排序</strong>（partition-exchange sort）。</p>
<p>思路如下：</p>
<ol>
<li>n 个元素被分成左（left）、中（middle）、右（right）三段<ul>
<li>其中中段仅包含一个元素，作为<strong>支点</strong>（<strong>pivot</strong>）</li>
<li>支点不一定是最中间的元素，即：left 和 right 的元素数量可以不一样</li>
</ul>
</li>
<li>左段元素均小于或等于中段元素，右段元素均大于或等于中段元素<ul>
<li>相对于<a href="/2023/02/25/merge-sort">归并排序</a>而言，left 和 right 的元素可独立排序，无需合并</li>
</ul>
</li>
<li>分别递归使用快排，对 left 和 right 排序</li>
<li>所得序列为 left + middle + right</li>
</ol>
<p>之所以叫<strong>快排</strong>，是因为在步骤 1 之后，支点以左的任一元素无需再与支点以右的元素再发生比较和交换，大大减少了比较和交换的次数；<br>因此其速度通常明显比其他算法更快，其递归排序的循环可以在大部分的架构上很有效率地去完成。</p>
<p>在执行步骤 1 的时候，数组需要<strong>先进行一次排序</strong>，分别筛选比支点大和小的元素；而这一次的排序，也是需要<strong>递归执行</strong>的排序。</p>
<p>变种：中值快速排序（median-of-three quick sort）</p>
<ul>
<li>取 {<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.586ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1585 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(529,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(807,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1307,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.395ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5036.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(529,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mo" transform="translate(807,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1196,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1918.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2918.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3369.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3758.4,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(4258.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4758.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.475ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1536 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(529,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(807,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1258,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>} 中大小居中的元素作为支点</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>C++：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T *a, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// Sort a[0:n-1] using quick sort.</span></span><br><span class="line">    <span class="comment">// Requires a[n] must have largest key.</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, <span class="number">0</span>, n<span class="number">-1</span>);  <span class="comment">// 以数组第一个元素作为支点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">// Sort a[l:r], a[r+1] has large value.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l,  <span class="comment">// left-to-right cursor</span></span><br><span class="line">    j = r + <span class="number">1</span>;  <span class="comment">// right-to-left cursor</span></span><br><span class="line">    T pivot = a[l];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap elements &gt;= pivot on left side</span></span><br><span class="line">    <span class="comment">// with elements &lt;= pivot on right side</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; pivot) {  <span class="comment">// find &gt;= element on left side</span></span><br><span class="line">            <span class="keyword">if</span> (i == r) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; pivot) {  <span class="comment">// find &lt;= element on right side</span></span><br><span class="line">            <span class="keyword">if</span> (j == l) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) {</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// swap pair not found</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">Swap</span>(a[i], a[j]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// place pivot</span></span><br><span class="line">    a[l] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(a, l, j<span class="number">-1</span>);  <span class="comment">// sort left segment</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, j+<span class="number">1</span>, r);  <span class="comment">// sort right segment</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= end) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = begin;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[begin];  <span class="comment">// 首元素为支点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// search element smaller than pivot from right to left</span></span><br><span class="line">            <span class="keyword">while</span> (a[right] &gt;= pivot &amp;&amp; left &lt; right) {</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// then search element bigger than pivot from left to right</span></span><br><span class="line">            <span class="keyword">while</span> (a[left] &lt;= pivot &amp;&amp; left &lt; right) {</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) {</span><br><span class="line">                Swapper.swap(a, left, right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put pivot into middle</span></span><br><span class="line">        a[begin] = a[left];</span><br><span class="line">        a[left] = pivot;</span><br><span class="line"></span><br><span class="line">        quickSort(a, begin, left - <span class="number">1</span>);  <span class="comment">// sort left part</span></span><br><span class="line">        quickSort(a, left + <span class="number">1</span>, end);  <span class="comment">// sort right part</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>改进版：随机选择支点，使每次递归快排尽可能均匀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= end) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = begin;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="comment">// 随机确定支点的位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotInt = RANDOM.nextInt(end - begin + <span class="number">1</span>) + begin;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[pivotInt];</span><br><span class="line">        <span class="comment">//选定基准值后，将基准值的位置和最开头的位置交换，这样在右边留出连续空间，便于交换</span></span><br><span class="line">        Swapper.swap(a, pivotInt, begin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// search element smaller than pivot from right to left</span></span><br><span class="line">            <span class="keyword">while</span> (a[right] &gt;= pivot &amp;&amp; left &lt; right) {</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// then search element bigger than pivot from left to right</span></span><br><span class="line">            <span class="keyword">while</span> (a[left] &lt;= pivot &amp;&amp; left &lt; right) {</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) {</span><br><span class="line">                Swapper.swap(a, left, right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put pivot into middle</span></span><br><span class="line">        a[begin] = a[left];</span><br><span class="line">        a[left] = pivot;</span><br><span class="line"></span><br><span class="line">        quickSort(a, begin, left - <span class="number">1</span>);  <span class="comment">// sort left part</span></span><br><span class="line">        quickSort(a, left + <span class="number">1</span>, end);  <span class="comment">// sort right part</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><ul>
<li>最坏情况：left 为空—— <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
<li>最好情况：left 和 right 数目大致相同—— <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ 概述</title>
    <url>/2021/07/21/rabbitmq/</url>
    <content><![CDATA[<p>RabbitMQ 是由 Erlang 语言开发的 <a href="/2021/07/20/mq/#AMQP">AMQP</a> 的开源实现。</p>
<span id="more"></span>
<p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p>
<p><strong>1</strong>. 可靠性（Reliability）：RabbitMQ 使用一些机制实现持久化、传输确认及发布确认等</p>
<p><strong>2</strong>. 灵活的路由（Flexible Routing）</p>
<ul>
<li>在 AMQP 协议中，消息进入路由之前，是通过交换器（Exchange）来路由信息的</li>
<li>RabbitMQ 针对典型的路由功能提供一些内置的交换器实现</li>
<li>针对更复杂的功能，可以将多个交换器绑定在一起，也可以通过插件机制实现自己的交换器。</li>
</ul>
<p><strong>3</strong>. 扩展性（Clustering）</p>
<ul>
<li>多个 RabbitMQ 节点可组成一个集群，形成一个逻辑 Broker</li>
<li>也可根据实际业务情况动态扩展集群中节点，且集群部署相对简单</li>
</ul>
<p><strong>4</strong>. 高可用性（Highly Available Queues）</p>
<ul>
<li>Erlang 为电话交换机开发而生，自带高并发和高可用属性，因此 RabbitMQ 在高可用性方面有保障</li>
<li>队列可在集群中的机器上设置镜像，使得部分节点出现问题时，队列仍然可用</li>
</ul>
<p><strong>5</strong>. 多协议（Multi-protocol）：支持原生 AMQP，还支持 STOMP、MQTT 等多种消息中间件协议</p>
<p><strong>6</strong>. 多语言客户端：对于所有主流编程语言（Java, Python, Ruby, Go, PHP, C#, JavaScript 等）均有与代理接口通讯的客户端库</p>
<p><strong>7</strong>. 管理界面（Management UI）：易用，可监控和管理消息以及 Broker 集群节点</p>
<p><strong>8</strong>. 跟踪机制（Tracing）：如果消息异常，使用者可以找出发生了什么</p>
<p><strong>9</strong>. 插件机制（Plugin System）：可从多方面进行扩展，如网页控制台消息管理插件、消息延迟插件等</p>
<p><strong>10</strong>. 社区活跃度高，解决问题成本低。</p>
<p><br></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>RabbitMQ 相关的重要角色如下：</p>
<ul>
<li>生产者</li>
<li>消费者</li>
<li>代理：RabbitMQ 本身，自身不产生消息</li>
</ul>
<p>细化到内部与 AMQP 的相关概念相差不大：</p>
<p><img src="/2021/07/21/rabbitmq/rabbitmq.png" alt></p>
<p><strong>Message</strong>：包括消息体和 RoutingKey、properties（消息优先级、延迟等特性）等消息头信息。</p>
<p><strong>Publisher</strong>：消息生产者。在 RabbitMQ 中是一个向 Exchange 发布消息的客户端应用程序 Client。</p>
<p><strong>Exchange</strong>：交换器。用于接收生产者发送的消息，并且分发消息给队列 Queue。</p>
<p><img src="/2021/07/21/rabbitmq/exchange.png" alt></p>
<p>RabbitMQ 默认采用 Direct Exchange。</p>
<p><strong>RoutingKey</strong>：路由键。将 Publisher 的数据按照某种规则分配到特定 Exchange 上。</p>
<p><strong>Binding</strong>：绑定。基于 Binding Key 将 Exchange 和 Queue 之间连接起来，组成一个路由规则。Exchange 可以被理解为是由多个 Binding 组成的路由表。</p>
<p><strong>BindingKey</strong>：绑定键。指定了 Exchange 和相应 Queue 之间的 binding key 之后，Exchange 根据对应的关系，将消息推送到相应的 Queue 中。</p>
<ul>
<li>多个 Queue 可以和同一个 Exchange 绑定，此时多个 Binding 允许使用相同的 BindingKey。</li>
</ul>
<p><strong>Queue</strong>：队列。存储消息，先进先出。</p>
<p><img src="/2021/07/21/rabbitmq/queue.png" alt></p>
<p>队列结构通常分为两部分：</p>
<p><code>rabbit_amqqueue_process</code>：负责协议（AMQP）相关的消息处理，包括：</p>
<ul>
<li>接收生产者发布的消息</li>
<li>向消费者交付消息</li>
<li>处理消息的确认（生产端的 confirm，消费端的 ack 等）</li>
</ul>
<p><code>backing_queue</code>：消息存储的具体形式和引擎</p>
<ul>
<li>向 <code>rabbit_amqqueue_process</code> 提供相关接口以供调用</li>
</ul>
<p><strong>Connection</strong>：网络连接，比如一个 <strong>TCP</strong> 连接</p>
<ul>
<li>另：<strong>ConnectionFactory</strong>：连接管理器。应用程序与 RabbitMQ 之间建立连接的管理器，在程序代码中使用。</li>
</ul>
<p><strong>Channel</strong>：信道。消息推送使用的通道，是多路复用连接中的一条独立的双向数据流通道。</p>
<ul>
<li>AMQP 无论是发布消息、订阅队列还是接收消息，都是通过信道完成</li>
<li>一个 Connection 中有一个或多个 Channel。</li>
</ul>
<p><strong>Consumer</strong>：消息消费者。在 RabbitMQ 中表示一个从 Queue 中获取消息客户端应用程序 Client。</p>
<p><strong>Virtual Host</strong>（vhost）：虚拟主机，AMQP 概念的基础，必须在连接时指定。本质上就是一个 mini 版的 RabbitMQ 服务器。</p>
<ul>
<li>每一个 vhost 拥有自己的 Exchange、Queue、Binding 和权限机制</li>
<li>同一个 vhost 里可以有多个 Exchange 和 Queue，但不能有同名的 Exchange 或 Queue</li>
<li>每个 RabbitMQ 服务器均可创建 vhost，默认为 “<code>/</code>“。</li>
</ul>
<p><strong>Broker</strong>：表示消息队列服务器实体。</p>
<p>注：消费者和生产者都可以创建队列。如果提交了一个已经存在的队列的创建请求，系统不会返回错误，不会有任何的影响。</p>
<p><br></p>
<h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><p>当消费者端需要进行大量的计算时，RabbitMQ 服务器需要一定的分发机制来平衡每个消费者的 workload。在 RabbitMQ 中定义了两种任务的分发机制：</p>
<p><strong>1. Round-robin Dispatching</strong>：循环分发，轮询</p>
<p>循环分发的场景是：多个消费者订阅同一个 Queue，Queue 中的消息<strong>平分</strong>给其他消费者。</p>
<p>此时 RabbitMQ 会将消息<strong>逐个发送</strong>到消费者序列中的<strong>下一个</strong>消费者：</p>
<ul>
<li>不考虑每个任务的时长等因素，而且是提前一次性分配，并非一个个分配</li>
<li>平均每个消费者会获得相同数量的消息</li>
</ul>
<p>在默认情况下，RabbitMQ 并不会考虑消费者处理消息的能力，即便是其中有的消费者闲置过久，有的却高负荷工作。<br>这就会造成资源分配不均的问题：有的消费者持续工作，其他的持续空闲。</p>
<p><strong>2. Fair Dispatch</strong>：公平分发，根据消费者的消费能力进行分发处理</p>
<ul>
<li>使用 <code>channel.basicQos(prefetchCount)</code> 限制每次发送给消费者消息的个数</li>
<li>可以让每个消费者在同一时间点最多去处理规定数量级个数的 message</li>
<li>在接收该消费者的 ack 前，队列不会将新的 message 分发给该消费者。</li>
</ul>
<p>注：使用公平分发必须关闭自动应答，改为手动应答。</p>
<p><img src="/2021/07/21/rabbitmq/fair-dispatch.png" alt></p>
<p>可将队列中的消息数量视为无限制，因为限制只是取决于机器的内存。<br>但消息过多会导致处理效率的下降。</p>
<h2 id="生产者消息运转"><a href="#生产者消息运转" class="headerlink" title="生产者消息运转"></a>生产者消息运转</h2><ol>
<li>生产者先连接到 Broker，建立连接（Connection），再开启一个或多个信道（Channel）</li>
<li>生产者声明一个 Exchange 并设置好相关属性</li>
<li>生产者声明一个 Queue 并设置好相关属性</li>
<li>生产者通过 RoutingKey 建立与 Exchange 的路由；通过 BindingKey 将 Exchange 和 Queue 绑定</li>
<li>生产者发送消息到 Broker，消息包含 RoutingKey、Exchange 等信息</li>
<li>相应的 Exchange 根据接收到的 RoutingKey 查找匹配的 Queue<ol>
<li>如匹配：将消息存入对应的队列</li>
<li>如不匹配：根据生产者先前的配置，丢弃消息（<code>mandatory=false</code>）或退回至生产者（<code>mandatory=true</code>）</li>
</ol>
</li>
<li>关闭信道</li>
<li>管理连接</li>
</ol>
<h2 id="消费者接收消息流程"><a href="#消费者接收消息流程" class="headerlink" title="消费者接收消息流程"></a>消费者接收消息流程</h2><ol>
<li>生产者先连接到 Broker，确保连接已建立，随后开启一个或多个信道</li>
<li>消费者向 Broker 请求，并消费响应了的 Queue 中的信息（可能会设置相应的回调函数）</li>
<li>等待 Broker 回应并投递相应 Queue 中的消息给消费者，消费者接收消息</li>
<li>消费者确认收到的信息，返回 ack</li>
<li>RabbitMQ 从 Queue 中删除已经返回 ack 的消息</li>
<li>关闭信道</li>
<li>关闭连接</li>
</ol>
<p><br></p>
<h1 id="消息稳定性"><a href="#消息稳定性" class="headerlink" title="消息稳定性"></a>消息稳定性</h1><p>要想提高消息的<a href="/2021/07/20/mq/#消息丢失问题">稳定性</a>，避免消息丢失，通常有以下方法：</p>
<ul>
<li>ACK 确认机制</li>
<li>消息持久化</li>
<li>设置集群镜像模式</li>
<li>消息补偿机制</li>
</ul>
<h2 id="消息确认机制（针对于-Producer，也叫生产者确认机制）"><a href="#消息确认机制（针对于-Producer，也叫生产者确认机制）" class="headerlink" title="消息确认机制（针对于 Producer，也叫生产者确认机制）"></a>消息确认机制（针对于 Producer，也叫生产者确认机制）</h2><p><strong>1. Confirm 模式</strong>（常用方法，也叫生产者重试模式，发布/确认模式）</p>
<ol>
<li>根据实际业务，消费者需要手动确认消息被消费（通过 <code>channel.basicAck()</code>）</li>
<li>生产者将 channel 设置为 <code>confirm</code> 确认模式； <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.confirmSelect()  <span class="comment">// channel 开启为 confirm 模式</span></span><br></pre></td></tr></table></figure>
<ul>
<li>确认后，所有在该 channel 发布的消息都会被指定一个唯一的 ID 号（<code>deliveryTag</code>，从 1 递增）</li>
</ul>
</li>
<li>消息发送到 queue 之后，broker 会给生产者发送消息。包括：<ul>
<li><code>deliveryTag</code></li>
<li>标志 ACK（成功发送到 queue）/ NACK（消息服务器因内部错误等原因丢失消息等）</li>
<li><code>multiple</code>：false 为单条确认，true 为该序号之前所有消息得到了处理</li>
<li>如果发送的是持久化消息，则在消息被<strong>成功写入磁盘之后</strong>才会发送给生产者确认消息</li>
</ul>
</li>
<li>如果一个队列没有对应的消费者：消息会被缓存，不会被丢弃</li>
<li>消费者处理完数据后，需要向 MQ Server 发送确认信息（acknowledge, ACK），MQ 随后会将这个 ACK 发送给生产者（包含 ID）<ul>
<li>如消息被某个消费者正确接收：消息会被从队列中移除</li>
<li>如有数据没有被 ACK，MQ Server 不会删除消息，而是进行后续操作</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.confirmSelect()  <span class="comment">// channel 开启为 confirm 模式</span></span><br></pre></td></tr></table></figure>
<p>生产者确认机制可以细分为三种：单条 confirm 模式、批量 confirm 模式，以及异步 confirm 模式。</p>
<p><strong>2. AMQP 事务机制</strong>：主要是对信道 channel 的设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与事务机制相关的方法：</span></span><br><span class="line">channel.txSelect();  <span class="comment">// 用于将当前的信道设置成事务模式，开启事务</span></span><br><span class="line">channel.txCommit();  <span class="comment">// 用于提交事务</span></span><br><span class="line">channel.txRoolback();  <span class="comment">// 用于事务回滚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规调用顺序从上到下</span></span><br></pre></td></tr></table></figure>
<p>缺点是会导致吞吐量下降。</p>
<p><strong>注</strong>：</p>
<ul>
<li>如事务提交执行前 RabbitMQ 异常崩溃或其他原因抛出异常：通过 <code>txRollback()</code> 回滚，当 <code>autoAck=true</code> 时，事务无效<ul>
<li>此时消息时自动消费确认，RabbitMQ 直接将消息从队列中擦除，即使后面事务回滚也不能起到任何作用</li>
</ul>
</li>
<li>Confirm 模式和事务机制不能共存，否则会导致 RabbitMQ 报错。</li>
</ul>
<h3 id="应用：RabbitMQ-消息重试"><a href="#应用：RabbitMQ-消息重试" class="headerlink" title="应用：RabbitMQ 消息重试"></a>应用：RabbitMQ 消息重试</h3><p>在 <code>spring-rabbit</code> 框架内实现的<strong>消费者内部重试</strong>，在业务使用 try-catch 的时候需要手动确认（<code>channel.basicAck()</code> 或 <code>channel.basicNack()</code>）。</p>
<p>同时，如果使用 <code>RejectAndDontRequeueRecoverer</code> 类进行重试的话，消息并不会被重新发送回队列；</p>
<ul>
<li>使用 <code>RepublishMessageRecoverer</code> 或 <code>ImmediateRequeueMessageRecoverer</code> 能够实现重新发布消息和立即重新返回队列；</li>
<li>与此同时要定义好重新发送的交换器和队列。</li>
</ul>
<p>以下是两个针对 MQ 本身的方案：</p>
<p><br></p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>RabbitMQ 消息默认是放在内存的，如果不特别声明消息持久到磁盘，当节点关掉或者 crash 掉，消息就会丢失。</p>
<p>消息有以下状态：</p>
<ol>
<li><code>alpha</code>：消息内容（包括消息体、属性和 headers）和消息索引都存储在内存</li>
<li><code>beta</code>：消息内容保存在磁盘，消息索引保存在内存</li>
<li><code>gamma</code>：消息内容保存在磁盘，消息索引分别保存在磁盘和内存</li>
<li><code>delta</code>：消息内容和索引都在磁盘中</li>
</ol>
<p>消息持久化的条件：</p>
<ul>
<li>队列是一个持久化的队列</li>
<li>消息的发送模式 <code>deliveryMode=2</code></li>
<li>消息已经到达持久化 Exchange 上</li>
<li>消息已经到达持久化的队列中</li>
</ul>
<p>消息持久化方法：</p>
<ul>
<li>投递消息时 Exchange 通过指定 <code>durable=true</code> 完成持久化</li>
<li>同时对应的 queue 的持久化标识 <code>durable</code> 设置为 <code>true</code>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.queueDeclare(x, durable=<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 具有该标识的 Exchange 和 Queue 在重启之后会重新建立</span></span><br><span class="line"><span class="comment">// 此时它们之间的 binding 也是持久化的</span></span><br><span class="line"><span class="comment">// 如两者中只有一个持久化，则不允许建立 binding</span></span><br></pre></td></tr></table></figure></li>
<li>设置投递模式 <code>deliveryMode</code> 为 <code>2</code>：持久化  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(x, x, MessageProperties.PERSISTENT_TEXT_PLAIN, x);  <span class="comment">// 存储纯文本到磁盘</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="集群化"><a href="#集群化" class="headerlink" title="集群化"></a>集群化</h2><p>RabbitMQ 的三种部署模式如下：</p>
<ul>
<li>单点模式：最简单的模式，非集群模式。当节点挂了或者消息不可用了，业务会瘫痪，只能等待；</li>
<li>普通模式：消息需要持久化，默认是集群模式；当某个节点挂了获消息不可用了造成业务瘫痪，此时只能等待节点恢复重启使用；</li>
<li>镜像模式：把队列做成镜像需要的队列，存放于多个节点中。</li>
</ul>
<p>要将 RabbitMQ 集群化，集群中应有以下的节点类型：</p>
<ul>
<li>内存节点 ram：将变更写入内存</li>
<li>磁盘节点 disc：磁盘写入操作</li>
</ul>
<p>RabbitMQ 集群要求最少有一个磁盘节点。</p>
<h2 id="消息补偿机制（针对于-Consumer）"><a href="#消息补偿机制（针对于-Consumer）" class="headerlink" title="消息补偿机制（针对于 Consumer）"></a>消息补偿机制（针对于 Consumer）</h2><p>消息补偿机制需要建立在消息要写入 DB 日志，发送日志，接收日志中，两者的状态必须做记录，然后根据 DB 日志记录 check 消息发送消费是否成功。<br>如果不成功，需要进行消息补偿措施，重新发送消息处理。</p>
<p><br></p>
<h2 id="为啥不直接基于-TCP"><a href="#为啥不直接基于-TCP" class="headerlink" title="为啥不直接基于 TCP"></a>为啥不直接基于 TCP</h2><p>RabbitMQ 是基于信道 Channel 传输消息的。Channel 通过建立真实 TCP 连接建立虚拟连接。</p>
<p>因为对于 OS 来说，建立和关闭 TCP 连接是有代价的，频繁建立和关闭 TCP 连接对于系统的性能有很大影响，且 TCP 的连接数也有限制，从而限制了系统处理高并发的能力；<br>但是在一个 TCP 连接中建立一个或多个 channel 的成本就低很多了。</p>
<p><br></p>
<h1 id="消息唯一性（幂等性）"><a href="#消息唯一性（幂等性）" class="headerlink" title="消息唯一性（幂等性）"></a>消息唯一性（幂等性）</h1><p>以 Message ID 为幂等键对消息进行幂等处理的步骤如下：</p>
<ul>
<li>在数据库中创建一张 unique key 索引为唯一 Message ID 的表；</li>
<li>在 Producer 客户端为每条消息设置唯一 Message ID；</li>
<li>在 Consumer 客户端根据唯一 Message ID 对消息进行幂等处理。</li>
</ul>
<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><p>先说说什么叫死信。</p>
<p>当一个消息遇到以下之一的情况：</p>
<ul>
<li>被拒（Basic.Reject / Basic.Nack），而且达到了 retry 上限，或者 requeue = false，不能重新进入队列；</li>
<li>消息 TTL（time to live）过期；</li>
<li>队列已满（x-max-length），无法再添加。</li>
</ul>
<p>这样的消息被称为<strong>死信</strong>（<strong>D</strong>ead <strong>L</strong>etter）。</p>
<p>当一个消息在队列中变为死信之后，如果这个消息所在的队列存在 <code>x-dead-letter-exchange</code> 参数，那么它会被发送到 <code>x-dead-letter-exchange</code> 对应的 Exchange 中，这个 Exchange 叫做死信交换器（<strong>D</strong>ead-<strong>L</strong>etter e<strong>X</strong>change, <strong>DLX</strong>）。</p>
<p>DLX 根据 RoutingKey 所绑定的 Queue 就是<strong>死信队列</strong>。</p>
<p>设置：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Exchange:</span> <span class="string">dlx.exchange</span></span><br><span class="line"><span class="attr">Queue:</span> <span class="string">dlx.queue</span></span><br><span class="line"><span class="attr">RoutingKey:</span> <span class="comment">#</span></span><br><span class="line"><span class="comment">#  &quot;#&quot; 表示只要有消息到达了 Exchange，那么都会被路由到这个 queue 上</span></span><br></pre></td></tr></table></figure></p>
<p>死信队列接收消息后并<strong>不消费该消息</strong>，所以可以监听死信队列中的消息做相应的处理。</p>
<h2 id="应用：消息重试"><a href="#应用：消息重试" class="headerlink" title="应用：消息重试"></a>应用：消息重试</h2><p>除了上面提到的<a href="#应用：RabbitMQ-消息重试">重试方法</a>，我们还可以使用死信队列进行重试：  </p>
<ul>
<li>如果业务队列绑定了死信交换器和死信路由键，重启开始时，消息会从业务队列中删除，同时发送到死信队列中；</li>
<li>如果是手动 ack 模式，还需手动调用 <code>channel.basicNack()</code> &amp; <code>requeue=false</code> 才能转发到死信队列。</li>
</ul>
<p><br></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>举一个简单的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络信道，消息读写的通道，与 RabbitMQ 打交道的主要接口</span></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 几乎所有操作都在 channel 对象中进行，包括：</span></span><br><span class="line"><span class="comment"> *    定义 Exchange 和 Queue</span></span><br><span class="line"><span class="comment"> *    绑定 Exchange 和 Queue</span></span><br><span class="line"><span class="comment"> *    发布消息</span></span><br><span class="line"><span class="comment"> * 客户端基于一个 Connection 可建立多个 channel 实例，</span></span><br><span class="line"><span class="comment"> * 即一个 TCP 连接上建立多个 RabbitMQ 会话，大大节省资源</span></span><br><span class="line"><span class="comment"> * 每个 channel 表示一个会话任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RabbitMQ 的 socket（TCP）连接，封装了 socket 协议相关逻辑</span></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="comment">// Connection 的制造工厂</span></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MqDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        factory.setHost(HOST);</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">            channel.basicQos(prefetchCount);  <span class="comment">// 每次只接收 1 个数据</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);  <span class="comment">// 第二个参数：消息持久化为 false</span></span><br><span class="line">            String message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Recv</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        factory.setHost(HOST);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;  <span class="comment">// 消息的异步处理</span></span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置消费者不消费消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicNack();</span><br><span class="line">channel.basicReject(messageId, <span class="keyword">true</span>);  <span class="comment">// 消息被拒绝，会被分配到其他订阅者</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a><strong>延迟队列</strong></h3><p>存储对应的延迟消息</p>
<ul>
<li>当消息被发送以后，并不想让消费者立即拿到消息</li>
<li>等待特定的时间后，消费者才能拿到这个消息进行消费</li>
<li>应用于超时未支付订单自动取消</li>
</ul>
<p>实现：</p>
<ul>
<li>3.6.x -：采用死信队列 + queue 设置 TTL 实现延迟队列</li>
<li>3.6.x +：官方提供延迟队列插件，下载放置 RabbitMQ 根目录的 <code>plugin/</code> 下</li>
</ul>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a><strong>优先级队列</strong></h3><p>优先级高的队列会先被消费</p>
<ul>
<li>可通过 <code>x-max-priority</code> 参数实现</li>
<li>当消费速度大于生产速度，且 Broker 没有堆积时：优先级显得没有意义</li>
</ul>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a><strong>异步处理</strong></h3><p>场景：用户注册后需要发送注册邮件和注册短信</p>
<p>传统设计：</p>
<ul>
<li>串行化：将注册信息写入数据库后，先发送注册邮件再发送注册短信<ul>
<li>以上三个任务全部完成后才返回给客户端</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/21/rabbitmq/mail-serial.png" alt></p>
<ul>
<li>并行化：将注册信息写入数据库后，发送邮件的同时发送短信<ul>
<li>以上三个任务全部完成后才返回给客户端</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/21/rabbitmq/mail-parallel.png" alt></p>
<p>新设计：消息队列</p>
<ul>
<li>前提：邮件和短信对用户正常使用网站没有任何影响<ul>
<li>客户没必要等着邮件短信发送完成才显示注册成功</li>
</ul>
</li>
<li>将不是必须的业务逻辑（发送邮件、短信）异步处理</li>
<li>响应时间大大缩短</li>
</ul>
<p><img src="/2021/07/21/rabbitmq/mail-mq.png" alt></p>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a><strong>应用解耦</strong></h3><p>场景：在电商应用中，用户下单后，订单系统通知库存系统</p>
<p>传统设计：订单系统直接调用库存系统接口</p>
<p><img src="/2021/07/21/rabbitmq/coupling.png" alt></p>
<p>缺点：</p>
<ul>
<li>库存系统出现故障时，订单就会失败</li>
<li>订单系统和库存系统高度耦合</li>
</ul>
<p>新设计：消息队列</p>
<ul>
<li>用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回“下单成功”通知</li>
<li>库存系统订阅下单的消息，当有订单进入对应队列后，获取下单消息，进行相应操作</li>
<li>即使库存系统奔溃，消息队列也能保证消息可靠传递，不会导致消息丢失</li>
<li>即使用 MQ 进行 RPC 通信的分布式系统</li>
</ul>
<p><img src="/2021/07/21/rabbitmq/decoupling.png" alt></p>
<h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a><strong>流量削峰</strong></h3><p>场景：秒杀活动，一般会因为瞬时流量过大导致应用宕机</p>
<p>设计：一般在应用前端引入消息队列</p>
<ol>
<li>服务器收到用户请求后，首先写入消息队列</li>
<li>加入消息队列长度超过最大值：直接抛弃用户请求，或跳转到错误页面</li>
<li>秒杀业务根据消息队列中的请求，再作后续的处理</li>
</ol>
<p><img src="/2021/07/21/rabbitmq/flow-cut.png" alt></p>
<p>作用：</p>
<ul>
<li>控制活动人数，超过一定阀值的订单直接丢弃</li>
<li>可避免短时间的高流量压垮应用，应用按照自身最大处理能力获取订单</li>
</ul>
]]></content>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的反射机制</title>
    <url>/2021/05/25/reflection-java/</url>
    <content><![CDATA[<p>首先，我们这里讨论的并不是物理上的反射（哈哈），而是基于计算机科学的反射式编程概念，讨论一下它的原理以及在 Java 语言当中的实现。</p>
<span id="more"></span>
<p><br></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在计算机科学中，<a href="https://zh.wikipedia.org/wiki/反射式编程">反射式编程</a>（reflective programming），或反射（reflection），指的是计算机程序运行时“访问、检测和修改它本身状态或行为的能力”：</p>
<ul>
<li>它可以把一个类，类的成员变量（函数、属性等）当成一个对象来操作；</li>
<li>在程序运行的时候，开发者还可以动态地对类进行以下操作：<ul>
<li>构造任意一个类的对象；</li>
<li>了解任意一个对象所属的类；</li>
<li>了解任意一个类的成员变量和方法；</li>
<li>调用任意一个对象的属性和方法。</li>
</ul>
</li>
</ul>
<p>最早的计算机在它们的原生汇编语言里编程，其本质上就是反射：由定义编程指令作为数据；<br>而在面向对象的编程语言中，反射允许在编译期无法确认接口的名称、字段、方法的情况下，在<strong>运行时检查类、接口、字段和方法</strong>。</p>
<p>为什么有反射？因为它“<strong>灵活</strong>”。<br>在运行期根据某种条件才能确定使用哪个类的对象时，就可使用反射。</p>
<p>例子：<strong>策略模式</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可在运行时根据不同条件创建不同的类，实现不同的 Strategy 实例</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例：构造时传进不同的 String 代表某个子类以初始化不同的实例</span></span><br><span class="line"><span class="comment"> * 能避免很多的 if-else</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行某种策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseStrategy <span class="title">select</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 根据 type 进行不同实例的初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="Java-的反射机制"><a href="#Java-的反射机制" class="headerlink" title="Java 的反射机制"></a>Java 的反射机制</h1><p>Java 中的反射机制，指的是直接操作编译后的 <code>.class</code> 文件，动态获取程序信息及动态调用对象的功能。</p>
<p>优点：</p>
<ul>
<li>可动态执行</li>
<li>在运行期间根据业务功能动态执行方法、访问属性</li>
<li>最大限度发挥 Java 灵活性</li>
</ul>
<p>缺点：</p>
<ul>
<li>对性能有影响，总是慢于直接执行 Java 代码</li>
</ul>
<p><br></p>
<h2 id="Java-的反射与所谓“传统-RTTI”的区别"><a href="#Java-的反射与所谓“传统-RTTI”的区别" class="headerlink" title="Java 的反射与所谓“传统 RTTI”的区别"></a>Java 的反射与所谓“传统 RTTI”的区别</h2><p><img src="/2021/05/25/reflection-java/reflection-vs-rtti.png" alt></p>
<p><br></p>
<h2 id="普通的生成对象-v-s-反射生成对象"><a href="#普通的生成对象-v-s-反射生成对象" class="headerlink" title="普通的生成对象 v.s. 反射生成对象"></a>普通的生成对象 v.s. 反射生成对象</h2><p><img src="/2021/05/25/reflection-java/r.png" alt></p>
<p><br></p>
<h2 id="class-文件包括了什么？"><a href="#class-文件包括了什么？" class="headerlink" title=".class 文件包括了什么？"></a>.class 文件包括了什么？</h2><p><img src="/2021/05/25/reflection-java/class.png" alt></p>
<p>注：左边为编译前源码的内容，右边为类的信息</p>
<p><br></p>
<h2 id="Class-对象相关"><a href="#Class-对象相关" class="headerlink" title="Class 对象相关"></a>Class 对象相关</h2><h3 id="基本类图"><a href="#基本类图" class="headerlink" title="基本类图"></a>基本类图</h3><p><img src="/2021/05/25/reflection-java/class-diagram.png" alt></p>
<p>我们可知，Java 反射体系里面重要的实体类有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Class  <span class="comment">// 类相关</span></span><br><span class="line">java.lang.reflect.Constructor  <span class="comment">// 构造函数相关</span></span><br><span class="line">java.lang.reflect.Field  <span class="comment">// 属性相关</span></span><br><span class="line">java.lang.reflect.Method  <span class="comment">// 其他方法相关</span></span><br></pre></td></tr></table></figure>
<p>相同的 class 全路径下只会有一个相对应的 .class 文件</p>
<ul>
<li>因此通过该全路径获得的所有 Class 对象都是相等的（<code>.equals() = true</code>）</li>
</ul>
<h3 id="获得-Class-对象的方式"><a href="#获得-Class-对象的方式" class="headerlink" title="获得 Class 对象的方式"></a>获得 Class 对象的方式</h3><ol>
<li>类名.class</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClazz = Person.class;</span><br></pre></td></tr></table></figure>
<ol>
<li>类实例.getClass()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class personClazz1 = person.getClass();</span><br></pre></td></tr></table></figure>
<ol>
<li>Class.forName(“类的全路径”)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClazz2 = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Class-类常用方法"><a href="#Class-类常用方法" class="headerlink" title="Class 类常用方法"></a>Class 类常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.example.Person&quot;</span>)     <span class="comment">// 根据全路径动态加载类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 非静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">newInstance()       <span class="comment">// 根据对象的 class 新建一个对象</span></span><br><span class="line"></span><br><span class="line">getSuperclass()         <span class="comment">// 获取继承的父类</span></span><br><span class="line">getInterfaces()         <span class="comment">// 获取继承的接口</span></span><br><span class="line">getDeclaredFields()     <span class="comment">// 获取所有声明的域，但不能获得继承过来的域</span></span><br><span class="line">getDeclaredMethods()    <span class="comment">// 获取当前类的所有方法</span></span><br><span class="line">getConstructors()       <span class="comment">// 获取所有构造函数</span></span><br><span class="line">getModifiers()          <span class="comment">// 获取修饰符</span></span><br><span class="line">getPackages()           <span class="comment">// 获得 package</span></span><br><span class="line">getField(String name)   <span class="comment">// 获得某个 public 域，包括从父类继承过来的域</span></span><br><span class="line">getFields()             <span class="comment">// 获得所有 public 域</span></span><br><span class="line">getMethods()            <span class="comment">// 获得所有 public 方法</span></span><br><span class="line"></span><br><span class="line">isAnnotation()      <span class="comment">// 判断是否为注解类型</span></span><br><span class="line">isPrimitive()       <span class="comment">// 判断是否为基本类型</span></span><br><span class="line">isArray()           <span class="comment">// 判断是否为数组类型</span></span><br><span class="line">isEnum()            <span class="comment">// 判断是否为枚举类型</span></span><br><span class="line"></span><br><span class="line">getClassLoader()    <span class="comment">// 获得类的类加载器</span></span><br></pre></td></tr></table></figure>
<p><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 的区别：</p>
<ul>
<li><code>Class.forName()</code> 是将类的 .class 文件加载到 JVM 中，并且该类已经被初始化完成了；</li>
<li><code>ClassLoader.loadClass()</code> 只是将 .class 文件加载到 JVM 中，还没经过链接，更不用说初始化了。</li>
</ul>
<p><br></p>
<h2 id="Constructor-构造函数相关"><a href="#Constructor-构造函数相关" class="headerlink" title="Constructor 构造函数相关"></a>Constructor 构造函数相关</h2><p>通过 Class 对象创建构造方法对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .getConstructor() 方法支持无参及多个参数传入</span></span><br><span class="line">Constructor c = personClazz.getConstructor(String.class, Integer.class, Byte.class);</span><br><span class="line">Constructor c1 = personClazz.getConstroctor();</span><br></pre></td></tr></table></figure><br>随后通过 constructor 实例创建对象的时候，要根据 constructor 初始化时传入对应的参数来创建对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = (Person) c.newInstance(<span class="string">&quot;test&quot;</span>, <span class="number">10</span>, (<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">Person p2 = (Person) c1.newInstance();</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Field-属性相关"><a href="#Field-属性相关" class="headerlink" title="Field 属性相关"></a>Field 属性相关</h2><p>先获取到 Class 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClazz = Person.class;</span><br></pre></td></tr></table></figure>
<p>通过 Class 对象获取 Field 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field nameField = personClazz.getField(<span class="string">&quot;name&quot;</span>);  <span class="comment">// 获得类的属性</span></span><br><span class="line"><span class="comment">// 或：Field nameField = personClazz.getDeclaredField(&quot;name&quot;);</span></span><br></pre></td></tr></table></figure>
<p>根据实际的对象，获取属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor c = personClazz.getConstructor();</span><br><span class="line">Person person = (Person) c.newInstance();  <span class="comment">// 创建实际对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据实际对象获取实际的属性值</span></span><br><span class="line">String name = (String) nameField.get(person);</span><br></pre></td></tr></table></figure>
<p>可通过反射调用私有变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤同上，但在获得 Field 对象时的方法有些许不同</span></span><br><span class="line">Field nameField = personClazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 多个 Field：Class.getDeclaredFields()</span></span><br></pre></td></tr></table></figure>
<p>然后调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nameField.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>随后便可通过 <code>.get()</code> 方法获取值。</p>
<p><br></p>
<h2 id="Method-方法相关：与属性类似"><a href="#Method-方法相关：与属性类似" class="headerlink" title="Method 方法相关：与属性类似"></a>Method 方法相关：与属性类似</h2><p>可通过反射调用私有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clazz.getDeclaredMethod(String name, Class[] parameterTypes);</span><br><span class="line">clazz.getDeclaredMethods();</span><br></pre></td></tr></table></figure>
<p>然后调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>可以应用于服务的水平分割，如 MVC 框架：每一层都存在着能承载结果的实体类</p>
<ul>
<li>视图层：VO (V:view) / UO</li>
<li>应用层：DTO / Entity</li>
<li>领域层 Domain：Entity / VO (V-value)</li>
<li>基础设施层：PO (Persistent)</li>
</ul>
<p>视图层依赖于应用层，应用层依赖于领域层，基础设施层依赖于领域层。</p>
<p>例：持久对象 PersonPO 转为 值对象 PersonVO，如果属性繁多，一个一个转会很麻烦。<br>解决方法：利用反射实现工具类（如：<code>BeanUtils</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">BeanUtils.convert(objectFrom, objectTo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(Object srcObj, Object targetObj)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步，获得 class 对象</span></span><br><span class="line">    Class srcClazz = srcObj.getClass();</span><br><span class="line">    Class targetClazz = targetObj.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，获得 Field</span></span><br><span class="line">    Field[] srcFields =  srcClazz.getDeclaredFields();</span><br><span class="line">    Field[] targetFields =  targetClazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：赋值</span></span><br><span class="line">    <span class="keyword">for</span> (Field srcField : srcFields) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Field targetField : targetFields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (srcField.getName().equals(targetField.getName())) &#123;</span><br><span class="line">                srcField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                targetField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                targetField.set(targetObj, srcField.get(srcObj));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会有一部分的性能损耗，但并不大：因为服务器并没有那么脆弱。<br>如果使用“反模式”：所有层次从上到下都用同一个实体类，只要有一点变化的话，从上到下都会有影响。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>远程过程调用 RPC</title>
    <url>/2021/07/31/rpc/</url>
    <content><![CDATA[<p>RPC 全称 Remote Procedure Call Protocol，远程过程调用协议。</p>
<span id="more"></span>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单体服务的时代：</p>
<ul>
<li>以前用户量和数据量都比较小，<strong>一个项目中包含了所有的服务</strong>：所有功能模块都在一个工程中编码、编译、打包，随后部署到一个服务器中，即可提供服务；</li>
<li>最常见的 J2EE 的场景就是打好一个 war 包部署到 tomcat 中</li>
<li>特点就是：各部分服务，包括数据库都是使用<strong>单节点</strong>（all-in-one）进行部署的</li>
<li>初期：这种单体应用的优点就是简单实用，迭代快，维护也简单，成本低</li>
<li>随着业务增加，项目会变得臃肿，<strong>耦合变得严重</strong>，<strong>维护周期变长，变得困难</strong>了；而且一个模块出现了问题，会影响另一个模块的功能以及维护，“牵一发而动全身”。</li>
</ul>
<p>水平架构：扩容多个服务器，实现横向扩展，负载均衡。</p>
<p>垂直架构的时代：</p>
<ul>
<li>按照业务对应用作垂直划分，相当于将一个单体架构拆分成一堆单体应用，组成一个集群</li>
<li>这样就能针对不同的模块进行优化，且<strong>模块之间影响减小</strong>，避免上面单体应用出现的问题；而且<strong>方便水平扩展</strong>，<strong>负载均衡</strong>，<strong>迭代高效</strong>，容错率也提高了</li>
<li>有一个明显的缺点是：服务之间的调用方式变了，需要通过网络调用，采用的协议根据不同的业务场景很难统一起来（Webservice、HTTP …）<ul>
<li>而且多个垂直应用一共要维护大量的接口地址。如果某个服务端口或 IP 地址发生改变，调用的系统得手动改变</li>
<li>随着系统的发展，调用关系会越来越复杂</li>
</ul>
</li>
<li>而且随着流量增大，应用间调用的网络成本逐渐增加；集群化的负载均衡实现也比较复杂</li>
<li>服务监控也不到位</li>
</ul>
<p>面向服务的架构：Service-Oriented Architecture, <strong>SOA</strong></p>
<ul>
<li>根据实际业务，把系统拆分成合适的、独⽴部署的模块，模块之间相互独⽴（通过 Webservice / Dubbo 等技术进⾏通信），不仅仅是按照业务划分。<ul>
<li>越是核心的业务，越要拆出来</li>
</ul>
</li>
<li>因此衍⽣出了⼀系列相应的技术，如对服务提供、服务调⽤、连接处理、通信协议、序列化⽅式、服务发现、服务路由、⽇志输出等⾏为进⾏封装的服务框架。</li>
</ul>
<p>由此可见，我们总结了服务由单体 -&gt; 负载均衡（水平） -&gt; 分布式（垂直） -&gt; 垂直+水平的优化与升级（以 Dubbo 的发展为例）：</p>
<p><img src="/2021/07/31/rpc/roadmap.png" alt></p>
<p>因此业界常说的<strong>分布式服务</strong>的概念，与 RPC 紧密相关。</p>
<p>既然是比垂直 MVC 架构的负载更均衡，RPC 要做到的，就是能通过网络请求远程计算机程序的服务时，要能像本地调用一样方便，让调用者感知不到远程调用的逻辑。</p>
<p>总的来说，它属于<strong>跨网络跨进程通信</strong>的范畴，是一种通过网络从远程计算机程序请求服务，而不需要了解底层网络技术的<strong>思想</strong>，并不是一种具体的规范或者协议，使用 TCP、UDP 都可以。</p>
<p>RPC 的使用代表：</p>
<ul>
<li>应用及服务框架：Dubbo, <a href="/2022/04/20/springboot">Spring Boot</a></li>
<li>远程通信协议：RMI, Socket, SOAP(HTTP with XML), REST(HTTP with JSON)</li>
<li>通信框架：MINA, Netty</li>
</ul>
<p><br></p>
<h1 id="完整框架"><a href="#完整框架" class="headerlink" title="完整框架"></a>完整框架</h1><p>先说说在 RPC 思想中主要的功能组成模块：</p>
<p><strong>客户端</strong>（<strong>client</strong>）：服务调用方。</p>
<p><strong>客户端存根</strong>（<strong>client stub</strong>）</p>
<ul>
<li>存放服务端服务的地址信息</li>
<li>将客户端的请求参数数据信息打包（marshalling，或序列化）成网络消息，再通过网络传输发送到服务端</li>
<li>通过网络传输接收服务端返回的处理结果，并将其解包（unmarshalling，或反序列化）成具体的返回值，返回给客户端</li>
<li>除了上述工作之外，stub 为一辅助对象，不执行任何实际功能</li>
</ul>
<p><strong>服务端存根</strong>（<strong>server stub</strong>）</p>
<ul>
<li>通过网络传输接收到客户端发送过来的请求信息，并进行解包，随后发送至（调用）服务端</li>
<li>接收服务端的处理结果，并将其打包成网络信息，通过网络传输发送到客户端</li>
<li>和客户端的存根一样，除了上述工作之外，stub 为一辅助对象，不执行任何实际功能</li>
</ul>
<p><strong>服务端</strong>（<strong>server</strong>）：服务真正提供者。</p>
<p><strong>网络服务</strong>：底层传输，可为 TCP 或 HTTP。</p>
<p>在一次网络调用中，RPC 的<strong>核心调用</strong>如下：</p>
<p><img src="/2021/07/31/rpc/rpc-call.jpeg" alt></p>
<p>时序图：</p>
<p><img src="/2021/07/31/rpc/sequence-diagram.jpg" alt></p>
<ol>
<li>客户端通过本地调用，执行需要调用的语句，并传递参数</li>
<li>客户端 stub 接收到调用请求后，将方法、入参等信息序列化成能够进行网络传输的消息体</li>
<li>客户端 stub 找到远程服务地址，发送网络消息到服务端</li>
<li>服务端 stub 接收到信息后，解析取得方法名和参数</li>
<li>服务端 stub 根据解析的结果，调用本地服务执行服务（即“远程过程”）</li>
<li>服务端执行过程完毕，将结果返回服务端 stub</li>
<li>服务端 stub 将处理结果序列化</li>
<li>服务端 stub 通过网络服务发送结果至客户端</li>
<li>客户端 stub 接收到结果，对结果进行解码</li>
<li>客户端接收到调用语句返回的结果数据</li>
</ol>
<p>整个调用为一同步过程。</p>
<p><img src="/2021/07/31/rpc/rpc-call.png" alt></p>
<p>上图在原来的核心调用之外，多了一个“<strong>RPC Runtime</strong>”的概念：发送和接收请求，其中客户端的 RPC Runtime 多了等待远端执行结果的功能。</p>
<p>完整的 RPC 架构图如下：</p>
<p><img src="/2021/07/31/rpc/framework.jpeg" alt></p>
<p>在一个典型的 RPC 使用场景中，包含了服务发现、服务暴露、负载、容错、网络传输、序列化等组件，其中 RPC 的思想就指明了程序应该怎么样来进行序列化和网络传输。</p>
<p><br></p>
<h1 id="核心功能的技术点"><a href="#核心功能的技术点" class="headerlink" title="核心功能的技术点"></a>核心功能的技术点</h1><h2 id="服务寻址"><a href="#服务寻址" class="headerlink" title="服务寻址"></a>服务寻址</h2><p>我们要调用某个方法的函数体是由函数指针指定的；但放在远程调用中，因为两个进程的地址空间完全不同，函数指针无效。</p>
<p>因此在 RPC 中，所有函数必须有自己的 ID，该 ID 在所有进程中唯一确定；客户端作远程调用时必须附上 ID。<br>所以服务寻址可以使用 Call ID 映射。</p>
<p>客户端和服务端分别维护 “函数 &lt;—&gt; <strong>Call ID</strong>” 的<strong>映射表</strong>：</p>
<ul>
<li>客户端启动时，通过服务发现将所需的服务接口信息缓存到本地；执行远程调用的时候：查表，找出对应 ID，传给服务端</li>
<li>服务端接收到 ID 后，通过查表，确定客户端需要调用的函数，执行</li>
</ul>
<p>可以引入服务注册中心（Service Registry），通过管理 IP 端口 / 接口信息来实现寻址；RMI 就是这么实现的。Dubbo 官方推荐使用 Zookeeper。</p>
<h2 id="数据流的序列化和反序列化"><a href="#数据流的序列化和反序列化" class="headerlink" title="数据流的序列化和反序列化"></a>数据流的序列化和反序列化</h2><p>说多一嘴：什么是序列化和反序列化？</p>
<p>序列化和反序列化属于通信协议的一部分</p>
<ul>
<li><strong>序列化</strong>：将数据结构或对象转换成二进制串的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所产生的二进制串转换成数据结构或者对象的过程（序列化的逆过程）</li>
</ul>
<p>再说回 RPC：方法在本地调用的时候，JVM 将参数压入栈，函数自己去栈里读就好；而远程调用的客户端和服务端不能通过内存传递参数，只能通过网络，因此需要有序列化和反序列化的存在。</p>
<p>在 OSI 协议模型中，表示层（Presentation Layer）的主要功能就是序列化和反序列化。</p>
<h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><p>要讨论的就是上图“核心功能”的那一块：</p>
<p><img src="/2021/07/31/rpc/network-transmission.png" alt></p>
<p>客户端和服务端通过网络连接，所有数据需要通过网络传输。<br>在网络传输中，我们需要一个网络传输层传递 Call ID + 序列化的参数字节流，以及序列化的调用结果（一来一去）。</p>
<p>网络传输的实现协议不限：</p>
<ul>
<li>大部分 RPC 框架使用 TCP 协议（最常见）</li>
<li>gRPC 使用 HTTP2</li>
<li>UDP 也可以</li>
</ul>
<h3 id="基于-TCP"><a href="#基于-TCP" class="headerlink" title="基于 TCP"></a><strong>基于 TCP</strong></h3><ol>
<li>由服务调用方（客户端）与服务提供方（服务端）建立 Socket 连接</li>
<li>服务调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务提供方</li>
<li>服务提供方反序列化后，再利用反射调用相关方法</li>
<li>执行方法后，将结果序列化，返回服务调用方</li>
</ol>
<p>在实际应用中会进行一系列封装，如 RMI。</p>
<h3 id="基于-HTTP"><a href="#基于-HTTP" class="headerlink" title="基于 HTTP"></a><strong>基于 HTTP</strong></h3><p>服务调用方向服务提供方发送请求，请求为 GET, POST, PUT, DELETE 等其中的一种；<br>服务提供方根据不同请求作不同处理，或某个方法只允许某种请求方式。</p>
<p>流程概述：</p>
<ul>
<li>根据请求中的 URL 调用具体方法</li>
<li>方法所需要的参数，可以是对服务调用方传输过去的 XML 或 JSON 数据解析出来的部分或全部结果</li>
<li>最后返回 XML 或 JSON 数据结果</li>
</ul>
<p>实现起来更加容易，请求也更像访问网页一般，返回结果更加简单、单一。</p>
<p>两者的<strong>对比</strong>如下：</p>
<p>基于 TCP 实现的 RPC 调用</p>
<ul>
<li>TCP 协议处于协议栈靠下的层次中</li>
<li>能够更灵活地对协议字段进行定制</li>
<li>减少网络开销，提高性能，实现更大吞吐量和并发数</li>
<li>需更多关注底层复杂的细节，实现代价更高</li>
</ul>
<p>基于 HTTP 实现的 RPC 调用</p>
<ul>
<li>能够使用 JSON 和 XML 格式请求或响应数据：格式标准相当通用，解析工具成熟，二次开发便捷且简单</li>
<li>HTTP 为靠上层的协议<ul>
<li>发送包含同等内容的信息，使用 HTTP 传输所占用字节数比 TCP 的更高</li>
<li>在同样的网络状态下：HTTP 传输相同内容的效率比 TCP 低传输占用时间更长，不过通过压缩数据能缩小这一差距</li>
</ul>
</li>
</ul>
<h3 id="基于消息队列"><a href="#基于消息队列" class="headerlink" title="基于消息队列"></a><strong>基于消息队列</strong></h3><p><img src="/2021/07/31/rpc/network-transmission-mq.png" alt></p>
<p>总的来说，使用消息队列实现能够保证 RPC 在消息传递过程中的安全性和稳定性。</p>
<p>更具体一点：</p>
<ul>
<li>消息队列能让请求从同步变异步，实现更加轻松<ul>
<li>使用线程池的话：缺点是要自己实现，且强耦合</li>
</ul>
</li>
<li>低内聚高耦合：解耦，减少强依赖</li>
<li>流量削峰：通过消息队列设置请求最大值，超过阈值的会被抛弃或转到错误界面</li>
<li>网络通信性能提高<ul>
<li>每次连接都要建立一次 TCP 连接，高峰期成千上万的连接会造成巨大的性能瓶颈和资源浪费</li>
<li>消息队列采用信道通信，不采用 TCP 直接通信</li>
<li>一个线程一条信道，多个线程多条信道，共用一个 TCP 连接</li>
</ul>
</li>
</ul>
<h2 id="具体的-RPC-实现"><a href="#具体的-RPC-实现" class="headerlink" title="具体的 RPC 实现"></a>具体的 RPC 实现</h2><ul>
<li>Call ID：可直接使用函数字符串，也可使用整数 ID；映射表一般为哈希表</li>
<li>序列化与反序列化：可以自己实现，也可使用 <code>Hessian</code>, <code>Protobuf</code>（Google 内部混合语言数据标准）, <code>Thrift</code>（Facebook 开源框架）或 <code>FlatBuffers</code> 等</li>
<li>网络传输库：可以自己写 Socket，不过不多，更多的是应用 <code>Asio</code>, <code>ZeroMQ</code>, <code>Netty</code> 等现成的框架。</li>
</ul>
<p><br></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>RPC 多应用在大型网站，内部子系统较多、接口非常多的系统中。</p>
<ul>
<li>长链接：不必每次通信都像 HTTP 一样三次握手，减少网络开销</li>
<li>注册发布机制：监控管理、发布、下线接口、动态扩展</li>
<li>安全性：没有暴露资源操作</li>
<li><a href="/2023/06/10/micro-service">微服务</a>支持</li>
</ul>
<p><br></p>
<h1 id="与其它技术栈的比较"><a href="#与其它技术栈的比较" class="headerlink" title="与其它技术栈的比较"></a>与其它技术栈的比较</h1><h2 id="RPC-v-s-RESTful"><a href="#RPC-v-s-RESTful" class="headerlink" title="RPC v.s. RESTful"></a>RPC v.s. RESTful</h2><p><strong>1</strong>. 面向的对象不同</p>
<ul>
<li>REST 的主体是资源，而 RPC 更侧重于动作</li>
<li>REST 是面向资源的设计架构，但系统中很多对象不能被抽象成资源，如登录，修改密码等</li>
<li>RPC 可通过动作去操作资源<ul>
<li>操作全面性：RPC &gt; REST</li>
</ul>
</li>
</ul>
<p><strong>2</strong>. 传输效率不同</p>
<ul>
<li>RPC 使用自定义 TCP 协议，请求报文体积更小，效率更高</li>
<li>HTTP2 协议也可很好地减少报文体积</li>
</ul>
<p><strong>3</strong>. 复杂度不同</p>
<ul>
<li>RPC 实现复杂，流程繁琐</li>
<li>REST 调用和测试都很方便</li>
</ul>
<p><strong>4</strong>. 灵活性</p>
<ul>
<li>HTTP 相对更规范，更标准，更通用，不限制于语言</li>
<li>RPC 可实现跨语言调用，但整体灵活性不如 REST</li>
</ul>
<h2 id="RPC-or-HTTP"><a href="#RPC-or-HTTP" class="headerlink" title="RPC or HTTP?"></a>RPC or HTTP?</h2><p>HTTP 接口在接口不多、系统与系统交互较少时，是解决信息孤岛初期常使用的通信手段。<br>因此 HTTP 具有简单、直接、开发方便的优点，同时耦合程度比 RPC 低（越往 OSI 底层靠近，耦合程度越高）。</p>
<p>如果系统内部子系统较多，接口多时，RPC 优势更大。因为：</p>
<ul>
<li>长连接，不必每一次通信都像 HTTP 一样进行三次握手，减少网络开销</li>
<li>RPC 的注册中心的监控管理功能丰富，可发布、动态扩展等</li>
<li>安全</li>
<li>RPC 能基于 TCP 协议实现，说明 RPC 是基于 OSI 的<strong>第四层</strong>实现，比第七层的 HTTP 效率更高、更快。</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 入门</title>
    <url>/2021/07/29/redis-basics/</url>
    <content><![CDATA[<p>在非关系型数据库（NoSQL）中，Redis 绝对是 C 位的存在。今天就开一个帖来专门唠唠 Redis。</p>
<span id="more"></span>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis，全称 <strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver。官方解释是“BSD 开源许可的，使用 ANSI C 语言开发的，部署于内存的数据结构（in-memory data structure store）”。<br>Redis 不仅可以用来做内存数据库，还可以做缓存和消息代理。</p>
<p>Redis 支持多种数据结构：</p>
<ul>
<li>字符串 string</li>
<li>列表 list</li>
<li>hash</li>
<li>集合 set</li>
<li>带范围查询的有序集合 sorted set (zset)</li>
<li>位图 bitmap</li>
<li>hyperloglog</li>
</ul>
<p>前五种为基本数据类型，后两种为高级对象。</p>
<p>Redis 具有内置的复制，Lua 脚本，LRU 淘汰策略，事务和不同级别的磁盘持久性，并通过 Redis Sentinel 和 Redis Cluster 的自动分区提供高可用性。</p>
<p>Redis 所有的单个操作都是原子性的（Lua 脚本保证），多个操作支持事务。</p>
<p><br></p>
<h1 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h1><p>先来说说 Redis 里面基本对象的源码：</p>
<h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a><strong>redisObject</strong></h2><ul>
<li>Redis 的对象类型、内部编码、内存回收、共享对象等功能均需其支持</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redis.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> {</span></span><br><span class="line">    <span class="comment">// 对象的类型，占 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的内部编码，占 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构（即 val 对应的 SDS）的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">2</span>;  <span class="comment">/* Not used */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="comment">// REDIS_LRU_BITS 在不同版本中的 Redis 的长度也有所不同</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录该对象被引用的次数</span></span><br><span class="line">    <span class="keyword">int</span> refcount; </span><br><span class="line">} robj;</span><br></pre></td></tr></table></figure>
<p>一个 redisObject 占用 <strong>16</strong> 字节的空间。</p>
<p><strong><big>1. type</big></strong></p>
<p>redisObject 一共有 5 种数据类型：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure></p>
<p>4 位 type 字段最多能排出 15 种组合，记录 5 种数据类型足够。</p>
<p><strong><big>2. encoding</big></strong></p>
<p>redisObject 一共有 10 种编码类型：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0      <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1      <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2       <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3   <span class="comment">/* Encoded as zipmap, deprecated after v 3.2.5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4  <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5  <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6   <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8    <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_QUICKLIST 9  <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>encoding 常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>SDS</td>
</tr>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型（8 字节长，64 位）的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPMAP</td>
<td>zipmap，3.2.5 后弃用</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双向链表，非循环</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表，访问速度较快</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳表 + 字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的 SDS</td>
</tr>
<tr>
<td>REDIS_ENCODING_QUICKLIST</td>
<td>以压缩列表为元素的双向链表</td>
</tr>
</tbody>
</table>
</div>
<p>4 位 encoding 字段最多能排出 15 种组合，记录 10 种编码类型足够。</p>
<p><br></p>
<p><strong>注</strong>：这里比较一下 <code>REDIS_ENCODING_EMBSTR</code> 和 <code>REDIS_ENCODING_RAW</code>（下面简称 embstr 和 raw）：</p>
<ul>
<li>embstr 与 raw 都使用 redisObject 和 SDS 保存数据</li>
<li>从 Redis 3.0 开始引进 embstr，意为 “embedded string”，使用时只分配一次内存空间（因为 redisObject 和 SDS 空间上连续）<ul>
<li>专门用于存储<strong>短</strong>（不大于 44 字节的）字符串（Redis 3.2 之前是 39）</li>
<li>好处是：创建时少分配一次空间，删除时少释放一次空间；对象所有数据连在一起，创建快速，寻找方便</li>
<li>坏处是：字符串长度增加需要重新分配内存时，整个 redisObject 和 SDS 都需要重新分配空间</li>
<li>因此 embstr 实现是只读，并且没有提供修改值的函数</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/29/redis-basics/redis-encoding-embstr.png" alt></p>
<ul>
<li>raw 需要分别为 redisObject 和 SDS 分配内存空间（调用两次内存分配函数）<ul>
<li>存储大于 44 字节的字符串（Redis 3.2 之前是 39）</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/29/redis-basics/redis-encoding-raw.png" alt></p>
<p><strong><big>3. lru</big></strong></p>
<p>通过对比 lru 的值与当前时间，可计算某个对象的空转时间（object idletime）并打印出来。</p>
<p>lru 与 Redis 内存回收关系颇为密切。<br>如果 Redis 打开了 <code>maxmemory</code> 选项，且内存回收算法选择 <code>volatile-lru</code> 或 <code>allkeys-lru</code> 作为淘汰策略的话，当内存占用超过 maxmemory 阈值时，Redis 会优先选择 object idletime 最长的对象释放。</p>
<p><strong><big>4. refcount</big></strong>：主要用于对象引用计数和内存回收（计数法）</p>
<ul>
<li>创建新对象：refcount = 1</li>
<li>有新程序使用该对象：refcount + 1</li>
<li>对象不再被一个新程序使用：refcount - 1</li>
<li>refcount = 0：对象占用内存会被释放</li>
</ul>
<p>refcount &gt; 1，意味着该对象被多次使用，其被称为共享对象。<br>这就意味着当某些对象重复出现时，新程序不会创建新对象，而是仍然使用原来的对象；这样可以节省内存。</p>
<p>Redis 五种类型都可以使用共享对象，但仅支持整数值的字符串对象，因为这考虑到对内存和 CPU（时间）的平衡：</p>
<ul>
<li>共享对象虽然降低了内存消耗，但判断两个对象是否相等需消耗额外时间</li>
<li>整数值判断操作复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>；普通字符串为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>；列表等为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>Redis 服务器初始化时会创建 10000 个字符串对象：0 - 9999</p>
<ul>
<li>Redis 需要使用值为该范围其中的字符串对象时可直接使用。</li>
</ul>
<p>再说说刚刚提到的 SDS：</p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a><strong>SDS</strong></h2><p>全称 Simple Dynamic String，简单动态字符串，是 Redis 自己开发的字符串抽象类型。</p>
<p>所谓“动态”，意思是 Redis 能根据 redisObject 不同的值去对应上不同的编码，且进行自动扩展。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sds.h（Redis 3.2 之前）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;  <span class="comment">// buf 已使用的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">// buf 未使用长度</span></span><br><span class="line">    <span class="keyword">char</span> buf[];  <span class="comment">// 字节数组，len(buf)=len+free+1</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sds.h（Redis 3.2 之后，关于 SDS 有了多种结构：sdshdr5，sdshdr8，sdshdr16，sdshdr32，sdshdr64）</span></span><br><span class="line"><span class="comment">// sdshdr8：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;  <span class="comment">// 字符数组长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;  <span class="comment">// 字符数组总共分配内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;  <span class="comment">// 标记字符数组属性</span></span><br><span class="line">    <span class="keyword">char</span> buf[];  <span class="comment">// 字符数组，字符串真正的值</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// 相比于 Redis 3.2 之前的 sdshdr 优化了 5 个字节的空间，使 embstr 数据空间多了 5 字节</span></span><br></pre></td></tr></table></figure>
<p>SDS 在 C 字符串基础上加入了 <code>len</code> 和 <code>free</code>（<code>alloc</code>） 字段，是为了杜绝缓冲区溢出（C 字符串在没有进行足够的内存分配时，会存在缓冲区溢出的情况），并且能存储二进制数据；</p>
<p>同时 <code>len</code> 字段降低了原本 C 字符串读取字符长度的复杂度（从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 降为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>）；</p>
<p>另外，SDS 通过<strong>空间预分配</strong>和<strong>惰性空间释放</strong>来解决内存重新分配带来的性能问题：</p>
<ul>
<li>对 SDS 的值进行修改之后，如 SDS 的长度小于 1 M，此时分配的 len = free</li>
<li>如 &gt;= 1 M，就按照 1 M 分配</li>
<li>修改删除部分元素时，不及时释放，还保留空间（len 减少掉的数量加到 free 里）</li>
</ul>
<p>针对 C 字符串只能通过 ‘\0’ 判断字符串结束，且不能存储空字符串的特性，SDS 通过 len 字段判定结尾，且能够存储任意数据。</p>
<p>这也是 Redis 使用自己开发的字符串的原因。</p>
<p><br></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis 作为 NoSQL 类型的内存数据库，在内存中主要以键值对（key-value）的方式存储内容：</p>
<p><img src="/2021/07/29/redis-basics/redisobj.png" alt></p>
<p>其中“值”（value）的类型有：</p>
<p><strong><big>String</big></strong></p>
<ul>
<li>Redis 最基本的数据类型，扩展性非常高</li>
<li>上面已经提到过了：底层为字符数组，长度不超过 512 MB</li>
<li>Redis K-V 中的 key 只能为 String 类型</li>
<li>该类型二进制安全，可以包含任何数据，如 jpg 图像或者序列化的对象</li>
</ul>
<p>String 最简单的编码：</p>
<p><img src="/2021/07/29/redis-basics/redis-encoding-int.png" alt></p>
<p>String 编码转换：</p>
<ul>
<li>当 int 数据不再是整数，或大小超过 long 范围时，String 自动转为 raw 编码方式</li>
<li>因 embstr 的实现是只读：修改 String 的值时，要先将 embstr 转化为 raw，再进行修改</li>
</ul>
<p>String 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>set key value</td>
<td>将对应 key 赋值为 value</td>
</tr>
<tr>
<td>get key</td>
<td>获取 key 对应的 value 值</td>
</tr>
<tr>
<td>del key</td>
<td>删除 key</td>
</tr>
<tr>
<td>expire key seconds</td>
<td>设置 key 在 seconds 秒后过期</td>
</tr>
<tr>
<td>expireat key timestamp</td>
<td>设置 key 的超时时间至某个时间戳</td>
</tr>
<tr>
<td>setex key timeout value</td>
<td>如果 key 存在，则将值更新为 value，过期时间为 timeout 秒</td>
</tr>
<tr>
<td>ttl key</td>
<td>查看 key 还有多久过期</td>
</tr>
<tr>
<td>setnx key value</td>
<td>如果 key 不存在，就新增 key 和 value</td>
</tr>
<tr>
<td>strlen key</td>
<td>计算 key 对应 value 的长度</td>
</tr>
<tr>
<td>incr key</td>
<td>如果 key 对应的 value 值为 int 类型，则自增 1；否则报错</td>
</tr>
<tr>
<td>incrby key numbers</td>
<td>如果 key 对应的 value 值为 int 类型，则增加对应的值；否则报错</td>
</tr>
<tr>
<td>mset key1 value1 key2 value2 …</td>
<td>批量添加</td>
</tr>
<tr>
<td>mget key1 key2 key3 …</td>
<td>批量获取</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong><big>Hash</big></strong></p>
<ul>
<li>键值对（key-value）集合</li>
<li>本质为 String 类型的 field 和 value 的映射表</li>
<li>指令以 h 开头</li>
</ul>
<p>Hash 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset key name value</td>
<td>添加键值对 name、value 到 key 中</td>
</tr>
<tr>
<td>hget key name</td>
<td>查看键为 name 的 value 值</td>
</tr>
<tr>
<td>hmset key name1 value1 name2 value2</td>
<td>往 key 批量添加键值对</td>
</tr>
<tr>
<td>hmget key name1 name2</td>
<td>从 key 中批量获取值</td>
</tr>
<tr>
<td>hlen key</td>
<td>获取 key 的键值对数目</td>
</tr>
<tr>
<td>hgetall key</td>
<td>获取 key 中所有元素，包括键和值</td>
</tr>
</tbody>
</table>
</div>
<p>Hash 的编码：</p>
<p><img src="/2021/07/29/redis-basics/hash-encoding-ziplist.png" alt></p>
<p>ziplist 编码特点：如上，所有数据内存上连续，以实现快速访问。</p>
<p><img src="/2021/07/29/redis-basics/hash-encoding-hashtable.png" alt></p>
<p>当 hash 中键值对数量少于 512 个，且 key 和 value 的长度都小于某个字节长度阈值时，hash 采用 ziplist 编码，否则采用 hashtable 编码。</p>
<p><br></p>
<p><strong><big>List</big></strong></p>
<ul>
<li>简单的 String 列表，按照插入顺序排序</li>
<li>可添加至列表头（左）或尾（右）</li>
<li>相关操作指令以 l 开头</li>
</ul>
<p>List 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>lpush key value1 value2</td>
<td>往 key 的左侧插入 value1、value2 …</td>
</tr>
<tr>
<td>rpush key value1 value2</td>
<td>往 key 的右侧插入 value1、value2 …</td>
</tr>
<tr>
<td>lpop key</td>
<td>从 key 的左侧弹出元素</td>
</tr>
<tr>
<td>rpop key</td>
<td>从 key 的右侧弹出元素</td>
</tr>
<tr>
<td>llen key</td>
<td>查看 key 的长度（元素个数）</td>
</tr>
<tr>
<td>lindex key index</td>
<td>查看列表 key 中某个 index 对应的值</td>
</tr>
<tr>
<td>lrange key startIndex endIndex</td>
<td>查看指定范围内元素，下标从 0 开始</td>
</tr>
<tr>
<td>ltrim key startIndex endIndex</td>
<td>保留指定范围内元素，删除其他元素；下标从 0 开始</td>
</tr>
</tbody>
</table>
</div>
<p>List 的编码：</p>
<p><img src="/2021/07/29/redis-basics/list-encoding-ziplist.png" alt></p>
<p>在 Redis 3.2 之后，List 使用 quicklist 替换了原来的 ziplist；quicklist 的底层使用的还是 ziplist 的实现。</p>
<p><img src="/2021/07/29/redis-basics/list-encoding-linkedlist.png" alt></p>
<p><br></p>
<p><strong><big>Set</big></strong></p>
<ul>
<li>元素为 String 的无序不重复集合，通过哈希表实现</li>
<li>保存数字的时候是有序的</li>
<li>相关操作指令以 s 开头</li>
</ul>
<p>Set 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd key value1 value2</td>
<td>往集合 key 中添加元素 value1、value2 …</td>
</tr>
<tr>
<td>smembers key</td>
<td>查看集合 key 中的所有元素</td>
</tr>
<tr>
<td>sismember key value</td>
<td>查看 value 是否在集合 key 中</td>
</tr>
<tr>
<td>scard key</td>
<td>查询集合 key 的长度</td>
</tr>
<tr>
<td>spop key</td>
<td>取出集合 key 的一个元素</td>
</tr>
<tr>
<td>del key</td>
<td>删除集合 key</td>
</tr>
</tbody>
</table>
</div>
<p>Set 的编码：</p>
<p><img src="/2021/07/29/redis-basics/set-encoding-intset.png" alt></p>
<p>存入不多于 512 个纯整数时，Set 采用 intset 编码；否则均采用 hashtable 编码。</p>
<p><img src="/2021/07/29/redis-basics/set-encoding-hashtable.png" alt></p>
<p>Set 中的每个元素为 dictEntry 的 key，value 值为空。</p>
<p><br></p>
<p><strong><big>zset</big></strong>（Sorted Set）</p>
<ul>
<li>String 有序不重复集合，与 Set 类似</li>
<li>每个元素关联一个 double 类型的权重（score），Redis 根据权重从小到大排序</li>
<li>相关操作指令以 z 开头</li>
</ul>
<p>zset 类型相关指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>zadd key score1 value1 score2 value2</td>
<td>添加元素至集合 key 中；如果 value 相同，后输入的 score 会覆盖前面的 score</td>
</tr>
<tr>
<td>zscore key value</td>
<td>查看 value 的 score 值，输出 -∞ &lt; score &lt; +∞ 的所有元素</td>
</tr>
<tr>
<td>zrange key 0 -1</td>
<td>正序输出</td>
</tr>
<tr>
<td>zrangebyscore key -inf +inf</td>
<td>正序输出</td>
</tr>
<tr>
<td>zrevrange key 0 -1</td>
<td>倒序输出</td>
</tr>
<tr>
<td>zcard key</td>
<td>查看集合 key 的元素个数</td>
</tr>
<tr>
<td>zrangebyscore key indexStart indexEnd</td>
<td>输出集合 key 中 indexStart &lt;= score &lt;= indexEnd 的元素，正序排列</td>
</tr>
<tr>
<td>zrevrangebyscore key indexStart indexEnd</td>
<td>输出集合 key 中 indexStart &lt;= score &lt;= indexEnd 的元素，倒序排列</td>
</tr>
<tr>
<td>zrem key value</td>
<td>删除集合 key 中的 value</td>
</tr>
</tbody>
</table>
</div>
<p>zset 的编码：</p>
<p><img src="/2021/07/29/redis-basics/zset-encoding-ziplist.png" alt></p>
<p>ZIPLIST 会按照 score 的大小排序。</p>
<p>当数据量增大时，zset 会调整到跳表（skiplist）的编码模式：</p>
<p><img src="/2021/07/29/redis-basics/zset-encoding-skiplist.png" alt></p>
<p>为啥每种对象类型都有至少两种编码？</p>
<ol>
<li>接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响</li>
<li>可根据不同应用场景切换内部编码，提高效率</li>
</ol>
<p><img src="/2021/07/29/redis-basics/redis-type-encoding-mapping.png" alt></p>
<p>小结：</p>
<table>
    <tr>
        <th>类型</th>
        <th>编码（Redis 3.0）</th>
        <th>简介</th>
        <th>应用场景</th>
    </tr>
    <tr>
        <th rowspan="3">String (REDIS_STRING)</th>
        <td>REDIS_ENCODING_INT</td>
        <td>使用整数值实现的字符串对象</td>
        <td rowspan="3"></td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_EMBSTR</td>
        <td>使用 embstr 编码的 SDS 实现的字符串对象</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_RAW</td>
        <td>使用 SDS 实现的字符串对象</td>
    </tr>
    <tr>
        <th rowspan="2">Hash (REDIS_HASH)</th>
        <td>REDIS_ENCODING_ZIPLIST</td>
        <td>使用压缩列表实现的 hash 对象</td>
        <td rowspan="2">存储、读取、修改用户属性</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_HT</td>
        <td>使用字典实现的 hash 对象</td>
    </tr>
    <tr>
        <th rowspan="2">List (REDIS_LIST)</th>
        <td>REDIS_ENCODING_ZIPLIST</td>
        <td>使用压缩列表实现的列表对象</td>
        <td rowspan="2">最新消息排行；消息队列等功能</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_LINKEDLIST</td>
        <td>使用双向链表实现的列表对象</td>
    </tr>
    <tr>
        <th rowspan="2">Set (REDIS_SET)</th>
        <td>REDIS_ENCODING_INTSET</td>
        <td>使用整数集合实现的集合对象</td>
        <td rowspan="2">共同好友<br>点赞系统（不能重复点赞）<br>利用唯一性统计访问网站的所有独立 IP<br>好友推荐：根据 tag 求交集</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_HT</td>
        <td>使用字典实现的集合对象</td>
    </tr>
    <tr>
        <th rowspan="2">Sorted Set (REDIS_ZSET)</th>
        <td>REDIS_ENCODING_ZIPLIST</td>
        <td>使用压缩列表实现的有序集合对象</td>
        <td rowspan="2">排行榜<br>带权重的消息队列</td>
    </tr>
    <tr>
        <td>REDIS_ENCODING_SKIPLIST</td>
        <td>使用跳表和字典实现的有序集合对象</td>
    </tr>
</table>

<p>编码转换在 Redis 写入数据时完成，而且转换过程是不可逆的，只能从小内存编码向大内存编码转换。</p>
<p><br></p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>通过 <code>info memory</code> 来看 Redis 的内存统计：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; info memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:199960008</span><br><span class="line">used_memory_human:190.70M</span><br><span class="line">used_memory_rss:213798912</span><br><span class="line">used_memory_peak:201290832</span><br><span class="line">used_memory_peak_human:191.97M</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">mem_fragmentation_ratio:1.07</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br></pre></td></tr></table></figure>
<p>内存统计中各字段的含义：</p>
<p><code>used_memory</code>：Redis 内存分配器分配的内存总量（Byte），包括使用的虚拟内存（swap）。</p>
<p><code>used_memory_human</code>：used_memory 更友好的显示方式。</p>
<p><code>used_memory_rss</code>：Redis 进程占据操作系统的内存（Byte），与 top 和 ps 命令看到的值是一样的，包括：</p>
<ul>
<li>Redis 内存分配器分配的内存</li>
<li>Redis 进程运行本身需要的内存</li>
<li>内存碎片</li>
<li>…</li>
</ul>
<p>但并不包括虚拟内存。</p>
<p>注：<code>used_memory</code> 是从 Redis 得到的数量，而 <code>used_memory_rss</code> 则是从操作系统角度得到的量。两者的值不一样，是因为：</p>
<ol>
<li>Redis 进程运行需要占用内存，且存在着内存碎片的时候：前者会比后者小</li>
<li>当存在虚拟内存：前者会比后者大</li>
</ol>
<p><code>mem_fragmentation_ratio</code>：内存碎片比率，等于 used_memory_rss / used_memory。</p>
<ul>
<li>数值一般大于 1，1.03 为比较健康的状态；比率越大，内存碎片的占比就越大</li>
<li>数值小于 1，说明 Redis 使用了虚拟内存：要及时排查</li>
<li>在实际应用中，当 Redis 的数据量比较大时，进程运行所占用的内存与 Redis 数据量和内存碎片相比会小很多。</li>
</ul>
<p><code>mem_allocator</code>：定义 Redis 使用的内存分配器，在编译时指定</p>
<ul>
<li>可以是 libc, jemalloc 或 tcmalloc，默认使用 jemalloc</li>
</ul>
<p>以 jemalloc 为例：将内存空间划分为小、大、巨大三个范围，每个范围内划分许多小的内存块单位：</p>
<table>
    <tr>
        <th>Category</th>
        <th>Spacing</th>
        <th>Size</th>
    </tr>
    <tr>
        <th rowspan="7">Small</th>
        <td>8</td>
        <td>[8]</td>
    </tr>
    <tr>
        <td>16</td>
        <td>[16, 32, 48, ..., 128]</td>
    </tr>
    <tr>
        <td>32</td>
        <td>[160, 192, 224, 256]</td>
    </tr>
    <tr>
        <td>64</td>
        <td>[320, 384, 448, 512]</td>
    </tr>
    <tr>
        <td>128</td>
        <td>[640, 768, 896, 1024]</td>
    </tr>
    <tr>
        <td>256</td>
        <td>[1280, 1536, 1792, 2048]</td>
    </tr>
    <tr>
        <td>512</td>
        <td>[2560, 3072, 3584]</td>
    </tr>
    <tr>
        <th>Large</th>
        <td>4 KiB</td>
        <td>[4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB]</td>
    </tr>
    <tr>
        <th>Huge</th>
        <td>4 MiB</td>
        <td>[4 MiB, 8 MiB, 12 MiB, ...]</td>
    </tr>
</table>

<p><br></p>
<p>综上，Redis 的内存占用主要有以下部分：</p>
<p><strong>1. 数据</strong></p>
<ul>
<li>最主要的部分，其占用的内存被统计在 used_memory 中</li>
<li>每种数据类型可能有两种或更多的内部编码实现</li>
<li>存储数据对象时，并不是直接将数据扔进内存，而是对对象进行各种包装：如 redisObject、SDS 等</li>
</ul>
<p><strong>2. 进程本身运行需要的内存</strong></p>
<ul>
<li>包括代码、常量池等内容，不由 jemalloc 去分配，因此不会统计在 used_memory 中</li>
<li>在大多数场景中，这部分的内存占用可忽略</li>
<li>除主进程外，Redis 创建的子进程（如执行 AOF、RDB 重写时创建的子进程）也会占用内存：<ul>
<li>这部分内存并不属于 Redis 进程，因此不会统计在 used_memory 和 used_memory_rss 中</li>
</ul>
</li>
</ul>
<p><strong>3. 缓冲内存</strong>，包括：</p>
<ul>
<li>客户端缓冲区：存储客户端连接的输入输出缓冲</li>
<li>复制积压缓冲区：用于部分复制功能</li>
<li>AOF 缓冲区：在进行 AOF 重写时，保存最近的写入命令</li>
<li>…</li>
</ul>
<p><strong>4. 内存碎片</strong>：Redis 分配、回收物理内存过程中产生的。</p>
<p>产生的原因：<br>比如：对内存中的数据更改频繁，且数据之间的大小相差很大，会导致 Redis 释放的空间在物理内存中并没有释放，但 Redis 又无法有效利用这些物理内存。由此便会产生内存碎片。</p>
<p>内存碎片的产生，和对数据进行的操作、数据的特点等有关；也和使用的内存分配器有关。</p>
<ul>
<li>如内存分配器设计合理，可以尽可能减少内存碎片产生</li>
<li>如内存碎片很大，可以通过安全重启减小内存碎片：重启后 Redis 重新从备份文件中读取数据，在内存中进行重排</li>
</ul>
<p>内存碎片不会被统计在 used_memory 中。</p>
<h2 id="数据存储的细节"><a href="#数据存储的细节" class="headerlink" title="数据存储的细节"></a>数据存储的细节</h2><p><code>dictEntry</code> 对应的是 Redis 的每个键值对，存储着指向 key 和 val 的指针；<br>其中 val 的数据结构是一个联合体（union）。<br>另外，每一个 dictEntry 都有一个 next 指针指向下一个 dictEntry。</p>
<p>例：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hello world</span><br></pre></td></tr></table></figure></p>
<ul>
<li>key 为 “hello”：存储于 SDS 中</li>
<li>val 为 “world”：存储于 redisObject 中<ul>
<li>字符串对象 “world” 存储于 SDS</li>
<li><code>type</code>：指明 val 对象的类型；因为指令是 set，所以对应类型为 REDIS_STRING</li>
<li><code>ptr</code>：指向字符串对象所在地址</li>
</ul>
</li>
<li>Redis 的内存分配器分配内存：dictEntry 有三个指针，占用 24 字节，分配器就会分配 32 字节。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>当 Redis 内存不足的时候，服务有可能限制缓存写入，且淘汰策略开始起作用，可能导致 key 频繁被逐出、响应时间上升、QPS 不稳定等问题，影响业务的运行。</p>
<p>Redis 的 <code>MEMORY DOCTER</code> 指令会提供内存诊断提议。</p>
<p>同时可以优化内存的使用率：</p>
<ol>
<li>查询现有 key 是否符合业务预期，及时清理无用的 key；</li>
<li>分析大 key 分布和 TTL 过期策略；</li>
<li>从业务方向对大 key 进行拆分；</li>
<li>根据业务，设置合理的数据驱逐策略和过期 key 的删除频率；</li>
<li>升级内存</li>
</ol>
<p><br></p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>最大的优点：<big><strong>快</strong></big></p>
<p>Redis 是单进程单线程的模型，对于数据的操作完全基于内存，因此 CPU 不是瓶颈；而且单线程容易实现。</p>
<p>为何 Redis 是单线程模型，处理起来还仍然这么快？</p>
<ul>
<li>数据结构简单，对数据的操作也简单</li>
<li>数据存储类似于 HashMap：查找和操作的时间复杂度是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
<li>采用单线程，避免不必要的上下文切换和竞争条件</li>
<li>使用非阻塞 IO</li>
</ul>
<p><br></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Redis 最大的用途就是缓存系统。而缓存系统需要关注以下三个问题：</p>
<ul>
<li>缓存击穿（失效）</li>
<li>缓存穿透</li>
<li>缓存雪崩</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>指的是流量访问数据的地点应该是缓存系统，然而缓存系统中的<strong>某些缓存数据失效</strong>（过期），导致缓存系统被“击穿”，流量直接打到数据库访问数据。</p>
<p>此时数据库可能因为高并发导致反应缓慢，甚至不可用。</p>
<p>解决方案：</p>
<ul>
<li>对于某些缓存数据，如热点数据，不设置过期时间，或者给过期时间添加随机值，避免大量缓存数据集中在一个时间点过期，给数据库造成压力；</li>
<li>预热：预先将重要缓存数据保存到 Redis 中；</li>
<li>锁：缓存失效时先获取分布式锁，获取成功后才执行数据库操作</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>比击穿还彻底：请求缓存和数据库<strong>均不存在</strong>的数据。这样的并发请求会很大程度上影响数据库运行。</p>
<p>解决方案：</p>
<ul>
<li>缓存空值</li>
<li>BloomFilter 布隆过滤器：在数据写入数据库的同时，将 id 同步到布隆过滤器中；当请求的 id 不存在于布隆过滤器里面，则说明该请求查询的数据一定没有在数据库中保存，就不要去数据库查询了。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是大量的请求无法在缓存系统中处理，从而请求全部打到数据库，导致数据库压力激增，甚至宕机。</p>
<p>原因主要有两种：</p>
<ul>
<li>大量缓存同时过期，导致大量请求需要查询数据库并写到缓存；</li>
<li>缓存服务出现异常导致故障宕机。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>对于某些缓存数据，如热点数据，不设置过期时间，或者给过期时间添加随机值，避免大量缓存数据集中在一个时间点过期，给数据库造成压力；</li>
<li>接口限流：在业务系统的请求入口控制单位时间请求数，避免过多的请求被发送到数据库；</li>
<li>对缓存服务采取服务熔断和接口限流措施；有必要时构建高可用缓存集群系统</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>可以使用 list 实现消息队列。基本操作与模型的对应如下：</p>
<p><img src="/2021/07/29/redis-basics/list-message-queue.png" alt></p>
<p>基于主流配置，结合生产者与消费者的模型如下：</p>
<p><img src="/2021/07/29/redis-basics/list-message-queue-model.png" alt></p>
<p>可以使用 <code>blpop</code> 或 <code>brpop</code> （<code>b</code> 表示阻塞 blocking）实现“拉”的消息获取。</p>
<ul>
<li>不过，因为操作会一直阻塞 list，Redis 监测到一段时间 list 没有消息，会抛出异常，令 MQ 终止。</li>
<li>因此实现消息队列时需要捕获这种异常并加以处理（重建队列，…）</li>
</ul>
<p>如果要实现延时队列的话，需要将模型改为 <code>zset</code>，给某一个时段进入的消息赋予一定的 score，然后通过对应操作（如 <code>zrangebyscore</code>）获取消息。</p>
<p>因为市面上成熟的 AMQP 产品很多，同时 MySQL 也有消息队列功能提供，一般不会使用 Redis 来做消息队列。</p>
<p><br></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>应用中如有多个服务对同一数据进行操作，JVM 的锁机制并不能满足，只能通过分布式锁解决。<br>如下图中的场景，服务 A 和服务 B 中的 JVM 锁就不能相互对对方起约束作用：</p>
<p><img src="/2021/07/29/redis-basics/distributed-lock.png" alt></p>
<p>概述：</p>
<ul>
<li>加锁操作：<code>setnx</code> + 过期时间 -&gt; <code>set key value ex timeout nx</code></li>
<li>解锁：<code>del key</code>，原子性操作</li>
</ul>
<p>实现要点：</p>
<ol>
<li>加锁和解锁的 key 一定要一致，要不然无法解锁，再多的 <code>setnx</code> 指令都是白费。</li>
<li>不能永久加锁，一定要加上过期时间；越来越多永久的锁存在于内存中，系统会受不了的。</li>
<li>一定要保证加锁和设置过期时间的<strong>原子性</strong>。</li>
</ol>
<p>有必要的话，分布式锁要支持过期<strong>续租</strong>（协程实现 watchdog） / <strong>可重入</strong>分布式锁（Redisson 客户端，原理与 ReentrantLock 类似）。</p>
<h3 id="雷区"><a href="#雷区" class="headerlink" title="雷区"></a>雷区</h3><p><strong>1. 锁过期</strong>：获得锁的线程因为各种原因还没操作完，锁就过期释放了。</p>
<p>解决方法：根据业务设定合适的加锁时间。</p>
<p><strong>2. 重叠解锁</strong>：基于锁过期引发的另一个严重问题</p>
<ul>
<li>甲线程在获得锁之后，在未执行完任务的情况下锁就过期了；</li>
<li>此时乙线程拿到锁并执行任务，在其未执行完毕的时候，甲执行完毕，并进行解锁操作；</li>
<li>因为甲线程所加的锁早已过期，此时甲线程的解锁操作解掉的是<strong>乙线程获得的锁</strong>，此时锁又被释放；</li>
<li>以此类推，当丙线程进来了，获得锁但未执行完任务，乙线程执行完毕并解锁的时候，解掉的是丙线程加的锁；以此反复，就会出现很大的问题。</li>
</ul>
<p>解决方法：加锁（set 操作）的时候，value 带上<strong>唯一标识</strong>（如线程 ID），就会避免解错锁的情况。</p>
<p><strong>3. 单点问题</strong></p>
<p>在 Redis <strong>集群环境</strong>中，甲线程获得锁之后，将信息保存到主节点；<br>在信息同步至从节点的过程中，主节点挂掉了（……）；从节点会升级为主节点，但是它并没有保存到甲线程获取到锁的信息，导致锁会被其它线程获取到。</p>
<p>解决方法：<strong>Redlock</strong> 算法</p>
<p><br></p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 最大的弊端在于其是内存数据库，万一宕机，数据就没有了。因此 Redis 需要持久化，以便服务重新启动时能恢复数据。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>全称 <strong>R</strong>edis <strong>D</strong>ata<strong>B</strong>ase，将当前进程数据生成快照保存到硬盘。支持手工执行和服务器定时执行。</p>
<p>分两种命令：</p>
<p>SAVE：阻塞当前 Redis 服务器，直到 RDB 过程完成。</p>
<ul>
<li>对于内存比较大的实例会造成长时间的阻塞</li>
<li>已被逐渐废弃，线上环境不建议使用</li>
</ul>
<p>BGSAVE (<strong>B</strong>ack<strong>G</strong>round <strong>SAVE</strong>)</p>
<ul>
<li>Redis 进程执行 fork 操作创建子进程，由该子进程负责 RDB 的持久化，完成后自动结束</li>
<li>由此可知，定时执行初始化使用的就是 BGSAVE</li>
<li>阻塞只发生在 fork 阶段，只占很短的一段时间</li>
<li>系统的条件检测器 Server Cron 每 <strong>100ms</strong> 进行一次条件检测，满足备份条件才会创建子进程执行持久化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
<p>相关的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redis.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> {</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// save point 数组，下面会介绍</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span>  <span class="comment">/* Save points array for RDB */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计数器。记录上一次成功执行 SAVE 或 BGSAVE 后，数据进行了多少次修改（写入、删除、更新等）</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> dirty;  <span class="comment">/* Changes to DB from the last save */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 例：</span></span><br><span class="line">	<span class="comment">// set key "value": dirty 计数器加 1</span></span><br><span class="line">	<span class="comment">// sadd key "value1" "value2" "value3": dirty 计数器加 3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录上一次成功执行 SAVE 或 BGSAVE 的时间</span></span><br><span class="line">	<span class="keyword">time_t</span> lastsave;  <span class="comment">/* Unix time of last successful save */</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> {</span>  <span class="comment">// 能否执行定时操作的标准</span></span><br><span class="line">	<span class="comment">// 执行时长</span></span><br><span class="line">	<span class="keyword">time_t</span> seconds;</span><br><span class="line">	<span class="comment">// 修改次数</span></span><br><span class="line">	<span class="keyword">int</span> changes;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>saveparam</code> 相当于 redisServer 的配置项。意思是：在 seconds 时间内执行了 changes 次修改之后，服务器会定时执行 BGSAVE 操作进行持久化。</p>
<p>以当前时间戳减去 lastsave，结果如果大于 seconds，即满足持久化条件；以 dirty 值与 changes 比较，如果比 changes 大即满足持久化条件。</p>
<p><img src="/2021/07/29/redis-basics/rdb.png" alt></p>
<p>当 RDB 文件比较大时，Redis 服务启动的时候需要耗费较多的时间。</p>
<p><br></p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>全称 <strong>A</strong>ppend <strong>O</strong>nly <strong>F</strong>ile。通过记录<strong>所有执行过的 redis 命令</strong>来记录数据库的变更。<br>命令被执行之后并没有马上结束，而是继续由 Redis 服务器将命令保存至 AOF 文件中。</p>
<p>AOF 频率比 RDB 高；如果开启了 AOF 开关，服务器启动时会先执行 AOF 加载 AOF 文件，否则会执行 RDB。</p>
<p>相关的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redis.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> {</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲区，以请求协议格式保存每一个被执行完的写命令的地方</span></span><br><span class="line">	sds aof_buf  <span class="comment">/* AOF buffer, written before entering the event loop */</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/29/redis-basics/aof.png" alt></p>
<p>多提一嘴：其实真正的写入文件，是包括写入和同步的：</p>
<p><img src="/2021/07/29/redis-basics/write-sync.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 开关</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span>  <span class="comment"># 文件名</span></span><br></pre></td></tr></table></figure>
<p>比较一下这三种写入策略：</p>
<p><code>appendfsync always</code>：将 aof_buf 的内容写入并同步到 AOF 文件中，真正地将指令写入了磁盘</p>
<ul>
<li>优点：能够保证基本数据不丢失</li>
<li>缺点：效率低，给磁盘带来的压力很大</li>
</ul>
<p><code>appendfsync everysec</code>：将 aof_buf 的内容先行写入 AOF 文件中；若上次同步时间距今超过 1 秒，则进行 AOF 同步</p>
<ul>
<li>默认设置</li>
</ul>
<p><code>appendfsync no</code>：将 aof_buf 的内容先行写入 AOF 文件中，但不同步 AOF 文件；何时同步由操作系统决定。</p>
<p>由此显而易见，AOF 的<strong>缺陷</strong>是：文件会增长。<br>不仅会占用大量的空间，还会拖慢 Redis 服务启动时数据的加载速度。</p>
<p>打个比方，一顿操作之后，最后的数据结构里只有两个元素，AOF 却可能记录了上百条执行过的命令，当中有大部分大概率是浪费的。</p>
<h3 id="改进：AOF-重写"><a href="#改进：AOF-重写" class="headerlink" title="改进：AOF 重写"></a>改进：AOF 重写</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  <span class="comment"># 比上一次 AOF 重写后体量超过了 100%</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb  <span class="comment"># AOF 文件超过 64 MB</span></span><br><span class="line"><span class="comment"># 两个指令是 且 的关系，同时满足才触发 AOF</span></span><br></pre></td></tr></table></figure>
<p>每执行一次重写，会有大量的写入操作，如果让主线程去干这个事的话，主线程会被长时间阻塞；<br>因此解决的办法是：Redis fork 一个子进程去做这个事情。</p>
<p>但是这又会带来另一个问题：主进程一直在接收新指令，子进程发起重写时，重写数据会与数据库数据不一致。<br>针对数据不一致的情况，Redis 服务器设置了一个 AOF 缓冲区：</p>
<ul>
<li>Redis 接收一个指令的时候，除了执行处理之外，还会将它放在 AOF 缓冲区和 AOF <strong>重写缓冲区</strong>；</li>
<li>子进程重写完毕后，会通知回主进程，随后主进程阻塞，将 AOF 重写缓冲区的内容 append 到 AOF 文件中。</li>
</ul>
<p><img src="/2021/07/29/redis-basics/aof-rewrite.png" alt></p>
<p>由上图可知，基于重写的 AOF，每次重写的<strong>不是旧的 AOF 文件</strong>，而是基于 DB 数据创建新的文件。</p>
<p><br></p>
<h1 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h1><p>我们可以将数据分隔到多个 Redis 实例，每个实例只保存所有 key 的一个子集。</p>
<p>优势：</p>
<ul>
<li>通过利用多台计算机内存构造更大数据库，扩展计算能力</li>
</ul>
<p>不足：</p>
<ul>
<li>涉及多个 key 的操作通常不被支持</li>
<li>处理多个持久化文件</li>
</ul>
<p>分区策略：</p>
<ul>
<li>按照范围分区</li>
<li>按照 hash 分区</li>
</ul>
<p><br></p>
<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p><img src="/2021/07/29/redis-basics/redis-cluster.png" alt></p>
<p>master 支持数据的更新和修改，slave 只支持数据的查看。</p>
<p>同时，Redis 的主从切换，需要 Redis Sentinel 的支持。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式（Singleton）</title>
    <url>/2021/06/19/singleton/</url>
    <content><![CDATA[<p>单例模式应该是众多设计模式中最容易被引用，最容易理解的了，但是也最容易出问题。今天写个帖记录一下。</p>
<span id="more"></span>
<p>单例模式（Singleton）属于对象创建型模式。在《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“保证一个类仅有一个实例，并提供一个对该实例的全局访问点。”
</code></pre><p><br></p>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul>
<li>在很多开发场景中，整个系统只需要拥有一个该类的全局对象：有利于协调系统整体的行为</li>
<li>让类保证没有其他实例可以被创建</li>
</ul>
<p><br></p>
<h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><ul>
<li>适合在公用场合使用，如多个模块使用同一个数据源连接对象等场景</li>
<li>这类实例可以为：<ul>
<li>需要频繁实例化然后销毁的对象</li>
<li>创建对象时耗时过多或耗资源过多，但又经常用到的对象</li>
<li><strong>有状态</strong>的工具类对象</li>
<li>频繁访问数据库或文件的对象</li>
</ul>
</li>
</ul>
<p>此时：</p>
<ul>
<li>类只能有一个实例，客户可从一个众所周知的访问点访问它</li>
<li>或：这个唯一实例可以通过子类化扩展，且客户应该无需代码改动就能使用一个扩展的实例</li>
</ul>
<h2 id="工具类的选型：使用单例模式还是静态方法"><a href="#工具类的选型：使用单例模式还是静态方法" class="headerlink" title="工具类的选型：使用单例模式还是静态方法"></a>工具类的选型：使用单例模式还是静态方法</h2><ul>
<li>如果是没有配置信息的工具类：使用静态类，随处调用，不需引用；</li>
<li>如果是有配置信息的工具类：（考虑到配置信息的不同带来的对象<strong>状态的改变</strong>）单例模式优先，比如有多个数据源的情况就可以用单例模式。</li>
</ul>
<p><br></p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2021/06/19/singleton/singleton-diagram.png" alt></p>
<p>以上，可见单例模式就包括一个角色：</p>
<p><code>Singleton</code></p>
<ul>
<li>定义一个 Instance 操作（类操作），允许客户访问它的唯一实例</li>
<li>可能也会负责创建它自己的唯一实例</li>
</ul>
<p><br></p>
<h1 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h1><p>客户只能通过 Singleton 的 <code>instance()</code> 操作访问一个 Singleton 实例</p>
<p><br></p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><ul>
<li>对唯一实例的受控访问<ul>
<li>Singleton 类封装它的唯一实例</li>
<li>严格控制客户怎样以及何时访问它</li>
<li>能够节省内存，加快对象的访问速度</li>
</ul>
</li>
<li>缩小 namespace<ul>
<li>属于对全局变量的改进</li>
<li>避免存储唯一实例的全局变量污染 namespace</li>
</ul>
</li>
<li>允许对操作和表示的精细化<ul>
<li>Singleton 类可以有子类：使用一个扩展类的实例去配置一个应用，是很容易的</li>
<li>可以在运行时刻配置应用</li>
</ul>
</li>
<li>允许可变数目的实例<ul>
<li>控制应用所使用的实例数目</li>
<li>只有允许访问 Singleton 实例的操作需要改变</li>
</ul>
</li>
<li>比类操作更灵活</li>
</ul>
<p><br></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="1-保证一个唯一的实例"><a href="#1-保证一个唯一的实例" class="headerlink" title="1. 保证一个唯一的实例"></a>1. 保证一个唯一的实例</h2><ul>
<li>该唯一实例是类的一般实例，但应用里只有一个实例能被创建<ul>
<li>创建实例的操作隐藏在类操作（静态成员函数或者类方法）后面</li>
<li>使用全局/静态对象的缺点：所有单例无论用到与否都要被创建</li>
</ul>
</li>
<li>一个类能够返回对象的一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法）</li>
<li>客户仅通过 <code>getInstance()</code> 访问该单例</li>
<li>由此，其他代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法（<code>getInstance()</code>）来得到该类的唯一实例。</li>
</ul>
<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优点：没有线程安全问题，简单</span></span><br><span class="line"><span class="comment">     * 缺点：提前初始化会延长类加载器加载类的时间；如果不使用会浪费内存空间；不能传递参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式（Lazy）单例"><a href="#懒汉式（Lazy）单例" class="headerlink" title="懒汉式（Lazy）单例"></a>懒汉式（Lazy）单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ClazzName clazz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClazzName</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 单例实例 1</span></span><br><span class="line"><span class="comment"> * 当调用该方法时，如果类持有的引用不为空，就返回这个引用</span></span><br><span class="line"><span class="comment"> * 如果类保持的引用为空，就创建该类的实例，并将实例的引用赋予该类保持的引用</span></span><br><span class="line"><span class="comment"> * 同时，将该类的构造函数定义为私有的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClazzName <span class="title">getInstance1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = <span class="keyword">new</span> ClazzName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例实例 2：静态内部类</span></span><br><span class="line"><span class="comment"> * Java 中的静态变量和静态代码块是在类加载的时候就执行的</span></span><br><span class="line"><span class="comment"> * 成员变量随着对象的创建而存在，随着对象的被回收而释放；</span></span><br><span class="line"><span class="comment"> * 静态变量随着类的加载而存在，随着类的消失而消失；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 优点：解决线程安全，延迟初始化（Effective Java 推荐写法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClazzName <span class="title">getInstance2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不会新建对象，而是从静态内部类中取</span></span><br><span class="line">    <span class="keyword">return</span> Holder.SINGLE_TON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：静态内部类的加载不需要依附外部类，其在使用时才会被加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初次：在运行时常量池将符号引用替换为直接引用，此时静态变量被创建</span></span><br><span class="line">    <span class="comment">// JVM 执行类的加载并随后初始化的时候，在多线程环境中有自动加锁和同步机制</span></span><br><span class="line">    <span class="comment">// 多个创建静态内部类的请求最终只会创建一个实例，由此解决线程安全问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClazzName SINGLE_TON = <span class="keyword">new</span> ClazzName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/19/singleton/singleton-new-instance.png" alt></p>
<p>虽然简单，但是缺点是：并发高的情况下会阻塞；仅能实现静态变量的延迟初始化；不能传递参数</p>
<h3 id="双重检查锁（Double-checked-Locking）"><a href="#双重检查锁（Double-checked-Locking）" class="headerlink" title="双重检查锁（Double-checked Locking）"></a>双重检查锁（Double-checked Locking）</h3><p>常见于多线程环境下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;  <span class="comment">// 禁止重排序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nuniqueSingleton == <span class="keyword">null</span>) &#123;  <span class="comment">// 空值判断 1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;  <span class="comment">// 空值判断 2</span></span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<p><strong>1. 使用 <a href="/2021/07/14/keywords/#volatile"><code>volatile</code></a> 限制指令重排序：</strong><br>背景：执行程序时为了提高性能，处理器和编译器常会对指令重排序<br>重排序的准则：</p>
<ol>
<li>单线程环境下不能改变程序运行的结果（不影响数据的结果）</li>
<li>存在数据依赖关系的指令集不允许重排序</li>
</ol>
<p>如双重检查锁中的 uniqueSingleton：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><br>包含以下三步：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1. 分配内存空间</span></span><br><span class="line">ctorInstance(memory);  <span class="comment">// 2. 初始化对象</span></span><br><span class="line">uniqueSingleton = memory;  <span class="comment">// 3. 将对象指向刚分配的内存空间</span></span><br></pre></td></tr></table></figure></p>
<p>有些编译器为了性能原因，可能会将第二步和第三步重排序，结果变成了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1. 分配内存空间</span></span><br><span class="line">uniqueSingleton = memory;  <span class="comment">// 3. 将对象指向刚分配的内存空间（对象还没被初始化）</span></span><br><span class="line">ctorInstance(memory);  <span class="comment">// 2. 初始化对象</span></span><br></pre></td></tr></table></figure></p>
<p>如果不禁止重排序的话，考虑两个线程访问单例，在时间片中如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间片 Time</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T1</td>
<td>检查到 uniqueSingleton 为空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td>获取锁</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td>再次检查到 uniqueSingleton 为空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>T4</strong></td>
<td>为 uniqueSingleton 分配内存空间</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>T5</strong></td>
<td>将 uniqueSingleton 指向内存空间</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">T6</td>
<td></td>
<td>检查到 uniqueSingleton 不为空</td>
</tr>
<tr>
<td style="text-align:center">T7</td>
<td></td>
<td>访问 uniqueSingleton（此时该对象还未完成初始化）</td>
</tr>
<tr>
<td style="text-align:center"><strong>T8</strong></td>
<td>初始化 uniqueSingleton</td>
</tr>
</tbody>
</table>
</div>
<p>由上，可以发现 A 线程从时间片 T4 开始的步骤是经过重排序的，结果会导致 B 线程访问到的是一个还没初始化的对象。<br>因此使用 volatile 禁止重排序，所有对变量的读操作（将对象指向刚分配的内存空间）必须发生在写操作（分配内存空间，及初始化对象）之后。</p>
<p><br></p>
<p><strong>2. 双重检查 null</strong><br>情景：两个线程同时在初始化 context 中调用 getInstance()<br>此时 singleton == null，两个线程均可通过第一层空值判断。</p>
<ul>
<li>随后，两个线程中的一个获取锁。如果没有第二层空值判断的话，先获得锁的线程创建完单例，释放锁之后，<strong>另一个线程随即获得锁，仍然会去创建单例</strong>，停不下来了。</li>
<li>此时单例变多例，违反了设计模式。</li>
</ul>
<p>因此加上第二层空值判断，这样的话前面的线程获得锁，创建完单例后释放锁，随后的线程经过空值判断之后，就不会重新创建单例了。</p>
<p>如果没有第一层空值判断：看似是可以实现了单例模式，但是<strong>每一个进程访问都需要进入一次锁</strong>，非常消耗性能。<br>在 Java 6 及之前会带来很大的性能消耗，Java 7 开始引入了锁的升级机制，大大优化性能。</p>
<p><br></p>
<h2 id="2-创建-Singleton-的子类"><a href="#2-创建-Singleton-的子类" class="headerlink" title="2. 创建 Singleton 的子类"></a>2. 创建 Singleton 的子类</h2><ul>
<li>在 Singleton 的 getInstance() 操作中决定想使用哪一个单例</li>
<li>或：将 getInstance() 的实现放入子类中<ul>
<li>直接链接：难以在运行时选择单例</li>
<li>条件语句：硬性规定了可能的单例组合</li>
<li>使用注册表</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Singleton* <span class="title">Singleton::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_instance) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* singletonName = <span class="built_in">getenv</span>(<span class="string">&quot;SINGLETON&quot;</span>);</span><br><span class="line">        <span class="comment">// user or environment supplies this at startup</span></span><br><span class="line"></span><br><span class="line">        _instance = <span class="built_in">Lookup</span>(singletonName);</span><br><span class="line">        <span class="comment">// Lookup returns 0 if there’s no such singleton</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><p>很多的设计模式都可用 Singleton 实现，如 Abstract Factory，Builder，Prototype 等</p>
<p><br></p>
<h1 id="Spring-Framework-中单例的应用"><a href="#Spring-Framework-中单例的应用" class="headerlink" title="Spring Framework 中单例的应用"></a>Spring Framework 中单例的应用</h1><p>多个客户端请求同一个服务时：容器给每一个请求分配一个线程<br>此时：多个线程会并发执行该请求所对应的业务逻辑（对应成员方法）</p>
<p>如该业务逻辑有对单例状态的修改（改变单例的成员属性）：必须考虑<strong>线程同步</strong>问题。</p>
<ol>
<li><strong>有状态</strong>单例（<strong>Stateful Bean</strong>）：有数据存储功能<ul>
<li>有实例变量的对象，可以保存数据，非线程安全</li>
<li>在不同方法调用间不保留任何状态</li>
</ul>
</li>
<li><strong>无状态</strong>单例（<strong>Stateless Bean</strong>）：一次性操作，不存储数据，是不变类<ul>
<li>没有实例变量的对象，不能保存数据，线程安全</li>
</ul>
</li>
</ol>
<h2 id="Bean-的单例实现"><a href="#Bean-的单例实现" class="headerlink" title="Bean 的单例实现"></a>Bean 的单例实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 充当了 Bean 实例的缓存，实现方式和单例注册表相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map singletonCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Class requiredType, Object[] args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对传入的 Bean name 稍做处理，防止传入的 Bean name 名有非法字符(有则做转码)</span></span><br><span class="line">        String beanName = transformedBeanName(name);</span><br><span class="line">        Object bean = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 手工检测单例注册表</span></span><br><span class="line">        Object sharedInstance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 使用了代码锁定同步块，原理和同步方法相似，但是这种写法效率更高</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">            sharedInstance = <span class="keyword">this</span>.singletonCache.get(beanName); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span>) &#123;  <span class="comment">// 非空判断 1</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 返回合适的缓存 Bean 实例</span></span><br><span class="line">            bean = getObjectForSharedInstance(name, sharedInstance);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 取得 Bean 的定义</span></span><br><span class="line">            RootBeanDefinition mergedBeanDefinition = getMergedBeanDefinition(beanName, <span class="keyword">false</span>);</span><br><span class="line">            ... </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 Bean 定义判断，此判断依据通常来自于组件配置文件的单例属性开关 </span></span><br><span class="line">            <span class="comment">// &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot; scope=&quot;singleton&quot;/&gt;</span></span><br><span class="line">            <span class="comment">// 如果是单例，做如下处理</span></span><br><span class="line">            <span class="keyword">if</span> (mergedBeanDefinition.isSingleton()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;  <span class="comment">// 同步锁</span></span><br><span class="line">                    <span class="comment">// 再次检测单例注册表</span></span><br><span class="line">                    sharedInstance = <span class="keyword">this</span>.singletonCache.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (sharedInstance == <span class="keyword">null</span>) &#123;  <span class="comment">// 非空判断 2</span></span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 真正创建 Bean 实例</span></span><br><span class="line">                            sharedInstance = createBean(beanName, mergedBeanDefinition, args);</span><br><span class="line">                            <span class="comment">// 向单例注册表注册 Bean 实例</span></span><br><span class="line">                            addSingleton(beanName, sharedInstance);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">                            ...</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForSharedInstance(name, sharedInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是非单例，即 prototpye，每次都要新创建一个 Bean 实例 </span></span><br><span class="line">            <span class="comment">// &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;/&gt; </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                bean = createBean(beanName, mergedBeanDefinition, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Controller-默认是单例的"><a href="#Controller-默认是单例的" class="headerlink" title="Controller 默认是单例的"></a><strong>Controller 默认是单例的</strong></h2><p>因此不要在 Controller 中使用非静态的成员变量，否则会发生数据逻辑混乱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testScope&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testScope2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScope2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先访问 http://localhost:8080/testScope，得到 1；</span></span><br><span class="line"><span class="comment">// 然后访问 http://localhost:8080/testScope2，得到 2。</span></span><br></pre></td></tr></table></figure>
<h2 id="单例对象的生命周期"><a href="#单例对象的生命周期" class="headerlink" title="单例对象的生命周期"></a>单例对象的生命周期</h2><p>单例对象与容器共存亡：</p>
<ul>
<li>出生：容器创建其时，对象出生。(立即创建或者延迟创建)</li>
<li>活着：只要容器在，对象就一直活着。</li>
<li>死亡：容器被销毁之后，对象消亡。</li>
</ul>
<h2 id="多例对象的生命周期"><a href="#多例对象的生命周期" class="headerlink" title="多例对象的生命周期"></a>多例对象的生命周期</h2><ul>
<li>出生：当我们使用对象时，Spring 框架为我们创建对象。(延迟创建)</li>
<li>活着：对象只要在使用过程中就一直活着。</li>
<li>死亡：当对象长时间不用且没有别的对象引用时，由 Java 垃圾回收器回收。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2023/05/27/red-black/</url>
    <content><![CDATA[<p>红黑树同样是自平衡二叉查找树，是较于 <a href="/2023/05/26/avl">AVL 树</a>对性能、功能、空间开销的折中结果。</p>
<span id="more"></span>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>红黑树（Red-Black tree），属于自平衡二叉查找树，树中每一个节点的颜色是<strong>黑色</strong>或者<font color="red"><strong>红色</strong></font>。</p>
<p>如例图所示，红黑树需满足：</p>
<ol>
<li>节点是<font color="red"><strong>红色</strong></font>或者<strong>黑色</strong></li>
<li>根节点是<strong>黑色</strong></li>
<li>所有的叶子都是<strong>黑色</strong>（外部节点，即 NIL 节点）</li>
<li>每个<font color="red"><strong>红色</strong></font>节点必须有两个<strong>黑色</strong>的子节点<ul>
<li>即：从每个叶子到根的所有路径上<strong>不能有两个连续的<font color="red">红色</font>节点</strong></li>
</ul>
</li>
<li>从任一节点到其每个叶子的所有简单路径都包含数量相同的<strong>黑色</strong>节点<ul>
<li>即：所有根至外部节点路径上有相同数目的<strong>黑色</strong>节点</li>
</ul>
</li>
</ol>
<p><img src="/2023/05/27/red-black/rb-tree1.png" alt></p>
<p>另一种要求：源于节点及其子女间指针的颜色</p>
<ol>
<li>从父节点到<strong>黑色</strong>孩子的指针是<strong>黑色</strong></li>
<li>从父节点到<font color="red"><strong>红色</strong></font>孩子的指针是<font color="red"><strong>红色</strong></font></li>
<li>内部节点指向外部节点的指针是<strong>黑色</strong></li>
<li>从根到外部节点途中没有两个连续的<font color="red"><strong>红色</strong></font>指针</li>
<li>所有根至外部节点路径上有相同数目的<strong>黑色</strong>指针</li>
</ol>
<p>以上的约束条件确保了从根到叶子的最长可能路径不大于最短的可能路径的<strong>两倍</strong>（证明见<a href="#定理-1">定理 1</a>），得到的结果是：这个树大致上是平衡的。</p>
<p>如果知道了指针的颜色，就能知道节点的颜色；反之亦然。</p>
<p><img src="/2023/05/27/red-black/rb-tree2.png" alt></p>
<p>跟二叉搜索树一样，红黑树可以在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时间内查找、插入和删除。</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><ol>
<li>在实际应用中使用零指针或空指针描述外部节点；</li>
<li>对于每个节点，需要储存的只是该节点的颜色 / 指向它的两个孩子的指针颜色</li>
</ol>
<h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><p><strong>阶</strong>（Rank）：指从某节点到其子树中任意外部节点的任一条路径上<strong>黑色指针</strong>的数量。</p>
<p>可知：</p>
<ul>
<li>外部节点的阶为 0</li>
<li>上图根节点的阶为 2</li>
<li>上图左孩子的阶为 2，右孩子的阶为 1</li>
</ul>
<h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理 1"></a>定理 1</h2><p>设从根节点到外部节点的路径长度（length）为该路径中指针的数量。如 P 和 Q 分别是红黑树中两条从根至外部节点的路径，则</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="23.728ex" height="2.269ex" role="img" focusable="false" viewbox="0 -753 10487.6 1003"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(764,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1364,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1841,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2202,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(2778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(3167,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mo" transform="translate(3918,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4584.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(5640.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(6140.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(6438.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(6904.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(7504.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(7981.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(8342.6,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(8918.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(9307.6,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g><g data-mml-node="mo" transform="translate(10098.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p>
<p>即：从根到叶子的最长可能路径<strong>不大于最短可能路径的两倍</strong>。</p>
<p><strong>证明</strong>：</p>
<p>对任意一棵红黑树，设根节点的阶为 r，已知：</p>
<ul>
<li>每条从根节点至外部节点的路径中，最后一个指针必为<strong>黑色</strong></li>
<li>不存在包含连续两个<font color="red"><strong>红色</strong></font>指针的路径。</li>
</ul>
<p>因此：每个<font color="red"><strong>红色</strong></font>指针后必定跟着一个黑色指针。</p>
<p>也就是说，每一条从根节点至外部节点路径都有 r ~ 2r 个指针，可得 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="23.728ex" height="2.269ex" role="img" focusable="false" viewbox="0 -753 10487.6 1003"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(764,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1364,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1841,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2202,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(2778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(3167,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mo" transform="translate(3918,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4584.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(5640.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(6140.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(6438.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(6904.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(7504.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(7981.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(8342.6,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(8918.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(9307.6,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g><g data-mml-node="mo" transform="translate(10098.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<h2 id="定理-2"><a href="#定理-2" class="headerlink" title="定理 2"></a>定理 2</h2><p>设 h 是一棵红黑树的高度（不包括外部节点），n 为树中内部节点的数量，r 是根节点的阶，则</p>
<ol>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="6.472ex" height="2.1ex" role="img" focusable="false" viewbox="0 -753 2860.6 928"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(853.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(1909.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(2409.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="10.312ex" height="2.1ex" role="img" focusable="false" viewbox="0 -753 4557.9 928"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(1933.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(3057.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4057.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.304ex" height="2.269ex" role="img" focusable="false" viewbox="0 -753 7206.6 1003"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(853.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(1909.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(2409.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2707.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(3192.6,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(4106.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4495.1,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5317.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(6317.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6817.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ol>
<p><strong>证明</strong>：</p>
<p>第 1 点：已知每一条从根节点至外部节点路径都有不多于 2r 个指针；<br>因此 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="6.472ex" height="2.1ex" role="img" focusable="false" viewbox="0 -753 2860.6 928"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(853.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mn" transform="translate(1909.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(2409.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>。</p>
<p>第 2 点（使用数学归纳法证明）：设根节点的阶是 r</p>
<ol>
<li>树高度为 0 时，即只有一个叶节点，r = 0，内部节点数量为 0，满足 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="10.164ex" height="2.283ex" role="img" focusable="false" viewbox="0 -833.9 4492.6 1008.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(1833.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2992.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3992.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>；</li>
<li>设树高度 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="5.137ex" height="2.1ex" role="img" focusable="false" viewbox="0 -753 2270.6 928"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(853.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(1909.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g></svg></mjx-container> 时，有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="10.312ex" height="2.1ex" role="img" focusable="false" viewbox="0 -753 4557.9 928"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(1933.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(3057.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4057.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 成立，则：<ul>
<li>记树高为 t + 1 的红黑树根节点的左子树内部节点数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.032ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 898 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g></g></g></svg></mjx-container>，右子树内部节点数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.378ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 1051 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container></li>
<li>可知俩子树的阶为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.648ex" height="1.742ex" role="img" focusable="false" viewbox="0 -759 728.5 770"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(484,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g></g></g></g></svg></mjx-container>（俩子树阶一定相同），树高 ≦ t<ul>
<li>即：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="11.43ex" height="2.431ex" role="img" focusable="false" viewbox="0 -899.7 5052.1 1074.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(1175.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(2231.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(484,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g></g></g></g><g data-mml-node="mo" transform="translate(3551.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4552.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="11.776ex" height="2.431ex" role="img" focusable="false" viewbox="0 -899.7 5205.1 1074.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1328.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(2384.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(484,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g></g></g></g><g data-mml-node="mo" transform="translate(3704.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4705.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>两式相加：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="18.618ex" height="2.431ex" role="img" focusable="false" viewbox="0 -899.7 8229.2 1074.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(1120.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2120.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2720.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3449.2,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(4505,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(484,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g></g><g data-mml-node="mo" transform="translate(728.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1506.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mo" transform="translate(6729,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(7729.2,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container></li>
<li>左右各加 1：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="35.844ex" height="2.431ex" role="img" focusable="false" viewbox="0 -899.7 15843.1 1074.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(1120.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2120.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2720.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3393.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4393.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(5171.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(6227.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7105.2,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(8161,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(484,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g></g><g data-mml-node="mo" transform="translate(728.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1506.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mo" transform="translate(10385,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(11385.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(12163,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(13218.8,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(14342.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(15343.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
<li>整理后可得 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="10.312ex" height="2.1ex" role="img" focusable="false" viewbox="0 -753 4557.9 928"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(1933.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(3057.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4057.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>第 3 点：第 2 点 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.396ex;" xmlns="http://www.w3.org/2000/svg" width="10.312ex" height="2.1ex" role="img" focusable="false" viewbox="0 -753 4557.9 928"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="2267" d="M83 733Q83 741 89 747T99 753Q107 753 253 685T543 548T687 478Q694 473 694 463T687 448Q685 446 395 309L107 173H101Q83 175 83 193Q83 194 83 196Q82 203 98 212Q117 222 248 284Q326 321 378 345L626 463L360 589Q291 622 200 665Q112 706 98 714T83 733ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="msup" transform="translate(1933.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(3057.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(4057.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> -&gt; <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.89ex" height="2.269ex" role="img" focusable="false" viewbox="0 -753 6581.6 1003"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(728.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(1784.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2082.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(2567.6,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3481.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(3870.1,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4692.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(5692.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6192.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，再结合第 1 点可完成证明。</p>
<p>由此可知红黑树最大高度为为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.984ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5297 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(798,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msub" transform="translate(1283,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2196.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2585.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3407.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4408,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4908,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，因此搜索、插入、删除操作复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，符合二叉查找树的定义。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>可以参照<a href="/2022/07/19/binary-search-tree/#搜索节点">二叉搜索树</a>的搜索算法，时间为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>可使用<a href="/2022/07/19/binary-search-tree/#添加节点">二叉搜索树</a>的插入算法，并给新元素上色，再矫正树的颜色。</p>
<ul>
<li>如果插入前是空树：新节点是根节点，<strong>黑色</strong>；</li>
<li>如果插入前树非空：<ul>
<li>上<strong>黑色</strong>的话：从根到外部节点的路径中，将有一个特殊的黑色节点作为新节点的孩子，肯定违反要求 5，而且调整困难</li>
<li>上<font color="red"><strong>红色</strong></font>的话：可能出现连续的红色节点，可能违反要求 4</li>
</ul>
</li>
</ul>
<p>因此在权衡之下，应先给新插入节点上<font color="red"><strong>红色</strong></font>，当出现不平衡的情况，再作调整。</p>
<p>通过检查<strong>新节点 <code>u</code></strong>、其<strong>父节点 <code>pu</code></strong> 及<strong>祖父节点 <code>gu</code></strong> 可确定不平衡类型。</p>
<p>设 <code>u</code> 和 <code>pu</code> 为连续的<font color="red"><strong>红色</strong></font>节点，<code>gu</code> 为<strong>黑色</strong>节点（<code>gu</code> 与 <code>pu</code> 不可能同色），以此定义以下不平衡情况：</p>
<ol>
<li><strong>LLb</strong>：<code>pu</code> 是 <code>gu</code> 左孩子，<code>u</code> 是 <code>pu</code> 左孩子，且 <code>gu</code> 另一个孩子是<strong>黑</strong>的（叔叔节点，可以为外部节点）</li>
<li><strong>LLr</strong>：<code>pu</code> 是 <code>gu</code> 左孩子，<code>u</code> 是 <code>pu</code> 左孩子，且 <code>gu</code> 另一个孩子是<font color="red"><strong>红</strong></font>的（同上）</li>
<li><strong>LRb</strong>：<code>pu</code> 是 <code>gu</code> 左孩子，<code>u</code> 是 <code>pu</code> 右孩子，且 <code>gu</code> 另一个孩子是<strong>黑</strong>的（同上）</li>
<li><strong>LRr</strong>：<code>pu</code> 是 <code>gu</code> 左孩子，<code>u</code> 是 <code>pu</code> 右孩子，且 <code>gu</code> 另一个孩子是<font color="red"><strong>红</strong></font>的（同上）</li>
<li><strong>RRb</strong>：<code>pu</code> 是 <code>gu</code> 右孩子，<code>u</code> 是 <code>pu</code> 右孩子，且 <code>gu</code> 另一个孩子是<strong>黑</strong>的（同上）</li>
<li><strong>RRr</strong>：<code>pu</code> 是 <code>gu</code> 右孩子，<code>u</code> 是 <code>pu</code> 右孩子，且 <code>gu</code> 另一个孩子是<font color="red"><strong>红</strong></font>的（同上）</li>
<li><strong>RLb</strong>：<code>pu</code> 是 <code>gu</code> 右孩子，<code>u</code> 是 <code>pu</code> 左孩子，且 <code>gu</code> 另一个孩子是<strong>黑</strong>的（同上）</li>
<li><strong>RLr</strong>：<code>pu</code> 是 <code>gu</code> 右孩子，<code>u</code> 是 <code>pu</code> 左孩子，且 <code>gu</code> 另一个孩子是<font color="red"><strong>红</strong></font>的（同上）</li>
</ol>
<p><img src="/2023/05/27/red-black/unbalanced.png" alt></p>
<h2 id="LLr-与-LRr"><a href="#LLr-与-LRr" class="headerlink" title="LLr 与 LRr"></a>LLr 与 LRr</h2><ol>
<li>将 <code>pu</code> 与 <code>gu</code> 的右孩子（<code>gr</code>）由<font color="red"><strong>红色</strong></font>改为<strong>黑色</strong><ul>
<li>如果 <code>gu</code> 不是根，则还应将 <code>gu</code> 改成<font color="red"><strong>红色</strong></font>；</li>
<li>如果 <code>gu</code> 是根，则将 <code>gu</code> 改成<strong>黑色</strong>，该红黑树的阶<strong>增加了 1</strong></li>
</ul>
</li>
<li>如果 <code>gu</code> 改为<font color="red"><strong>红色</strong></font>之后引起新的不平衡：<ul>
<li><code>gu</code> 变成新的 <code>u</code> 节点，依据它的 <code>pu</code>，<code>gu</code> 节点继续调整</li>
</ul>
</li>
</ol>
<p><img src="/2023/05/27/red-black/llr.png" alt></p>
<p>图例为 LLr，LRr 是类似的操作，目的是要将<font color="red"><strong>红色</strong></font>往根部移动：</p>
<ul>
<li><font color="red"><strong>红色</strong></font>节点往上移，并不会打破红黑树的特性</li>
<li>不断将<font color="red"><strong>红色</strong></font>节点往上移动，直至根时直接将根设为<strong>黑色</strong>。</li>
</ul>
<h2 id="LLb-与-LRb"><a href="#LLb-与-LRb" class="headerlink" title="LLb 与 LRb"></a>LLb 与 LRb</h2><p>LLb：</p>
<ol>
<li>将 <code>pu</code> 由红色改为<strong>黑色</strong>，将 <code>gu</code> 由黑色改为<font color="red"><strong>红色</strong></font></li>
<li>做 <a href="/2023/05/26/avl/#调整-LL-型不平衡：LL-旋转">LL 旋转</a></li>
<li>此时 <code>gu</code> 子树已经平衡；又因为 <code>gu</code> 往上的层原本就平衡，所以整棵树平衡。</li>
</ol>
<p>LRb：</p>
<ol>
<li>将 <code>u</code> 由红色改为<strong>黑色</strong>，将 <code>gu</code> 由黑色改为<font color="red"><strong>红色</strong></font></li>
<li>做 <a href="/2023/05/26/avl/#调整-LR-型不平衡：LR-旋转">LR 旋转</a><ul>
<li>或：如果先做单旋转，可以先转换成 LLb（如下图）</li>
</ul>
</li>
<li>此时 <code>gu</code> 子树已经平衡；又因为 <code>gu</code> 往上的层原本就平衡，所以整棵树平衡。</li>
</ol>
<p><img src="/2023/05/27/red-black/llb-lrb.png" alt></p>
<h2 id="RRr-与-RLr"><a href="#RRr-与-RLr" class="headerlink" title="RRr 与 RLr"></a>RRr 与 RLr</h2><p>与 LLr 与 LRr 类似。</p>
<p><img src="/2023/05/27/red-black/rrr-rlr.png" alt></p>
<h2 id="RRB-与-RLb"><a href="#RRB-与-RLb" class="headerlink" title="RRB 与 RLb"></a>RRB 与 RLb</h2><p>与 LLb 与 LRb 类似。</p>
<p><img src="/2023/05/27/red-black/rrb-rlb.png" alt></p>
<h2 id="处理方法小结"><a href="#处理方法小结" class="headerlink" title="处理方法小结"></a>处理方法小结</h2><ul>
<li>XYr （X 和 Y 可以是 L 或 R）类型不平衡可通过改变颜色处理；</li>
<li>XYb 类型则需要旋转</li>
</ul>
<p><br></p>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>使用<a href="/2022/07/19/binary-search-tree/#删除节点">二叉搜索树</a>的删除算法，再进行矫正；<br>如需要还要做一次单旋转。</p>
<p>设 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 是替代被删除节点的节点</p>
<ul>
<li>当且仅当被删除节点是<strong>黑色</strong>，且 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 不是所得树的根的时候，执行二叉搜索树的删除算法会违反要求 5；</li>
<li>不会出现违反其他特征的情况</li>
</ul>
<p>此时以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为根的子树缺少一个黑色节点（指针）；也就是说，从根到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 子树外部节点路径上的黑色节点数，比从根到其他外部节点路径上的黑色节点数少一个，这就导致树<strong>不平衡</strong>。</p>
<p>定义 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 的<strong>同胞（兄弟）节点 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container></strong>，如果 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 缺少一个黑色节点，则 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 肯定不是一个外部节点：</p>
<ul>
<li>因为如果 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是外部节点的话，它那一分支的黑色节点数为 1（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 自己），<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 缺少一个黑色节点，则 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为红色叶子，不会不平衡。</li>
</ul>
<p>通过识别 <strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 的父节点 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container></strong> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 来区分不平衡类型：</p>
<ol>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 右孩子：R 型不平衡</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 左孩子：L 型不平衡</li>
<li>如 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是黑色：不平衡为 <strong>Rb</strong> 或 <strong>Lb</strong></li>
<li>如 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是红色：不平衡为 <strong>Rr</strong> 或 <strong>Lr</strong></li>
</ol>
<h2 id="Rb-型不平衡"><a href="#Rb-型不平衡" class="headerlink" title="Rb 型不平衡"></a>Rb 型不平衡</h2><p>Lb 型不平衡与 Rb 型互为镜像，因此在这里我们介绍 Rb 型不平衡的解决方法。</p>
<p>Rb 型根据 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的红色子节点数量分为三种不平衡类型。</p>
<h3 id="Rb0"><a href="#Rb0" class="headerlink" title="Rb0"></a>Rb0</h3><p>即：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 是右孩子；</li>
<li>它的兄弟节点（左孩子）<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是<strong>黑色</strong>；</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 的侄子节点（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的子节点）没有红色节点（0 个红色节点），都是<strong>黑色</strong>。</li>
</ul>
<p>回顾：此时删除的节点是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 路径上的<strong>黑</strong>节点，通过改变颜色可以改变不平衡。</p>
<p>当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为<strong>黑</strong>节点：将兄弟 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 改为<font color="red"><strong>红</strong></font>节点，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 不变</p>
<ul>
<li>此时无论 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 通过 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 到达外部节点的路径，还是通过 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 的路径，都缺少了一个黑色节点</li>
<li>如 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为整棵树的根：无需调整，已经平衡</li>
<li>否则：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为新的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，如有必要，再次调整以达到平衡。</li>
</ul>
<p>当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为<font color="red"><strong>红</strong></font>节点：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 改为<strong>黑色</strong>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 改为<font color="red"><strong>红</strong></font>节点</p>
<ul>
<li>此时从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 到外部节点路径上的黑色节点数减一，子树达到平衡</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 为新的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，如有必要，再次调整以达到平衡。</li>
</ul>
<p><img src="/2023/05/27/red-black/rb0.png" alt></p>
<h3 id="Rb1-或-Rb2"><a href="#Rb1-或-Rb2" class="headerlink" title="Rb1 或 Rb2"></a>Rb1 或 Rb2</h3><p>当侄子节点存在<font color="red"><strong>红色</strong></font>节点的时候，子树需要旋转。</p>
<p>注：下列例图中，白色的节点表明旋转前后颜色不变。</p>
<p><strong>Rb1</strong></p>
<p>即：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 是右孩子；</li>
<li>它的兄弟节点（左孩子）<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是<strong>黑色</strong>；</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 的侄子节点（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的子节点）有一个<font color="red"><strong>红色</strong></font>节点。</li>
</ul>
<p>如果 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的左孩子为<font color="red"><strong>红色</strong></font>节点，右孩子为<strong>黑色</strong>节点（如下图 <code>a)</code> <code>b)</code>）：</p>
<ol>
<li>做 <a href="/2023/05/26/avl/#调整-LL-型不平衡：LL-旋转">LL 旋转</a></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 变成 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 原来的颜色，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 左孩子变成<strong>黑色</strong></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 变成<strong>黑色</strong></li>
</ol>
<p>如果 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的左孩子为<strong>黑色</strong>节点，右孩子（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container>）为<font color="red"><strong>红色</strong></font>节点（如下图 <code>c)</code> <code>d)</code>）：</p>
<ol>
<li>做 <a href="/2023/05/26/avl/#调整-LR-型不平衡：LR-旋转">LR 旋转</a></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container> 变成 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 原来的颜色</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 变成<strong>黑色</strong></li>
</ol>
<p><img src="/2023/05/27/red-black/rb1.png" alt></p>
<p><strong>Rb2</strong></p>
<p>即：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 是右孩子；</li>
<li>它的兄弟节点（左孩子）<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是<strong>黑色</strong>；</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 的侄子节点（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的子节点）都是<font color="red"><strong>红色</strong></font>节点。</li>
</ul>
<p>平衡方案：</p>
<ol>
<li>做 <a href="/2023/05/26/avl/#调整-LR-型不平衡：LR-旋转">LR 旋转</a></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container> 变成 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 原来的颜色</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 变成<strong>黑色</strong></li>
</ol>
<p><img src="/2023/05/27/red-black/rb2.png" alt></p>
<p>旋转后，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 从根节点至外部节点路径上的黑色节点数加一，子树恢复平衡。</p>
<h2 id="Rr-型不平衡"><a href="#Rr-型不平衡" class="headerlink" title="Rr 型不平衡"></a>Rr 型不平衡</h2><p>与 Rb 型类似，Rr 型根据 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 右孩子的<font color="red"><strong>红色</strong></font>子节点数量分为三种不平衡类型。</p>
<p>此时 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.375ex" height="1.342ex" role="img" focusable="false" viewbox="0 -443 1049.5 593"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g></g></g></svg></mjx-container> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="2.499ex" height="1.375ex" role="img" focusable="false" viewbox="0 -443 1104.7 607.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></svg></mjx-container> 中至少有一个黑色节点不是外部节点；<br>因为要判断 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的右孩子情况，可知 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的孩子节点<strong>都是内部节点</strong>。</p>
<h3 id="Rr0"><a href="#Rr0" class="headerlink" title="Rr0"></a>Rr0</h3><p>即：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 是右孩子；</li>
<li>它的兄弟节点（左孩子）<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是<font color="red"><strong>红色</strong></font>；</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的右孩子没有红色节点（0 个红色节点），都是<strong>黑色</strong>。</li>
</ul>
<p>平衡方案：</p>
<ol>
<li>做 <a href="/2023/05/26/avl/#调整-LL-型不平衡：LL-旋转">LL 旋转</a></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 变成<font color="red"><strong>红色</strong></font></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="2.499ex" height="1.375ex" role="img" focusable="false" viewbox="0 -443 1104.7 607.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></svg></mjx-container> 变成<font color="red"><strong>红色</strong></font>，并成为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 的左孩子</li>
</ol>
<p>此时 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="2.499ex" height="1.375ex" role="img" focusable="false" viewbox="0 -443 1104.7 607.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></g></svg></mjx-container> 的阶减 1，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 子树达到平衡；<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 路径的阶加 1，原 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 子树达到平衡。</p>
<p><img src="/2023/05/27/red-black/rr0.png" alt></p>
<h3 id="Rr1"><a href="#Rr1" class="headerlink" title="Rr1"></a>Rr1</h3><p>即：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 是右孩子；</li>
<li>它的兄弟节点（左孩子）<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是<font color="red"><strong>红色</strong></font>；</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的右孩子有一个<font color="red"><strong>红色</strong></font>节点。</li>
</ul>
<p>如果 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的右孩子（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container>）的左孩子为<font color="red"><strong>红色</strong></font>节点，右孩子为<strong>黑色</strong>节点（如下图 <code>a)</code> <code>b)</code>）：</p>
<ol>
<li>做 <a href="/2023/05/26/avl/#调整-LR-型不平衡：LR-旋转">LR 旋转</a></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container> 的左孩子变成<strong>黑色</strong>，成为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的右孩子</li>
</ol>
<p>如果 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container> 的左孩子为<strong>黑色</strong>节点，右孩子为<font color="red"><strong>红色</strong></font>节点（如下图 <code>c)</code> <code>d)</code>）：</p>
<ol>
<li>通过旋转，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container> 的右孩子成为根节点，并变成<strong>黑色</strong></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 成为新根节点的右孩子</li>
</ol>
<p><img src="/2023/05/27/red-black/rr1.png" alt></p>
<h3 id="Rr2"><a href="#Rr2" class="headerlink" title="Rr2"></a>Rr2</h3><p>即：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 是右孩子；</li>
<li>它的兄弟节点（左孩子）<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 是<font color="red"><strong>红色</strong></font>；</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.097ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 485 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g></g></g></svg></mjx-container> 的右孩子都是<font color="red"><strong>红色</strong></font>节点。</li>
</ul>
<p>平衡方案类似于 Rr1 左黑右红的情况：</p>
<ol>
<li>通过旋转，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewbox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></svg></mjx-container> 的右孩子成为根节点，并变成<strong>黑色</strong></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.247ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 993 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 成为新根节点的右孩子</li>
</ol>
<p><img src="/2023/05/27/red-black/rr2.png" alt></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>如需调整的节点的兄弟节点为红：想办法通过旋转和改色，换成一个黑色的兄弟；</li>
<li>如需调整的节点的兄弟节点为黑：分析俩侄子节点的颜色<ol>
<li>如侄子均为黑：将兄弟染红，递归分析父节点</li>
<li>如左红右黑：左改黑，兄弟右旋改红（即原兄弟-&gt;新的右侄子是红的）</li>
<li>如右红：父节点旋转，改掉某些节点的颜色，右变黑</li>
</ol>
</li>
</ol>
<h1 id="红黑树-v-s-AVL-树"><a href="#红黑树-v-s-AVL-树" class="headerlink" title="红黑树 v.s. AVL 树"></a>红黑树 v.s. AVL 树</h1><p>树的结构：</p>
<ul>
<li>AVL 树严格要求节点平衡因子不大于 1</li>
<li>红黑树不追求“完全平衡”，但提出为节点增加颜色</li>
</ul>
<p>就插入节点导致的失衡：</p>
<ul>
<li>AVL 树和红黑树都是最多两次旋转实现复衡，旋转量级是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>删除：</p>
<ul>
<li>AVL 树需要维护从被删除节点到根节点路径所有节点的平衡，量级为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
<li>红黑树最多需要实现 3 次实现复衡，量级为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li>
</ul>
<p>红黑树是性能、功能、空间开销的折中结果。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>平衡二叉树类型</th>
<th>平衡度</th>
<th>调整频率</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVL 树</td>
<td>高</td>
<td>高</td>
<td>查询多，增删少</td>
</tr>
<tr>
<td>红黑树</td>
<td>低</td>
<td>低</td>
<td>增删频繁</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.joxrays.com/rb-tree-cpp/#%E7%BA%A2%E9%BB%91%E6%A0%91">我所理解的红黑树(RBT)</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2022/11/11/selection-sort/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a>，也称直接选择排序。</p>
<span id="more"></span>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>选择排序属于比较排序，大体步骤如下：</p>
<ol>
<li>在待排序序列中<strong>选择</strong>最小（大）的元素，将其<strong>移动</strong>到该序列的起始位置（或末尾）；</li>
<li>再从剩余未排序元素中继续选择最小（大）元素，然后移动到已排序部分的末尾（或前面）；</li>
<li>重复操作，直到序列有序。</li>
</ol>
<p>选择排序是不稳定的排序：如果当前元素比某一个元素小，而该较小的元素又出现在一个和当前元素相等的元素后面，则稳定性就被破坏。</p>
<h1 id="复杂度评估"><a href="#复杂度评估" class="headerlink" title="复杂度评估"></a>复杂度评估</h1><ul>
<li>交换操作：0~(n-1) 次</li>
<li>比较操作：n(n-1)/2</li>
<li>赋值操作（元素移动次数）：0~3(n-1)</li>
</ul>
<p>在数据量（n）比较小的时候，选择排序比冒泡排序快：然而，这种实际适用的场合非常罕见。</p>
<ul>
<li>可以说，选择排序是综合性能最差的排序算法。</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) {</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[minIndex]) {</span><br><span class="line">                minIndex = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = a[minIndex];</span><br><span class="line">            a[minIndex] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>上述程序的缺点：即使元素已经按序排列，程序依然继续运行。如即使在第二次循环后数组元素可能已经按序排列，首层 for 循环还需要执行 n-1 次。</p>
<p>为了终止不必要的循环，在查找最大元素期间，可顺便检查数组是否已按序排列。</p>
<p>改进版：最好情况仅比较 n-1 次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortEarlyTerm</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">boolean</span> sorted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = length; !sorted &amp;&amp; size &gt; <span class="number">1</span>; size--) {</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        sorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果经历一轮遍历后 sorted 还是 true，说明元素都是顺序的，就不需要再排序了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[maxIndex]) {</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sorted = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (maxIndex != size - <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = a[maxIndex];</span><br><span class="line">            a[maxIndex] = a[size - <span class="number">1</span>];</span><br><span class="line">            a[size - <span class="number">1</span>] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解</title>
    <url>/2022/01/01/spring-annotation/</url>
    <content><![CDATA[<p>在 <a href="/2021/12/05/spring-ioc/">Spring IoC 概览</a>中我们提到过，除了配置文件，Spring 还能通过注解进行 Bean 的依赖管理。</p>
<span id="more"></span>
<p>传统的 XML 注入 bean 存在以下缺点：</p>
<ol>
<li>如果所有内容都配置在 XML 文件中，长久以往配置文件将会十分庞大；如果按照需求拆分配置文件，那么 XML 文件又会变得很多，可维护性会降低；</li>
<li>开发中 Java 和 XML 之间不断切换，是一件麻烦的事。</li>
</ol>
<p>由此引入注解与 Bean 紧密结合，既大大减少了配置文件的体积，又增加了 Bean 的可读性和内聚性。</p>
<p>关于注解的配置也是在 Bean 的定义 XML 文件上，使用 <code>&lt;context:annotation-config/&gt;</code> 标记：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者使用 <code>&lt;context:component-scan base-package=&quot;xxx&quot; /&gt;</code> 开启扫描功能：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;xxx&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring 会自动扫描包 xxx 路径下的注解 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下篇幅介绍几个常见的 Spring 注解。</p>
<p><br></p>
<h1 id="非类级别的注解"><a href="#非类级别的注解" class="headerlink" title="非类级别的注解"></a>非类级别的注解</h1><p>包括修饰字段、构造函数和方法的注解们。</p>
<h2 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h2><p>应用于 bean 某个属性的 setter 中，标明该属性必须在配置文件 xml 中配置，且值不能为 null；否则容器会抛出 <code>BeanInitializationException</code>。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;  <span class="comment">// age 不能为空</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  <span class="comment">// name 不能为空</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for student bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Zara&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- try without passing age and check the result --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name=&quot;age&quot; value=&quot;11&quot; /&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- result: 抛出 Property &#x27;age&#x27; is required for bean &#x27;student&#x27; 的异常 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常配置与输出：</span></span><br><span class="line">Name : Zara</span><br><span class="line">Age : 11</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>顾名思义，就是<strong>自动装配</strong>。能应用于 bean 中某个属性的 setter 方法、非 setter 方法、构造函数和属性上；标记后可以更精确地控制在何处和如何进行自动装配。</p>
<p>@Autowired 默认按 byType 的方式，在容器里查找匹配的 bean；当 Spring 容器中<strong>有且只有一个匹配</strong>的 bean 时，完成自动装配。</p>
<p>如果需要 byName 装配，可结合 <code>@Qualifier</code> 使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for textEditor bean without constructor-arg or property --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for spellChecker bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;spellChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.SpellChecker&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，上面的配置文件中没有配置任何的 <code>constructor-arg</code> 或者 <code>property</code>，这就属于非 xml 配置的 IoC。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. setter 的 @Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 默认执行 byType 自动装配</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpellChecker</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 可以不需要了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 属性上的 @Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 省去了 setter，不会为了实现依赖注入导致暴露不该暴露的接口</span></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside TextEditor constructor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 可以不需要了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 构造函数上的 @Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside TextEditor constructor.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 任意方法中使用 @Autowired 注解，和多参数注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(SpellChecker spellChecker, WordCounter counter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    <span class="keyword">this</span>.wordCounter = counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，也可使用 @Autowired 注入 Set、Map 等类型</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，如果需要被注入的 Bean 里面保留着依赖的 <code>&lt;property&gt;</code>，Spring 会按照<strong>配置文件（XML）优先</strong>的原则进行依赖注入，容器会寻找对应依赖中的 getter / setter。<br>这个时候，如果依赖该 bean 的 .java 文件标记了 @Autowired 而 bean 没有定义 getter / setter，bean 的初始化就会报错。</p>
<p><code>@Autowired</code> 默认表明依赖是必须的，相当于标记了 <code>@Required</code>。如果 bean 找不到而允许空值，不抛出异常，可使用 <code>@Autowired(required=false)</code> 关闭默认行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required=false)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 还是需要值的，不然就抛 BeanCreationException 了</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h2><p>指定注入 Bean 的具体名称（name），能够从多个匹配的相同类型（type）的 bean 中找出想要装配的某个 bean。</p>
<p>存在多个实例时与 <code>@Autowired</code> 结合使用。</p>
<p>示例配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for profile bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;profile&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Profile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for student1 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Zara&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for student2 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Nuha&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;student1&quot;)</span>  <span class="comment">// 指定了想要的 bean 是 student1</span></span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅如此，同一个接口类的两个实现类 bean 也是通过这样的方法匹配想要的 bean：</p>
<p>定义一个 ICar 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCarModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q5</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Q5&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A3</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ICar car;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;audiFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.AudiFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;q5&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Q5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;a3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.A3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>调用 audiFactory 的时候会抛出 <code>NoSuchBeanDefinitionException</code>：说 No unique bean of type ICar is defined。</p>
<p>因此需要删除其中一个 bean 的定义，或者通过 @Qualifier 指明是哪一个 bean。</p>
<p><br></p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>和 @Autowired 非常相似，作用于 setter 上，使用 name 属性，默认遵循 byName 语义自动装配。</p>
<ul>
<li>@Resource 没有指定任何内容，默认 byName 匹配，找不到再 byType；</li>
<li>如果指定了 name 或者 type，则 byType 匹配；</li>
<li>如果同时指定了 name 和 type，则根据指定的 name 和 type 去匹配，任何一个不匹配都会报错。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name= &quot;spellChecker&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpellChecker</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">getSpellChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>@Resource 和 @Autowired 功能是一样的，都需要配置 DI 注解解析器</li>
<li>@Resource 是 JavaEE 的注解，默认按名称（name）注入；@Autowired 是 Spring 的注解，默认按类型（type）注入</li>
</ul>
<p>因此建议使用 @Resource 来减少与 Spring 之间的耦合。</p>
<p><br></p>
<h2 id="PostConstruct-amp-PreDestroy"><a href="#PostConstruct-amp-PreDestroy" class="headerlink" title="@PostConstruct &amp; @PreDestroy"></a>@PostConstruct &amp; @PreDestroy</h2><p><code>@PostConstruct</code>：相当于 xml 配置中的 init-method；<br><code>@PreDestroy</code>：相当于 xml 配置中的 destroy-method。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// getters &amp; setters</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean is going through init.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean will destroy now.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 HelloWorld bean 前仍需给 context 注册一个 shutdown hook</span></span><br><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></figure>
<p>配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello World!&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用注解可以指定多个初始化 / 销毁方法，而配置文件只能分别指定一个。</p>
<p>添加注解后，在配置文件中，该 bean 的 init-method 和 destroy-method 属性可无需配置。</p>
<p>如配置文件添加了 init-method 和 destroy-method：</p>
<ul>
<li>如配置的方法相同，则两者行为相同，两者互相覆盖；</li>
<li>如配置方法不同，则<strong>先执行注解</strong>的方法，再执行配置的方法。</li>
</ul>
<p>@Resource、@PostConstruct 和 @PreDestroy 都属于 JavaEE 的 JSR-250（Java Specification Request）注释。</p>
<p><br></p>
<h1 id="构造-IoC-容器的注解"><a href="#构造-IoC-容器的注解" class="headerlink" title="构造 IoC 容器的注解"></a>构造 IoC 容器的注解</h1><p>添加了这些注解，XML 配置文件可以得到真正的简化，做到“无配置”地依赖注入。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>表明该类可作为 Spring IoC 容器用来管理 bean 的配置类。<br>标记了之后就不需要额外的 XML 进行配置了。</p>
<p>类里面的某个方法如果标记了 <code>@Bean</code>，就会作为 Spring 容器中的 Bean 被注册进去。</p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>@Bean 是属于标记在方法上面的注解。<br>以此手动创建一个 Spring Bean 注册到 Spring context。</p>
<p>结合两个注解来看一段示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;  <span class="comment">// 方法名作为 bean 的 id</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();  <span class="comment">// 作为单例注册进 Spring context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">ApplicationContext ctx1 = <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class);</span><br><span class="line">HelloWorld helloWorld1 = ctx1.getBean(HelloWorld.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或：</span></span><br><span class="line">ApplicationContext ctx2 = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx2.register(AppConfig.class, OtherConfig.class, HelloWorldConfig.class, ...);</span><br><span class="line">HelloWorldConfig config = ctx2.getBean(HelloWorldConfig.class);</span><br><span class="line">HelloWorld helloWorld2 = config.helloWorld();</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(helloWorld1, helloWorld2);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以上代码等同于以下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.HelloWorld&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>@Configuration 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Component.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码说明 Spring Configuration 配置类也是 Spring 的一个组件。</p>
<p>bean 的依赖性可以通过构造函数注入接收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Bean 注解可指定任意初始化和销毁的回调，也可指定 bean 的作用域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>@Scope</code> 用来配置 Spring bean 的作用域：</p>
<ul>
<li><code>singleton</code> 为单例；</li>
<li><code>prototype</code> 为原型，每次都会 new 一个新的对象出来。</li>
</ul>
<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>根据传入的 class 确定类的全路径名，将其加载进容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个配置类：</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 另一个配置类：</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span>  <span class="comment">// 从 ConfigA 加载关于 @Bean 的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 context 初始化的时候，指定 ConfigB.class 即可获得 bean A 和 B。</p>
<p>以下代码会得到两个不同的 Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(A.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Import 进容器的是 com.xxx.A 全路径名，而 @Bean 引入容器的是 a；虽然它们是同一个类，但是是<strong>两个 bean</strong>。</p>
<h2 id="ConditionalXX"><a href="#ConditionalXX" class="headerlink" title="@ConditionalXX"></a>@ConditionalXX</h2><p>顾名思义，条件注解。被标记了的类或方法要满足了一定的条件之后，相应的 bean 才会被注册进容器中。</p>
<p>Spring 中定义了很多条件注解：</p>
<p><img src="/2022/01/01/spring-annotation/conditional.png" alt></p>
<p>在以下的实例代码中，调用 getBean() 获取 car 的时候会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;engine&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">new</span> Car();</span><br><span class="line">    car.setBrand(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line">    car.setEngine(engine());</span><br><span class="line">    car.setModel(<span class="string">&quot;Civic&quot;</span>);</span><br><span class="line">    car.setIteration(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Engine <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">    engine.setModel(<span class="string">&quot;earth dream&quot;</span>);</span><br><span class="line">    engine.setModel(<span class="string">&quot;L15C8&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 car 不能被 Spring 注册进容器中，即使通过了 engine() 传入了所需变量，但是所依赖的 bean（<code>@ConditionalOnBean(name = &quot;engine&quot;)</code>）没被初始化，所以 car 初始化失败。</p>
<p>在实际应用中可利用 @ConditionalXX <strong>选择性地注册 bean</strong>（比如不同系统用到的不同数据库 driver），减轻 Spring 应用负担。</p>
<p><br></p>
<h2 id="其它创建对象的注解"><a href="#其它创建对象的注解" class="headerlink" title="其它创建对象的注解"></a>其它创建对象的注解</h2><p>这些注解都是标记在类上的，用于表示 Spring 中的组件。</p>
<p><strong><code>@Component</code></strong></p>
<p>将某个 Java 类标记为 bean，是所有受 Spring 管理组件的通用形式。</p>
<p>Spring 组件扫描机制能将标记了 @Component 的类拉入应用程序中。</p>
<p>当组件不好归类的时候，我们可以使用它进行标注。</p>
<p><strong><code>@Controller</code></strong></p>
<p>将 Java 类标记为 Spring Web MVC 控制器（控制层 Controller 组件）。</p>
<p>同样，被标记的 bean 会被自动导入到 IoC 容器中。</p>
<p><strong><code>@Service</code></strong></p>
<p>是 @Component 注解的特化，用于标记业务层的组件。</p>
<p>可在服务层类中使用 @Service 而不是 @Component，它不会对 @Component 注解提供任何其他行为。</p>
<p><strong><code>@Repository</code></strong></p>
<p>也是 @Component 注解的特化，用于标记持久层的组件（DAO 类）。</p>
<p>被标记之后，IoC 容器会将该 DAO 导入，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><code>@ComponentScan</code>：扫描并装配指定包下的所有 @Component, @Controller, @Service, @Repository 注解的 Bean 到 IOC 容器中。</p>
<ul>
<li>默认情况下扫描入口类（XxxApplication.class）<strong>同级以及子级包</strong>下的所有文件；</li>
<li>可通过 <code>basePackages</code> &amp; <code>value</code> / <code>basePackageClasses</code> 指定扫描路径</li>
</ul>
<p><code>@Primary</code>：手动创建 Spring Bean 时，如果 IoC 容器发现了多个 bean 候选者，则 <code>@Primary</code> 可以指定当前为默认注入的 bean；否则会抛出异常。</p>
<p><code>@Lazy</code>：延迟初始化，表示延迟注入 bean。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean</title>
    <url>/2022/03/11/spring-bean/</url>
    <content><![CDATA[<p>Bean 是 Spring 应用中的核心组成部分，通过 Spring IoC（多数是依赖注入）容器被实例化、组装和管理。</p>
<span id="more"></span>
<h1 id="Spring-Bean-的属性"><a href="#Spring-Bean-的属性" class="headerlink" title="Spring Bean 的属性"></a>Spring Bean 的属性</h1><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>class</code></td>
<td>指定创建 bean 的类，使用全限定名</td>
</tr>
<tr>
<td><code>id</code></td>
<td>bean 唯一的标识符。Spring 通过 id 对 bean 进行配置和管理</td>
</tr>
<tr>
<td><code>name</code></td>
<td>可与 id 一起参与 Spring 对 bean 的管理。bean 可被指定多个名称</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>设定 bean 实例的作用域，共有 5 种类型：<br><li>singleton（默认值）<br></li><li>prototype<br></li><li>request<br></li><li>session<br></li><li>global session</li></td>
</tr>
<tr>
<td><code>constructor-arg</code></td>
<td><code>&lt;bean&gt;</code> 的子标签（子元素），使用该元素传入构造参数进行实例化。<br>该元素中，<code>index</code> 属性指定构造参数的序号，<code>type</code> 属性指定构造参数的类型，ref 表示对其他 bean 的引用。</td>
</tr>
<tr>
<td><code>property</code></td>
<td><code>&lt;bean&gt;</code> 的子标签（子元素），调用 bean 实例中的 setter 完成赋值，完成依赖注入；可用属性跟 <code>constructor-arg</code> 相同。</td>
</tr>
<tr>
<td><code>autowire</code></td>
<td>确定 bean 的自动装配模式</td>
</tr>
<tr>
<td><code>lazy-init</code></td>
<td>将 bean 的初始化延迟到它第一次被请求时，而不是启动 IoC 容器的时候</td>
</tr>
<tr>
<td><code>init-method</code></td>
<td>定义了容器设置好 bean 的属性值后，开始初始化 bean 时执行的 callback</td>
</tr>
<tr>
<td><code>destroy-method</code></td>
<td>定义了 bean 被容器移除之后的 callback</td>
</tr>
<tr>
<td><code>parent</code></td>
<td>指定要继承的 bean</td>
</tr>
</tbody>
</table>
</div>
<p>配置文件参照：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- A simple bean definition --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- other collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- A bean definition with lazy init set on --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- A bean definition with initialization method --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- A bean definition with destruction method --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域-scope-的取值"><a href="#作用域-scope-的取值" class="headerlink" title="作用域 scope 的取值"></a>作用域 scope 的取值</h2><p>scope 的取值和<a href="/2022/01/01/spring-annotation">注解</a> @Scope 是一样的：</p>
<ol>
<li><strong>singleton</strong>（默认值）：bean 以<strong>单例</strong>存在，容器中仅存在一个该 bean 的实例；</li>
<li><strong>prototype</strong>：每次从容器调用 bean 都会返回<strong>新的实例</strong>，调用 <code>getBean()</code> 相当于 <code>new XxxBean()</code>。</li>
</ol>
<p>其它三种类型仅适用于 WebApplicationContext：</p>
<ol>
<li><strong>request</strong>：每次 HTTP 请求都会创建一个新的 bean</li>
<li><strong>session</strong>：同一个 HTTP session 共享一个 bean，不同 session 使用不同 bean</li>
<li><strong>global session</strong>：一般用于 portlet 应用环境；在一个全局的 HTTP session 中，一个 bean 对应一个实例</li>
</ol>
<p>之所以默认值是单例，是因为在 Spring 的设计中，少创建实例能使得垃圾回收高效，同时缓存能快速获取。</p>
<p>编程的时候，在业务中遇到有状态 bean，我们使用 prototype；无状态 bean 使用 singleton。</p>
<p>要注意的是，单例 bean 不是线程安全的，Spring 容器不保证 singleton 的线程安全。</p>
<p><br></p>
<h1 id="与容器的关系"><a href="#与容器的关系" class="headerlink" title="与容器的关系"></a>与容器的关系</h1><p>关系如下图：</p>
<p><img src="/2022/03/11/spring-bean/beans-in-container.png" alt></p>
<p>图中的 <code>BeanDefinition</code> 注册表，指的是 <code>AliasRegistry</code> 接口以及其多个子类。它们通过内部维护的 ConcurrentHashMap 存储注册了的 BeanDefinition，以便后续的注册、移除等相关操作。</p>
<p><br></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>先上结论：Spring Bean 的生命周期<big><strong>只有以下四个阶段</strong></big>：</p>
<ol>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ol>
<p>具体到 Spring Framework 代码，主要的逻辑都在 <code>doCreateBean()</code> 里，依序是以下三个方法调用：</p>
<ol>
<li><code>createBeanInstance()</code> -&gt; 实例化</li>
<li><code>populateBean()</code> -&gt; 属性赋值</li>
<li><code>initializeBean()</code> -&gt; 初始化</li>
</ol>
<p>Bean 的销毁是在容器关闭（<code>ConfigurableApplicationContext#close()</code>）的时候被触发的。</p>
<p>下面咱们来详细唠一唠：</p>
<p><br></p>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>Spring Bean 实例化的主要步骤如下：</p>
<ol>
<li>Spring 容器扫描 class（xml 配置文件或 @Configuration 配置类）并解析，通过组装得到 BeanDefinition</li>
<li>根据得到的 BeanDefinition 生成 Bean</li>
<li>根据 class 推断构造方法</li>
<li>根据推断出来的构造方法，利用<a href="/2021/05/25/reflection-java">反射</a>得到一个对象</li>
</ol>
<p>该对象我们暂时称它为<strong>原始对象</strong>。原始对象是不完整的，它的属性还没有完成填充，是<strong>不可用</strong>的对象。</p>
<h2 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h2><p>通过 setter 或注解 @Autowired 填充原始对象的属性（基于<a href="/2021/12/24/spring-di">依赖注入</a>）。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>如果 Bean 实现了 InitializingBean 接口，Spring 会调用接口的 <code>afterPropertiesSet()</code>；<br>如果 Bean 使用了 <code>init-method</code> 配置声明了初始化方法，Spring 会以此调用初始化的 callback。</p>
<p>如果原始对象中某个方法被 AOP 了，则还需要根据原始对象生成一个<strong>代理对象</strong>。</p>
<p>完成初始化之后，不管得到的是本体还是代理对象，最终的生成对象已经是<strong>可用</strong>的了；它会被放入单例池（singletonObjects）中，下次 getBean() 时就可从单例池直接获取。</p>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>如果 Bean 实现了 DisposableBean 接口，Spring 会调用接口的 <code>destroy()</code>；<br>如果 Bean 使用 <code>destroy-method</code> 配置声明了销毁方法，Spring 会以此调用销毁的 callback。</p>
<p><br></p>
<p>除了以上四个必经之路，Spring Bean 整个生命周期之中的<strong>扩展点</strong>非常之多，主要分为两种：作用于 Bean 多个生命周期阶段的接口，和只调用一次的接口。</p>
<p>先说说切入到多个生命周期中的接口，主要提两个：<code>InstantiationAwareBeanPostProcessor</code> 和 <code>BeanPostProcessor</code>。</p>
<h2 id="Processor-接口"><a href="#Processor-接口" class="headerlink" title="-Processor 接口"></a>-Processor 接口</h2><p><code>BeanPostProcessor</code> 是 Spring Framework 里面所有的 -Processor 类都实现了的接口类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法名可以看出，实现了 BeanPostProcessor 接口的 -Processor 们可以通过丰富接口方法，在 Bean <strong>初始化</strong>阶段的前（<code>postProcessBeforeInitialization()</code>）后（<code>postProcessAfterInitialization()</code>）对 Bean 对象进行额外的处理。</p>
<p>Spring 应用（ApplicationContext）会自动检测实现了 BeanPostProcessor 接口的所有 Bean，将它们注册为 Post Processor，在适当的时候（也就是 Bean 初始化阶段前后）调用。</p>
<p>我们来实现一个 BeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitHelloWorld</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before bean initialization: &quot;</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;  <span class="comment">// you can return any other object as well</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After bean initialization: &quot;</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;  <span class="comment">// you can return any other object as well</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>beans.xml</code> 添加 bean 信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.InitHelloWorld&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>众多 BeanPostProcessor 的执行需要<strong>确保顺序</strong>，因此它们还实现了排序相关的接口 <code>PriorityOrdered</code> <code>Ordered</code>。Spring 根据不同排序接口进行分组，优先级高的比低的先加入。</p>
<p><code>InstantiationAwareBeanPostProcessor</code> 扩展了 BeanPostProcessor，也就是说，实现了 InstantiationAwareBeanPostProcessor 的类也需要实现初始化阶段前后的 callback 接口。</p>
<p>除此之外，InstantiationAwareBeanPostProcessor 还有另外两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，我们由方法名字可以看出，实现了 InstantiationAwareBeanPostProcessor 接口的 -Processor 们可以通过丰富接口方法，在 Bean <strong>实例化</strong>阶段的前后对 Bean 对象进行额外的处理。</p>
<p><br></p>
<p>说完多个生命周期阶段的接口，我们来看看只调用一次的接口。主要是 -Aware 类型的接口。</p>
<h2 id="Aware-接口的调用"><a href="#Aware-接口的调用" class="headerlink" title="-Aware 接口的调用"></a>-Aware 接口的调用</h2><p>Aware，意识到，觉察到的意思。因此从接口的名字就能看出来，-Aware 类型的接口的作用在于获取到 Spring 容器中的一些资源。</p>
<p>所有的 -Aware 接口实现都是在<strong>属性赋值之后，初始化之前</strong>调用的（initializeBean()），按照执行顺序分以下两组：</p>
<p>第一组：通过 invokeAwareMethods(beanName, bean) 在代码中<strong>直接调用</strong></p>
<ol>
<li>BeanNameAware：调用 <code>setBeanName()</code></li>
<li>BeanClassLoaderAware：调用 <code>setBeanClassLoader()</code></li>
<li>BeanFactoryAware：调用 <code>setBeanFactory(BeanFactory fac)</code></li>
</ol>
<p>第二组：</p>
<ol>
<li>EnvironmentAware：调用 <code>setEnvironment()</code></li>
<li>EmbeddedValueResolverAware：调用 <code>setEmbeddedValueResolver()</code> 获取 Spring EL 解析器，用户自定义注解需要支持 spel 表达式的时候可以使用</li>
<li>ApplicationContextAware（ResourceLoaderAware / ApplicationEventPublisherAware / MessageSourceAware）：分别调用各自接口方法，返回 bean 所在应用的上下文 ApplicationContext</li>
</ol>
<p>之所以 ApplicationContextAware 那么多接口一起说，是因为 ApplicationContext 本身是<strong>复合型接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>, <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanXxxAware 都是在 initializeBean() 直接调用，而 ApplicationContext 相关的 Aware 通过 BeanPostProcessor#postProcessBeforeInitialization() 实现。</p>
<p><br></p>
<p>除了 -Aware 接口之外，其它只调用一次的生命周期扩展点就是刚刚提及的 InitializingBean 和 DisposableBean 相关接口了。</p>
<p>总结一下：</p>
<p><img src="/2022/03/11/spring-bean/bean-lifecycle.png" alt></p>
<h2 id="扩展点相关类的初始化"><a href="#扩展点相关类的初始化" class="headerlink" title="扩展点相关类的初始化"></a>扩展点相关类的初始化</h2><p>既然 Spring 有诸如 -Processor 和 -Aware 等接口去扩展 Bean 生命周期的各个阶段，那么执行这些接口类的 Bean 总是需要被初始化的。</p>
<p>它们会比 Bean 先实例化：</p>
<ul>
<li>实例化 BeanFactoryPostProcessor</li>
<li>实例化 BeanPostProcessor</li>
<li>实例化 BeanPostProcessor 的实现类</li>
<li>实例化 InstantiationAwareBeanPostProcessor 的实现类</li>
</ul>
<p><br></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Bean 使用起来并不难，配置简单明了，能让开发者专注于业务开发，不用花太多时间在配置中。</p>
<h2 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h2><p>如上面所说，Bean 可以实现 InitializingBean 和 DisposableBean 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 Spring 官方并不建议使用者这么去干，因为这会令业务与 Spring Framework 高度耦合。</p>
<p>Spring 建议通过两个途径去实现 Bean 的创建和销毁：</p>
<p><strong>1</strong>. 在<a href="/2021/12/24/spring-di"><strong>配置文件</strong></a>的 bean 标签添加 <code>init-method</code> / <code>destroy-method</code> 属性。</p>
<p>Bean 的类定义文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some destruction work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果想给所有的 bean 都定义一个默认的初始化和销毁方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 在 <code>@Configuration</code> <a href="/2022/01/01/spring-annotation">注解</a>标记的 Bean <code>@Bean</code> 中添加 <code>initMethod</code> 和 <code>destroyMethod</code> 变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在非 WebApplicationContext 应用中，如需关闭 Spring IoC 容器，需要在 JVM 里面为 Spring Context 注册一个 shutdown hook，以确保容器正常关闭，释放所有资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a shutdown hook for the above context...</span></span><br><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承通过配置文件实现：在 bean 中标明 <code>parent</code> 属性的值，使其指定某个要继承的 bean id。</p>
<ul>
<li>可以继承父 bean 中所有属性的值，也可自己单独声明某些属性的值</li>
<li>父 bean 还可以使用 <code>abstract</code> 属性声明为抽象类（<code>abstract=&quot;true&quot;</code>），此时父 bean 自身不能被实例化</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;abstractCarFactory&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;engine&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Engine&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transmission&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Transmission&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;battery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Battery&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hondaFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;jp.factory.car.HondaFactory&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;abstractCarFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;engine&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Earth Dream&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;battery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Honda B&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Bean-的循环依赖问题"><a href="#Bean-的循环依赖问题" class="headerlink" title="Bean 的循环依赖问题"></a>Bean 的循环依赖问题</h1><p>假设我们有如下场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">a.b = b;</span><br><span class="line">b.a = a;</span><br></pre></td></tr></table></figure>
<p>如此便是<strong>循环依赖</strong>，在注入 / 设置属性的时候会有问题：</p>
<ul>
<li>A 被创建 <code>—&gt;</code> 被发现依赖了 B 属性 <code>—&gt;</code> 触发 B 创建 <code>—&gt;</code> 发现 B 依赖了 A 属性 <code>—&gt;</code> 需要 A <code>-&gt;</code> 但 A 还在创建过程中</li>
</ul>
<p>导致 A 和 B 都创建不出来。</p>
<p><img src="/2022/03/11/spring-bean/circular-dep.png" alt></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有些循环依赖场景可以通过 Spring 解决。</p>
<p>先说一下 Spring 的三级缓存：</p>
<p>一级缓存：<code>singletonObjects</code></p>
<ul>
<li>缓存某个 beanName 对应的已经经历了<strong>完整生命周期</strong>的 bean 对象</li>
</ul>
<p>二级缓存：<code>earlySingletonObjects</code></p>
<ul>
<li>缓存提前对原始对象进行了 AOP 得到的代理对象</li>
<li>此时原始对象还没进行属性注入和后续的 BeanPostProcessor 等生命周期</li>
</ul>
<p>三级缓存：<code>singletonFactories</code></p>
<p>缓存某个 beanName 对应的 objectFactory，该工厂类主要用来生成原始对象进行 AOP 得到的代理对象。</p>
<ul>
<li>在 bean 的生成过程中会提前暴露该工厂类</li>
<li>如没有出现循环依赖：工厂类无作用，该 bean 按照自己生命周期执行，完后将 bean 放入 singletonObjects</li>
<li>如有循环依赖该 bean：依赖该 bean 的另一个 bean（bean2）从缓存中取出 bean 对应的工厂类并调用，获得原始对象（bean 无需 AOP）或代理对象（bean 需要 AOP）</li>
</ul>
<p>另：<code>earlyProxyReferences</code>：记录某个原始对象是否被 AOP 了</p>
<p>如何打破死循环？<br>可以通过<strong>加入中间人</strong>来解决。</p>
<p>场景1：上述场景，我们将其视为普通场景</p>
<ol>
<li>A 在进行依赖注入前，先将 A 的原始 bean 对象放入缓存<ul>
<li>提早暴露，只要放到缓存了，其它 bean 需要时就可从缓存中拿</li>
</ul>
</li>
<li>放入缓存后再进行依赖注入<ul>
<li>示例中 A 依赖于 B</li>
<li>如 B 的 bean 不存在，则需要创建 B 的 bean</li>
</ul>
</li>
<li>B 的创建过程跟 A 相似<ul>
<li>B 从缓存中拿到 A 的原始对象（不是最终的 bean），完成注入，创建完成</li>
<li>由此 A 创建完成</li>
</ul>
</li>
</ol>
<p><img src="/2022/03/11/spring-bean/circular-dep-1.png" alt></p>
<p>场景2：基于场景1</p>
<ul>
<li>A 的原始对象注入给 B 的属性后，A 的原始对象进行了 AOP，产生了一个代理对象<ul>
<li>对于 A：其 bean 对象是 AOP 后的代理对象</li>
<li>对于 B 的 a 属性：对应的不是 AOP 后的代理对象</li>
<li>即：B 依赖的 A 和最终的 A 不是同一个对象</li>
</ul>
</li>
<li>过程：A 生成普通对象 -&gt; 属性注入 -&gt; 基于切面生成代理对象 -&gt; 将代理对象放入 singletonObjects 单例池</li>
<li>总结（常出现的情况）：经常出现某个 bean name 对应的最终对象和原始对象<strong>不是同一个对象</strong>的情况。</li>
</ul>
<p>解决：利用第三级缓存 <code>singletonFactories</code></p>
<ul>
<li>在 bean 生命周期中，生成原始对象之后，就构建一个 ObjectFactory 存入 singletonFactories 中；</li>
<li>ObjectFactory 为函数式接口，支持执行 SmartInstantiationAwareBeanPostProcessor（接口）中的 <code>() -&gt; getEarlyBeanReference(beanName, rootBeanDefinition, bean)</code></li>
</ul>
<p>AbstractAutoProxyCreator 对该接口的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);  <span class="comment">// 首先得到 cache key，也就是 beanName</span></span><br><span class="line">    <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);  <span class="comment">// 将 beanName 和 bean（原始对象）存入 earlyProxyReferences 中</span></span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  <span class="comment">// 调用该方法进行 AOP，得到代理对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有这个类真正意义上实现了该方法，而这个类就是用来 AOP 的</span></span><br></pre></td></tr></table></figure>
<p>InstantiationAwareBeanPostProcessorAdapter 对该接口的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessorAdapter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/11/spring-bean/circular-dep-2.png" alt></p>
<p>ObjectFactory 存入 singletonFactories 时不会马上执行 lambda 表达式 getEarlyBeanReference()。</p>
<p>需要从缓存中取对象时：</p>
<ul>
<li>从 singletonFactories 根据 beanName 得到一个 ObjectFactory</li>
<li><strong>执行 ObjectFactory 的 <code>getEarlyBeanReference()</code></strong>，得到 A 代理对象</li>
<li>A 代理对象被放入 earlySingletonObjects 中</li>
</ul>
<p>此时 A 代理对象并未被放入 singletonObjects 中</p>
<ul>
<li>该代理对象由 A 的原始对象得来，还没进行属性填充，并不完整</li>
<li>其他依赖 A 的对象可从 earlySingletonObjects 得到 A 原始对象的代理对象</li>
</ul>
<p>A 完成属性注入后，会按照它本身的逻辑进行 AOP</p>
<ul>
<li>若 A 原始对象已经经历过 AOP，则此时不会再做 AOP</li>
<li>如何判断一个对象是否经历过 AOP？利用 AbstractAutoProxyCreator 实例的 earlyProxyReferences：<ul>
<li>AbstractAutoProxyCreator 的 postProcessAfterInitialization() 会判断当前 beanName 是否已在 earlyProxyReferences 中</li>
<li>如果存在则说明已经进行过 AOP</li>
</ul>
</li>
<li>判断 AOP 以及执行 BeanPostProcessor 后：<ul>
<li>从 earlySingletonObjects 获取 A 的代理对象，将其放入 singletonObjects 中</li>
</ul>
</li>
</ul>
<p>依此，循环依赖解决完毕。</p>
<p>从场景 2 延申：</p>
<p>BeanPostProcessor 可以对 bean 进行加工，不仅可修改 bean 的属性值，也可替换掉当前的 bean</p>
<ul>
<li>在 postProcessAfterInitialization 中可以返回新的 bean 对象</li>
<li>BeanPostProcessor 在 bean 属性注入后执行，而循环依赖在属性注入中进行</li>
<li>可能导致：注入 B 的 A，并不是那个经历过完整生命周期后的 A<br>问题无法解决：</li>
<li>属性注入时，Spring 并不知道 A 对象后续会经过哪些 BeanPostProcessor，以及会对 A 对象做什么处理</li>
</ul>
<p>如果发生另外的循环依赖，就需要程序员自己解决了。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 初探</title>
    <url>/2023/06/09/spring-cloud-overview/</url>
    <content><![CDATA[<p>Spring Cloud 和 Dubbo 都是目前主流的微服务框架。这篇主要聊聊 Spring Cloud 的一些组成情况。</p>
<span id="more"></span>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring Cloud 是一个基于 Spring Boot 实现的开源微服务架构开发工具。演进至今，衍生出了主流的两套框架：</p>
<h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p>包括以下组件：</p>
<ul>
<li><strong>Spring Cloud Config</strong>：分布式系统中统一的外部集中配置管理工具，默认使用 Git 存储；支持客户端配置信息的刷新、加密、解密操作。</li>
<li><strong>Spring Cloud Netflix</strong>：核心组件，对多个 Netflix OSS 开源套件进行整合<ul>
<li><a href="/2023/10/19/spring-cloud-service-regiscovery/#Eureka">Eureka</a>：负责服务治理，包括服务注册与发现，已停止维护</li>
<li><a href="/2023/10/05/spring-cloud-gateway/#Zuul">Zuul</a>：服务网关，提供智能路由、访问过滤等功能；其替代品是 <a href="/2023/10/05/spring-cloud-gateway/#Gateway">Gateway</a></li>
<li>Ribbon：负载均衡</li>
<li>Hystrix：容错管理组件，实现断路器模式，提供服务熔断和限流</li>
<li>Feign：基于 Ribbon 和 Hystix 的声明式服务调用组件，负责远程服务的客户端代理</li>
<li>Tuibine：将各个服务实例上的 Hystrix 监控信息统一整合</li>
<li>Archaius：外部化配置组件</li>
</ul>
</li>
<li><strong>Spring Cloud Bus</strong>：用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</li>
<li><strong>Spring Cloud Consul</strong>：基于 Hashicorp Consul 的服务治理组件。</li>
<li><strong>Spring Cloud ZooKeeper</strong>：基于 Apache ZooKeeper 的服务治理组件。</li>
<li><strong>Spring Cloud Cluster</strong>：针对 ZooKeeper, <a href="/2021/07/29/redis-basics">Redis</a>, Hazelcast, Consul 的选举算法和通用状态模式的实现。</li>
<li><strong>Spring Cloud Security</strong>：Spring Security 组件封装，提供用户验证和权限验证，对 Zuul 代理中的负载均衡 OAuth2 客户端及登陆认证进行支持。</li>
<li><strong>Spring Cloud Sleuth</strong>：分布式链路追踪组件，支持使用 HTrace, Zipkin 和基于 <a href="/2022/02/09/es/#ELK">Elastic Stack</a> 的跟踪。</li>
<li><strong>Spring Cloud Stream</strong>：轻量级事件驱动微服务框架，使用简单的声明式模型发送接收消息。主要实现是 Kafka 和 <a href="/2021/07/21/rabbitmq">RabbitMQ</a>。</li>
<li>…</li>
</ul>
<p>优点是产品成熟，缺点是已经停止更新了，且可视化界面缺少。</p>
<h2 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h2><p>从 2018 开始推出并迅速发展和成熟，已经在多个组织里面得到了广泛的应用。</p>
<p>包括以下组件：</p>
<ul>
<li><a href="/2023/10/19/spring-cloud-service-regiscovery/#Nacos">Nacos</a>：分布式配置中心、服务注册与发现</li>
<li>RocketMQ：消息驱动组件</li>
<li><a href="//#Sentinel">Sentinel</a>：服务容错组件，包括流量控制与服务降级</li>
<li>Seate：分布式事务</li>
<li>Dubbo：结合到 Spring Cloud 中，便是以 RPC 为框架的远程调用组件</li>
</ul>
<p>相对于 Spring Cloud Netflix，优点是产品能够持续迭代，配置相对简单；而缺点是欠缺稳定性。</p>
<h1 id="Spring-Cloud-v-s-Dubbo"><a href="#Spring-Cloud-v-s-Dubbo" class="headerlink" title="Spring Cloud v.s. Dubbo"></a>Spring Cloud v.s. Dubbo</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">Spring Cloud</th>
<th style="text-align:left">Dubbo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务注册中心</td>
<td style="text-align:left">Eureka, Consul, ZooKeeper, Nacos</td>
<td style="text-align:left">ZooKeeper</td>
</tr>
<tr>
<td style="text-align:left">服务调用方式</td>
<td style="text-align:left">REST，基于 HTTP</td>
<td style="text-align:left">RPC，基于 Dubbo</td>
</tr>
<tr>
<td style="text-align:left">服务监控</td>
<td style="text-align:left">Spring Boot Admin</td>
<td style="text-align:left">Dubbo-Monitor</td>
</tr>
<tr>
<td style="text-align:left">熔断器</td>
<td style="text-align:left">Spring Cloud Netflix Hystrix</td>
<td style="text-align:left">不完善</td>
</tr>
<tr>
<td style="text-align:left">服务网关</td>
<td style="text-align:left">Spring Cloud Netflix Zuul, Gateway</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">分布式配置</td>
<td style="text-align:left">Spring Cloud Config, Nacos</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">链路跟踪</td>
<td style="text-align:left">Spring Cloud Sleuth + Zipkin</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">数据流</td>
<td style="text-align:left">Spring Cloud Stream</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">批量任务</td>
<td style="text-align:left">Spring Cloud Task</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">信息总线</td>
<td style="text-align:left">Spring Cloud Bus</td>
<td style="text-align:left">无</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>架构</tag>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 依赖注入概述</title>
    <url>/2021/12/24/spring-di/</url>
    <content><![CDATA[<p>在 <a href="/2021/12/05/spring-ioc/">Spring IoC 概览</a>中我们提到过，Spring IoC 容器主要是通过 DI 实现并管理的。</p>
<span id="more"></span>
<p>本帖基于通过<strong>配置文件</strong>管理 Bean 的方式，简单地介绍一下 Spring IoC 容器在不同注入方向中的具体使用。</p>
<p><br></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>Spring 项目需要一份 XML 文件定义容器需要管理的所有 Bean，基本格式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;golf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.volkswagen.jeta&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jeta&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ea888&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ea888&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.volkswagen.ea888&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要能被找到，配置文件可以放在项目工程中的任意位置，且可以任意命名。一般都是命名为 <code>applicationContext.xml</code>，置于 <code>/src</code> 目录下。<br>Spring Framework 利用该文件创建所有已经在配置文件中定义的 Bean，按照其中标签的定义，给分配唯一的 ID。</p>
<p><br></p>
<h1 id="基于-setter-的依赖注入"><a href="#基于-setter-的依赖注入" class="headerlink" title="基于 setter 的依赖注入"></a>基于 setter 的依赖注入</h1><p>常用方法，用于 Bean 的无参构造函数或无参 static 工厂方法的实例化。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method to inject the dependency.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpellChecker</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside setSpellChecker.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a getter method to return spellChecker</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">getSpellChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dependency</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside SpellChecker constructor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSpelling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside checkSpelling.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spellChecker&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;spellChecker&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for spellChecker bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;spellChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.SpellChecker&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">TextEditor te = (TextEditor) context.getBean(<span class="string">&quot;textEditor&quot;</span>);</span><br><span class="line">te.spellCheck();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Inside SpellChecker constructor.</span></span><br><span class="line"><span class="comment">// Inside setSpellChecker.</span></span><br><span class="line"><span class="comment">// Inside checkSpelling.</span></span><br></pre></td></tr></table></figure>
<p>另外，我们还可以使用 <code>p-namespace</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:spellChecker-ref</span>=<span class="string">&quot;spellChecker&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>-ref</code> 表明这不是一个直接的值，而是对另一个 bean 的<strong>引用</strong>。</p>
<p>或者可以将配置文件改为注入内部 bean（内部类）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for textEditor bean using inner bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spellChecker&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;spellChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.SpellChecker&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注入集合"><a href="#注入集合" class="headerlink" title="注入集合"></a>注入集合</h2><p>本质上是基于 setter 的依赖注入。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>元素</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;list&gt;</code></td>
<td>线性表</td>
</tr>
<tr>
<td><code>&lt;set&gt;</code></td>
<td>不重复线性表</td>
</tr>
<tr>
<td><code>&lt;map&gt;</code></td>
<td>键值对，可为任何类型</td>
</tr>
<tr>
<td><code>&lt;props&gt;</code></td>
<td>键值对，须为字符串类型</td>
</tr>
</tbody>
</table>
</div>
<p>先上配置文件 <code>Beans.xml</code> 看一看：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for javaCollection --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;carBrands&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.CarBrand&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- results in a setBrandList(java.util.List) call --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brandList&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Mazda<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Honda<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Ford<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Cadillac<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- results in a setBrandSet(java.util.Set) call --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brandSet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Toyota<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Bentley<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BMW<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Geely<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- results in a setBrandMap(java.util.Map) call --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brandMap&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mini&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Trumpchi&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Nissan&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;4&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Chevrolet&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- results in a setBrandProp(java.util.Properties) call --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brandProp&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;one&quot;</span>&gt;</span>Jaguar<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;three&quot;</span>&gt;</span>BYD<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;four&quot;</span>&gt;</span>Benz<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Bean 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarBrand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List brandList;</span><br><span class="line">    Set brandSet;</span><br><span class="line">    Map brandMap;</span><br><span class="line">    Properties brandProp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method to set List</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrandList</span><span class="params">(List brandList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brandList = brandList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prints and returns all the elements of the list.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getBrandList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;List Elements :&quot;</span> + brandList);</span><br><span class="line">        <span class="keyword">return</span> brandList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method to set Set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrandSet</span><span class="params">(Set brandSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brandSet = brandSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prints and returns all the elements of the Set.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set <span class="title">getBrandSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Set Elements :&quot;</span> + brandSet);</span><br><span class="line">        <span class="keyword">return</span> brandSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method to set Map</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrandMap</span><span class="params">(Map brandMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brandMap = brandMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prints and returns all the elements of the Map.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getBrandMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Map Elements :&quot;</span> + brandMap);</span><br><span class="line">        <span class="keyword">return</span> brandMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method to set Property</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrandProp</span><span class="params">(Properties brandProp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brandProp = brandProp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prints and returns all the elements of the Property.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getBrandProp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Property Elements :&quot;</span> + brandProp);</span><br><span class="line">        <span class="keyword">return</span> brandProp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">CarBrand jc = (CarBrand) context.getBean(<span class="string">&quot;carBrands&quot;</span>);</span><br><span class="line">jc.getBrandList();</span><br><span class="line">jc.getBrandSet();</span><br><span class="line">jc.getBrandMap();</span><br><span class="line">jc.getBrandProp();</span><br></pre></td></tr></table></figure>
<h2 id="注入-Bean-引用"><a href="#注入-Bean-引用" class="headerlink" title="注入 Bean 引用"></a>注入 Bean 引用</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bean Definition to handle references and values --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Passing bean reference for java.util.List --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brandList&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;brand1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;brand2&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Benz<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Passing bean reference for java.util.Set --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brandSet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;brand1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;brand2&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BMW<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Passing bean reference for java.util.Map --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brandMap&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Porsche&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">&quot;two&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;brand1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">&quot;three&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;brand2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注入空值或-null"><a href="#注入空值或-null" class="headerlink" title="注入空值或 null"></a>注入空值或 null</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;exampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;exampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>小结：使用 <code>ref</code> 进行引用传递，使用 <code>value</code> 进行值传递。</p>
<p><br></p>
<h1 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside TextEditor constructor.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside SpellChecker constructor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSpelling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside checkSpelling.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件大同小异：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;spellChecker&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- “构造函数的引用” --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for spellChecker bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;spellChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.SpellChecker&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">TextEditor te = (TextEditor) context.getBean(<span class="string">&quot;textEditor&quot;</span>);</span><br><span class="line">te.spellCheck();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Inside SpellChecker constructor.</span></span><br><span class="line"><span class="comment">// Inside TextEditor constructor.</span></span><br><span class="line"><span class="comment">// Inside checkSpelling.</span></span><br></pre></td></tr></table></figure>
<p>如果构造函数里面不止一个形参，应该怎么解析？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如不止一个参数：需要按照形参的顺序提供参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Bar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Baz&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 也可使用 type 属性显式指定构造函数的形参类型（用于基本数据类型和 String） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2001&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Zara&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最好能使用 index 属性显式指定顺序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2001&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Zara&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Spring-Bean-的装配"><a href="#Spring-Bean-的装配" class="headerlink" title="Spring Bean 的装配"></a>Spring Bean 的装配</h1><p>决定了 bean 在 Spring 容器中组合在一起的方式。<br>Spring 容器需要知道需要什么 bean，以及容器应该如何使用 DI 将 bean 绑定在一起，同时将 bean 装配好。</p>
<h2 id="Bean-自动装配"><a href="#Bean-自动装配" class="headerlink" title="Bean 自动装配"></a>Bean 自动装配</h2><p>自动装配能让容器在不使用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 的时候能够<strong>自动装配</strong>（auto-wire）相互协作的 bean。<br>这样可以减少 xml 配置数量。</p>
<p>自动装配的本质是基于 setter（<code>byName</code>、<code>byType</code>）和构造函数（constructor）的依赖注入。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>no</code></td>
<td>默认配置，即没有自动装配，需通过 ref 显式引用。</td>
</tr>
<tr>
<td><code>byName</code></td>
<td>根据 <code>&lt;bean&gt;</code> 中某个 <code>&lt;property&gt;</code> 的 <code>name</code>（不是 property 的类名 class）自动装配。<br>如：某个 bean 中有一个名为 master 的属性（对应 setMaster() 的 setter），则容器会查找名字为 master（<code>name=&quot;master&quot;</code>）的 bean 并装配。</td>
</tr>
<tr>
<td><code>byType</code></td>
<td>根据 property 的数据类型（type），查找与其有 IS-A 关系的 bean，并自动装配。<br>* 多个匹配会抛出 <code>fatal exception</code>；<br>* 没有匹配的话，bean 的 property 不会被装配。</td>
</tr>
<tr>
<td><code>constructor</code></td>
<td>根据构造方法的参数的数据类型，进行 byType 模式的自动装配。</td>
</tr>
<tr>
<td><code>autodetect</code></td>
<td>如发现默认的构造方法，则用 constructor 模式；否则使用 byType 模式。</td>
</tr>
</tbody>
</table>
</div>
<p>基于 setter 装配的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpellChecker</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显式装配 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spellChecker&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;spellChecker&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Generic Text Editor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自动装配 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 寻找名字（byName）为 spellChecker 的 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Generic Text Editor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 寻找类型（byType）为 SpellChecker 的 bean --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注：如配置文件中存在另一个 class 为 com.example.SpellChecker 或此类的子类，会报错 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Generic Text Editor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基于构造函数装配的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动装配 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Definition for textEditor bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.TextEditor&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 寻找类型为 SpellChecker 的 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;Generic Text Editor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自动装配的限制：</p>
<ul>
<li>自动装配不如显式装配精确；</li>
<li>自动装配随时会被 <code>&lt;constructor-arg&gt;</code> 或 <code>&lt;property&gt;</code> 覆写；</li>
<li>基本数据类型（primitive）、字符串、类等简单属性不能被自动装配。</li>
</ul>
<p>一个比较好的选择是：用构造器参数实现强制依赖，用setter 方法实现可选依赖。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP 概述</title>
    <url>/2022/03/18/spring-aop/</url>
    <content><![CDATA[<p>同样，AOP 不仅仅是针对 Spring 才能应用的逻辑。</p>
<span id="more"></span>
<h1 id="AOP-概述"><a href="#AOP-概述" class="headerlink" title="AOP 概述"></a>AOP 概述</h1><p>我们知道，OOP 可以提供复杂而纵深的继承体系，但是对于一些非继承关系的横向加强功能并不容易实现。</p>
<p>比如，当很多其它的类的方法都调用某一个类的成员方法时，需要这些类都持有该类的对象，且这些类的所有对象都需要显式地依赖该对象。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    TheOne theOne;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheOne</span><span class="params">(TheOne theOne)</span> </span>&#123;<span class="keyword">this</span>.theOne = theOne;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aDoSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        theOne.doSth();</span><br><span class="line">        ...  <span class="comment">// business</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    TheOne theOne;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheOne</span><span class="params">(TheOne theOne)</span> </span>&#123;<span class="keyword">this</span>.theOne = theOne;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bDoSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        theOne.doSth();</span><br><span class="line">        ...  <span class="comment">// business</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A 和 B 两个类中的 doSth() 部分代码几乎是完全重复的，而且与其业务并不相关联。<br>有的时候虽然这种代码并不多，但是业务类膨胀了之后，万一都需要用到这一段逻辑，反复添加这种与业务不相关的代码也是一件比较烦的事。</p>
<p>能否用某种方式实现同样功能，而不需要开发者写重复的代码逻辑？</p>
<p><br></p>
<p>由此，我们提出了 <strong>A</strong>spect-<strong>O</strong>riented <strong>P</strong>rogramming，<strong>面向切面编程</strong>的概念，是一种对 OOP 纵向结构丰富而横向结构缺失的补充。</p>
<p>在 AOP 思想中，应用的功能分为两类：</p>
<ol>
<li>核心业务（核心关注点），如登陆、增加数据、删除数据</li>
<li>周边功能（横切关注点），如性能统计、日志、事务管理等</li>
</ol>
<p>周边功能，或者说非核心功能在 AOP 中被定义为切面；核心业务功能与切面功能分别独立开发，然后“编织”到一起，就是 AOP。</p>
<h2 id="AOP-实现基础"><a href="#AOP-实现基础" class="headerlink" title="AOP 实现基础"></a>AOP 实现基础</h2><p>AOP 的实现主要有两个方向：</p>
<ol>
<li>使用特殊的编译器，将这些功能代码在编译阶段“织入”源代码，运行时代码会被切入到类的指定方法、指定位置。</li>
<li>利用<strong>动态代理</strong>在运行时将这些功能代码切入。</li>
</ol>
<p>动态代理能够解决静态代理中代理类接口过多的问题。Java 提供了两种动态代理的方法：</p>
<p><strong>JDK 代理</strong></p>
<ul>
<li>通过<strong>反射</strong>接收被代理的类</li>
<li>被代理的目标类需要实现一个接口（业务相关的接口），没有在该接口定义的方法不能被代理</li>
<li>Spring AOP 默认采用此方式进行代理</li>
<li>只有被代理的类没有实现接口时：才会被切换到 CGLib 代理</li>
</ul>
<p><strong>CGLib</strong>（<strong>C</strong>ode <strong>G</strong>eneration <strong>Lib</strong>rary）代理</p>
<p>一个强大的高性能的代码生成包，底层使用一个小而快的字节码处理框架 <strong>ASM</strong></p>
<ul>
<li>需要 CGLib 支持，<code>Enhancer</code> 是 CGLib 的字节码增强器，可以很方便的对类进行拓展</li>
<li>相当于运行时扩展 Java 类与实现 Java 接口，动态创建一个被代理的类的非继承子类（组合）</li>
<li>也称为子类代理</li>
<li>final 类无法使用 CGLib 作为动态代理</li>
</ul>
<p>不同的 AOP 工具以及它们对应的织入时机如下：</p>
<p><img src="/2022/03/18/spring-aop/aop-tools.png" alt></p>
<h2 id="AOP-相关概念"><a href="#AOP-相关概念" class="headerlink" title="AOP 相关概念"></a>AOP 相关概念</h2><p>既然是“面向切面编程”，我们先来聊聊“切面”。</p>
<p><strong><big>切面</big></strong>（<strong>Aspect</strong>）是一个总的概念，阐述的是在什么时候（When），什么地方（Where）执行什么样的代码（What）。</p>
<p>切面由以下几个概念点组成：</p>
<p><strong>1</strong>. <strong><big>增强 Advice</big></strong></p>
<p>Advice 定义了切面当中的方法，以及声明了 Advice 方法在目标（Target）业务层的执行位置。<br>也就是说，Advice 定义好了 What（切入后进行的行为）和 When（切面切入时机）。</p>
<p>比如上例中的 <code>TheOne.doSth()</code> 就可以看作是一个可增强的点（Advice），它在类 A 和 B 里面执行的时机就是 “When”。 </p>
<p>针对一个 Advice 方法（What），合理的切入时机（When）包括：</p>
<ul>
<li><code>@Before</code>: 前置通知，方法调用前</li>
<li><code>@After</code>: 后置通知，方法执行后，不考虑返回</li>
<li><code>@AfterReturning</code>: 返回通知，方法返回后</li>
<li><code>@AfterThrowing</code>: 异常通知，方法抛出异常后</li>
<li><code>@Around</code>: 环绕通知，方法前以及方法后</li>
</ul>
<p>上述的切入时机叫做<strong>连接点</strong> <strong>Join Point</strong>，属于程序（业务流）中的概念，说明在业务流中<strong>可以</strong>对哪些方法进行拦截，拦截后怎么处理。</p>
<p>具体到代码中的话，可以将 Join Point 理解为目标对象中的具体方法。</p>
<p><strong>2</strong>. <strong><big>切入点 Pointcut</big></strong></p>
<p>切入点定义了 Where，即选择在某一个<strong>确定的连接点 Join Point</strong> —— 确定在哪些类、哪些方法上进行切入。</p>
<p>在确定切入点的时候，允许定义具体的方法名、类名，或者使用正则匹配等方法。</p>
<p>因此连接点 Join Points 指的是程序执行流中<strong>所有</strong>可以被选择做增强的点；而切入点 Pointcut 指的是从所有可以的 Join Points 中确定<strong>具体</strong>要拦截的某个业务点。</p>
<p>在 Advice 与 Pointcut 配合下，切面就成型了。程序就知道切入的 When、Where 和 What，即什么时机，什么地方做什么样的增强。</p>
<p><img src="/2022/03/18/spring-aop/aop.png" alt></p>
<p>除了切面的概念之外，其它概念包括：</p>
<p><strong><big>织入 Weaving</big></strong></p>
<p>织入指的是根据切面的定义，将相应的 advice 加入到切面 pointcut 指定的 join points，并创造出代理对象的过程。</p>
<p>织入由代理完成。</p>
<p><strong><big>目标对象 Target</big></strong></p>
<p>被一个或多个切面增强的对象，因此也被称为“被增强对象”。它永远是一个被代理对象。</p>
<p><strong><big>引入 Introduction</big></strong></p>
<p>相对于切面只是针对指定方向的增强，引入可以针对类进行增强，为其动态添加<strong>新的方法或域</strong>。</p>
<h2 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h2><ul>
<li>权限控制（鉴权）</li>
<li>日志</li>
<li>参数校验</li>
<li>缓存、调试、性能检测</li>
<li>一定程度的事务处理</li>
<li>…</li>
</ul>
<p>应用 AOP 的目的：</p>
<ul>
<li>将与业务无关，却为业务所共同调用的逻辑或责任（事务处理、日志管理、鉴权、…）封装起来</li>
<li>可以集中处理某一关注点/横切逻辑，并且很方便地添加/删除关注点</li>
<li>便于减少系统重复代码，降低模块间耦合度，利于可拓展性和可维护性</li>
</ul>
<p>在别处找了一个 AOP 的思维导图参考一下：</p>
<p><img src="/2022/03/18/spring-aop/aop-mind-mapping.png" alt></p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器。</p>
<p>实现原理：运行时通过<strong>代理</strong>方式向目标类织入增强代码。</p>
<p>主要的实现方向有两个：</p>
<ul>
<li>接口 + 实现类：采用 JDK 动态代理 Proxy</li>
<li>仅实现类：使用 CGLib 字节码增强</li>
</ul>
<p><img src="/2022/03/18/spring-aop/spring-aop-process.jpg" alt></p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><ul>
<li>如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP。</li>
<li>如果目标对象实现了接口，可以强制使用 CGLib 实现 AOP。</li>
<li>如果目标对象没有实现了接口，必须采用 CGLib 库，Spring 会自动在 JDK 动态代理和 CGLib 之间转换。</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>JDK 动态代理：通过<strong>接口</strong>实现</p>
<ul>
<li>通过继承 <code>InvocationHanlder</code> 实现<strong>拦截器</strong>，结合<strong>反射</strong>机制实现一个代理接口</li>
<li>再通过 <code>Proxy.newProxyInstance()</code> 方法，由传入的 classloader 生成接口<strong>代理类</strong>的字节码文件</li>
<li>根据字节码文件创建代理类的实例对象</li>
<li>只能对<strong>实现了接口</strong>的类生成代理，否则抛出异常</li>
</ul>
<p>CGLib：通过<strong>继承</strong>覆盖</p>
<ul>
<li>利用 ASM 开源包，加载被代理对象（真实对象）类的 <code>.class</code> 文件，通过<strong>修改其字节码</strong>生成<strong>子类</strong></li>
<li>主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强</li>
<li>因为采用的是<strong>继承</strong>，对于 final 类或方法，是无法起效果的</li>
</ul>
<p><br></p>
<p>Spring 2.0+ 之后引入了对 AspectJ 的支持。</p>
<p>Spring AOP 和 AspectJ 两种 AOP 方向的比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Spring AOP</th>
<th>AspectJ</th>
</tr>
</thead>
<tbody>
<tr>
<td>纯 Java 实现</td>
<td>使用 Java 语言的扩展实现</td>
</tr>
<tr>
<td>不需要单独的编译过程</td>
<td>除非设置 LTW，否则需要 AspectJ 编译器（ajc）</td>
</tr>
<tr>
<td>只能使用运行时织入</td>
<td>运行时织入不可用。<br>支持编译时、编译后和加载时织入</td>
</tr>
<tr>
<td>功能不强：只支持方法级织入</td>
<td>更强大：可编织字段、方法、构造函数、静态初始值设定项、final 类/方法等</td>
</tr>
<tr>
<td>只能在由 Spring 容器管理的 bean 上实现</td>
<td>可在所有域对象上实现</td>
</tr>
<tr>
<td>仅支持方法执行切入点</td>
<td>支持所有织入点</td>
</tr>
<tr>
<td>代理是由目标对象创建的，并且切面应用在这些代理上</td>
<td>执行应用程序（运行时）前，各方面直接在代码中进行织入</td>
</tr>
<tr>
<td>比 AspectJ 慢多了</td>
<td>更好的性能</td>
</tr>
<tr>
<td>易于学习和应用</td>
<td>相对于 Spring AOP 更复杂</td>
</tr>
</tbody>
</table>
</div>
<p>下面说一下几种不同的 AOP 实现方式：</p>
<p><br></p>
<h2 id="手动方式（原理代码）"><a href="#手动方式（原理代码）" class="headerlink" title="手动方式（原理代码）"></a>手动方式（原理代码）</h2><p>下面基于 Spring AOP 实现原理手动实现 <strong>JDK 动态代理</strong>和 <strong>CGLib</strong> 两种方式的 AOP，这是没有 Spring 侵入的实现方式。</p>
<p>现有目标类 Target：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这些都是 join points</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和切面类 Aspect：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;  <span class="comment">// 该切面类属于环绕通知</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BEFORE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AFTER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>1</strong>. JDK 动态代理。要求目标类为接口 + 实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;  <span class="comment">// 实现方式的核心</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标类</span></span><br><span class="line">        <span class="keyword">final</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 切面类</span></span><br><span class="line">        <span class="keyword">final</span> MyAspect myAspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理类（核心）</span></span><br><span class="line">        UserService proxyService = (UserService) Proxy.newProxyInstance(</span><br><span class="line">                MyBeanFactory.class.getClassLoader(),  <span class="comment">// 提供类加载器将类加载到内存</span></span><br><span class="line">                userService.getClass().getInterfaces(),  <span class="comment">// 获取代理类需要实现的所有接口</span></span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;  <span class="comment">// 处理类（核心）。代理类每一个方法执行时将调用一次 invoke()</span></span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,  // 代理对象</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Method method,  // 目标类对象当前执行的方法对象（反射）</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Object[] args  // 方法实参</span></span></span><br><span class="line"><span class="params"><span class="function">                                        )</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 前执行</span></span><br><span class="line">                        myAspect.before();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 执行目标类的方法</span></span><br><span class="line">                        Object obj = method.invoke(userService, args);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 后执行</span></span><br><span class="line">                        myAspect.after();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> proxyService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. CGLib 字节码增强：只有实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;  <span class="comment">// CGLib 实现核心</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标类</span></span><br><span class="line">        <span class="keyword">final</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 切面类</span></span><br><span class="line">        <span class="keyword">final</span> MyAspect myAspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理类，以此创建目标类的子类，无需接口</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(userService.getClass());  <span class="comment">// 确定父类</span></span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123; <span class="comment">// 等效于 JDK 中的 InvocationHandler 接口</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// intercept 等效于 JDK 中的 invoke</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args,  // 参数和 JDK 动态代理实现时差不多</span></span></span><br><span class="line"><span class="params"><span class="function">                        MethodProxy methodProxy  // 代理对象当前执行的方法对象</span></span></span><br><span class="line"><span class="params"><span class="function">                        )</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前</span></span><br><span class="line">                myAspect.before();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行目标类的方法</span></span><br><span class="line">                Object obj = method.invoke(userService, args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 或：执行代理类的父类，即目标类（目标类和代理类是父子关系）</span></span><br><span class="line">                <span class="comment">// Object obj = methodProxy.invokeSuper(proxy, args);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 后</span></span><br><span class="line">                myAspect.after();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建代理</span></span><br><span class="line">        UserServiceImpl proxyService = (UserServiceImpl) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxyService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：MethodInterceptor.intercept() 能够代理某个对象所有<strong>非 final 方法</strong>的调用。<br>因此 getClass(), wait() 等 final 方法不能被代理。</p>
<h2 id="半自动"><a href="#半自动" class="headerlink" title="半自动"></a>半自动</h2><p>利用切面实现介入器 MethodInterceptor，并从 Spring 容器手动获取代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切面实现 MethodInterceptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动执行目标方法</span></span><br><span class="line">        Object obj = mi.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 目标类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切面类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyAspect&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 创建代理类</span></span><br><span class="line"><span class="comment">        * 通过工厂 bean ProxyFactoryBean 创建，底层调用 getObject() 返回特殊代理对象</span></span><br><span class="line"><span class="comment">            - interfaces：确定接口</span></span><br><span class="line"><span class="comment">                通过&lt;array&gt;可以设置多个值</span></span><br><span class="line"><span class="comment">                只有一个值：value=&quot;&quot;</span></span><br><span class="line"><span class="comment">            - target：确定目标类</span></span><br><span class="line"><span class="comment">            - interceptorNames：增强切面类的名称</span></span><br><span class="line"><span class="comment">            - optimize：强制使用 CGLib</span></span><br><span class="line"><span class="comment">                &lt;property name=&quot;optimize&quot; value=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment">        * ProxyFactoryBean 的底层机制</span></span><br><span class="line"><span class="comment">            - 如目标有接口：采用 JDK 动态代理</span></span><br><span class="line"><span class="comment">            - 如没有接口：采用 CGLib 字节码增强</span></span><br><span class="line"><span class="comment">            - 如声明 optimize=true：强制使用 CGLib</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;proxyService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaces&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.UserService&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;myAspect&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- 定义切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>MyAspect 的 AOP 在以下的调用中就能实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">&quot;proxyService&quot;</span>);</span><br><span class="line">userService.addUser();</span><br></pre></td></tr></table></figure>
<h2 id="全自动"><a href="#全自动" class="headerlink" title="全自动"></a>全自动</h2><p>大体的步骤如下：</p>
<ol>
<li>从 Spring 容器获得目标类（target）</li>
<li>通过配置文件配置 AOP</li>
<li>Spring 自动生成代理</li>
</ol>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>= <span class="string">&quot;http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for beans --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.target&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;someAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aspect.someAspect&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 AOP --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如配置 proxy-target-class=“true”：使用 CGLib 代理 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- where: 在哪些地方（包.类.方法）做增强 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;someCutpoint&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">expression</span>=<span class="string">&quot;execution(* target.doSomething.*(..))&quot;</span>/&gt;</span>  <span class="comment">&lt;!--  声明切入点 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一个 *：返回值任意</span></span><br><span class="line"><span class="comment">             接下来：包.类名.方法名.(参数) --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- what: 做什么增强 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;aspectDemo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;someAspect&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 声明切面 --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- when: 在什么时机（方法前/后/前后） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;someCutpoint&quot;</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">method</span>=<span class="string">&quot;someMethod&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- 这里的时机是：方法前后（around）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 特殊的切面，只有一个通知和一个切入点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;someAspect&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;someCutpoint&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外还需要在 CLASSPATH 使用相关 AspectJ 库文件。</p>
<p>AOP 切面声明参考：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;someBusinessServiceMethod&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- a before advice definition --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;someBusinessServiceMethod&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doRequiredTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- an after advice definition --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;someBusinessServiceMethod&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doRequiredTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- an after-returning advice definition --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--The doRequiredTask method must have parameter named retVal --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;someBusinessServiceMethod&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;retVal&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doRequiredTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- an after-throwing advice definition --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--The doRequiredTask method must have parameter named ex --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;someBusinessServiceMethod&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;ex&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doRequiredTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- an around advice definition --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;someBusinessServiceMethod&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doRequiredTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用的时候就可以：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就免掉了 AOP 的 Java 代码。</p>
<h2 id="基于-AOP-的-AspectJ：注解配置-AOP"><a href="#基于-AOP-的-AspectJ：注解配置-AOP" class="headerlink" title="基于 AOP 的 AspectJ：注解配置 AOP"></a>基于 AOP 的 AspectJ：注解配置 AOP</h2><p>需要在配置文件中添加这么一行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新增如下配置： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>工程中再声明一个增强：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Following is the definition for a pointcut to select </span></span><br><span class="line"><span class="comment">     * all the methods available. So advice will be called </span></span><br><span class="line"><span class="comment">     * for all the methods. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.tutorialspoint.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectAll</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 此处为 pointcut signature</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * This is the method which I would like to execute </span></span><br><span class="line"><span class="comment">     * before a selected method execution. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Before(&quot;selectAll()&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Going to setup student profile.&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注：注解的值可以为 pointcut 表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span>(&quot;execution(* com.tutorialspoint.*.*(..))&quot;)</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method which I would like to execute</span></span><br><span class="line"><span class="comment">     * after a selected method execution.</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@After(&quot;selectAll()&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Student profile has been setup.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method which I would like to execute</span></span><br><span class="line"><span class="comment">     * when any method returns.</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;selectAll()&quot;, returning=&quot;retVal&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Returning:&quot;</span> + retVal.toString() );</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method which I would like to execute</span></span><br><span class="line"><span class="comment">     * if there is an exception raised by any method.</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;selectAll()&quot;, throwing = &quot;ex&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterThrowingAdvice</span><span class="params">(IllegalArgumentException ex)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;There has been an exception: &quot;</span> + ex.toString()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记好注解之后，在配置文件只需要添加 aspect bean 的定义即可。</p>
<p>声明参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;someBusinessServiceMethod()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(&quot;someBusinessServiceMethod()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;someBusinessServiceMethod()&quot;, returning=&quot;retVal&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturnningTask</span><span class="params">(Object retVal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you can intercept retVal here. </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterThrowing(pointcut = &quot;someBusinessServiceMethod()&quot;, throwing=&quot;ex&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowingTask</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you can intercept thrown exception here. </span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;someBusinessServiceMethod()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAroundTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring AspectJ 是通过 <code>AnnotationAwareAspectJAutoProxyCreator</code> 实现的。</p>
<p>其本质上是一个 BeanPostProcessor，父类为 AbstractAutoProxyCreator。<br>给一个类中的某个方法设置了切面之后，这个类最终需要生成一个代理对象，再放进 bean 缓存池中。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC 概览</title>
    <url>/2021/12/05/spring-ioc/</url>
    <content><![CDATA[<p>首先我们要明确的是，IoC 并不是最近才兴起的说法，更不是只有 Spring 才能应用的逻辑，而是自 OOP 面世以来就有的概念。</p>
<span id="more"></span>
<h1 id="什么是-IoC？"><a href="#什么是-IoC？" class="headerlink" title="什么是 IoC？"></a>什么是 IoC？</h1><p><strong>Inversion of Control</strong>，译作<strong>控制反转</strong>，是 OOP 的一种设计原则和架构模式，还算不上是设计模式。</p>
<p>一句经典的解释，就是：<br><strong>“Don’t call me, I’ll call you. “</strong></p>
<p><br></p>
<h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><p>针对“控制反转”这个概念，我们先提出三个问题：</p>
<p><strong>Q1</strong>：什么的控制？<br><strong>Q2</strong>：为何反转？<br><strong>Q3</strong>：如何反转？</p>
<p>接着我们来看一下传统 Java 代码中的 HAS-A 结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种耦合度较强的代码，至少有一处需要：</p>
<ol>
<li>显式或隐式地创建 A 的对象</li>
<li>B 类依赖于 A 类对象作为内部属性</li>
</ol>
<p>对于每一次的 HAS-A，都需要这样的程序代码进行上述控制（<strong>Q1</strong>），当复杂度升高时，便难以掌控了（<strong>Q2</strong>）。<br>针对 HAS-A 的这个典型问题，为了解耦这样的代码，且便于掌控代码引用，我们需要使用一个<strong>统一的对象依赖控制器</strong>。</p>
<p>IoC 能够代替程序代码包办这层控制，从而降低耦合度。<br>程序代码只需向 IoC 控制器“索要”依赖的对象，而不是自己“造”。<br>也就是说，<strong>依赖对象的获得被反转了</strong>（<strong>Q3</strong>），所反转的“控制”是对象间的依赖。</p>
<h2 id="特点（Q2）"><a href="#特点（Q2）" class="headerlink" title="特点（Q2）"></a>特点（<strong>Q2</strong>）</h2><ul>
<li>体现软件工程原则之一：解耦；</li>
<li>对实例的控制由程序转移到了控制器/容器/框架，随后便可以注入到引用中；</li>
<li>为模块化提供支撑，实现“热插拔”。</li>
</ul>
<h2 id="IoC-的实现"><a href="#IoC-的实现" class="headerlink" title="IoC 的实现"></a>IoC 的实现</h2><p>IoC 各种概念的层次如下：</p>
<p><img src="/2021/12/05/spring-ioc/ioc-layer.png" alt></p>
<p>因此 IoC 仅为一种设计原则，需要具体的实现，通常还结合着 DIP（Dependency Inversion Principle）使用。</p>
<p>市面上较为知名的 Java IoC 容器如下：</p>
<ul>
<li>轻量级：Pico Container，Avalon，<strong>Spring</strong>，HiveMind</li>
<li>较重量级：<strong>JBoss</strong>，Jdon</li>
<li>超重量级：<strong>EJB</strong></li>
</ul>
<p>它们都是基于以下三个方向去实现控制反转：</p>
<ol>
<li>构造方法注入</li>
<li>setter 注入</li>
<li>成员变量注入</li>
</ol>
<p>IoC 的实现有多种方式：</p>
<p><img src="/2021/12/05/spring-ioc/ioc-implementation.png" alt></p>
<p>当然用得最多的要数依赖注入（DI）了。</p>
<p><br></p>
<h3 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入 DI"></a>依赖注入 DI</h3><p><strong>Dependency Injection</strong>，依赖注入，属于设计模式的一种，是 IoC 的一种具体实现。</p>
<p>此时，被注入的对象依赖于 IoC 容器去配置依赖对象。由此便改变了以往由程序代码主动为对象的依赖赋值的操作，改为由 DI 控制器统一处理。</p>
<p>依赖注入的实现方式可以基于多个方面：</p>
<ul>
<li>基于接口（Interface Injection）：实现特定接口，以供外部容器注入所依赖类型的对象</li>
<li>基于构造函数（Constructor Injection）：在新建对象时传入所依赖类型的对象</li>
<li>基于 setter（Setter Injection）：让外部容器调用传入所依赖类型的对象</li>
<li>基于参数（Parameter Injection）</li>
<li>基于注解</li>
<li>…</li>
</ul>
<p>举一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IocSpellChecker checker;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.checker = <span class="keyword">new</span> SpellChecker();  <span class="comment">// TextEditor 依赖于 SpellChecker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于构造函数的依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(IocSpellChecker checker)</span> </span>&#123;  <span class="comment">// 在构造函数注入依赖 IocSpellChecker</span></span><br><span class="line">        <span class="keyword">this</span>.checker = checker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来，再调用 TextEditor 的时候就可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IocSpellChecker sc = <span class="keyword">new</span> SpellChecker();  <span class="comment">// dependency</span></span><br><span class="line">TextEditor textEditor = <span class="keyword">new</span> TextEditor(sc);  <span class="comment">// get the dependency (inject the dependency)</span></span><br></pre></td></tr></table></figure>
<p>依上述，我们可以大概总结出基于 DI 的 IoC 实现：</p>
<p><img src="/2021/12/05/spring-ioc/ioc-steps.png" alt></p>
<h3 id="依赖查找-DL"><a href="#依赖查找-DL" class="headerlink" title="依赖查找 DL"></a>依赖查找 DL</h3><p>Dependency Lookup，比依赖注入更加主动</p>
<ul>
<li>在需要时，通过调用框架提供的方法主动索取相对应类型的对象</li>
<li>在获取时，需要提供相关的配置文件路径、key 等信息来确定获取对象的状态</li>
</ul>
<p>下面来看一看 Spring 框架是怎么实现 IoC 的。</p>
<p><br></p>
<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><p>很明显，Spring IoC 将原本在程序中手动创建对象的控制权，交给了 Spring 框架来管理。</p>
<p><img src="/2021/12/05/spring-ioc/get-bean.png" alt></p>
<p>Spring 的 IoC 定义了以下概念：</p>
<p><strong>Bean</strong>：等待被注入的依赖对象。对象不一定非得要 JavaBean，也可以是 POJO 类。</p>
<p><strong>容器</strong>：控制反转的控制器，负责创建、管理、装配、配置 bean。<br>容器管理着所有 bean 的生命周期以及它们之间的依赖链，并支持加载服务时的饿汉式初始化和懒加载。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>好处就显而易见了，都是 IoC 本身带来的红利：</p>
<ul>
<li>使应用代码量降到最低，容易测试，UT 不再需要单例和 JNDI 查找机制</li>
<li>使松散耦合得以实现</li>
<li>支持即时实例化和懒加载</li>
</ul>
<h2 id="Spring-IoC-的容器类型"><a href="#Spring-IoC-的容器类型" class="headerlink" title="Spring IoC 的容器类型"></a>Spring IoC 的容器类型</h2><p><strong>BeanFactory</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 包含 bean 集合的工厂类</span></span><br><span class="line"><span class="comment">     * 使用上最简单，为 DI 提供基本支持</span></span><br><span class="line"><span class="comment">     * 相对于 ApplicationContext 更轻量级，数据量和速度可观</span></span><br><span class="line"><span class="comment">     * 主要应用于移动设备或基于 applet 的应用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.xml;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 XML 文件读取配置元数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line">XmlBeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;Beans.xml&quot;</span>));  <span class="comment">// 参数为配置文件全路径</span></span><br><span class="line">HelloWorld obj = (HelloWorld) factory.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/2021/12/05/spring-ioc/xmlbeanfactory-class-diagram.png" alt></p>
<p><strong>ApplicationContext</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>, <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Spring 的核心，负责管理所有 bean 完整生命周期</span></span><br><span class="line"><span class="comment">     * BeanFactory 的子接口，在 BeanFactory 基础上提供额外功能</span></span><br><span class="line"><span class="comment">     *   (ListableBeanFactory extends BeanFactory)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在抽象类的基础上添加了更多企业特定功能，比如：</span></span><br><span class="line"><span class="comment">     *   - 从属性文本中解析文本</span></span><br><span class="line"><span class="comment">     *   - 将事件传递给所指定的监听器</span></span><br><span class="line"><span class="comment">     * 包含 BeanFactory 容器所有功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供配置文件 XML 的完整路径</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供正确配置的 CLASSPATH 环境变量，容器便会从 CLASSPATH 搜索 bean 配置文件</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;/src/Beans.xml&quot;</span>);</span><br><span class="line">HelloWorld obj = (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/2021/12/05/spring-ioc/filesystemxmlapplicationcontext-class-diagram.png" alt></p>
<p><img src="/2021/12/05/spring-ioc/classpathxmlapplicationcontext-class-diagram.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 Web application 范围内加载在 XML 文件中已被定义的 bean</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/05/spring-ioc/webapplicationcontext-class-diagram.jpg" alt></p>
<p>区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用懒加载</td>
<td>使用即时加载</td>
</tr>
<tr>
<td>使用语法显式提供资源对象</td>
<td>自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Spring-实现概述"><a href="#Spring-实现概述" class="headerlink" title="Spring 实现概述"></a>Spring 实现概述</h2><p>Spring 容器主要通过 DI，根据配置文件或注解获取 metadata，进行 Bean 依赖的管理。</p>
<p>Spring 的 DI 容器主要完成三个任务：</p>
<ol>
<li>根据配置文件或注解，解析出 Bean 之间完整的依赖图，拿到 Bean 的全路径名；</li>
<li>利用 Java <a href="/2021/05/25/reflection-java">反射</a>，用适当的方式创建出 Bean，保存到一个容器内；</li>
<li>再次利用反射，在适当时机取得将被依赖的 Bean，将其作为成员变量（构造函数、setter 或其他方法）注入到依赖这个 Bean 的另一个 Bean 中。</li>
</ol>
<p>对于通过<a href="/2021/12/24/spring-di">配置文件</a>或<a href="/2022/01/01/spring-annotation">注解</a>定义 Bean，随后会有专门的篇幅加以介绍。</p>
<p><img src="/2021/12/05/spring-ioc/beans-management.png" alt></p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 开发概况</title>
    <url>/2021/11/20/spring-overview/</url>
    <content><![CDATA[<p>接触过 Java 开发的人，基本上都听说过 <code>Spring</code>。</p>
<span id="more"></span>
<p>Spring 是目前最受欢迎的 Java 开发容器框架。它的成功是基于 <strong>IoC</strong>（<strong>I</strong>nvension <strong>o</strong>f <strong>C</strong>ontrol, 控制反转）和 <strong>AOP</strong>（<strong>A</strong>spect <strong>O</strong>riented <strong>P</strong>rogramming, 面向切面编程）等理念，而不是技术本身。</p>
<p>跟 EJB 差不多的是，Spring 也是基于使用 Bean 或 JavaBean 属性（也可以是任意 POJO 组件）进行组件管理的。</p>
<p>Spring 的<a href="https://spring.io/projects/spring-framework#learn">版本迭代</a>非常快，但是基本的架构是不会做大改动的。</p>
<p>Spring 能做什么？</p>
<ul>
<li><strong>微服务</strong>（microservices）：程序员能够根据具体业务，快速搭建所需要的软件和应用架构</li>
<li><strong>响应式编程</strong>（reactive）</li>
<li><strong>云</strong>（cloud）：云端开发</li>
<li><strong>Web 应用</strong>（web apps）开发：覆盖了日常使用 Spring 的绝大部分场景</li>
<li><strong>无服务</strong>（serverless）：提供对应的操作函数到云上，按需提供服务</li>
<li><strong>事件驱动</strong>（event driven）：响应式的一种，通过事件对业务进行驱动形式的分发</li>
<li><strong>批量任务处理</strong>（batch）</li>
</ul>
<p><img src="/2021/11/20/spring-overview/what-spring-can-do.png" alt></p>
<p><br></p>
<h1 id="初衷和目标"><a href="#初衷和目标" class="headerlink" title="初衷和目标"></a>初衷和目标</h1><p>初衷：</p>
<ol>
<li>简化 Java EE 开发</li>
<li>为 JavaBean 提供一个更好的应用配置框架</li>
<li>使用接口而不是使用类，是更好的编程习惯</li>
<li>更多强调面向对象设计，而不是现行技术如 Java EE</li>
<li>尽量减少不必要的异常捕捉</li>
<li>使应用程序更容易测试</li>
</ol>
<p>Spring 将使用接口的复杂度几乎降到了 0。</p>
<p>目标：</p>
<ol>
<li>令人更愉快使用 Spring</li>
<li>应用程序代码并不依赖于 Spring APIs</li>
<li>Spring 不和现有的解决方案竞争，而是致力于将它们融合在一起</li>
</ol>
<p><br></p>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul>
<li>轻量级，基本版本的大小约为 2 MB</li>
<li>由 IoC 和 AOP 带来的高内聚，低侵入/低耦合</li>
<li>容器式的管理：包含并管理应用中对象的生命周期和配置</li>
<li>非侵入式设计：无需继承框架提供的任何类；将来更换框架的时候，之前的代码几乎可继续使用</li>
<li>声明式事务管理：只需要通过配置就可完成对事务的管理，无需手动编程</li>
<li>方便集成各种优秀框架<ul>
<li>Struts, Hibernate, iBatis, Quartz, …</li>
</ul>
</li>
<li>降低 J2EE API 的使用难度，使 J2EE 开发变得更容易使用</li>
<li>支持 JUnit4 注解，方便程序的测试</li>
</ul>
<p><br></p>
<h1 id="Spring-开发项目内的各种概念"><a href="#Spring-开发项目内的各种概念" class="headerlink" title="Spring 开发项目内的各种概念"></a>Spring 开发项目内的各种概念</h1><h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><p>Spring Framework 是一个大引擎，是我们最常说的“Spring”，也是 Spring 所有项目的核心。</p>
<p>Spring Framework 包括 20+ 组件/模块，分为：</p>
<ul>
<li>核心容器<ul>
<li>提供最重要的 IoC/DI 功能，包含 Core、Beans、Context 等组件</li>
<li>创建、包含所有对象并管理应用对象的生命周期和依赖关系</li>
</ul>
</li>
<li>数据处理与集成<ul>
<li>提供与数据库交互的抽象，比如对 JDBC、ORM 等的封装</li>
<li>提供事务管理和消息驱动</li>
</ul>
</li>
<li>Web：提供基于 Servlet 的 Web 服务支撑</li>
<li>AOP：提供面向切面编程的支持</li>
<li>测试：提供与 JUnit 等测试组件对接的支持</li>
</ul>
<p><img src="/2021/11/20/spring-overview/spring-framework-runtime.png" alt></p>
<p>Spring Framework 能帮我们做什么？</p>
<ul>
<li>根据配置文件，创建及组装对象之间的依赖关系；</li>
<li>通过 AOP 实现无耦合的日志记录、性能统计、安全控制等；</li>
<li>非常简单地管理数据库事务，可向下扩展到本地事务；</li>
<li>与第三方数据访问框架（Hibernate、JPA）无缝集成，自身也提供一套 JDBC 访问模版；</li>
<li>与第三方 Web 框架（Struts1/2、JSF）无缝集成，自身也提供一套 MVC 框架；</li>
<li>方便地与 J2EE 及更多技术整合（如缓存框架）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 核心依赖包：</span></span><br><span class="line">spring-beans-5.0.0.RELEASE.jar  <span class="comment"># 提供 BeanFactory</span></span><br><span class="line">spring-context-5.0.0.RELEASE.jar  <span class="comment"># 使用类似 JNDI 方法访问对象</span></span><br><span class="line">spring-context-support-5.0.0.RELEASE.jar</span><br><span class="line">spring-core-5.0.0.RELEASE.jar  <span class="comment"># 框架基本组成部分，包括 IoC 和 DI</span></span><br><span class="line">spring-expression-5.0.0.RELEASE.jar  <span class="comment"># Spring 表达式语言支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOP 模块：</span></span><br><span class="line">spring-aop-5.0.0.RELEASE.jar  <span class="comment"># 基于代理的 AOP 支持</span></span><br><span class="line">spring-aspects-5.0.0.RELEASE.jar  <span class="comment"># 基于 Aspects 的 AOP 支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据处理与集成：</span></span><br><span class="line">spring-jdbc-5.0.0.RELEASE.jar  <span class="comment"># 对 JDBC 连接的封装功能</span></span><br><span class="line">spring-orm-5.0.0.RELEASE.jar  <span class="comment"># 对象关系映射 API 集成，包括 JPA、JDO、Hibernate 等</span></span><br><span class="line">spring-oxm-5.0.0.RELEASE.jar  <span class="comment"># JAXB、XML Beans 等</span></span><br><span class="line">spring-tx-5.0.0.RELEASE.jar  <span class="comment"># 事务操作</span></span><br><span class="line">spring-jms-5.0.0.RELEASE.jar  <span class="comment"># 生产消费消息模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Web模块：</span></span><br><span class="line">spring-web-5.0.0.RELEASE.jar  <span class="comment"># 提供 web 基础功能</span></span><br><span class="line">spring-webmvc-5.0.0.RELEASE.jar  <span class="comment"># 提供 Spring MVC 功能</span></span><br><span class="line">spring-websocket-5.0.0.RELEASE.jar  <span class="comment"># 提供 web socket 支持</span></span><br><span class="line">spring-webmvc-portlet-5.0.0.RELEASE.jar  <span class="comment"># 提供 portlet 环境支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试：</span></span><br><span class="line">spring-test  <span class="comment"># 提供对测试功能的支持</span></span><br></pre></td></tr></table></figure>
<p>依赖关系：</p>
<p><img src="/2021/11/20/spring-overview/spring-framework-dependencies.png" alt></p>
<p>Spring 允许只选择适用自身开发的模块，不需要将其他模块也引入。</p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC 属于 Spring Framework 的 Web 类模块中的一个提供 Web 服务的基础框架。</p>
<p>顾名思义，它能提供 MVC 架构和随时可用的组件，有助于分离应用程序的不同方面，如输入逻辑、业务逻辑和 UI 逻辑，且在所有元素之间提供松散耦合。</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><a href="/2022/04/20/springboot">Spring Boot</a></h2><p>Spring Boot 是基于 Spring Framework 的解决方案<strong>套件</strong>（Suite），或者快捷方式，相当于一套脚手架。</p>
<ul>
<li>集成了 Web 服务器，实现了 Spring Framework 的自动化配置，以及解决了许多常用包的依赖问题</li>
<li>开发者可很快地上手写业务代码，而不必过于关注 Spring 的部分。</li>
</ul>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>基于 Spring Boot 的<strong>分布式应用</strong>，其为了解决更上层的问题，提供了一套完善的微服务框架：</p>
<ul>
<li>分布式配置：多个 Spring Boot 服务使用分布式配置服务进行配置</li>
<li>服务注册/发现/路由/调用：多个 Spring Boot 服务间能很方便地互相发现和调用</li>
<li>客户端负载均衡：由 Spring Boot 服务进行负载均衡计算，来决策调用其他服务的哪个实例</li>
</ul>
<p>Spring Cloud 提出了一套完善的<strong>微服务开发规范</strong>，协调了多个微服务组件的版本适配和兼容问题。</p>
<h1 id="Spring-v-s-EJB"><a href="#Spring-v-s-EJB" class="headerlink" title="Spring v.s. EJB"></a>Spring v.s. EJB</h1><p>比较：</p>
<ul>
<li>Spring 是一套具体的实现；而 EJB 3.0 是 J2EE 的规范，实现包括 JBoss 和 Oracle，两者概念是不一样的；</li>
<li>共同的核心设计理念：为松耦合的 POJO 类提供中间件服务<ul>
<li>Spring 可作为中间层使用，如同 EJB 的 Session Bean</li>
</ul>
</li>
<li>Spring 的 DI 很强大，而 EJB 只支持 JNDI 方式的注入</li>
<li>EJB 有持久层，如 JPA；Spring 可无缝结合很多持久化框架，如 Hibernate, JPA, ibatis, JDBC</li>
<li>EJB 支持分布式（这是它自身最大的特点）；Spring 可通过继承 Webservice 实现，也可结合一些分布式框架实现，但相比之下 EJB 更成熟</li>
<li>Spring 有 Spring MVC 提供 Web 层，而 EJB 需要结合 jsf 或自己组装 struts 等框架实现</li>
</ul>
<p>总结：</p>
<ul>
<li>Spring 灵活性更强，充分利用 Java 多开源的特点；</li>
<li>EJB 都是 JakartaEE 内部的东西，灵活性很差，但分布式方面表现最好。</li>
</ul>
<p>不过软件发展到现今为止，大多数应用不需要采用分布式的解决方案，使用 EJB 的话就过为臃肿了。而且 Spring 已经基于自身开发了 Spring Cloud，扩展至分布式应用更加方便和安全。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 概述</title>
    <url>/2022/04/20/springboot/</url>
    <content><![CDATA[<p>Spring Boot 是为了简化 Spring 应用搭建及开发流程而推出的一个“脚手架”，相当于对 Spring 进行了一层封装。</p>
<span id="more"></span>
<p>它使用特定的方式进行配置（“<strong>约定大于配置</strong>”），让开发人员不需要自己再去定义样板化的配置，更加专注于业务的开发，或者说，更加“傻瓜”地使用 Spring 进行开发。</p>
<p><img src="/2022/04/20/springboot/what-is-springboot.png" alt></p>
<h1 id="核心：自动配置"><a href="#核心：自动配置" class="headerlink" title="核心：自动配置"></a>核心：自动配置</h1><p>Spring Boot 的核心最直接体现在 Spring Boot 的 starter 依赖上。</p>
<p>starter 在 spring 的官方解释是：a set of convenient dependency descriptors。它们<strong>封装了项目构建所需要的一整套依赖</strong>，由此便减少了很多构建所需要的配置。<br>为了方便，官方 starter 的命名都以 spring-boot-starter-<em> 为格式，</em> 代表某个具体的应用。<br>比如 <code>spring-boot-starter-web</code> 是给 web 应用开发做的依赖包，包括 <code>spring-boot-starter-tomcat</code> <code>spring-web</code> 等；<code>spring-boot-starter-amqp</code> 是给消息队列开发做的依赖包。<br>在依赖中引入的每一个 starter，相当于一个应用启动“场景”。官方提供了不少的 starter，当然自己也可以定义 starter。</p>
<p>最底层（Core）的 starter 是 <code>spring-boot-starter</code>，包含了对自动配置（<code>spring-boot-autoconfigure</code>）的支持、日志（<code>spring-boot-starter-logging</code>）和 YAML 依赖。</p>
<h2 id="都配置了啥？"><a href="#都配置了啥？" class="headerlink" title="都配置了啥？"></a>都配置了啥？</h2><p>Spring Boot 默认配置了很多框架的使用方式，简化了项目管理工具（Maven, Gradle）配置；</p>
<p>Spring Boot 自动配置了很多<strong>常用第三方库</strong>的版本，只要声明了依赖，并且存在相应的 jar（Spring 和第三方库），Spring 就会根据自动配置把所需的依赖都拉进来，由此能解决了很多第三方库因为不同版本所导致的相互无法兼容的问题（包括 Spring Framework 和 Spring Boot 的版本适配问题）。<br>如默认的配置不能满足需求，可替换掉自动配置类，使用自己的配置：比如用不上默认的 MySQL 版本（如 8.0.25），可通过手动引入其他版本的依赖来覆盖。<br>Spring Boot <strong>优先检测自定义设置</strong>，如没有就使用官方提供的默认值。</p>
<p>除自动配置外，Spring Boot 还有以下特点：</p>
<ol>
<li>能创建独立（stand-alone）的 Spring 应用程序；</li>
<li>内嵌 Tomcat、Jetty、Undertow 等，无需再部署 WAR 文件：再也不需要额外部署一个 tomcat 了；</li>
<li>提供常用的安全性、性能维度度量、运行状况检查、外部化配置等生产环境所需验证体系；</li>
<li>无需 XML 手工配置（<code>&lt;bean&gt;</code> 等）。</li>
</ol>
<h1 id="版本迭代"><a href="#版本迭代" class="headerlink" title="版本迭代"></a>版本迭代</h1><p>目前主要在用 Spring Boot 2.5+，Spring Boot 1 和 Spring Boot 2 之间的区别还是比较大的。</p>
<p>要注意的是，并不是每一个版本的 Spring 都能与随便一个版本的 Spring Boot 相结合，必须<strong>结合 Spring Boot 的 System Requirements</strong> 来安装。<br>比如 Spring Boot 2.5.1 就需要 5.3.8 版本以上的 Spring。<br>同时，Spring Boot 对 <strong>Maven</strong>（<strong>3.5+</strong>）和 <strong>Gradle</strong>（<strong>6.8.x, 6.9.x, 7.x</strong>）的版本都有要求。</p>
<p>Spring Boot 更新迭代速度非常快，一定程度上会带来一些问题：比如 <code>Bootstrapper</code> 在 Spring 2.4.5 已弃用，改为使用 <code>BootstrapRegistryInitializer</code> 做兼容。</p>
<p>虽说迭代快，但是基本的那一套不会做太大的改动。</p>
<p>Spring Boot 2.x 底层架构主要分两部分：</p>
<ol>
<li>Servlet Stack：搭建 <strong>Spring MVC</strong> 的基础，使用阻塞 I/O 架构实现请求模型，基于 Spring MVC、Spring Security、JDBC/JPA 等部分提供 Servlet 容器和 API；</li>
<li>Reactive Stack：<strong>Spring WebFlux</strong>，是非阻塞 Web 框架的基础，处理高并发网络连接，基于 Spring Security Reactive、Webflux、Mongo、Redis 等部分的封装提供 Netty 等容器和响应式流适配器。</li>
</ol>
<p><img src="/2022/04/20/springboot/springboot-2.jpg" alt></p>
<p>开发者可任意选择其中一种作为应用的框架进行开发。</p>
<h1 id="Spring-Boot-项目结构"><a href="#Spring-Boot-项目结构" class="headerlink" title="Spring Boot 项目结构"></a>Spring Boot 项目结构</h1><p>一个 Spring Boot 项目创建完毕后，会自动生成以下文件：</p>
<h2 id="应用启动类"><a href="#应用启动类" class="headerlink" title="应用启动类"></a>应用启动类</h2><p>启动类一般跟项目名同名（Artifact + <code>Application</code>），带 <code>main()</code> 方法（Java 应用入口），是整个 Spring 应用的入口。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CarFactoryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>@SpringBootApplication</code> 就是 Spring 应用的<strong>启动注解</strong>。详情如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure;</span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;  <span class="comment">// 不配置的话，默认扫描启动类所在包及以下的所有类；在此之外的包都不会被扫描到</span></span><br><span class="line">    <span class="comment">// 因此不专门配置包路径的话，别的地方的类访问将会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;nameGenerator&quot;)</span></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@SpringBootApplication</code> 是 Spring Boot 应用的<strong>核心注解</strong>，根据上面的源码可知其为<strong>组合注解</strong>，主要组合了：</p>
<p><strong>1</strong>. <code>@SpringBootConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 说明该注解所标记的类为配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. <code>@ComponentScan</code>：说明注解具有组件扫描的能力。</p>
<p><strong>3</strong>. <code>@EnableAutoConfiguration</code>：自动配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure;</span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该配置主要包含：</p>
<p><strong>1</strong>. <code>@AutoConfigurationPackage</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationPackages.Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将确定的所有组件自动注册到 Spring 容器中</span></span><br><span class="line">        register(registry, <span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义了主配置类（入口类）所在包以及其子包中的所有组件</span></span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此在项目结构中，启动类（如 CarFactoryApplication）应放在项目的最顶层目录中，默认也是这么干的。</p>
<p><img src="/2022/04/20/springboot/springboot-project.png" alt></p>
<p><strong>2</strong>. <code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code></p>
<p>自动配置注入选择器 <code>AutoConfigurationImportSelector</code>：</p>
<p><img src="/2022/04/20/springboot/autoconfigurationimportselector.png" alt></p>
<p>通过该 selector 获取所有能导入的组件的全类名，然后按需添加到容器中。</p>
<p>AutoConfigurationImportSelector 在获取所有候选（candidate） configuration 的时候，在 <code>getCandidateConfigurations()</code> 中调用 <code>SpringFactoriesLoader.loadFactoryNames()</code> -&gt; <code>SpringFactoriesLoader.loadSpringFactories()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 configuration 的路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有 factories resource（configurations）</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            ...  <span class="comment">// 逐个加载候选 configuration</span></span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(classLoader, result);  <span class="comment">// 更新缓存</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>由此浅析一下 Spring Boot <strong>自动加载配置项</strong>的原理：</p>
<ol>
<li>查找项目所有依赖的 jar 包，从每一个 jar 包中搜索文件 <code>META-INF/spring.factories</code>；</li>
<li>从搜索到的 <code>spring.factories</code> 中获取所有信息，作为候选 bean 加载到容器中；</li>
<li>AutoConfigurationImportSelector 根据 @EnableAutoConfiguration 指定的条件（@ConditionalXX 等），对所有 <code>spring.factories</code> 的信息去重、过滤，得到所需要的 bean 作为自动配置类进行加载</li>
</ol>
<p>Auto config 包下的 spring.factories 长这样：</p>
<p><img src="/2022/04/20/springboot/spring-factories.png" alt></p>
<p>可见与自动配置相关的很多类都以 -AutoConfiguration 结尾。</p>
<p>注意：并不是所有的 jar 包中都存在 <code>META-INF/spring.factories</code>。</p>
<h2 id="resources-文件夹"><a href="#resources-文件夹" class="headerlink" title="resources 文件夹"></a>resources 文件夹</h2><p>资源文件包括：</p>
<ul>
<li><code>/static</code>（或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/resources</code>）：静态资源</li>
<li><code>/templates</code>：前端模板</li>
<li>配置文件 <code>application.properties</code> / <code>application.yml</code>，可以指定服务端口、服务器地址、是否配置 SSL 等。</li>
</ul>
<p>静态资源的默认访问路径是 <code>/**</code>，意思是无论是配置了 <code>/static</code>，还是 <code>/public</code>、<code>/resources</code> 或 <code>/META-INF/resources</code>，Spring 应用都能将其文件作为静态资源<strong>映射并加载</strong>进去。<br>可通过配置指定的路径来重新安排静态资源的访问路径：</p>
<pre><code>spring.mvc.static-path-pattern=/resources/**
</code></pre><p>也可配置指定某一路径为<strong>合法的静态资源路径</strong>：</p>
<pre><code>web.resources.static-locations=[classpath:/testresources/]
</code></pre><p>配置文件支持热加载，每一项都对应着在 Spring Boot 中像 <code>ServerProperties</code>, <code>ActiveMQProperties</code>, <code>JdbcProperties</code> 等配置类中的某一个 getter/setter。</p>
<p><img src="/2022/04/20/springboot/application-properties.png" alt></p>
<h1 id="开发实战"><a href="#开发实战" class="headerlink" title="开发实战"></a>开发实战</h1><h2 id="Spring-Boot-的组合注解"><a href="#Spring-Boot-的组合注解" class="headerlink" title="Spring Boot 的组合注解"></a>Spring Boot 的组合注解</h2><p>Spring Boot 基于 Spring Framework 的注解之上，还提供了相当多有用的组合注解。</p>
<p><code>@RestController</code>：相当于 Spring Framework 中 @Controller 和 @ResponseBody 的组合注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.bind.annotation;  <span class="comment">// 组合注解</span></span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">// 此注解表明方法返回应包在 web 返回消息体中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@XxxMapping</code>：相当于 @RequestMapping(method = RequestMethod.Xxx)，满足 Rest 风格的请求映射。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.bind.annotation;</span><br><span class="line"></span><br><span class="line">...  <span class="comment">// imports</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GetMapping &#123;</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// 除了 method() 其它方法跟 @RequestMapping 相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：新的项目会保留对旧注解的支持。</p>
<p>不过，某些提交表单的场景并不支持 PUT 和 DELETE 的 Rest 请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不支持，会默认调用 POST 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/car&quot;</span> <span class="attr">method</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/car&quot;</span> <span class="attr">method</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们需要对此进行包装：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新添加 hidden method --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/car&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 皆为 post --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/car&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时需要在配置文件添加配置识别 hidden method（默认为 false）：</p>
<pre><code>spring.mvc.hiddenmethod.filter.enabled=true
</code></pre><h2 id="自定义配置文件-Properties"><a href="#自定义配置文件-Properties" class="headerlink" title="自定义配置文件 Properties"></a>自定义配置文件 Properties</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;factory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> iteration;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; tags;</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// getters &amp; setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后就可以在配置文件中用 <code>factory.model=civic</code> 等赋值给新的属性。</p>
<h2 id="自定义入参的实现"><a href="#自定义入参的实现" class="headerlink" title="自定义入参的实现"></a>自定义入参的实现</h2><p>对于入参不是以 <code>@PathVariable</code> <code>@RequestParam</code> 定义，而是自定义对象的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/car&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> car.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以添加自定义 WebMvcConfigurer 解析请求携带的表单数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">            registry.addConverter((Converter&lt;String, Car&gt;) source -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasText(source)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] sourceArgs = source.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                Car car = <span class="keyword">new</span> Car();</span><br><span class="line">                car.setBrand(sourceArgs[<span class="number">0</span>]);</span><br><span class="line">                car.setModel(sourceArgs[<span class="number">1</span>]);</span><br><span class="line">                Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">                engine.setModel(sourceArgs[<span class="number">3</span>]);</span><br><span class="line">                engine.setName(sourceArgs[<span class="number">2</span>]);</span><br><span class="line">                car.setEngine(engine);</span><br><span class="line">                car.setIteration(Integer.parseInt(sourceArgs[<span class="number">4</span>]));</span><br><span class="line">                <span class="keyword">return</span> car;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此添加自定义 WebMvcConfigurer 之后，便可在 Rest 请求中通过传递表单数据 <code>car=honda,civic,earthdream,4,11</code> 来创建 Car 对象。</p>
<h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>新建 Spring Boot 项目的时候，添加上 <code>Lombok</code>(org.projectlombok)和 <code>Spring Configuration Processor</code>(org.springframework.boot)两个依赖，能大大优化关于注解的开发。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>先着手看一看 Spring Boot 应用启动的原理。</p>
<h2 id="启动原理"><a href="#启动原理" class="headerlink" title="启动原理"></a>启动原理</h2><p>看回刚刚关于应用入口的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CarFactoryApplication.class, args);  <span class="comment">// 该静态方法返回一个 ConfigurableApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来到 SpringApplication：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 run(Class&lt;?&gt; primarySource, String... args) 触发</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);  <span class="comment">// 新建一个 SpringApplication，并执行 run() 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);  <span class="comment">// resourceLoader 为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;  <span class="comment">// 启动类调用该方法时，resourceLoader 为空</span></span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 启动类调用该方法时，传入启动类本身（CarFactoryApplication.class）</span></span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));  <span class="comment">// 主要资源集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();  <span class="comment">// 通过 classpath 推断 Web 应用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取工厂类实例，初始化应用上下文初始化器</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));  <span class="comment">// 初始化 initializers list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取工厂类实例，初始化应用监听器</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));  <span class="comment">// 初始化 listeners list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化主应用类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();  <span class="comment">// 通过 stacktrace 找具有 main() 方法的类，最终会找到主应用类（CarFactoryApplication.class）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));  <span class="comment">// SpringFactoriesLoader.loadFactoryNames() 解析入参 class，从 META-INF/spring.factories 加载并返回对应的类名列表</span></span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);  <span class="comment">// 利用反射初始化类</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以上是 SpringApplication 的构造函数，一共 6 步，全部是初始化属性的过程。</p>
<ol>
<li>初始化资源加载器 ResourceLoader：启动类调用该方法时，resourceLoader 为<strong>空</strong></li>
<li>初始化主要的资源类集合 Set<Class<?>&gt; primarySources：启动类调用该方法时，传入的是<strong>启动类本身</strong></Class<?></li>
<li>初始化 Web 服务类型 <code>WebApplicationType</code>，共有三种：<ul>
<li><strong>REACTIVE</strong>：响应式应用；此时应用存在 <code>reactive.DispatcherHandler</code> 且不存在 <code>DispatcherServlet</code> 和 <code>ServletContainer</code></li>
<li><strong>NONE</strong>：非 Web 应用，不能被内嵌 Web 服务器启动；此时应用不存在 <code>Servlet</code> 或 <code>ConfigurableWebApplicationContext</code></li>
<li><strong>SERVLET</strong>：Spring MVC</li>
</ul>
</li>
<li>初始化应用上下文初始化器列表 <code>ArrayList&lt;ApplicationContextInitializer&lt;?&gt;&gt;</code></li>
<li>初始化应用监听器列表 <code>ArrayList&lt;ApplicationListener&lt;?&gt;&gt;</code></li>
<li>初始化主应用类：通过调用的 stack trace 定义到调用了 main() 方法的栈层，从而找到<strong>启动类本身</strong></li>
</ol>
<p>其中 Bootstrap Registry 的初始化因为 bootstraper 在 Spring 2.4.5 的废弃而被移除。</p>
<p>由此，ConfigurableApplicationContext 在初始化的时候就加载了关于 processor, factory, autoconfiguration 等等很多相关的 bean。</p>
<p>SpringApplication 完成初始化之后，便执行 run() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();  <span class="comment">// 启动一个计时器，记下启动时间</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);  <span class="comment">// 获取所有运行监听器</span></span><br><span class="line">    listeners.starting();  <span class="comment">// 运行监听器 start</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 配置好环境变量</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);  <span class="comment">// 配置系统参数 spring.beaninfo.ignore</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 banner 横幅</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建应用上下文</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备应用上下文</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新应用上下文</span></span><br><span class="line">        refreshContext(context);  <span class="comment">// IoC 初始化核心：完成对 Bean 的初始化，注册 listener，并启动内嵌 Web 服务器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续处理</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refreshContext() 对应着 <a href="/2022/03/11/spring-bean/生命周期">Spring Bean 的生命周期</a>。</p>
<h2 id="静态资源加载原理"><a href="#静态资源加载原理" class="headerlink" title="静态资源加载原理"></a>静态资源加载原理</h2><p>源码在 <code>WebMvcAutoConfiguration</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;  <span class="comment">// 对应配置文件中的 spring.mvc.static-path-pattern</span></span><br><span class="line">                logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// isAddMappings 默认为 true</span></span><br><span class="line">            ...</span><br><span class="line">            String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();  <span class="comment">// 获取 spring.mvc.static-path-pattern</span></span><br><span class="line">            <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">                customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                        .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))  <span class="comment">// 获取 web.resources.static-locations</span></span><br><span class="line">                        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>web.resources.static-locations 映射到启动原理中，默认是 Resources 类中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources&quot;</span>, <span class="string">&quot;classpath:/resources&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public&quot;</span> &#125;;  <span class="comment">// 正好对应 Spring Boot 的文档描述</span></span><br></pre></td></tr></table></figure>
<h2 id="Spring-MVC-请求映射"><a href="#Spring-MVC-请求映射" class="headerlink" title="Spring MVC 请求映射"></a>Spring MVC 请求映射</h2><p><img src="/2022/04/20/springboot/spring-mvc-request-flow.png" alt></p>
<h2 id="参数注解源码解析"><a href="#参数注解源码解析" class="headerlink" title="参数注解源码解析"></a>参数注解源码解析</h2><p>我们拿一个 Controller 方法作为例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET 请求</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/model/&#123;model&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">hello</span><span class="params">(<span class="meta">@PathVariable(&quot;model&quot;)</span> String model, </span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看 Spring MVC 的基础类 <code>DispatcherServlet</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 通过父类 FrameworkServlet 的 doGet(req, resp) -&gt; processRequest(req, resp) </span></span><br><span class="line"><span class="comment"> * 调用回 DispatcherServlet 实现的 doService(req, resp) -&gt; doDispatch(req, resp)：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());  <span class="comment">// 能够获取到 RequestMappingHandlerAdapter</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  <span class="comment">// 执行 handler 方法</span></span><br><span class="line">            <span class="comment">// 在这里会调用到 RequestMappingHandlerAdapter#handle(req, resp, handlerMethod) -&gt; handleInternal(req, resp, handlerMethod) -&gt; invokeHandlerMethod(req, resp, handlerMethod)</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在 <code>RequestMappingHandlerAdapter</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;  <span class="comment">// 获取所有参数 resolver（Spring Boot 中共 27 种解析器）</span></span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);  <span class="comment">// 并设置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// @PathVariable 对应 PathVariableMethodArgumentResolver</span></span><br><span class="line">        <span class="comment">// @RequestParam 对应 RequestParamMethodArgumentResolver</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);  <span class="comment">// -&gt; 基类的 invokeForRequest()，调用并处理返回值</span></span><br><span class="line">        <span class="comment">// 再调用基类 getMethodArgumentValues() 获取方法参数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在 <code>InvocableHandlerMethod</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request,</span><br><span class="line">        <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="comment">// PathVariableMethodArgumentResolver：有 @PathVariable 注解，且参数不是 Map 类型；或者参数为 Map 类型且非空，则返回 true</span></span><br><span class="line">            <span class="comment">// RequestParamMethodArgumentResolver：有 @RequestParam 注解，参数不是 Map 类型，或者参数为 Map 类型且非空，返回 true</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析入参</span></span><br><span class="line">            args[i] = <span class="keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="Hidden-method-原理"><a href="#Hidden-method-原理" class="headerlink" title="Hidden method 原理"></a>Hidden method 原理</h2><p>源码还是在 <code>WebMvcAutoConfiguration</code> 中（因为 Spring Boot 所有关于 Web MVC 应用的配置都在这里面）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)</span>  <span class="comment">// 满足 spring.mvc.hiddenmethod.filter.enabled=true 才会被注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();  <span class="comment">// 扩展自 HiddenHttpMethodFilter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.filter;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS =</span><br><span class="line">            Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),</span><br><span class="line">                    HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));  <span class="comment">// 支持的 hidden method</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Default method parameter: &#123;<span class="doctag">@code</span> _method&#125;. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_METHOD_PARAM = <span class="string">&quot;_method&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String methodParam = DEFAULT_METHOD_PARAM;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest requestToUse = request;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod())  <span class="comment">// 这是表单（form）method 为什么要设置为 &quot;post&quot; 的原因</span></span><br><span class="line">            &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="keyword">null</span>) &#123;  <span class="comment">// 请求没有异常</span></span><br><span class="line"></span><br><span class="line">            String paramValue = request.getParameter(<span class="keyword">this</span>.methodParam);  <span class="comment">// 获取 _method 的方法请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">                String method = paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">                <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;  <span class="comment">// 支持 PUT, DELETE, PATCH 方法</span></span><br><span class="line">                    requestToUse = <span class="keyword">new</span> HttpMethodRequestWrapper(request, method);  <span class="comment">// 重新包装请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(requestToUse, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务机制</title>
    <url>/2022/03/27/spring-transaction/</url>
    <content><![CDATA[<p>Spring 事务机制默认回滚 <code>RuntimeException</code> 及其异常子类，和 <code>Error</code> 等异常。</p>
<span id="more"></span>
<h1 id="主要接口与配置"><a href="#主要接口与配置" class="headerlink" title="主要接口与配置"></a>主要接口与配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的属性，返回当前在线（active）的事务或创建一个新的事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交指定的事务及关于它的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回滚给定的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/27/spring-transaction/platform-transaction-manager.jpg" alt></p>
<p>接口方法中的形参包括 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code>：</p>
<p><br></p>
<h2 id="事务传播级别"><a href="#事务传播级别" class="headerlink" title="事务传播级别"></a>事务传播级别</h2><p><code>TransactionDefinition</code>：定义事务属性，包括隔离级别和传播行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回传播行为，包括：</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.PROPAGATION_MANDATORY</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.PROPAGATION_NESTED</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.PROPAGATION_NEVER</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.PROPAGATION_NOT_SUPPORTED</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.PROPAGATION_REQUIRED（默认）</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.PROPAGATION_REQUIRES_NEW</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.PROPAGATION_SUPPORTS</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.TIMEOUT_DEFAULT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回隔离级别，即该事务独立于其他事务的工作程度，包括：</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.ISOLATION_DEFAULT（默认）</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.ISOLATION_READ_COMMITTED</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.ISOLATION_READ_UNCOMMITTED</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.ISOLATION_REPETABLE_READ</span></span><br><span class="line"><span class="comment">     *   TransactionDefinition.ISOLATION_SERIALIZABLE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;  <span class="comment">// 事务名称</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  <span class="comment">// 事务超时时间，单位为秒</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;  <span class="comment">// 事务是否只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事物的传播性一般在<strong>事务嵌套</strong>时使用。<br>比如，有一个事务 A 里面调用了另一个使用事务的方法，那么这两个事务<strong>各自作为独立的事务</strong>进行提交，或者将内层事务合并到外层事务中，再一并提交。</p>
<p><code>TransactionDefinition.PROPAGATION_REQUIRED</code></p>
<ul>
<li>Spring 默认的事务传播机制</li>
<li>支持当前事务，如果其外层不存在事务，则创建一个新的事务</li>
<li>如外层存在事务，则加入该事务，一起提交一起回滚</li>
</ul>
<p><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></p>
<ul>
<li>每次创建一个新的事务</li>
<li>如果当前事务的外层存在另一个事务，则先将外层事务挂起，等到新事务执行完毕后再恢复外层事务执行</li>
</ul>
<p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></p>
<ul>
<li>支持当前事务</li>
<li>如果当前事务的外层存在另一个事务，则加入该事务；如不存在，则以非事务执行</li>
</ul>
<p><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></p>
<ul>
<li>不支持当前事务，总是执行非事务性</li>
<li>如当前外层存在事务，则将当前事务挂起，执行当前逻辑，再恢复外层事务</li>
</ul>
<p><code>TransactionDefinition.PROPAGATION_NEVER</code></p>
<ul>
<li>不支持当前事务，如外层事务存在则抛出异常</li>
</ul>
<p><code>TransactionDefinition.PROPAGATION_MANDATORY</code></p>
<ul>
<li>支持当前事务，说明该传播性方法只能在<strong>已经存在事务</strong>的方法中被调用</li>
<li>如不存在外层事务则抛出异常，如存在则加入该事务</li>
</ul>
<p><code>TransactionDefinition.PROPAGATION_NESTED</code></p>
<ul>
<li>可以保存事务至状态保存点中</li>
<li>如存在当前事务，则在一个嵌套的事务中执行，如没有事务则创建一个</li>
<li>当事务回滚时，会回滚到某一个保存点上，从而避免所有嵌套事务都回滚</li>
</ul>
<p><code>TransactionDefinition.TIMEOUT_DEFAULT</code></p>
<ul>
<li>使用默认的底层事务系统，如果不支持超时，则以非事务执行</li>
</ul>
<h2 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h2><p><code>TransactionStatus</code>：负责事务开始到结束期间的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前事务是否为新事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有一个保存点</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事务为 rollback-only 标记</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该事务是否被标记为 rollback-only</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务是否完成（被提交或回滚）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/27/spring-transaction/spring-transaction-interfaces.png" alt></p>
<h1 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h1><p>Spring 支持<strong>编程式</strong>和<strong>声明式</strong>两种事务管理方式。</p>
<h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><p>通过编程实现的事务管理，胜在操作灵活，但是维护困难，而且属于侵入式编程，与 Spring Framework 耦合程度高。</p>
<p>举个例子，我们有下面一个 POJO 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentMarks</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer marks; </span><br><span class="line">    <span class="keyword">private</span> Integer year; </span><br><span class="line">    <span class="keyword">private</span> Integer sid; </span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// getters and setters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应地，在 DAO 实现类中引入事务管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplateObject; </span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;  <span class="comment">// 侵入式编程</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name, Integer age, Integer marks, Integer year)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"></span><br><span class="line">    TransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    TransactionStatus status = transactionManager.getTransaction(def);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// add row</span></span><br><span class="line">        String SQL1 = <span class="string">&quot;insert into Student(name, age) values(?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplateObject.update(SQL1, name, age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the latest student id to be used in Marks table </span></span><br><span class="line">        String SQL2 = <span class="string">&quot;select max(id) from Student&quot;</span>; </span><br><span class="line">        <span class="keyword">int</span> sid = jdbcTemplateObject.queryForInt(SQL2);</span><br><span class="line"></span><br><span class="line">        String SQL3 = <span class="string">&quot;insert into Marks(sid, marks, year) values(?, ?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplateObject.update(SQL3, sid, marks, year); </span><br><span class="line">        System.out.println(<span class="string">&quot;Created Name = &quot;</span> + name + <span class="string">&quot;, Age = &quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit 3 data operations in one transaction</span></span><br><span class="line">        transactionManager.commit(status); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (DataAccessException e) &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error in creating record, rolling back.&quot;</span>); </span><br><span class="line">        transactionManager.rollback(status); </span><br><span class="line">        <span class="keyword">throw</span> e; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MANDATORY: Initialization for data source --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/TEST&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MANDATORY: Initialization for TransactionManager --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for studentJDBCTemplate bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentJDBCTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.StudentJDBCTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了 PlatformTransactionManager，还可以使用 TransactionTemplate 进行编程式事务管理。</p>
<p>虽然说编程式事务管理为侵入式编程，对代码维护会有所挑战，但是对于事务应用较少的业务代码，编程式事务处理不失为一个好选择。</p>
<p><br></p>
<h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><p>声明式事务管理使用<strong>注释</strong>或 <strong>XML 配置</strong>管理事务，将事务管理的逻辑从业务代码中分离开来，不需要在 JdbcTemplate 等模版类中显式调用 transaction manager 来提交或回滚事务。</p>
<p>声明式事务管理无侵入，业务影响小，是最好的选择。</p>
<h3 id="基于注释-Transactional"><a href="#基于注释-Transactional" class="headerlink" title="基于注释 @Transactional"></a>基于注释 <code>@Transactional</code></h3><p>通过 @Transactional 注解开启一个事务。</p>
<p>实现机制：基于 <a href="/2022/03/18/spring-aop">AOP</a></p>
<ol>
<li>代码运行时先生成一个代理对象</li>
<li>代理对象根据 @Transactional 配置的属性，决定声明了 @Transactional 的目标方法是否由拦截器 TransactionInterceptor 来拦截</li>
<li>在 TransactionInterceptor 拦截时，会在目标方法开始执行之前创建并加入事务</li>
<li>执行目标方法的逻辑</li>
<li>根据执行情况作后续处理：<ol>
<li>执行情况无异常：AbstractPlatformTransactionManager 操作数据源提交事务</li>
<li>执行情况异常：AbstractPlatformTransactionManager 操作数据源回滚事务</li>
</ol>
</li>
</ol>
<p>程序执行时序图如下：</p>
<p><img src="/2022/03/27/spring-transaction/spring-transaction-sequence-diagram.jpg" alt></p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 所有该类的 public 方法都会被配置相同的事务属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceBean</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDao</span><span class="params">(TestDao dao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dao = dao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation=Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注：方法级别的注解会覆盖类级别的注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Transactional 可配置的<strong>属性</strong>信息与接口 TransactionDefinition 的方法一一对应：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>指定所使用的事务管理器，适用于配置文件中存在多个 TransactionManager 的情况</td>
</tr>
<tr>
<td>propagation</td>
<td>设置事务的传播行为，取值同接口 TransactionDefinition 的枚举值</td>
</tr>
<tr>
<td>isolation</td>
<td>设置底层数据库的事务隔离级别<br>通常使用数据库默认的隔离级别即可</td>
</tr>
<tr>
<td>timeout</td>
<td>如超过该时间但事务尚未完成：自动回滚事务<br>默认值为 -1：表示永不超时</td>
</tr>
<tr>
<td>readOnly</td>
<td>设置当前事务是否为只读事务，默认为 <code>false</code>&lt;br/&gt;<code>@Transactional(readOnly=&quot;true&quot;)</code></td>
</tr>
<tr>
<td>rollbackFor</td>
<td>指定能够触发事务回滚的异常类型，值为 Class 对象数组<br>如指定多个异常类型：各类型之间通过逗号分隔</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>指定能够触发事务回滚的异常类名数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>抛出其指定的异常类型，不回滚事务</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>抛出指定的类名数组中的某一个，不回滚事务</td>
</tr>
</tbody>
</table>
</div>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> /&gt;</span>  <span class="comment">&lt;!-- 开启事务 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MANDATORY: Initialization for data source --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/TEST&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MANDATORY: Initialization for TransactionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置指定回滚的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = JavastackException.class)</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = [aException.class, bException.class])</span></span><br></pre></td></tr></table></figure>
<p>配置指定不回滚的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = JavastackException.class)</span></span><br><span class="line"><span class="meta">@Transactional(noRollbackFor = [aException.class, bException.class])</span></span><br></pre></td></tr></table></figure>
<p>需要注意的地方：</p>
<p><strong>1</strong>. @Transactional <strong>只能应用到 <code>public</code> 方法</strong>才有效。</p>
<p>因为 TransactionInterceptor 在进行拦截之前会调用 <code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;  <span class="comment">// 非 public 不会去获取 @Transactional 属性配置信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，CglibAopProxy 内部的 <code>DynamicAdvisedInterceptor#intercept()</code> 或 <code>JdkDynamicAopProxy#invoke()</code> 也会间接调用以上方法。 </p>
<p>所以编程的时候，默认权限或私有代码就不要标记 @Transactional 了。</p>
<p><strong>2</strong>. 避免 AOP 自调用问题</p>
<p>如果一个类中的一个或多个非事务方法中<strong>调用自身类的事务方法</strong>，那么在调用非事务方法时，事务方法的事务会<strong>被忽略</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        insertOrder();  <span class="comment">// no transaction</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// insert log info</span></span><br><span class="line">        <span class="comment">// insertOrder</span></span><br><span class="line">        <span class="comment">// updateAccount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，在执行 insert() 时，insertOrder() 的事务不会被执行；如果抛出了异常，事务也不会被回滚。</p>
<p>因为：Spring 扫描到所有添加了 @Transactional 注解的类之后将它们初始化，对应地会各自生成一个<strong>代理对象</strong>，Spring 事务再去判断代理对象的执行方法是否添加了 @Transactional 注解。</p>
<p>而对象中的非事务方法去调用事务方法属于<strong>自调用</strong>，自调用方法并不是由代理通过反射执行的，因此被调用的事务方法，其注解无效。</p>
<h3 id="Transactional-源码简析"><a href="#Transactional-源码简析" class="headerlink" title="@Transactional 源码简析"></a>@Transactional 源码简析</h3><p>上面一小节的时序图已经说明了大概情况。</p>
<p>Spring Framework 在为某一操作建立事务之前，先寻找<strong>增强器</strong>，判断这些增强器是否与方法或类相匹配，以完成对应类或方法的事务属性解析。</p>
<p>步骤如下：</p>
<p>首先：初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用对应的解析器去解析 advice, annotation-driven, transaction-manager 等标签</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> TxAdviceBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;jta-transaction-manager&quot;</span>, <span class="keyword">new</span> JtaTransactionManagerBeanDefinitionParser());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读到配置中的注解之后，调用 <code>AnnotationDrivenBeanDefinitionParser</code> 解析器的 parse() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">    String mode = element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">    <span class="comment">// AspectJ 另外处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">        registerTransactionAspect(element, parserContext);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;javax.transaction.Transactional&quot;</span>, getClass().getClassLoader())) &#123;</span><br><span class="line">            registerJtaTransactionAspect(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;proxy&quot;</span></span><br><span class="line">        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">        <span class="comment">// 默认以 aop 为基础</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AopAutoProxyConfigurer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">configureAutoProxyCreator</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 beanName 为 org.springframework.aop.config.internalAutoProxyCreator 的 bean：</span></span><br><span class="line"><span class="comment">     * InfrastructureAdvisorAutoProxyCreator，自动创建代理器</span></span><br><span class="line"><span class="comment">     *     实现了 InstantiationAwareBeanPostProcessor 接口</span></span><br><span class="line"><span class="comment">     *     即：Spring 容器实例化所有 bean 时会保证调用 postProcessAfterInitialization 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// txAdvisorBeanName = org.springframework.transaction.config.internalTransactionAdvisor</span></span><br><span class="line">    String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;</span><br><span class="line">    <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) &#123;</span><br><span class="line">        Object eleSource = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the TransactionAttributeSource definition. </span></span><br><span class="line">        <span class="comment">// 创建 TransactionAttributeSource 的 bean</span></span><br><span class="line">        RootBeanDefinition sourceDef = <span class="keyword">new</span> RootBeanDefinition(<span class="string">&quot;org.springframework.transaction.annotation.AnnotationTransactionAttributeSource&quot;</span>);</span><br><span class="line">        <span class="comment">// 注册 bean，并使用 Spring 中的定义规则生成 beanName</span></span><br><span class="line">        String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 TransactionInterceptor 的 bean</span></span><br><span class="line">        RootBeanDefinition interceptorDef = <span class="keyword">new</span> RootBeanDefinition(TransactionInterceptor.class);</span><br><span class="line">        interceptorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(sourceName));</span><br><span class="line">        String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 TransactionAttributeSourceAdvisor 的 bean</span></span><br><span class="line">        RootBeanDefinition advisorDef = <span class="keyword">new</span> RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);</span><br><span class="line">        <span class="comment">// 组成切面：</span></span><br><span class="line">        <span class="comment">// 1. 将 sourceName 的 bean 注入 advisor 的 transactionAttributeSource 属性中</span></span><br><span class="line">        advisorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(sourceName));</span><br><span class="line">        <span class="comment">// 2. 将 interceptorName 的 bean 注入到 advisor 的 adviceBeanName 属性中</span></span><br><span class="line">        advisorDef.getPropertyValues().add(<span class="string">&quot;adviceBeanName&quot;</span>, interceptorName);</span><br><span class="line">        <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;order&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果配置了 order 属性，则加入到 bean 中</span></span><br><span class="line">            advisorDef.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, element.getAttribute(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以 txAdvisorBeanName 名字注册 advisorDef</span></span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 CompositeComponentDefinition</span></span><br><span class="line">        CompositeComponentDefinition compositeDef = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), eleSource);</span><br><span class="line">        compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(sourceDef, sourceName));</span><br><span class="line">        compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(interceptorDef, interceptorName));</span><br><span class="line">        compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(advisorDef, txAdvisorBeanName));</span><br><span class="line">        parserContext.registerComponent(compositeDef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上述源码可知，在创建增强器的时候，注册了三个类：</p>
<ol>
<li><code>AnnotationTransactionAttributeSource</code>：封装了目标方法是否被拦截的逻辑<ol>
<li>没有实现 Pointcut 接口</li>
<li>在后面目标方法判断时，委托 AnnotationTransactionAttributeSource.getTransactionAttributeSource()，通过适配器模式返回 Pointcut 切点信息</li>
</ol>
</li>
<li><code>TransactionInterceptor</code>：实现 Advice 接口，定义了拦截后执行的增强</li>
<li><code>TransactionAttributeSourceAdvisor</code>：实现 Advisor 接口，包装上面两个信息（增强+切入点），即形成切面<ol>
<li>切面（增强器）属于 BeanFactoryTransactionAttributeSourceAdvisor</li>
<li>组成环绕型（<code>@Around</code>）的增强</li>
</ol>
</li>
</ol>
<p>实例化 bean 时，调用代理器父类 <code>AbstractAutoProxyCreator#postProcessAfterInitialization()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 组装 key</span></span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="comment">// 如果适合被代理，则需要封装指定的 bean</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这个方法干了什么：</span></span><br><span class="line"><span class="comment">             *   - 找出指定 bean 对应的增强器</span></span><br><span class="line"><span class="comment">             *   - 根据找出的增强器创建代理</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建代理的时候，还需：</p>
<p><strong>1</strong>. 判断目标方法是否适合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">        <span class="comment">// TransactionAttributeSourceAdvisor 父类是 PointcutAdvisor，因此能取出切点信息</span></span><br><span class="line">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">        <span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据之前注入的切面类型 AnnotationTransactionAttributeSource，再通过以下方法包装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现父类的方法，在子类中进行了扩展，返回之前在标签注册时的 AnnotationTransactionAttributeSource</span></span><br><span class="line">        <span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 匹配标签：识别 @Transactional 标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionAttributeSourcePointcut</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事务切点匹配的方法，判定是否是事务方法</span></span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直跟踪到 AnnotationTransactionAttributeSource.determineTransactionAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历注册的注解解析器进行解析</span></span><br><span class="line">    <span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">        TransactionAttribute attr = parser.parseTransactionAnnotation(element);</span><br><span class="line">        <span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> attr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此刻直接定位到事务注解的解析器</span></span><br><span class="line"><span class="comment">// SpringTransactionAnnotationParser</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析事务注解的属性</span></span><br><span class="line">    AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">            element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;  <span class="comment">// 判断是否含有 @Transactional 注解</span></span><br><span class="line">        <span class="keyword">return</span> parseTransactionAnnotation(attributes);  <span class="comment">// 开始解析事务注解的每一个属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析事务注解的属性</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line">    <span class="comment">// 解析事务注解的每一个属性</span></span><br><span class="line">    Propagation propagation = attributes.getEnum(<span class="string">&quot;propagation&quot;</span>);</span><br><span class="line">    rbta.setPropagationBehavior(propagation.value());</span><br><span class="line"></span><br><span class="line">    Isolation isolation = attributes.getEnum(<span class="string">&quot;isolation&quot;</span>);</span><br><span class="line">    rbta.setIsolationLevel(isolation.value());</span><br><span class="line"></span><br><span class="line">    rbta.setTimeout(attributes.getNumber(<span class="string">&quot;timeout&quot;</span>).intValue());</span><br><span class="line">    rbta.setReadOnly(attributes.getBoolean(<span class="string">&quot;readOnly&quot;</span>));</span><br><span class="line">    rbta.setQualifier(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;rollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;rollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;noRollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;noRollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就在运行时执行事务，主要有几个处理步骤：</p>
<ol>
<li>获取事务属性</li>
<li>加载配置中的 transactionManager</li>
<li>不同事物处理方式使用不同逻辑</li>
<li>在目标方法执行前获取事务并收集事务信息</li>
<li>执行目标方法</li>
<li>出现异常，尝试异常处理</li>
<li>提交事务前的事务信息消除</li>
<li>提交事务</li>
</ol>
<p><strong>1</strong>. 执行注册到 BeanFactoryTransactionAttributeSourceAdvisor 中的 TransactionInterceptor 进行增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务增强器 TransactionInterceptor    </span></span><br><span class="line"><span class="comment">// 继承于 MethodInterceptor（org.aopallience.intercept.MethodInterceptor）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 执行事务拦截器，完成整个事务的逻辑</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用父类 TransactionAspectSupport.invokeWithinTransaction()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">    <span class="comment">// 查询目标方法事务属性、确定事务管理器、构造连接点标识（用于确认事务名称）</span></span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="comment">// 1. 获取对应事务属性</span></span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 2. 获取事务管理器</span></span><br><span class="line">    <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr); <span class="comment">// 确定事务管理器</span></span><br><span class="line">    <span class="comment">// 构造方法唯一标识（类.方法）</span></span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用不同的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// 不带回调的事务处理，一般是声明式事务处理</span></span><br><span class="line">        <span class="comment">// 标准事务划分 : 使用 getTransaction 和 commit / rollback 调用</span></span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); <span class="comment">// 4. 开启事务</span></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 传入的是回调函数对象：invocation.proceed。 执行被增强的方法</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 6. 异常回滚</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7. 清除信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8. 提交事务</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 带回调的事务执行处理，一般用于编程式事务处理</span></span><br><span class="line">        <span class="keyword">final</span> ThrowableHolder throwableHolder = <span class="keyword">new</span> ThrowableHolder();</span><br><span class="line">        <span class="comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">                TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定事务管理器</span></span><br><span class="line"><span class="comment">// 在配置文件中配置好了之后，返回应该是 DataSourceTransactionManager</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PlatformTransactionManager <span class="title">determineTransactionManager</span><span class="params">(<span class="meta">@Nullable</span> TransactionAttribute txAttr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do not attempt to lookup tx manager if no tx attributes are set</span></span><br><span class="line">    <span class="comment">// 寻找事务管理器</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || <span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如没有事务属性或者 BeanFactory 为空：从缓存里面寻找</span></span><br><span class="line">        <span class="keyword">return</span> asPlatformTransactionManager(getTransactionManager());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String qualifier = txAttr.getQualifier();</span><br><span class="line">    <span class="comment">// 如果注解配置中指定了事务管理器，直接取出使用</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">        <span class="keyword">return</span> determineQualifiedTransactionManager(<span class="keyword">this</span>.beanFactory, qualifier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.transactionManagerBeanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> determineQualifiedTransactionManager(<span class="keyword">this</span>.beanFactory, <span class="keyword">this</span>.transactionManagerBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 上面步骤都没找到，最后才去容器中根据 className 来寻找</span></span><br><span class="line">        PlatformTransactionManager defaultTransactionManager = asPlatformTransactionManager(getTransactionManager());</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> defaultTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(PlatformTransactionManager tm, TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有名称指定则使用方法唯一标识，并使用 DelegatingTransactionAttribute 包装 txAttr</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取 TransactionStatus （获得数据库连接）</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据指定的属性与 status 准备一个 TransactionInfo</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 获取事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        Object transaction = doGetTransaction();</span><br><span class="line">        doBegin(transaction, definition);</span><br><span class="line">        prepareSynchronization(status, definition);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 status = tm.getTransaction(txAttr)，具体调用 DataSourceTransactionManager 类中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">    <span class="comment">// 如果当前线程已经记录数据库链接则使用原有链接</span></span><br><span class="line">    ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line"></span><br><span class="line">    txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>); <span class="comment">// false 表示非新创建连接</span></span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同一线程中判断是否有重复的事务：TransactionSynchronizationManager.getResource()</span></span><br><span class="line"><span class="comment">// resource 中以 dataSource 为 key 保存当前线程池与当前线程中的一个连接，以后这个线程获取连接时都会获取同一个连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doGetResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断依据：当前线程、当前数据源(DataSource)中是否存在活跃的事务</span></span><br><span class="line">    Object value = map.get(actualKey);</span><br><span class="line">    <span class="comment">// Transparently remove ResourceHolder that was marked as void...</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">        map.remove(actualKey);</span><br><span class="line">        <span class="comment">// Remove entire ThreadLocal if empty...</span></span><br><span class="line">        <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">            resources.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断当前线程是否存在事务：</p>
<ul>
<li>当前线程记录的连接（ConnectionHolder）不为空</li>
<li>连接中的属性 transactionActive 不为空</li>
</ul>
<p><strong>3</strong>. 事务创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 没有数据库连接或数据库连接不同步：再造一个</span></span><br><span class="line">    <span class="keyword">if</span> (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">        Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">        txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">    con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置隔离级别</span></span><br><span class="line">    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">    txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// configured the connection pool to set it already.</span></span><br><span class="line">    <span class="comment">// 更改自动提交设置，由 spring 进行控制</span></span><br><span class="line">    <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">        txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备事务连接</span></span><br><span class="line">    prepareTransactionalConnection(con, definition);</span><br><span class="line">    <span class="comment">// 设置判断当前线程是否存在事务的依据</span></span><br><span class="line">    txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    <span class="keyword">int</span> timeout = determineTimeout(definition);</span><br><span class="line">    <span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">        txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the connection holder to the thread.</span></span><br><span class="line">    <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">        <span class="comment">// 将当前获取到的连接绑定到当前线程</span></span><br><span class="line">        TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即：Spring 事务的开启就是将数据库自动提交属性设置为 false</span></span><br></pre></td></tr></table></figure>
<h3 id="基于-XML-配置文件：添加-transaction-配置"><a href="#基于-XML-配置文件：添加-transaction-配置" class="headerlink" title="基于 XML 配置文件：添加 transaction 配置"></a>基于 XML 配置文件：添加 transaction 配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- encoding... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MANDATORY: Initialization for data source --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/TEST&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- NEW 添加基于 AOP 的事务管理的 aop:config --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;create&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- 需要添加事务管理的方法切入点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;createOperation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xxx.StudentJDBCTemplate.create(..))&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;createOperation&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MANDATORY: Initialization for TransactionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Definition for studentJDBCTemplate bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentJDBCTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.StudentJDBCTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法概况</title>
    <url>/2022/11/07/sort-algo-overview/</url>
    <content><![CDATA[<p>今天将多年前整理的一些排序算法捋一捋。先说个大概。</p>
<span id="more"></span>
<p>排序算法通常按照以下标准分类：</p>
<p><strong>1</strong>. 依据待排序数列的大小 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 计算时间复杂度（最差、平均及最好性能）。</p>
<ul>
<li>一般而言，好的性能是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，坏的性能是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li>
<li>对于一次排序，理想的性能是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>；然而在平均上总是需要 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li>
</ul>
<p><strong>2</strong>. 存储器使用量（以及其他计算机资源的使用）</p>
<p><strong>3</strong>. 稳定性：指的是某个排序算法会让原本有相同键值的记录维持相对次序。</p>
<ul>
<li>如果一个排序算法是稳定的，当有两个相同键值的记录 R 和 S，且在原本数列中 R 出现在 S 之前，那么在排序过的数列之中，R 也将会在 S 之前。</li>
</ul>
<p><br></p>
<h1 id="稳定排序算法"><a href="#稳定排序算法" class="headerlink" title="稳定排序算法"></a>稳定排序算法</h1><ul>
<li><a href="/2022/11/08/bubble-sort">冒泡排序</a></li>
<li><a href="/2022/11/12/insertion-sort">插入排序</a></li>
<li><a href="/2023/03/11/non-compare-sort#桶排序的改进：基数排序">基数排序</a></li>
<li><a href="/2023/03/11/non-compare-sort#计数排序">计数排序</a></li>
<li><a href="/2023/03/11/non-compare-sort#桶排序">桶排序</a></li>
<li><a href="/2023/02/25/merge-sort">归并排序</a></li>
<li>二叉排序树排序</li>
<li>图书馆排序</li>
</ul>
<h1 id="不稳定排序算法"><a href="#不稳定排序算法" class="headerlink" title="不稳定排序算法"></a>不稳定排序算法</h1><ul>
<li><a href="/2022/11/11/selection-sort">直接选择排序</a></li>
<li><a href="/2023/02/26/quick-sort">快速排序</a></li>
<li>希尔（shell）排序</li>
<li>堆排序</li>
</ul>
<p>怎么记忆哪些是稳定算法？</p>
<ul>
<li>时间复杂度复杂一些的（高级，包括快排、shell 排序、堆排序 —— 归并排序除外）都不稳定（选择排序也不稳定）；</li>
<li>时间复杂度简单一些的（低级，包括冒泡、插入、计数、基数）都稳定（归并排序也是稳定的）；</li>
<li>复杂算法中，归并排序是稳定排序；简单算法中，选择排序不稳定；</li>
<li>8 种稳定，4 种不稳定。</li>
</ul>
<h1 id="比较-v-s-不比较"><a href="#比较-v-s-不比较" class="headerlink" title="比较 v.s. 不比较"></a>比较 v.s. 不比较</h1><p>基于比较的排序（Comparison Sort）：通过对序列中的数据进行比较，确定数据的先后顺序。</p>
<p>包括：</p>
<ul>
<li><a href="/2022/11/11/selection-sort">直接选择排序</a></li>
<li><a href="/2022/11/08/bubble-sort">冒泡排序</a></li>
<li><a href="/2022/11/12/insertion-sort">插入排序</a></li>
<li>堆排序</li>
<li><a href="/2023/02/25/merge-sort">归并排序</a></li>
<li><a href="/2023/02/26/quick-sort">快速排序</a></li>
</ul>
<p>比较排序有着局限性：不能突破 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6F0" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 的复杂性下限。</p>
<ul>
<li>简单证明：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 888 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g></g></g></svg></mjx-container> 个数有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.638ex" height="1.62ex" role="img" focusable="false" viewbox="0 -716 1166 716"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"/></g></g></g></svg></mjx-container> 个可能的全排列，即基于比较的排序算法的判定树有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.638ex" height="1.62ex" role="img" focusable="false" viewbox="0 -716 1166 716"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"/></g></g></g></svg></mjx-container> 个叶节点，比较次数最少为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="20.621ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 9114.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(1260,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1649,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2537,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"/></g><g data-mml-node="mo" transform="translate(2815,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3481.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(4537.6,0)"><path data-c="1D6F0" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(5300.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(5689.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mi" transform="translate(6577.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(6875.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(7360.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(7837.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(8725.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>（斯特林公式）</li>
</ul>
<p>相对应的，非比较排序有：</p>
<ul>
<li><a href="/2023/03/11/non-compare-sort#桶排序的改进：基数排序">基数排序</a></li>
<li><a href="/2023/03/11/non-compare-sort#计数排序">计数排序</a></li>
<li><a href="/2023/03/11/non-compare-sort#桶排序">桶排序</a></li>
</ul>
<p>非比较排序的局限性是：对排序元素之间差值的大小有限制。</p>
<h1 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h1><p>总结了个表格（n 为数据量大小）：</p>
<table>
    <tr>
        <th rowspan="2">类别</th>
        <th rowspan="2">排序方法</th>
        <th rowspan="2">数据对象</th>
        <th rowspan="2">稳定性</th>
        <th colspan="3">时间复杂度</th>
        <th rowspan="2">空间复杂度</th>
    </tr>
    <tr>
        <th>平均情况</th>
        <th>最好情况</th>
        <th>最坏情况</th>
    </tr>
    <tr>
        <th rowspan="2">插入排序</th>
        <th>直接插入排序</th>
        <td>数组、链表</td>
        <td>☑️</td>
        <td><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td><font color="#2E6501">O(n)</font></td>
        <td><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td><font color="#2E6501">O(1)</font></td>
    </tr>
    <tr>
        <th>shell 排序</th>
        <td>数组</td>
        <td>✖️</td>
        <td>O(nlogn)</td>
        <td><font color="#2E6501">O(n)</font></td>
        <td>O(nlogn)</td>
        <td><font color="#2E6501">O(1)</font></td>
    </tr>
    <tr>
        <th rowspan="3">选择排序</th>
        <th rowspan="2">直接选择排序</th>
        <td>数组</td>
        <td>✖️</td>
        <td rowspan="2"><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td rowspan="2"><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td rowspan="2"><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td rowspan="2"><font color="#2E6501">O(1)</font></td>
    </tr>
    <tr>
        <td>链表</td>
        <td>☑️</td>
    </tr>
    <tr>
        <th>堆排序</th>
        <td>数组</td>
        <td>✖️</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td><font color="#2E6501">O(1)</font></td>
    </tr>
    <tr>
        <th rowspan="2">交换排序</th>
        <th>冒泡排序</th>
        <td>数组</td>
        <td>☑️</td>
        <td><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td><font color="#2E6501">O(n)</font></td>
        <td><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td><font color="#2E6501">O(1)</font></td>
    </tr>
    <tr>
        <th>快速排序</th>
        <td>数组</td>
        <td>✖️</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td><font color="#AE0810">O(n<sup>2</sup>)</font></td>
        <td>O(logn)</td>
    </tr>
    <tr>
        <th colspan="2">归并排序</th>
        <td>数组、链表</td>
        <td>☑️</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td>O(nlogn)</td>
        <td><font color="#2E6501">O(n)</font></td>
    </tr>
    <tr>
        <td colspan="8"></td>
    </tr>
    <tr>
        <th colspan="2">桶排序</th>
        <td>数组、链表</td>
        <td>☑️</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(n+k)</td>
    </tr>
    <tr>
        <th colspan="2">基数排序</th>
        <td>数组</td>
        <td>☑️</td>
        <td>O(nk)</td>
        <td>O(nk)</td>
        <td>O(nk)</td>
        <td>O(n+k)</td>
    </tr>
    <tr>
        <th colspan="2">计数排序</th>
        <td>数组、链表</td>
        <td>☑️</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
    </tr>
</table>

<p><small>注：对于非比较排序来说，k 为“桶”的个数。</small></p>
<p>再上个教材的图：</p>
<p><img src="/2022/11/07/sort-algo-overview/sort-algo-average-time.png" alt></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式（Strategy）</title>
    <url>/2021/06/19/strategy/</url>
    <content><![CDATA[<p>现实中，一件事可能会有很多种方式实现，但总有一种最高效的方式。</p>
<span id="more"></span>
<p>为了让问题得以解决，我们将可以解决问题的一个或多个方法定义成一个“算法群”；其中的每一个方法对应<strong>一组具体的算法</strong>，我们将其称之为“<strong>策略</strong>”。</p>
<p><br></p>
<big>策略模式别名为政策（Policy），属于对象行为型模式。</big>

<p>《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“定义一系列算法，将他们一一封装，并使他们可以相互替换”
“本模式使得算法能独立于使用它的客户而变化”
</code></pre><p>实现的时候把不同组的算法封装在不同的类里。</p>
<p><br></p>
<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/2021/06/19/strategy/strategy_pattern_diagram.jpeg" alt></p>
<p>以上，可见策略模式包括：</p>
<p><code>Context</code></p>
<ul>
<li>环境类，上层访问策略的<strong>入口</strong></li>
<li>维护一个对抽象策略 Strategy 对象的引用</li>
<li>通过一个 ConcreteStrategy 来配置</li>
<li>可定义一个接口让 Strategy 访问它的数据</li>
</ul>
<p><code>Strategy</code></p>
<ul>
<li>抽象策略类</li>
<li>定义所有所支持的算法的公共接口，Context 通过该接口调用某个具体策略类 ConcreteStrategy 定义的算法</li>
</ul>
<p><code>ConcreteStrategy</code></p>
<ul>
<li>具体策略类</li>
<li>封装具体的算法实现</li>
</ul>
<p>例图：<br><img src="/2021/06/19/strategy/strategy_pattern_uml_diagram.jpeg" alt></p>
<p><br></p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>角色代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context 持有对 Strategy 的引用，并且提供了调用策略的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过抽象类接口接收不同类型的具体策略类</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传进一个具体的策略实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用策略</span></span><br><span class="line"><span class="comment">     * 通过多态调用具体策略类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span> </span>&#123;</span><br><span class="line">        strategy.algorithmLogic(value1, value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象策略类，定义了策略的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmLogic</span><span class="params">(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体策略角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmLogic</span><span class="params">(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的算法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用某一组策略 A</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">        context.contextInterface(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>一系列算法组成一个策略</li>
<li>这些算法都实现了相同的接口或继承了相同的抽象类</li>
</ul>
<p><br></p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：</p>
<ol>
<li>算法可以自由切换。</li>
<li>避免使用多重条件判断，一定程度杜绝了 if-else 带来的代码不美观。</li>
<li>扩展性非常良好；如需新的策略，只需扩展原有抽象策略接口即可。</li>
</ol>
<p>缺点：</p>
<ol>
<li>策略类比较容易增多。</li>
<li>所有策略类都需要对外暴露</li>
</ol>
<p><br></p>
<h1 id="策略模式结合简单工厂模式的应用"><a href="#策略模式结合简单工厂模式的应用" class="headerlink" title="策略模式结合简单工厂模式的应用"></a>策略模式结合简单工厂模式的应用</h1><p>应用于：商店促销活动</p>
<p>策略上下文 Context：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContext</span> </span>&#123;</span><br><span class="line">    CashSuper cs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashContext</span><span class="params">(CashSuper csuper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cs = csuper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>策略：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象策略，计算实收的费用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 应收金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实收金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常收费策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashNormal</span> <span class="keyword">implements</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打折策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashRebate</span> <span class="keyword">implements</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> moneyRebate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moneyRebate 折扣</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashRebate</span><span class="params">(<span class="keyword">double</span> moneyRebate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.moneyRebate = moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money * (moneyRebate / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满减策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashRefund</span> <span class="keyword">implements</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应收金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> moneyCondition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返利金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> moneyRefund;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashRefund</span><span class="params">(<span class="keyword">double</span> moneyCondition, <span class="keyword">double</span> moneyRefund)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.moneyCondition = moneyCondition;</span><br><span class="line">        <span class="keyword">this</span>.moneyRefund = moneyRefund;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (money &gt;= moneyCondition) &#123;</span><br><span class="line">            money -= moneyRefund;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单工厂：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CashSuper <span class="title">createCashAccept</span><span class="params">(String cashType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CashSuper cs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (cashType.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;20discount&quot;</span>:  <span class="comment">// 八折</span></span><br><span class="line">                cs = <span class="keyword">new</span> CashRebate(<span class="number">8</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;refund100for300&quot;</span>:  <span class="comment">// 满 300 减 100</span></span><br><span class="line">                cs = <span class="keyword">new</span> CashRefund(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;normal&quot;</span>:  <span class="comment">// 正常收费</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> CashNormal();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就是简单的调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CashSuper cs = CashFactory.createCashAccept(<span class="string">&quot;20discount&quot;</span>);  <span class="comment">// 打八折</span></span><br><span class="line"><span class="keyword">double</span> result = cs.acceptCash(<span class="number">300</span>);</span><br><span class="line">System.out.println(result);  <span class="comment">// 240</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>策略的高级玩法：<strong>反射实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContextReflect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashContextReflect</span><span class="params">(String className, Class[] paramsType, Object[] params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(className);</span><br><span class="line">            Constructor con = clazz.getConstructor(paramsType);</span><br><span class="line">            obj = con.newInstance(params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((CashSuper) obj).acceptCash(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">String type = <span class="string">&quot;com.example.CashRebate&quot;</span>;  <span class="comment">// 调用“打八折”策略</span></span><br><span class="line">Class[] paramTypes = &#123;<span class="keyword">double</span>.class&#125;;</span><br><span class="line">Object[] params = &#123;<span class="number">8.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">CashContextReflect context = <span class="keyword">new</span> CashContextReflect(type, paramTypes, params);</span><br><span class="line"><span class="keyword">double</span> money = context.getResult(<span class="number">300</span>);</span><br><span class="line">System.out.println(money);  <span class="comment">// 240</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统线程管理</title>
    <url>/2021/08/03/threads/</url>
    <content><![CDATA[<p>今天在学习整理系统并发的知识点的时候，发现自己对操作系统调度的某些概念有些模糊了，特别是线程这一块。今天就另开一个帖子记一下。</p>
<span id="more"></span>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>首先来区分两个概念：<strong>进程</strong>与<strong>线程</strong></p>
<p>进程，是操作系统的资源调度实体</p>
<ul>
<li>内存中运行的一个应用程序，就会对应地启动一个（或多个）进程<ul>
<li>如：Windows 系统中，一个运行的 .exe 为一个进程</li>
</ul>
</li>
<li>每个进程都有自己独立的一块内存地址空间和运行环境</li>
<li>一个进程可以包含一个或多个线程，但至少要包含一个线程</li>
</ul>
<p>进程被启动之后，操作系统会为进程分配资源，最主要的是内存空间</p>
<ul>
<li>进程中有些程序流程块是乱序的，且可同时被多次执行</li>
<li>代码块——线程体</li>
</ul>
<p>而线程，是对程序中单独顺序控制流程的封装，即一个执行流程</p>
<ul>
<li>进程<strong>调度的最小单元</strong></li>
<li>线程本身依靠程序的进行而运行（总是属于某个进程），只能使用分配给它所依靠的进程的资源和环境</li>
<li>主要由线程ID、当前指令指针（PC）、寄存器集合（Registers）和堆栈（Heap &amp; Stack）等组成</li>
<li>一个进程可运行多个线程，多个线程共享进程的内存<ul>
<li>包括内存空间和打开的文件</li>
</ul>
</li>
<li>线程也叫“<strong>轻量级进程</strong>（<strong>Light-Weight Process</strong>, <strong>LWP</strong>）”</li>
</ul>
<p>处理器在线程之间高速地切换，让使用者感觉线程在同时执行。</p>
<p>刚刚说到，一个进程可以包含不止一个线程。<br>单线程，指的是程序中只存在一个线程；实际上，程序的主方法就是一个主线程。<br>多线程，指的是在一个程序中运行多个任务，目的是更好的使用CPU资源。一个程序中多个线程如果同时执行的时候，我们称之为<strong>并发</strong>。</p>
<p><img src="/2021/08/03/threads/threads-and-processes.png" alt></p>
<p><br></p>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><strong>就绪</strong></p>
<ul>
<li>线程被分配了除 CPU 以外的全部资源，等待获得 CPU 调度</li>
</ul>
<p><strong>运行</strong>（Running）</p>
<ul>
<li>就绪状态的线程获得了 CPU，开始执行程序代码</li>
<li>一个正在运行的线程仍然处于可运行状态</li>
<li>线程一旦运行了，就不必始终保持运行；有的时候，运行中的线程被中断，以便让其他的线程获得运行机会</li>
<li>如线程数目多于处理器数目，调度器会采用时间片机制</li>
</ul>
<p><strong>阻塞</strong></p>
<ul>
<li>线程因发生 I/O 或其他操作导致无法继续执行</li>
<li>此时线程会放弃处理机（CPU 使用权），转入线程就绪队列</li>
</ul>
<p><strong>挂起</strong></p>
<ul>
<li>由于终端请求，或操作系统的要求等原因，导致挂起</li>
</ul>
<p>那进程状态是怎样定义的？由于进程不是调度单位，不必划分成过细的状态，如 Windows 操作系统中仅把进程分成可运行和不可运行态，挂起状态属于不可运行态。</p>
<p><br></p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>当使用多个线程来访问同一个数据时，非常容易出现线程安全问题。<br>比如，多个线程都在操作同一数据（竞争条件 race condition），导致数据不一致。</p>
<p>此时需要使用同步机制解决：只能让一个线程将所有操作都执行完，且在它执行过程中，其他线程不参与执行。</p>
<p>线程同步前提：</p>
<ul>
<li>必须有两个或两个以上线程运行</li>
<li>必须多个线程使用同一个锁</li>
<li>优点：解决多线程安全问题</li>
<li>缺点：多个线程需要判定锁，耗费资源</li>
</ul>
<p>线程同步不是高枕无忧的，处理不当的话，很容易导致<strong>死锁</strong>问题：</p>
<ul>
<li>两个线程互相等待竞争资源，导致两边都无法得到资源，使自己无法执行</li>
<li>或：两个线程均无法达到执行所需条件</li>
</ul>
<p>举个死锁的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">&quot;B&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>t1 获得锁 A 之后，在尝试获得锁 B 的时候，t2 获得了锁 B，并在尝试获得锁 A；两者互相尝试去获得对方已经获得的锁，自然就会发生死锁。</p>
<p>如何避免死锁？</p>
<ul>
<li>避免一个线程同时获得多个锁</li>
<li>避免一个线程在锁内同时占用多个资源</li>
<li>尝试使用定时锁</li>
<li>加锁和解锁必须在一个数据库连接里</li>
</ul>
<p>另外，引入<strong>生产者与消费者模型</strong>可以解决问题：</p>
<ol>
<li>生产者仅在仓储未满时生产，仓满则停止生产；</li>
<li>消费者仅在仓储有产品时才能消费，仓空则等待；</li>
<li>当消费者发现仓储无产品可消费，则通知生产者生产；</li>
<li>生产者生产出可消费产品时，应通知等待的消费者消费</li>
</ol>
<p><br></p>
<h1 id="多线程编程的优势"><a href="#多线程编程的优势" class="headerlink" title="多线程编程的优势"></a>多线程编程的<strong>优势</strong></h1><ul>
<li>进程间不能共享内存，但线程之间共享内存很容易</li>
<li>系统创建线程所分配的资源相对创建进程而言，代价小</li>
</ul>
<p><br></p>
<h1 id="多线程就一定快吗？"><a href="#多线程就一定快吗？" class="headerlink" title="多线程就一定快吗？"></a>多线程就一定快吗？</h1><big>**不一定。**</big>

<p>起更多的线程，并不能保证程序最大程度上并发执行；若想要通过多线程让程序执行得更快，则需要面临很多的问题和挑战。<br>最大的问题，便是<strong>上下文切换</strong>和线程<strong>创建/销毁</strong>的开销。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>支持多线程执行程序的单核 CPU 通过给每个线程分配 CPU 时间片（一般是几十 ms），并且通过时间片分配算法，在不同的时间片之间高速切换，以执行不同线程的任务。</p>
<p>因为切换速度飞快且频繁，才让人感觉多个线程好像在同时执行。<br>而且在切换至下一个时间片之前，需要保存上一个时间片执行任务的状态，以便到时候切换回上一个时间片的正确状态，重新加载并执行。<br>以上都是上下文切换消耗资源，影响执行效率的原因。</p>
<p>如何<strong>减少上下文切换</strong>？</p>
<p>从程序设计的角度来看，可以尽量不在程序中使用锁，即采用无锁编程（无锁并发）：比如先将数据的 ID 通过 hash 算法取模，不同的线程根据模的值来处理不同的数据。</p>
<p>实在是需要锁的话，最好使用 CAS 算法来实现乐观锁的机制。</p>
<p>另外，可以通过协程来实现在单线程里实现多任务的调度，维护多任务的切换。</p>
<h2 id="线程的创建和销毁"><a href="#线程的创建和销毁" class="headerlink" title="线程的创建和销毁"></a>线程的创建和销毁</h2><p>使用线程池来减少创建销毁线程带来的系统开销。</p>
<p>&lt;/br&gt;</p>
<h1 id="线程管理的资源限制"><a href="#线程管理的资源限制" class="headerlink" title="线程管理的资源限制"></a>线程管理的资源限制</h1><p>并发代码运行的环境通常会受到硬件资源和软件资源的限制。</p>
<ul>
<li>硬件资源限制包括网络带宽、硬盘读写速度、CPU 处理速度等；</li>
<li>软件资源限制包括数据库连接数、socket 连接数等。</li>
</ul>
<p>将某个程序的串行程序改造成并行之后，如果由于资源限制使得程序仍然是在串行执行，这样便会使得 CPU 在串行执行程序的时候<strong>依然需要切换时间片</strong>和<strong>调度资源</strong>，程序比改造前还慢。</p>
<p>集群可以克服硬件资源限制；资源池可以克服软件资源限制。</p>
<p>运行环境实在是受限制的话，程序应该根据限制的情况调整并发度。<br>一般来说，最佳线程数 = CPU 核心数 * [1 + (I/O 耗时 / CPU 耗时)]。</p>
]]></content>
      <tags>
        <tag>多线程编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式（Template Method）</title>
    <url>/2021/06/22/template-method/</url>
    <content><![CDATA[<p>模版方法模式属于类行为型模式。</p>
<span id="more"></span>
<p>《设计模式：可复用面向对象软件的基础》中的介绍：</p>
<pre><code>“定义一个操作中算法的骨架，而将一些步骤延迟到子类中”
“能使得子类能在不改变一个算法的结构的情况下，即可重定义该算法的某些特定步骤”
</code></pre><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/2021/06/22/template-method/template-method.webp" alt></p>
<p>以上，可见模版方法模式包括：</p>
<p><code>AbstractTemplate</code></p>
<ul>
<li>抽象的模版方法</li>
<li>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</li>
</ul>
<p><code>ConcreteTemplate</code></p>
<ul>
<li>具体的模版方法</li>
<li>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</li>
</ul>
<p>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p>
<p>看起来的感觉就是抽象类，以及其具体实现子类。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类，模板方法被设置为 final </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line">        <span class="comment">// 开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line">        <span class="comment">// 结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建扩展了上述类的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football game finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football game initialized! Start the game.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football game started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p>
<ol>
<li>封装不变部分，扩展可变部分。</li>
<li>提取公共代码，便于维护。</li>
<li>行为由父类控制，子类实现。</li>
</ol>
<p>缺点</p>
<ul>
<li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 网关初探</title>
    <url>/2023/10/05/spring-cloud-gateway/</url>
    <content><![CDATA[<p>Spring Cloud 中的网关，是一个“不显山不露水”的组件。</p>
<span id="more"></span>
<p>没网关，也能访问服务。但是问题在于：如果服务多起来了，客户端需要对应着去实现访问不同服务的逻辑，这样一来，就会增加客户端的复杂度。</p>
<p>如果服务需要鉴权，则每个服务的鉴权处理还都需要分别实现和维护；而且流量控制也很不好做；</p>
<p>另外，如果服务想同时支持 HTTP 和 RPC 或另外的多种通信方式，client 要分别维护不同语言的 SDK，相当麻烦。</p>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>网关的好处，也就是网关的功能：</p>
<ul>
<li>针对所有请求进行统一鉴权、限流、缓存、日志（打点）；</li>
<li>协议转化。针对后端多种不同的协议，在网关层统一处理之后，以 HTTP 对外提供服务；</li>
<li>针对异常请求和异常处理，对外提供统一的错误码；</li>
<li>请求转发，且可以基于自身实现内网和外网的隔离。</li>
</ul>
<p>在实现<strong>鉴权</strong>的时候，网关相当于是一个统一的认证中心，访客通过网关进行交互，实现身份认证和访问权限控制；</p>
<p>另外在实现<strong>灰度发布</strong>的时候，网关与分流引擎交互，将<strong>不同比例</strong>的流量分发到新/旧不同的服务中：</p>
<ul>
<li>前期切小部分（如 10%）流量至新服务，如果效果不好或者存在 bug 就回退；</li>
<li>否则就可以逐步增大通往新服务的流量比例，以此实现平稳过渡。</li>
</ul>
<h1 id="常见实现方案"><a href="#常见实现方案" class="headerlink" title="常见实现方案"></a>常见实现方案</h1><p>市面上常见的微服务网关实现方案有以下几种：OpenResty, Zuul, Gateway, Kong, Apisix。下面重点介绍最常用的几套方案。</p>
<h2 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h2><p>Nginx + Lua 的高性能 Web 服务器，集成了大量的 Lua 库和第三方模块，可在不同阶段挂载 Lua 脚本实现不同阶段的自定义行为。</p>
<p>OpenResty 启动的不同的阶段包括：</p>
<ul>
<li><strong>初始化</strong>：init_by_lua 配置加载, init_worker_by_lua 健康检查</li>
<li><strong>Rewrite / Access</strong>：ssl_certificate_by_lua, set_by_lua 设值, rewrite_by_lua, access_by_lua 访问</li>
<li><strong>返回内容处理</strong>（封装访问结果）：content_by_lua 返回内容, balancer_by_lua 负载均衡, header_filter_by_lua, body_filter_by_lua</li>
<li><strong>日志处理阶段</strong>：log_by_lua</li>
</ul>
<p>优点是开放、解耦。</p>
<h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>属于 Netflix 解决方案的微服务网关，核心由一系列过滤器组成。</p>
<p>Zuul 制定了 4 种标准类型过滤器（pre filters, routing filters, post filters, error filters），对应了请求的整个生命周期：</p>
<ul>
<li>pre filters：鉴权、限流</li>
<li>routing filters：转发、路由</li>
<li>post filters：处理结果、统计、监控等，生成日志</li>
<li>error filters：顾名思义，处理请求和服务器错误</li>
</ul>
<p>Zuul 1.x 采用的是传统的 thread per connection 方式：一旦后台响应慢，线程容易阻塞，因此不适合高并发场景。</p>
<h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a><a href="https://spring.io/projects/spring-cloud-gateway">Gateway</a></h2><p>Spring 官方团队基于 Spring Boot 2.0 + WebFlux（Spring 5.0） + Project Reactor 这套成熟的解决方案研发的网关，目的为了是提供一种简单有效且统一的 API 路由管理方式。</p>
<p>Gateway 的目标是取代 Zuul，因为 Zuul 直至 2.0 版本还是使用非 Reactor 模式。</p>
<p>不仅提供统一的路由请求方式，还能基于 <strong>Filter 过滤链</strong>方式提供网关最基本的功能。</p>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>在理清 Gateway 处理流程之前，我们先了解下 Gateway 组件的一些定义：</p>
<ol>
<li>Route：路由</li>
<li>Predicate：路由中对于具体路径的匹配，在代码中由 RoutePredicateFactory 实现<br>Filter：对于请求做特殊处理（路径转换、跨域等）</li>
</ol>
<p>客户端首先向 Spring Cloud Gateway 应用发起请求。</p>
<p>随后，应用会在 Gateway Handler Mapping 中找到能与请求相匹配的路由，将请求发送到 Gateway Web Handler。</p>
<p>Handler 再通过指定的 Filter 过滤链，将请求最终发送到实际的服务执行逻辑。</p>
<h3 id="Gateway-组件"><a href="#Gateway-组件" class="headerlink" title="Gateway 组件"></a>Gateway 组件</h3><p>Gateway 中会部署不同的多个 route</p>
<p><code>spring.cloud.gateway.routes.id</code>: 自定义路由的唯一标识<br><code>spring.cloud.gateway.routes.predicates</code>: 路径匹配<br><code>spring.cloud.gateway.routes.filters</code></p>
<p>此外 Gateway 提供了不同的已经封装好的 RoutePredicateFactory：</p>
<ul>
<li>ZonedDateTime：指定时间范围，包括 BeforeRoutePredicateFactory, AfterRoutePredicateFactory, BetweenRoutePredicateFactory</li>
<li>Cookie：CookieRoutePredicateFactory</li>
<li>Header：HeaderRoutePredicateFactory, CloudFoundryRouteServiceRoutePredicateFactory</li>
<li>Host：HostRoutePredicateFactory</li>
<li>Method：MethodRoutePredicateFactory</li>
<li>Path：PathRoutePredicateFactory</li>
<li>Query：QueryRoutePredicateFactory</li>
<li>RemoteAddr：RemoteAddrRoutePredicateFactory, WeightRoutePredicateFactory, ReadBodyPredicateFactory</li>
</ul>
<p>Filter 分：pre 类型过滤器（请求前鉴权、限流）、post 类型过滤器（执行完毕后处理）</p>
<p>实现方式：</p>
<ul>
<li>GatewayFilter 只会应用到单个路由或一个分组的路由上</li>
<li>GlobalFilter 会应用到所有路由上</li>
</ul>
<p>不同的 RouteFilterFactory：</p>
<ul>
<li>GatewayFilter: AddRequestParameterGatewayFilterFactory（pre，添加查询参数，如登录态）, AddResponseHeaderGatewayFilterFactory（post，返回前在 header 添加数据）, RequestRateLimiterGatewayFilterFactory（需要引入依赖如 redis）, RetryGatewayFilterFactory</li>
<li>GlobalFilter: LoadBalancerClientFilter, GatewayMetricsFilter（指标过滤器）, ForwardRoutingFilter, NettyRoutingFilter</li>
</ul>
<p>此外还支持自定义 GatewayFilter 和 GlobalFilter，自定义需遵循命名规范。</p>
<h3 id="实战实例"><a href="#实战实例" class="headerlink" title="实战实例"></a>实战实例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">raymond-blog</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://daca-ao.github.io/</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/raymond</span></span><br></pre></td></tr></table></figure>
<h1 id="与-Spring-Cloud-其它组件的集成"><a href="#与-Spring-Cloud-其它组件的集成" class="headerlink" title="与 Spring Cloud 其它组件的集成"></a>与 Spring Cloud 其它组件的集成</h1><p>可集成 <a href="/2023/10/19/spring-cloud-service-regiscovery/#Nacos">Nacos</a>，结合服务发现实现请求负载均衡；</p>
<p>还可集成 <a href="/2023/10/20/spring-cloud-flow-control/#Sentinel">Sentinel</a> 实现网关限流。</p>
]]></content>
      <tags>
        <tag>架构</tag>
        <tag>计算机网络</tag>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 服务注册与发现</title>
    <url>/2023/10/19/spring-cloud-service-regiscovery/</url>
    <content><![CDATA[<p>服务注册和服务发现，是微服务能立足的根本。</p>
<span id="more"></span>
<p>没有服务注册和发现的功能，何来的微服务实现呢？由此服务注册和发现是微服务的重中之重，市面上也推出了大大小小很多的解决方案。</p>
<p>下面来介绍两款最著名的方案。</p>
<p><br></p>
<h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p>Netflix Eureka 是 <a href="/2023/06/09/spring-cloud-overview/#Spring-Cloud-Netflix">Netflex</a> 的核心服务，其为基于 REST 的用于定位的服务，以实现云端中间层的服务治理，包括服务注册、服务发现和故障转移。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Eureka 的设计为经典的 C-S 架构，包括 client 端，用于处理服务的注册和发现；以及 server 端的服务注册中心。</p>
<ul>
<li>客户端服务通过<strong>注解</strong>和<strong>参数配置</strong>的方式嵌入应用代码</li>
<li>应用运行时，Eureka 客户端向注册中心注册自身提供的服务，并周期性发送心跳来更新服务租约<ul>
<li>因此 Eureka 的保护机制就是心跳机制：心跳超时的服务不再注册回注册中心</li>
</ul>
</li>
<li>客户端可从服务端查询当前服务信息并<strong>缓存</strong>到本地，周期性刷新状态。</li>
</ul>
<p>Eureka 包括 <code>Region</code> 和 <code>Zone</code> 两个概念。<br>一个 <code>Region</code> 可以对应上多个 <code>Zone</code>，<code>Zone</code> 为对应服务的分区，相当于 Nacos 的 group。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>启动类中添加 <code>@EnableEurekaServer</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>@EnableEurekaServer</code> 注解原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(EurekaServerMarkerConfiguration)</span></span><br></pre></td></tr></table></figure>
<p>Eureka 唯一的自动配置类 <code>EurekaServerAutoConfiguration</code> 的条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(EurekaServerInitializerConfiguration.class)</span>  <span class="comment">// 初始化</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties({EurekaDashboardProperties.class})</span>  <span class="comment">// 控制台类，默认路径 path = "/"</span></span><br></pre></td></tr></table></figure>
<p>注册集群：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">--</span> <span class="string">application-cluster1.yml</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cluster1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://cluster2:8003/eureka/</span>  <span class="comment"># 注册到另一个 Eureka 注册中心</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="string">--</span> <span class="string">application-cluster2.yml</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cluster2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://cluster1:8003/eureka/</span>  <span class="comment"># 注册到另一个 Eureka 注册中心</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>阿里巴巴推出的王牌组件，能够充当配置中心 + 服务发现组件，实现动态配置服务、服务发现及管理、动态 DNS 等功能。</p>
<p>Nacos 的大体架构如下：</p>
<ul>
<li><strong>Provider APP</strong>：服务提供者，可通过 nacos client / sidecar 实现访问 Nacos Server；</li>
<li><strong>Consumer APP</strong>：服务消费者</li>
<li><strong>Name</strong>：通过 vip / dns / address-server 实现 Nacos 的高可用服务路由</li>
<li>Nacos Server，包括：<ul>
<li><strong>OpenAPI</strong>：服务访问入口</li>
<li><strong>Config Service</strong>：配置服务模块</li>
<li><strong>Naming Service</strong>：命名服务模块，建立分布式系统中所有对象、实体之间的域名与 ip 的映射关系，实现服务发现的能力</li>
<li><strong>Nacos core</strong></li>
<li>最底层的 <strong>Consistency Protocol</strong>：数据一致性协议，基于 priv-raft / sync renew / rdbms based 等</li>
</ul>
</li>
</ul>
<p>使用 Nacos 需要手动配置数据库：创建 <code>plugins/mysql/</code> 目录，并放入下载好的 mysql-connector。<br>随后执行 sql 创建 <code>nacos_config</code> 数据库。</p>
<h2 id="Nacos-服务注册与发现"><a href="#Nacos-服务注册与发现" class="headerlink" title="Nacos 服务注册与发现"></a>Nacos 服务注册与发现</h2><p>分别基于 HTTP 和 RPC 的通信方式，有两种实现：</p>
<p><strong>一是</strong>基于 Nacos + <a href="/2023/10/19/spring-cloud-load-balancer/#Ribbon-amp-OpenFeign">Feign + Ribbon</a> 实现：</p>
<p>Feign 对 HTTP 进行封装，充当 provider 服务的代理；Ribbon 实现 consumer 调用 provider 服务时的负载均衡，调用 Feign Client 完成通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name="nacos-provider")</span></span><br></pre></td></tr></table></figure>
<p>其底层实现的原理<a href="/2023/06/10/micro-service/#实现原理">大同小异</a>：</p>
<ul>
<li><code>NacosServiceRegistry</code> 实现了 <code>spring-cloud-commons</code> 包 <code>ServiceRegistry</code> 的接口方法；</li>
<li><code>NacosAutoServiceRegistration</code> 实现了 <code>AutoServiceRegistrationAutoConfiguration</code> -&gt; <code>AbstractAutoServiceRegistration</code> 以完成自动服务注册;</li>
<li>在 <code>AbstractAutoServiceRegistration</code> 的 <code>bind()</code> 中完成注册。</li>
</ul>
<p><strong>二是</strong>基于 Dubbo + Nacos：</p>
<p>Consumer 调用 provider 服务时，通过 Dubbo RPC 服务调用。</p>
<p>这种实现方式也是基于差不多的底层原理：最终也是调用 <code>NacosAutoServiceRegistration</code> 的 <code>register()</code> -&gt; <code>namingService.registerInstance()</code> 建立调用链。<br>通过 <code>registerInstance()</code> 调用中建立心跳机制（<code>ExecutorService.schedule()</code>），随后注册服务</p>
<p>通过 Nacos 的 OpenAPI 调用 Nacos Server 完成注册；<br>调用服务时，有服务就取出来，没有的话就调用 <code>createServiceIfAbsent()</code>，完了保存到变量 <code>concurrentHashMap</code> 中做缓存；  </p>
<p>同时会保持集群中服务的一致性：通过调用 <code>list()</code> 接口完成服务地址查询，获得指定服务的所有健康实例的 ip。</p>
<h2 id="Nacos-配置中心"><a href="#Nacos-配置中心" class="headerlink" title="Nacos 配置中心"></a>Nacos 配置中心</h2><p>与之对标的是 Netflix 的 Spring Cloud Config。</p>
<p>为了配置管理，Nacos 有一个新的概念 <code>namespace</code>：</p>
<ul>
<li>包括最外层 namespace（默认为 public），中间的配置分组 group，及最里层的配置集 data id，都是为了配置的隔离；</li>
<li>每一份配置集里面有对应的配置项。</li>
</ul>
<p>因此常用 namespace 来区分不同的测试环境（dev，test，…）。</p>
<p>通过注解获取配置项（<code>@Value("${xxx.xxx}")</code>）的值时，需要在 controller 类层面添加注解 <code>@RefreshScope</code> 保证配置能实时更新。</p>
<p>配置集群：在 <code>cluster.conf</code> 中配置集群机器的 ip 和端口，同时配置每一台机器的 <code>application.properties</code> 中的 ip 和端口。</p>
<p>注：nacos UI 可以生成访问示例代码。</p>
<h1 id="Dubbo-Zookeeper"><a href="#Dubbo-Zookeeper" class="headerlink" title="Dubbo + Zookeeper"></a>Dubbo + Zookeeper</h1><p>除了上述提到的 Nacos 和 Eureka，Dubbo + Zookeeper 也可以实现服务注册与发现。</p>
]]></content>
      <tags>
        <tag>架构</tag>
        <tag>Spring</tag>
        <tag>服务注册</tag>
        <tag>服务发现</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 负载均衡</title>
    <url>/2023/10/19/spring-cloud-load-balancer/</url>
    <content><![CDATA[<p>负载均衡，是微服务能够健壮持续运行的关键。</p>
<span id="more"></span>
<p>在 Spring Cloud 中，通常结合 Ribbon 和 OpenFeign 实现微服务之间的通信和负载均衡。</p>
<h1 id="Ribbon-amp-OpenFeign"><a href="#Ribbon-amp-OpenFeign" class="headerlink" title="Ribbon & OpenFeign"></a>Ribbon &amp; OpenFeign</h1><p>Spring Cloud Ribbon 基于 Netflix Ribbon 实现，需要配合 RestTemplate, Feign 等通信组件共同完成请求负载均衡</p>
<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>RestTemplate 是 Spring 3.0 支持的 HTTP 请求工具。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestTemplate</span> <span class="keyword">extends</span> <span class="title">InterceptingHttpAccessor</span> <span class="keyword">implements</span> <span class="title">RestOperations</span></span></span><br></pre></td></tr></table></figure>
<p>提供常见的 REST 请求方案的模板，以及一些通用的请求执行方法 <code>exchange()</code> 和 <code>execute()</code>，可以平替比较繁琐的 Apache HttpClient。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li><code>DiscoveryClient</code>（<a href="/2023/10/19/spring-cloud-service-regiscovery/#Nacos">Nacos</a> 实现的 <code>NacosDiscoveryClient</code>） + 自实现负载均衡</li>
<li><code>LoadBalancerClient</code>（Ribbon 实现的 <code>RibbonLoadBalancerClient</code>）</li>
<li><code>@LoadBalanced</code></li>
</ol>
<p>Ribbon 负载均衡策略：</p>
<ul>
<li>RoundRobin</li>
<li>Random</li>
<li>AvailabilityFiltering</li>
<li>WeightedResponse</li>
<li>Retry</li>
<li>BestAvailable</li>
</ul>
<p><code>OpenFeign</code> 组件 = Feign，是声明式的伪 http 客户端，底层使用的是 RestTemplate，默认实现了负载均衡。</p>
<p>Feign 与 Dubbo 的调用区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Feign</th>
</tr>
</thead>
<tbody>
<tr>
<td>传输协议</td>
<td>TCP</td>
<td>TCP</td>
</tr>
<tr>
<td>开发语言</td>
<td>Java</td>
<td>不限</td>
</tr>
<tr>
<td>性能</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>灵活性</td>
<td>一般</td>
<td>好</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>架构</tag>
        <tag>Spring</tag>
        <tag>负载均衡</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 流量控制</title>
    <url>/2023/10/20/spring-cloud-flow-control/</url>
    <content><![CDATA[<p>流量控制，是监控应用流量的 QPS 或者并发线程数等指标；当达到指定阈值时，对流量进行限制，必要时进行服务降级、甚至服务熔断。</p>
<span id="more"></span>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>面向分布式服务架构的轻量级流量控制组件，主要以流量为切入点，从限流、流量整形、服务降级、系统负载保护等多个维度保障微服务稳定。</p>
<p>主要特征：实时监控、机器发现、规则配置</p>
<ul>
<li>提供实时监控功能，包括查看单机秒级数据，设置 500 台以下规模的集群汇总运行情况</li>
<li>适用场景丰富</li>
<li>配置简单</li>
</ul>
<p>其组成为 Java 类库 + Dashboard，将配置中心/数据库作为动态规则源并与之结合。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 <code>SphU</code> 或 <code>SphO</code> 进行限流：引入 maven 依赖之后，定义资源 <code>SphU.entry()</code> / <code>SphO.entry()</code>，定义规则，查看执行结果</p>
<p>除此之外，还可以引入注解 <code>@SentinelResource</code> 标记在服务类的业务方法上：</p>
<ul>
<li>引入依赖后，编写 <code>Configuration</code> 配置类，再编写服务类</li>
<li>需要另外添加 <code>processBlockHandler</code> 和 <code>fallbackHandler</code></li>
</ul>
<p>限流异常和资源清洗：</p>
<ul>
<li>通过实现 <code>UrlBlockHandler</code> 接口重写 <code>blocked()</code> 方法，从而自定义 URL 限流异常</li>
<li>通过实现 <code>UrlCleaner</code> 接口重写 <code>clean()</code> 方法，进行 URL 资源清洗</li>
</ul>
<p>集成 Spring Cloud 后可以通过 dashboard 方式启动。</p>
<p>可集成 <a href="/2023/10/19/spring-cloud-service-regiscovery/#Nacos">Nacos</a> 保存流控规则，以免每次重启 Sentinel 后流控规则会被清空。</p>
]]></content>
      <tags>
        <tag>架构</tag>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>流量控制</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层与 IPv4</title>
    <url>/2023/11/17/ipv4/</url>
    <content><![CDATA[<p>聊一聊 OSI 模型中的第三层：网络层。</p>
<span id="more"></span>
<p>网络层通过路由选择算法提供<strong>路由</strong>和<strong>寻址</strong>的功能，为 IP 分组从源主机到目的主机选择一条合适的传输路径，并为下一层 —— [传输层]提供端到端的数据传输服务；同时网络层具有一定的拥塞控制和流量控制的能力。</p>
<p>符合网络层功能，专门处理网络层路由与转发功能的计算机，我们称之为“<strong>路由器</strong>”。</p>
<p>由于 TCP/IP 协议体系里面的网络层功能由 IP 协议规定和实现，因此网络层又称为 <strong>IP 层</strong>。</p>
<p>那，什么是 IP 分组？</p>
<h1 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1><p>在网络层中，一个完整的网络地址包括：</p>
<ul>
<li>网络名字（name）</li>
<li>网络地址（address）</li>
<li>路径（route）</li>
</ul>
<p>IP 地址标识的是一台主机或路由器与网络的接口，最早由 1981 年的 RFC791 描述了 IPv4 协议。</p>
<p>IP 协议的主要特点如下：</p>
<p><strong>1</strong>. IP 协议是<strong>无连接</strong>、<strong>不可靠</strong>的<strong>分组</strong>传送服务协议</p>
<ul>
<li>不提供对分组传输过程的跟踪，意为“尽力而为（best-effort）”；</li>
<li>无连接：指的是 IP 协议并不维护 IP 分组发送后的任何状态信息，每个分组在各自的传输过程中相互独立；</li>
<li>不可靠：指的是 IP 协议不能保证每个 IP 分组都能正确地、不丢失和按顺序地到达目的主机；</li>
</ul>
<p>IP 协议设计重点应放在系统适应性、可扩展性与可操作性上，在分组交付可靠性上只能做一定牺牲。</p>
<p><strong>2</strong>. IP 协议是点-点（<strong>Peer-to-Peer</strong>）的网络层通信协议</p>
<ul>
<li>网络层需要在 Internet 中为通信的两个主机之间寻找一条路径，该路径通常由多个路由器、点-点链路组成；</li>
<li>IP 协议要保证数据分组从一个到另一个路由器，能通过多条路径从源主机到目的主机。</li>
</ul>
<p>因此，IP 协议是针对源主机-路由器、路由器-路由器、路由器-目的主机之间的数据传输的点-点线路的网络层通信协议。</p>
<p><strong>3</strong>. IP 协议屏蔽了互联的网络往下在数据链路层、物理层协议与实现技术上的差异</p>
<ul>
<li>各种网络和协议，如广域网、城域网或局域网，都有可能是异构的；</li>
<li>即使都是局域网，其物理层、数据链路层协议也可能不同；</li>
<li>通过 IP 协议，网络层向传输层提供统一的 IP 分组，传输层不需要考虑互联网络在数据链路层、物理层协议与实现技术的差异。</li>
</ul>
<h1 id="IPv4-分组（IPv4-数据报）格式"><a href="#IPv4-分组（IPv4-数据报）格式" class="headerlink" title="IPv4 分组（IPv4 数据报）格式"></a>IPv4 分组（IPv4 数据报）格式</h1><p>回答上面的问题：一份 IP 分组，就是一次 IP 报文的发送。</p>
<p>一份 IPv4 的报文由两个部分组成：</p>
<p><strong>1</strong>. <strong>分组头</strong>：也称“首部”，长度可变。</p>
<ul>
<li>分组头中前 5 行（共 20 字节，160 bits）为每个字节头中必须有的字段；第 6 行开始为选项字段  </li>
<li>因此 IPv4 分组头基本长度是 <strong>20</strong> 字节；</li>
<li>如加上最长 40 字节（10 行）的选项（<code>options</code>），则最大可达 <strong>60</strong> 字节</li>
</ul>
<p><strong>2</strong>. 数据。</p>
<p>根据 RFC791 规定：IP 分组最大长度为 <strong>65535</strong>（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>） 字节。</p>
<h2 id="分组头格式"><a href="#分组头格式" class="headerlink" title="分组头格式"></a>分组头格式</h2><p>分组头总览如下：</p>
<p><img src="/2023/11/17/ipv4/ipv4_header.png" alt></p>
<p>以下为各字段的解释：</p>
<h3 id="版本-version"><a href="#版本-version" class="headerlink" title="版本 version"></a>版本 <code>version</code></h3><p>IP 分组第一个字段，共 4 位，表示所使用的网络层 IP 的版本号。</p>
<ul>
<li>字段值为 <code>0100 = 4</code>，表示 IPv4；<code>0110 = 6</code> 则表示 IPv6</li>
<li>IP 软件在处理该分组之前必须检查版本号，以避免错误解释分组的内容</li>
</ul>
<h3 id="分组头长度-header-length"><a href="#分组头长度-header-length" class="headerlink" title="分组头长度 header length"></a>分组头长度 <code>header length</code></h3><p>也称报头长度，共 4 位，定义<strong>以 4 字节为一个单位</strong>的分组头的长度。</p>
<p>因为分组头除了 IP 选项（<code>options</code>）字段和填充字段（<code>padding</code>）外，其他各字段长度均为确定的值。</p>
<ul>
<li>所以根据上文结论，分组头长度最小值为 <code>0101 = 5</code>（5 × 4 = 20 字节）；</li>
<li>如果加上 <code>options</code> 和 <code>padding</code>，分组头长度最大能达到 <code>1111 = 15</code>（15 × 4 = 60 字节）</li>
<li>IP 分组头长度必须是 4 字节的<strong>整数倍</strong>，如不是 4 字节整数倍，则需要 <code>padding</code> “补 0”</li>
</ul>
<h3 id="服务类型-differentiated-services"><a href="#服务类型-differentiated-services" class="headerlink" title="服务类型 differentiated services"></a>服务类型 <code>differentiated services</code></h3><p>8 位，指示路由器如何处理该分组。字段内容包括：</p>
<p><strong>1</strong>. 4 位服务类型（<code>Type of Service</code>, <code>TOS</code>），每一位分别表示：</p>
<ul>
<li><code>D</code>（Delay，延迟）</li>
<li><code>T</code>（Throughput，吞吐量）</li>
<li><code>R</code>（Reliability，可靠性）</li>
<li><code>C</code>（Cost，成本）</li>
</ul>
<p>每位的取值为 0 或 1；TOS 中最多只能有一位为 1，此时其他三位均为 0，代表基本配置：即只能有 <code>0000</code> <code>0001</code> <code>0010</code> <code>0100</code> <code>1000</code> 五种取值。</p>
<ul>
<li>延迟位 D = 1 表示低延迟 low delay；D = 0 表示 normal</li>
<li>吞吐量位 T = 1 表示高吞吐量 high throughput；T = 0 表示 normal</li>
<li>可靠性为 R = 1 表示高可用 high reliability；R = 0 表示 normal</li>
<li>成本为 C = 1 表示低成本 low cost；C = 0 表示 normal</li>
</ul>
<p>这个字段说明：每种服务类型都不可能同时在延迟、吞吐量、可靠性和成本 4 个方面达到最优，因此必须寻求折中方案，保证最基本性能。</p>
<p><strong>2</strong>. 3 位优先级（<code>precedence</code>）</p>
<ul>
<li>IP 报文在网络间传输的时候，有的应用需要网络提供优先服务，导致一些重要服务信息的处理等级会比一般服务信息的处理等级高</li>
<li>当网络高负荷，路由器发生拥塞必须丢弃一些分组时，路由器会只接收某优先级以上的分组</li>
<li>路由器根据四个参数的组合来确定选择的标准</li>
</ul>
<p><strong>3</strong>. 1 位保留位</p>
<h3 id="总长度-total-length"><a href="#总长度-total-length" class="headerlink" title="总长度 total length"></a>总长度 <code>total length</code></h3><p>16 位，定义以字节为单位的 IP 分组总长度，<strong>包括分组头长度与数据长度之和</strong>。</p>
<ul>
<li>最大长度为 65535（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>）字节</li>
<li>IP 分组中，高层协议的数据长度等于分组的总长度减去分组头长度</li>
</ul>
<h3 id="标识字段-identification"><a href="#标识字段-identification" class="headerlink" title="标识字段 identification"></a>标识字段 <code>identification</code></h3><p>16 位，是 IP 分组的分片（fragment）识别标识，最多可分配 65535 个 ID。</p>
<p>应用场景：</p>
<ul>
<li>属于同一分组的不同片到达时出现乱序，或与属于其他分组的片混在一起的情况；</li>
<li>目的主机会根据标识字段的 ID 值（如 1562），将所有<strong>同样 ID 值的分片</strong>挑出来，重新组装成一个分组</li>
</ul>
<h3 id="标志-flags"><a href="#标志-flags" class="headerlink" title="标志 flags"></a>标志 <code>flags</code></h3><p>长度为 3 位，其中最高位是 0，该值必须复制到所有分组中。</p>
<p>另两位分别是：</p>
<ul>
<li>不分片（Do not Fragment, <code>DF</code>）值：必须复制到所有分组中<ul>
<li>DF = 1：接收主机不能对分组进行分片<ul>
<li>如分组长度超过 MTU 又不可分片：该分组只能被丢弃，并要用 ICMP 差错报文向源主机报告</li>
</ul>
</li>
<li>DF = 0：接收主机可以对分组分片</li>
</ul>
</li>
<li>分片（More Fragment, <code>MF</code>）值<ul>
<li>MF = 1：接收到的分片不是最后一个分片</li>
<li>MF = 0：接收到的分片是最后一个分片</li>
</ul>
</li>
</ul>
<h3 id="片偏移-fragment-offset"><a href="#片偏移-fragment-offset" class="headerlink" title="片偏移 fragment offset"></a>片偏移 <code>fragment offset</code></h3><p>13 位，表示分片在整个分组中的相对位置。</p>
<p>举个例子，如果系统以 8 字节为单位计数，则选择的分片长度应为 8 字节的整数倍。</p>
<p>例：</p>
<p><img src="/2023/11/17/ipv4/fragment_offset.png" alt></p>
<p>说明：</p>
<p>举例来说，该分组头长度 20 字节，分组数据长度为 820 字节，那么</p>
<ul>
<li>第一个 IP 片：包括编号 0 - 799 的数据<ul>
<li>复制原分组头（除去标志和片偏移值），与第一分片数据构成第一分片</li>
<li>初始分片，片偏移值为 0</li>
</ul>
</li>
<li>第二个 IP 片：包括编号 800 - 1599 的数据<ul>
<li>复制原分组头（除去标志和片偏移值），与第二分片数据构成第二分片</li>
<li>该分片第一个数据编码号为 800，800/8 = 100，因此偏移值为 100</li>
</ul>
</li>
<li>第三个 IP 片：包括编号 1600 - 2199 的数据<ul>
<li>复制原分组头（除去标志和片偏移值），与第三分片数据构成第三分片</li>
<li>该分片第一个数据编码号为 1600，1600/8 = 200，因此偏移值为 200</li>
</ul>
</li>
</ul>
<p>从原始分组到分片后，分组头总长度字段、标志和片偏移字段均发生变化：其中分片 1、分片 2 中的 MF = 1；分片 3 中 MF = 0。</p>
<p>因标识、标志与片偏移均发生变化，分组头的校验和需要重新计算。</p>
<h3 id="生存时间-time-to-live-TTL"><a href="#生存时间-time-to-live-TTL" class="headerlink" title="生存时间 time-to-live, TTL"></a>生存时间 time-to-live, <code>TTL</code></h3><p>IP 分组从源主机到目的主机的传输延迟是不确定的。如果出现路由器的路由表错误，会造成分组在网络中循环、无休止的流动。</p>
<p>IPv4 通过该字段来设定分组在 Internet 中的“寿命”，长度为 8 位。</p>
<p>通常用转发分组最多的路由器跳数（hop）来度量</p>
<ul>
<li>初始值由源主机设置，每经由一路由器转发，TTL 值就减一；</li>
<li>当 TTL 减至 0 时，该分组会被丢弃，并发送 ICMP 报文通知源主机</li>
</ul>
<h3 id="协议-protocol"><a href="#协议-protocol" class="headerlink" title="协议 protocol"></a>协议 <code>protocol</code></h3><p>8 位，指使用 IP 的更高一层（传输层）协议类型。</p>
<p>常见协议类型如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>协议字段值</th>
<th>高层协议类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>ICMP</td>
</tr>
<tr>
<td>2</td>
<td>IGMP</td>
</tr>
<tr>
<td>6</td>
<td>TCP</td>
</tr>
<tr>
<td>8</td>
<td>EGP</td>
</tr>
<tr>
<td>17</td>
<td>UDP</td>
</tr>
<tr>
<td>41</td>
<td>IPv6</td>
</tr>
<tr>
<td>89</td>
<td>OSPF</td>
</tr>
</tbody>
</table>
</div>
<h3 id="头部校验和-header-checksum"><a href="#头部校验和-header-checksum" class="headerlink" title="头部校验和 header checksum"></a>头部校验和 <code>header checksum</code></h3><p>16 位，用以保证分组头部的数据完整性。</p>
<p>由于每经过一个路由器，IP 分组头都要改变一次，但数据部分不改变；且 IP 分组头之外的部分属于高层数据，高层数据都会有相应的校验字段。</p>
<p>因此 IP 分组可以不对高层数据进行校验，<strong>只对分组头进行校验</strong>，这样的校验方法是合理的，可以减少路由器对每个接收分组的处理时间，提高路由器运行效率。</p>
<p>计算方法：二进制反码求和</p>
<ol>
<li>将 IP 头看成 16 位字组成的二进制 bit 序列，计算前将校验和字段置 0</li>
<li>对 16 位字进行求和运算：如最高位出现进位，则将进位加到结果的最低位</li>
<li>将最终求和结果取反，得到校验和</li>
</ol>
<p>这种检错能力不强，但算法简洁，运算速度快。</p>
<h3 id="地址字段"><a href="#地址字段" class="headerlink" title="地址字段"></a>地址字段</h3><p>包括<strong>源地址</strong>（<code>source address</code>）和<strong>目的地址</strong>（<code>destination address</code>），长度均为 32 位，是 IP 头最简单的部分，在分组整个传输过程中保持不变。</p>
<h3 id="分组头选项-options"><a href="#分组头选项-options" class="headerlink" title="分组头选项 options"></a>分组头选项 <code>options</code></h3><p>设置选项的主要目的是用于控制和测试。<code>options</code> 最大长度为 40 字节；如果用户使用的选项长度不是 4 字节的整数倍，则需要添加 <code>padding</code> 补足。</p>
<p>注意：</p>
<ul>
<li>用户可以不使用 options，但作为 IP 分组头的组成部分，所有实现 IP 的硬件或软件都应能处理它</li>
</ul>
<p><code>options</code> 字段的组成如下：</p>
<ol>
<li><strong>选项码</strong>：用于确定该选项的具体功能，如源路由、记录路由、时间戳等；</li>
<li><strong>长度</strong>：表示选项数据的大小；</li>
<li>选项<strong>数据</strong></li>
</ol>
<p>这里说一下什么是<strong>源路由</strong>：</p>
<p>源路由指的是由发送分组的源主机<strong>指定的传输路径</strong>，用来区别由路由器通过路由选择算法确定的路径。<br>主要用于测试某网络的吞吐量，绕开出错的网络；也用于保证分组传输安全的应用。</p>
<p>源路由分两种：</p>
<p>一是<strong>严格源路由</strong>（Strict Source Route, <strong><code>SSR</code></strong>），其规定了在分组要经过的路径上，相邻路由器间不能插入其他路由器，且经过的路由器顺序不能改变。</p>
<p>SSR 主要用于网络测试，例如：</p>
<ul>
<li>将第一个测试点主机地址设定为分组头中的目的地址</li>
<li>将最后一个测试点主机地址设定为路径数据字段中的最后一个指定地址</li>
</ul>
<p>二是<strong>松散源路由</strong>（Loose Source Route, <strong><code>LSR</code></strong>），其规定分组一定要经过的路由器，但不是一条完整的传输路径，中途可经过其他路由器。</p>
<p>再说一下<strong>记录路由</strong>（Record Route）：它将分组经过的每个路由器 IP 地址记录下来，常用于网络测试，如网管要了解发送到某个主机的分组经过哪些路由器才能到达目的主机；以及互联网中的路由器配置是否正确。</p>
<p><code>options</code> 里的时间戳（Timestamp, TS）取的是格林尼治时间（毫秒）</p>
<ul>
<li>记录分组经过每个路由器时的本地时间</li>
<li>可利用其追踪路由器运行状态，分析网络吞吐率、拥塞情况与负荷情况等</li>
</ul>
<h2 id="IP-分组分片及组装"><a href="#IP-分组分片及组装" class="headerlink" title="IP 分组分片及组装"></a>IP 分组分片及组装</h2><h3 id="向下"><a href="#向下" class="headerlink" title="向下"></a>向下</h3><p>往下结合<strong>数据链路层协议</strong>来看，IP 分组作为网络层数据，必须通过数据链路层，封装成<strong>帧</strong>后再通过物理层传输。</p>
<p>帧的数据字段最大长度称为最大传输单元（Maximum Transfer Unit, <code>MTU</code>），不同网络的 MTU 长度会不同。  </p>
<p>IP 分组最大长度（65535 Bytes）一般都<strong>大于</strong>实际使用网络的 MTU（Ethernet 为 1500 Bytes），所以 IP 分组通常需被分成若干较小的<strong>片</strong>（<code>fragment</code>）传输；<br>在传输过程中，路由器根据下一跳 MTU 的大小，决定该分组在转发前是否需要分片。</p>
<h3 id="向上"><a href="#向上" class="headerlink" title="向上"></a>向上</h3><p>往上结合<strong>传输层</strong>协议来看，传输层数据包必须在网络层封装成 IP 分组，再传送到数据链路层组成帧。</p>
<p>在封装 IP 分组时，传输层数据包加上 IP 分组头的总长度必须小于 65535 字节；<br>因此在设计时，应该从应用层和传输层开始就控制报文长度，避免被分成多个分组的问题。</p>
<p>分片的基本方法：</p>
<ol>
<li>首先确定片长度；</li>
<li>随后，将原始 IP 分组包括分组头分成第一片；</li>
</ol>
<p>如果剩下的数据仍然超过片长度，则需要进行下一次分片，直至剩下的数据小于 MTU 为止。</p>
<p><img src="/2023/11/17/ipv4/ip_fragment.png" alt></p>
<p>与分片相关的字段：标识（<code>identification</code>）、标志（<code>flags</code>）与片偏移（<code>fragment offset</code>）</p>
<h1 id="IPv4-地址及分段"><a href="#IPv4-地址及分段" class="headerlink" title="IPv4 地址及分段"></a>IPv4 地址及分段</h1><p>IPv4 地址类型经过多年的发展，主要分成以下几个阶段：</p>
<h2 id="第一阶段：标准分类的-IP-地址"><a href="#第一阶段：标准分类的-IP-地址" class="headerlink" title="第一阶段：标准分类的 IP 地址"></a>第一阶段：标准分类的 IP 地址</h2><ul>
<li>地址有效利用率低</li>
</ul>
<p>在这个阶段中，IP 地址有三种分配方法：</p>
<ol>
<li>为每一个网络接口分配一个 IP 地址：IP 地址与 MAC 地址一一对应，且在 Internet 中是唯一的；</li>
<li>对于多归属主机（又称多穴主机）来说，一台主机或路由器可以通过多个 Ethernet 网卡，即多个接口分别连接到多个网络；因此也可以为多归属主机的每一个网络接口分配相应的 IP 地址；</li>
<li>也可以为一个网络接口分配多个 IP 地址，进行多网化 / 二级地址管理。</li>
</ol>
<p>也就是说：</p>
<ol>
<li>连接到 Internet 每一个主机（计算机或路由器）至少有一个 IP 地址；</li>
<li>IP 地址是分配给网络接口的；</li>
<li>多归属主机可以有多个 IP 地址；</li>
<li>一个网络接口也可以分配多个 IP 地址；</li>
<li>网桥、Ethernet 交换机、集线器 Hub 等属于数据链路层设备，不属于网络层设备，因此它们的标识使用 MAC 地址，<strong>不分配 IP 地址</strong>。</li>
</ol>
<p>分配好之后，怎么读这个 IP？</p>
<p><img src="/2023/11/17/ipv4/decimal_ip_1.png" alt></p>
<p>如上图所示，<strong>点分十进制</strong>（dotted decimal，即 x.x.x.x）是很好的表示方法：</p>
<ul>
<li>每个 x 长为 8 位，取值范围 0 - 255</li>
<li>通过回顾<a href="#地址字段">上文</a>可知：IPv4 地址总长度为 32 位，一般分两段：<ul>
<li>前半段的<strong>网络号</strong>为 <code>netID</code></li>
<li>后半段的<strong>主机号</strong>为 <code>hostID</code></li>
</ul>
</li>
</ul>
<p>我们常说的 <strong>IP 寻址</strong>，就是先找到 IP 所属的网络（网络号），再从 IP 中找到主机在网络的位置（主机号）。</p>
<p>在这个阶段里面，IPv4 协议将标准 IP 地址分为 5 大类，每一类的网络号和主机号标识都有所不同：</p>
<p><br></p>
<h3 id="A-类地址"><a href="#A-类地址" class="headerlink" title="A 类地址"></a><strong>A 类地址</strong></h3><p>首位为 0，往后 7 位为网络号，一共可分为大小相同的 128（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.53ex" height="2.088ex" role="img" focusable="false" viewbox="0 -841 3770.1 923"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container>）块，每块的 netID 不同：</p>
<ul>
<li>第 1 块：0.0.0.0 - 0.255.255.255（netID = 0，保留做特殊用途）</li>
<li>第 2 块：1.0.0.0 - 1.255.255.255（netID = 1）</li>
<li>…</li>
<li>第 11 块：10.0.0.0 - 10.255.255.255（netID = 10，一般用于专用 IP 地址）</li>
<li>…</li>
<li>第 128 块（最后一块）：127.0.0.0 - 127.255.255.255（netID = 127，保留做特殊用途）</li>
</ul>
<p>因此地址覆盖范围为 <code>0.0.0.0</code> 至 <code>127.255.255.255</code>。</p>
<p>除开特殊用途（0，127）和专用网络号（10）的三个，因此能得到 A 类地址的机构只有 125（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.016ex" height="2.088ex" role="img" focusable="false" viewbox="0 -841 2659 923"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g></g><g data-mml-node="mo" transform="translate(1158.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2159,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></svg></mjx-container>）个，每个 A 类网络可分配的 hostID 有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="20.895ex" height="2.343ex" role="img" focusable="false" viewbox="0 -841.7 9235.4 1035.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(3290.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(4346.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(5346.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(5790.8,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(500,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"/></g><g data-mml-node="mo" transform="translate(7290.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(7735.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container> 个。</p>
<h3 id="B-类地址"><a href="#B-类地址" class="headerlink" title="B 类地址"></a><strong>B 类地址</strong></h3><p>前两位为 <code>10</code>，往后 14 位为网络号，可分配的网络号有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="12.598ex" height="2.343ex" role="img" focusable="false" viewbox="0 -841.7 5568.3 1035.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2623.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(3623.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(4068.3,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container> 个；</p>
<p>因此地址覆盖范围为 <code>128.0.0.0</code> 至 <code>191.255.255.255</code>。</p>
<p>每个网络号（IP 地址）有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="16.495ex" height="2.326ex" role="img" focusable="false" viewbox="0 -833.9 7290.8 1027.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(3290.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(4346.1,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(5346.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(5790.8,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container> 个主机号（主机号为全 0 和 全 1 的两个地址保留）。</p>
<h3 id="C-类地址"><a href="#C-类地址" class="headerlink" title="C 类地址"></a><strong>C 类地址</strong></h3><p>前三位为 <code>110</code>，往后 21 位可分配网络号共 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="15.867ex" height="2.326ex" role="img" focusable="false" viewbox="0 -833.9 7013 1027.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2623.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(3123.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(3568.3,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(500,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"/></g><g data-mml-node="mo" transform="translate(5068.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(5513,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container> 个；</p>
<p>因此地址覆盖范围为 <code>192.0.0.0</code> 至 <code>223.255.255.255</code>。</p>
<p>每个网络号有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="12.427ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 5492.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/></g></g><g data-mml-node="mo" transform="translate(1158.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2159,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(2936.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3992.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container> 个主机号（主机号为全 0 和 全 1 的两个地址保留）。</p>
<h3 id="D-类地址"><a href="#D-类地址" class="headerlink" title="D 类地址"></a>D 类地址</h3><p>地址覆盖范围为 <code>224.0.0.0</code> 至 <code>239.255.255.255</code>。</p>
<p>不标识网络，仅用于特殊用途，如多播（multicasting）地址。</p>
<h3 id="E-类地址"><a href="#E-类地址" class="headerlink" title="E 类地址"></a>E 类地址</h3><p>暂时保留，地址覆盖范围为 <code>240.0.0.0</code> 至 <code>247.255.255.255</code>。</p>
<p><img src="/2023/11/17/ipv4/decimal_ip_2.png" alt></p>
<p><br></p>
<p>为什么“主机号为全 0 和 全 1 的两个地址保留”？因为这两种是<strong>特殊的地址形式</strong>，而且特殊的形式不止两种。</p>
<h3 id="网络特定主机地址"><a href="#网络特定主机地址" class="headerlink" title="网络特定主机地址"></a>网络特定主机地址</h3><p>这种地址的网络号为全 0 （如 0.0.0.25），分布在 A 类、B 类和 C 类地址中。</p>
<p>路由器接收到 IP 分组后，不会向外转发该分组，而是<strong>直接交付</strong>给本网络中指定主机；<br>对应上例为交付至主机号为 25 的主机。</p>
<h3 id="受限广播（limited-broadcasting）地址"><a href="#受限广播（limited-broadcasting）地址" class="headerlink" title="受限广播（limited broadcasting）地址"></a>受限广播（limited broadcasting）地址</h3><p>地址唯一，为网络号 + 主机号为全 1 的 IP 地址（255.255.255.255），用来将一个分组以广播形式发送给本网络中的所有主机。</p>
<p>路由器接收到该地址的分组时，不会向外转发该分组，而是在网络内部以广播方式发送给全部主机。</p>
<h3 id="直接广播（direct-broadcasting）地址"><a href="#直接广播（direct-broadcasting）地址" class="headerlink" title="直接广播（direct broadcasting）地址"></a>直接广播（direct broadcasting）地址</h3><p>主机号全为 1，包括：</p>
<ul>
<li>A 类：<code>x.255.255.255</code></li>
<li>B 类：<code>x.x.255.255</code></li>
<li>C 类：<code>x.x.x.255</code></li>
</ul>
<p>如 191.1.255.255。</p>
<p>路由器将接收到的分组以广播形式发送给特定网络（对应上例为 191.1.0.0）内的所有主机。</p>
<h3 id="回送地址（lookback-address）"><a href="#回送地址（lookback-address）" class="headerlink" title="回送地址（lookback address）"></a>回送地址（lookback address）</h3><p>为 A 类地址中的 <code>127.0.0.0</code>（保留地址），用于网络软件测试和本地进程间通信。</p>
<p>TCP/IP 规定：网络号为 127 的分组不能出现在任何网络中，主机和路由器不能为该地址广播任何任何寻址信息。</p>
<p>应用：<code>Ping</code> 应用程序可发送一个分组至将回送地址，以测试本地进程之间的通信状况，能否接受或发送一个分组。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NetID</th>
<th>HostID</th>
<th>作为 IP 分组源地址</th>
<th>作为 IP 分组目的地址</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全 0</td>
<td>全 0</td>
<td>可</td>
<td>否</td>
<td>在本网范围内表示主机；在路由表中用于表示默认路由（相当于表示整个 Internet 网络）</td>
</tr>
<tr>
<td style="text-align:center">全 0</td>
<td>特定值</td>
<td>否</td>
<td>可</td>
<td>表示本网内某个特定主机</td>
</tr>
<tr>
<td style="text-align:center">全 1</td>
<td>全 1</td>
<td>否</td>
<td>可</td>
<td>本网广播地址（路由器不转发）</td>
</tr>
<tr>
<td style="text-align:center">特定值</td>
<td>全 0</td>
<td>否</td>
<td>否</td>
<td>网络地址，表示一个网络</td>
</tr>
<tr>
<td style="text-align:center">特定值</td>
<td>全 1</td>
<td>否</td>
<td>可</td>
<td>直接广播地址，对特定网络上所有主机进行广播</td>
</tr>
<tr>
<td style="text-align:center">127</td>
<td>非全 0 或非全 1 的任何数</td>
<td>可</td>
<td>可</td>
<td>用于本地软件回送测试，称为回送地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="按照用途分类"><a href="#按照用途分类" class="headerlink" title="按照用途分类"></a>按照用途分类</h3><p>分两类：<strong>公有 IP 地址</strong>和<strong>私有 IP 地址</strong>。</p>
<p>公有 IP（全局 IP）地址，指在 Internet 全球唯一的地址。</p>
<p>对于私有 IP（专用 IP）地址，RFC1918 提出：A、B、C <strong>各留一部分地址</strong>作为专用 IP 地址，用于不接入 Internet 的内部网络；<br>当内网主机向 Internet 发送分组时，需要将专用地址转换为全局 IP 地址。</p>
<p>专用 IP 地址段如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>网络</th>
<th>网络号</th>
<th>网络总数</th>
<th>IP 总数</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td><code>10.*</code></td>
<td>1</td>
<td>16,777,214</td>
</tr>
<tr>
<td>B</td>
<td><code>172.16.*</code> - <code>172.31.*</code></td>
<td>16</td>
<td>65,536 * 16</td>
</tr>
<tr>
<td>C</td>
<td><code>192.168.0.*</code> - <code>192.168.255.*</code></td>
<td>256</td>
<td>256 * 256</td>
</tr>
</tbody>
</table>
</div>
<p>注意：</p>
<ul>
<li>如 IP 分组使用了（例：）<code>10.1.0.1</code>、<code>172.16.1.12</code> 或 <code>192.168.0.2</code>：路由器会<strong>认为这是一个内部网络</strong>使用的 IP 地址，不向 Internet 转发该分组；</li>
<li>如组织组建专用内部网络，不准备连接到 Internet；或转发分组到 Internet 时希望使用网络地址转换（NAT）：该组织可使用专用 IP 地址；</li>
<li>上述三个范围内的地址不会在 Internet 上被分配，因此可不必向 ISP 或注册中心申请，就可以在公司或者企业内部自由使用。</li>
</ul>
<h2 id="第二阶段：划分子网的三级地址结构"><a href="#第二阶段：划分子网的三级地址结构" class="headerlink" title="第二阶段：划分子网的三级地址结构"></a>第二阶段：划分子网的三级地址结构</h2><p>1991 年提出子网（<code>subnet</code>）和掩码（<code>mask</code>）概念后，在标准分类的 IP 地址基础上，增加了“子网号”的第三级地址结构。</p>
<h3 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h3><p>子网（subnet）的基本思想是：<strong>将大网络划分成若干较小网络</strong></p>
<ul>
<li>借用主机号的一部分作为子网的子网号，划分出更多的子网 IP 地址</li>
<li>对外部路由器寻址没有影响</li>
</ul>
<p>由此，网络结构从 “网络号 - 主机号” 演变成 “网络号 - 子网号 - 主机号”：</p>
<p><img src="/2023/11/17/ipv4/subid.png" alt></p>
<p>划分子网要点：</p>
<ol>
<li>三级层次：<code>netID</code> - <code>subnetID</code> - <code>hostID</code>；</li>
<li>在同一个子网中，所有主机必须使用相同的网络号与子网号(<code>netID</code> - <code>subnetID</code>)；</li>
<li>子网的概念可用于 A、B、C 类地址；</li>
<li>子网间距离必须很近：<ul>
<li>为了提高路由器工作效率</li>
<li>分配子网为组织内部事务：不需向 ICANN 申请，也不需改变任何外部路由器的数据库</li>
</ul>
</li>
</ol>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网掩码（subnet mask）又称掩码（mask）、子网屏蔽码，为了从 IP 地址中提取子网号而提出。</p>
<p>我们知道标准地址的掩码如下：</p>
<ul>
<li>标准 A 类：255.0.0.0（8 位）</li>
<li>标准 B 类：255.255.0.0（16 位）</li>
<li>标准 C 类：255.255.255.0（24 位）</li>
</ul>
<p>在包括子网号的三层结构的 IP 地址中，不能很直观地判断网络号和主机号，提取子网号比较困难。</p>
<p>比如，我们挑取一个 B 类地址，需要划分出 64 个子网</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.398ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3270.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/></g></g></g></svg></mjx-container>，即借用原主机号的前 6 位作为子网号</li>
<li>原有的 16 位网络号不变，则在原主机号中取 6 位加入网络号，主机号减作 10 位</li>
</ul>
<p>那么，B 类地址 190.1.2.26 就有两种表示方法</p>
<ol>
<li><code>IP: 190.1.2.26 mask: 255.255.252.0</code></li>
<li><code>190.1.2.26/22</code>（22 即网络号总和 16 + 6）</li>
</ol>
<p>子网规划与地址空间划分的注意点：</p>
<ul>
<li>子网地址与主机号<strong>不能使用全 0 或全 1</strong></li>
<li>划分字网通常以满足基本要求，并考虑留有一定余量为原则</li>
</ul>
<h3 id="可变长度子网掩码（VLSM）"><a href="#可变长度子网掩码（VLSM）" class="headerlink" title="可变长度子网掩码（VLSM）"></a>可变长度子网掩码（VLSM）</h3><p>Variable Length Subnet Masking，意为划分子网时考虑不同的子网号长度。</p>
<p>比如，给分别有 100、50、50 人的部门分别组建子网，某 C 类网络主机为 <code>202.60.31.0</code>：</p>
<ul>
<li>则 100 个人的部门，设定掩码为 /25（255.255.255.128），有 126 个可用地址</li>
<li>50 人的部门掩码为 /26 （255.255.255.192），有 61 个可用地址</li>
</ul>
<p>划分的关键是要找到合适的可变长度子网掩码。</p>
<h2 id="第三阶段：构成超网的无类别域间路由（CIDR）"><a href="#第三阶段：构成超网的无类别域间路由（CIDR）" class="headerlink" title="第三阶段：构成超网的无类别域间路由（CIDR）"></a>第三阶段：构成超网的无类别域间路由（<code>CIDR</code>）</h2><p>Classless Inter-Domain Routing，于 1993 年提出的 Internet 的建议标准协议。其<strong>不按照标准地址分类规则</strong>，将剩余的 IP 地址按照可变大小的地址块来分配，同时涉及 IP 寻址与路由选择。</p>
<p>与传统标准的分类 IP 地址与子网地址划分的方式相比，CIDR 是以<strong>任意二进制倍数</strong>的大小（可变大小）来分配地址的。<br>正因 CIDR 不采用传统的标准 IP 地址分类方法，因此无法从地址本身判定网络号的长度，故 CIDR 地址采用“斜线记法”：<strong>&lt;网络前缀&gt;/&lt;主机号&gt;</strong>：</p>
<p>例：从 CIDR 方法给出的一个地址块中一个 IP 地址是 200.16.23.1/20，表示在该 IP 地址中前 20 位是网络前缀（网络号）；<br>则后 12 位是主机号，共 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.461ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 4623.7 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2623.7,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(1000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1500,0)"/></g></g></g></svg></mjx-container> 个主机地址；这样网络前缀相同的连续 IP 地址组成一个 “CIDR 地址块”。<br>即：<code>200.16.23.1/20</code> = <strong>11001000 00010000 0001</strong>0111 00000001</p>
<p>另：一个 CIDR <strong>地址块</strong>由块起始地址与前缀表示</p>
<ul>
<li>起始地址：地址块中地址数值最小的一个（主机号全 0）</li>
<li>上述地址块中起始地址为 200.16.16.0，前缀为 20</li>
<li>最大地址：主机号为全 1 </li>
</ul>
<p>⚠️ 与标准分类 IP 地址相同的是，主机号全 0 和主机号全 1 不分配主机。即上述地址块可分配的 IP 地址范围是：200.16.16.1/20 ~ 200.16.31.254/20。</p>
<h2 id="第四阶段：网络地址转换（NAT）技术"><a href="#第四阶段：网络地址转换（NAT）技术" class="headerlink" title="第四阶段：网络地址转换（NAT）技术"></a>第四阶段：网络地址转换（<code>NAT</code>）技术</h2><p>NAT 全称 Network Address Translation，于 1996 年提出。</p>
<p>支持 IP 地址重用，能够短时期内快速缓解地址短缺的问题，但并没有深层次解决 IPv4 地址严重不足的问题。</p>
<h1 id="演进：IPv6"><a href="#演进：IPv6" class="headerlink" title="演进：IPv6"></a>演进：IPv6</h1><p>早期设计的 IP 分组结构、IPv4 地址、网络层服务质量 QoS 都不能满足 Internet 大规模发展的要求，因为 IPv4 协议中对于分组结构与分组头结构的规定是不变的。</p>
<p>因此，提出变化的部分包括三个方面：</p>
<ol>
<li>IP 地址处理方法</li>
<li>分组交付的路由算法与路由选择协议</li>
<li>如何提高协议的可靠性、服务质量与安全性</li>
</ol>
<p>2011 年 2 月 3 日，最后 5 块 IPv4 地址被分配完毕，因此需要新的 IP 协议（IPv6）。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2024/03/09/transport-layer/</url>
    <content><![CDATA[<p>传输层负责在会话进程之间建立和维护端到端的连接，实现网络环境中分布式进程通信。</p>
<span id="more"></span>
<h1 id="传输层与传输层协议"><a href="#传输层与传输层协议" class="headerlink" title="传输层与传输层协议"></a>传输层与传输层协议</h1><p>计算机网络的本质，就是要<strong>实现分布在不同地理位置的主机之间的进程（应用程序）通信，并以此为基础，实现应用层的各种网络服务功能</strong>。</p>
<p><img src="/2024/03/09/transport-layer/transport-layer.png" alt></p>
<p>而 OSI（或者是 TCP/IP）协议模型中的<strong>传输层</strong>实现了<strong>分布式</strong>进程通信，是实现各种网络应用的基础：</p>
<ul>
<li>传输层利用网络层所提供的服务（IP 分组数据传输 + “点 - 点”链路传输路径），在源主机的应用进程与目的主机的应用进程之间建立“端 - 端”连接，实现分布式进程通信；</li>
<li>同时传输层会对 IP 分组丢失、线路故障进行检测；并采取相应的差错控制措施，满足分布式进程通信对服务质量（QoS）的要求；</li>
<li>另外，传输层能够屏蔽传输网实现技术的差异性，弥补网络层提供服务的不足。</li>
</ul>
<h2 id="传输实体"><a href="#传输实体" class="headerlink" title="传输实体"></a>传输实体</h2><p>传输层中实现传输层协议的实体如下：</p>
<p><img src="/2024/03/09/transport-layer/transport-entity.png" alt></p>
<p>图中的<strong>传输协议数据单元</strong>（Transport Protocol Data Unit, <strong>TPDU</strong>），就是传输层之间（不同传输实体）所传输的报文：</p>
<p><img src="/2024/03/09/transport-layer/tpdu.jpg" alt></p>
<p>如上：</p>
<ul>
<li>TPDU 的有效载荷（<strong>payload</strong>）是来自于应用层的数据；</li>
<li>传输层在 TPDU payload 前加上 TPDU 头，便组成了 TPDU；</li>
<li>TPDU 在往下传递过程中，加上 IP 分组头组成 IP 分组，加上帧头、帧尾组成帧，等</li>
</ul>
<p><img src="/2024/03/09/transport-layer/tpdu-transmit.gif" alt></p>
<p>传输层的协议一般有两个，也是最常用的两个：<strong>UDP</strong> 和 <strong>TCP</strong>。</p>
<p><br></p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP 全称 User Diagram Protocol，数据报协议。在 1980 年协议面世的时候，标准文件只有 3 页，这也说明它设计的主要原则，就是<strong>协议简洁，运行快捷</strong>。</p>
<p>UDP 协议只提供端口形式的传输层寻址与一种可选的校验和功能，主要特点主打一个<strong>尽力而为</strong>。</p>
<p>首先，UDP 是面向报文（Segment）的传输层协议：</p>
<p><img src="/2024/03/09/transport-layer/udp-structure.png" alt></p>
<p>对于应用层提交过来的报文，UDP 协议会添加 UDP 报头构成 TPDU，再向下提交至 IP 层。</p>
<p>要注意的是，UDP 协议对应用层提交过来的报文<strong>既不合并，也不拆分</strong>：而是保留原报文的长度和格式，接收端将发送端提交传送的报文<strong>原封不动</strong>地提交至接收端应用程序。</p>
<p><img src="/2024/03/09/transport-layer/udp-transmit.png" alt></p>
<p>⚠️ 注：使用 UDP 协议时应选择合适长度的报文，报文太短会导致协议开销相对较大；太长，则 UDP 协议向 IP 层提交的 TPDU 可能在 IP 层被分片，降低协议效率。</p>
<p>其次，UDP 是无连接，不可靠的传输层协议：</p>
<ol>
<li>通信双方不需要提前建立好连接，这减少了协议开销与传输延迟；</li>
<li>作为补偿机制，UDP 为报文提供了可选的<strong>校验总和</strong>，用以检验数据完整性，而且为数据包的传输提供端口号</li>
</ol>
<p>UDP 熟知的端口号如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口号</th>
<th>服务进程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>53</td>
<td>DNS</td>
<td>域名服务</td>
</tr>
<tr>
<td>67/68</td>
<td>DHCP</td>
<td>动态主机配置协议</td>
</tr>
<tr>
<td>69</td>
<td>TFTP</td>
<td>简单文件传输协议</td>
</tr>
<tr>
<td>161/162</td>
<td>SNMP</td>
<td>简单网络管理协议</td>
</tr>
<tr>
<td>520</td>
<td>RIP</td>
<td>路由信息协议</td>
</tr>
</tbody>
</table>
</div>
<p>UDP 服务与端口号映射表会<strong>定期</strong>在 RFC768 等文件中公布，并可在大多数 UNIX 主机的 <code>/etc/services</code> 文件中得到。</p>
<p>注：与 DNS 不同的是，DHCP、SNMP 的客户端和服务器端在通信时都要使用熟知端口号。</p>
<p>不过除了可选的校验和，UDP 几乎没有其他任何可以保证数据传输可靠性的措施；也就是说，不一定能提供可靠的数据传输，也并不能保证数据准确无误地到达目的地。</p>
<p>如收到的分组校验出错，则<strong>丢弃该分组</strong>，既不确认，也不通知发送端和要求重传。</p>
<h2 id="UDP-头结构"><a href="#UDP-头结构" class="headerlink" title="UDP 头结构"></a>UDP 头结构</h2><p>UDP 的头长度固定为 8 个字节。结构如下：</p>
<p><img src="/2024/03/09/transport-layer/udp-header.png" alt></p>
<p><strong>源端口号</strong>（<strong>Source Port</strong>，16 位）：表示发送端进程端口号</p>
<p><strong>目的端口号</strong>（<strong>Destination Port</strong>，16 位）：表示接收端进程端口号</p>
<p>如源进程为客户端，则源端口号为 UDP 软件分配的临时端口号，目的端口号为服务器的熟知端口号。</p>
<p><strong>长度</strong>（<strong>Length</strong>，16 位）：定义了包括报头在内的用户数据报总长度</p>
<ul>
<li>最大为 65535 字节，最短为 8 字节（即 UDP 头自身长度）</li>
<li>实际数据长度最大为 65535 - 8 = 65527 字节</li>
</ul>
<p><strong>校验和</strong>（<strong>Checksum</strong>，16 位）用于检验整个用户数据报、UDP 报头与伪报头在传输中是否出现差错（效率优先），可选；如应用程序对通信效率要求高于可靠性，应用程序可选择不使用校验和。</p>
<p>校验和包括伪报头（pseudo header）、UDP 报头与数据。</p>
<p>伪报头包括以下内容：</p>
<ul>
<li>IP 分组头的源 IP 地址（16 位）</li>
<li>目的 IP 地址（16 位）</li>
<li>协议字段（8 位）：17，表示 UDP 报文（取 IP 分组头的一部分，其中填充域字段要补 0）</li>
<li>UDP 长度（16 位）</li>
</ul>
<p><img src="/2024/03/09/transport-layer/pseudo-header.png" alt></p>
<p>UDP 的长度不包括伪报头的长度；伪报头并不是 UDP 的真实头部，只是在计算时临时加上去起作用的，它既不向低层传输，也不向高层传送。</p>
<p>如果没有伪报头，那校验的对象只是 UDP 报文，也能判断 UDP 报文传输是否出错；但是如果 IP 分组头出错，那么分组就有可能会传送到错误的主机。因此在 UDP 校验和中习惯增加伪报头。</p>
<h2 id="适用的应用场景"><a href="#适用的应用场景" class="headerlink" title="适用的应用场景"></a>适用的应用场景</h2><ol>
<li>对数据交付实时性要求高，对数据交付可靠性要求相对较低<ul>
<li>对时间敏感的应用适用 UDP 协议：相比于等待响应，数据包丢失在某程度上是可以接受的；</li>
<li>适用于简单的响应协议，如 DNS 和 NTP</li>
</ul>
</li>
<li>视频播放应用<ul>
<li>用户关注的是视频流能尽快和不间断播放，丢失个别数据报文对视频节目的播放效果不会产生严重影响</li>
<li>采用 TCP 会因为重传个别丢失的报文而加大传输延迟，反而不利</li>
</ul>
</li>
<li>简短的交互式应用<ul>
<li>只需要进行简单的请求与应答报文的交互</li>
<li>可设置“定时器/重传机制”去处理由于 IP 数据分组丢失的问题，不需要确认/重传机制，提高工作效率</li>
</ul>
</li>
<li>多播和广播应用<ul>
<li>UDP 支持一对一、一对多和多对多的交互式通信，TCP 不支持</li>
<li>UDP 没有拥塞控制，在网络拥塞时不要求源主机降低报文发送速率，而只会丢弃个别的报文</li>
</ul>
</li>
</ol>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 全称 Transmission Control Protocol，传输控制协议。相比于 UDP，TCP 的特点如下：</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>1</strong>. TCP 是支持面向连接（Connection）的传输服务。</p>
<p>应用程序在使用 TCP 协议传送数据时，必须在源进程端口与目的进程端口之间建立一条 TCP <strong>传输连接</strong>，每个连接用双方<strong>端口号</strong>标识，为双方的<strong>一次</strong>进程通信提供服务。</p>
<p><strong>2</strong>. TCP 支持字节流（Stream）传输</p>
<p>流相当于管道：从一端放入什么，就可从另一端取出什么，以此来描述不丢失、不重复和不乱序的数据传输过程。</p>
<p>TCP 将应用程序提交的数据看成一连串、无结构的字节流；为支持字节流传输，发送端 &amp; 接收端都需要使用缓存，发送端使用缓存是因为要存储从应用程序送来的数据。</p>
<p>TCP 不可能为发送的每个写操作创建一个报文段，而是会选择将几个写操作组合成一个报文段，再提交至 IP 层。随后：</p>
<ul>
<li>IP 协议将数据封装成 IP 分组之后传送到接收端，接收端的 TCP 协议再将接收到的字节存储在接收缓存中；</li>
<li>应用程序随后使用读操作将接收数据从接收缓存中读出；</li>
<li>接收端应用程序数据字节的起始与终结位置需由应用程序自行确定</li>
</ul>
<p><strong>3</strong>. TCP 支持全双工通信，允许通信双方在任意时候发送数据。</p>
<p><strong>4</strong>. TCP 支持同时建立多个并发的 TCP 连接</p>
<p>有的时候根据应用程序需要，比如一个 Web 服务器必须要同时处理多个客户端的访问，那么 TCP 协议应该支持一个服务器与多个客户端同时建立多个 TCP 连接，也支持一个客户端与多个服务器同时建立多个 TCP 连接。</p>
<p><strong>5</strong>. TCP 支持<strong>可靠</strong>的传输服务</p>
<p>因为 TCP 建立在不可靠的网络层 IP 协议之上，因此想要保证可靠的传输服务，TCP 需要自行解决：</p>
<ul>
<li>使用<strong>确认机制</strong>对发送和接收的数据进行跟踪、确认和重传，检查数据是否安全和完整地到达；</li>
<li>提供<strong>拥塞控制</strong>功能，该功能是 TCP 的核心；</li>
<li>在相互进行通信的设备和服务之间保持一个虚拟连接；</li>
<li>TCP 为发送的每一个数据包提供一个序号，以此保证在接收<strong>无序、丢失</strong>或在数据传输期间<strong>被破坏</strong>的时候能完成数据恢复；</li>
<li>一旦 IP 或以下协议层出现传输错误，需要能不断进行重传</li>
</ul>
<p>这一点是 TCP 协议存在的目的。</p>
<p><img src="/2024/03/09/transport-layer/tcp-package-travel.png" alt></p>
<h2 id="TCP-头结构"><a href="#TCP-头结构" class="headerlink" title="TCP 头结构"></a>TCP 头结构</h2><p>TCP 头的长度为 20 - 60 字节（固定长度 20 字节，TCP 选项字段最长 40 字节）：</p>
<p><img src="/2024/03/09/transport-layer/tcp-header.png" alt></p>
<p><strong>源端口号</strong>（<strong>Source Port</strong>，16 位，2 字节）：表示发送某个报文段的应用进程的源端口号</p>
<p><strong>目的端口号</strong>（<strong>Destination Port</strong>，16 位，2 字节）：表示接收某个报文段的接收进程的目的端口号</p>
<p><strong>序号</strong>（<strong>Sequence Number</strong>, seq，32 位，4 字节）：TCP 给将要发送的字节流（Stream）中每个字节按照顺序编号，以此解决包乱序的问题</p>
<ul>
<li>范围从 0 至 4,284,967,295（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>）</li>
<li>在 TCP 建立连接时，通信双方需要使用随机数产生器产生一个初始序号（Initial Sequence Number, <strong>ISN</strong>）；</li>
<li>并且，双方各自随机产生初始序号：因此在一个 TCP 连接中，通信双方序号可以不同</li>
</ul>
<p><strong>确认号</strong>（<strong>Acknowledgment Number</strong>, ack，32 位，4 字节）</p>
<ul>
<li>表示一个进程已经正确接收到序号为 N 的字节，要求发送端接下来应该发送序号为 N+1 的字节</li>
<li>如主机 B 接收到主机 A 序号为 500 的字节，则 B 发送至 A 的确认号应该为 501</li>
<li>确认号发送时会捎带上确认方法</li>
</ul>
<p><strong>报头长度</strong>（<strong>Offset</strong>，4 位）：TCP 报头长度以 4 字节为一个单位计算，即该字段的值为 5（5 <em> 4 = 20, <code>0101</code>） 至 15（15 </em> 4 = 60, <code>1111</code>）之间</p>
<p><strong>保留字段</strong>（<strong>Reserved</strong>，6 位）</p>
<p><strong>控制字段</strong>（TCP Flags）</p>
<p>用于 TCP 的连接建立和终止、流量控制，以及数据传输过程，使用时在同一时间可设置一位或多位。包括如下标记位：</p>
<ol>
<li><p><strong>紧急</strong>（<strong>Urgent</strong>, URG, <strong>U</strong>）位</p>
<ul>
<li>URG = 1：该报文优先级高，需插到报文段最前面，尽快发送</li>
<li>需要与紧急指针字段（Urgent Pointer）一起使用</li>
</ul>
</li>
<li><p><strong>确认</strong>（<strong>Acknowledge</strong>, <strong>ACK</strong>, A）位：TCP 规定，在 TCP 建立连接之后发送的所有报文段的 ACK 位都要置 1</p>
</li>
<li><p><strong>推送</strong>（Push, <strong>PSH</strong>）位：应用于交互式通信</p>
<ul>
<li>如果一端应用程序希望输入一个指令后能够立即得到响应，则应置 PSH 为 1</li>
<li>设置后会立即创建一个报文段发送给对方</li>
<li>对方接收到 PSH 为 1 的报文段后，会尽快提交至应用进程，请求尽快应答</li>
</ul>
</li>
<li><p><strong>复位</strong>（Reset, <strong>RST</strong>）位</p>
<ul>
<li>RST = 1时：因主机崩溃等原因造成 TCP 连接出错，需立即释放连接，然后重新连接</li>
<li>TCP 拒绝一个非法 TCP 报文或拒绝释放一个连接</li>
</ul>
</li>
<li><p><strong>同步</strong>（<strong>SYN</strong>）位</p>
<ul>
<li>在连接建立的时候用来同步序号</li>
<li>SYN = 1 &amp; ACK = 0：标记一个连接建立请求报文</li>
<li>SYN = 1 &amp; ACK = 1：标记同意建立连接的响应报文</li>
</ul>
</li>
<li><p><strong>终止</strong>（Final, <strong>FIN</strong>）</p>
<ul>
<li>用来释放一个 TCP 连接</li>
<li>FIN = 1：表示发送端的报文段发送完毕，请求释放 TCP 连接</li>
</ul>
</li>
</ol>
<p><strong>窗口</strong>（<strong>Window</strong>，16 位）：0 至 65535 (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>) 之间</p>
<ul>
<li>因为接收端的接收缓冲区存在限制，所以在接收下一个 TCP 报文段之前，接收端会通知发送端，这次最多可发送多少字节的报文段</li>
<li>发送端根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</li>
<li>同时，发送端会根据接收端通知的窗口值去动态调整自己的发送窗口值大小</li>
</ul>
<p><strong>校验和</strong>（<strong>Checksum</strong>）</p>
<ul>
<li>必填字段，且同样需要伪报头</li>
<li>协议字段值为 6</li>
</ul>
<p><strong>紧急指针</strong>（<strong>Urgent Pointer</strong>，16 位）</p>
<ul>
<li>只有当紧急标志 URG = 1 时才有效；此时报文段中包括紧急数据</li>
<li>TCP 协议软件要在优先处理完紧急数据之后才能恢复正常工作</li>
</ul>
<p><strong>选项字段</strong>（<strong>Options</strong>），包括：</p>
<ul>
<li>单字节选项<ul>
<li>0: 选项结束（Ends of Options List）</li>
<li>1: 无操作（No Operation, NOP, Pad）</li>
</ul>
</li>
<li>多字节选项<ul>
<li>2: 最大报文段长度（Maximum Segment Size, MSS）：规定 TCP 报文数据的最大值，不包括报头长度</li>
<li>3: 窗口扩大因子（Window Scale）</li>
<li>8: 时间戳（Timestamp）</li>
</ul>
</li>
</ul>
<p>注：MSS 的值与每次传输的窗口大小无关</p>
<ul>
<li>窗口字段值指的是接收端通知发送端下一次可以连续传输的字节数</li>
<li>MSS 规定的是一个 TCP segment 最多能放的数据的字节数</li>
</ul>
<p>MSS 值的选择应考虑下列因素：</p>
<ol>
<li>协议开销<ul>
<li>例：报头和 MSS 值均为 40 字节时 -&gt; 报文段 50% 用来传输数据</li>
<li>MSS 值太小会增加协议开销</li>
</ul>
</li>
<li>IP 分片<ul>
<li>MSS 值选得太大：受到 IP 分组长度的限制，较长报文段在 IP 层会被分片传输 -&gt; 增加网络层开销和传输出错概率</li>
</ul>
</li>
<li>发送和接收缓冲区的限制：直接影响到发送和接收缓冲区设置的大小和使用效率</li>
</ol>
<p>MSS 的默认值：536 字节</p>
<ul>
<li>对于某些应用未必适用：在建立 TCP 连接时使用 SYN 报文中最大段长度选项来协商</li>
<li>TCP 允许双方选择使用不同的 MSS 值</li>
</ul>
<h2 id="TCP-连接建立和释放：三次握手与四次挥手"><a href="#TCP-连接建立和释放：三次握手与四次挥手" class="headerlink" title="TCP 连接建立和释放：三次握手与四次挥手"></a>TCP 连接建立和释放：三次握手与四次挥手</h2><p><img src="/2024/03/09/transport-layer/3-shake-hands.png" alt></p>
<p>连接建立的过程俗称“<strong>三次握手</strong>”：</p>
<ol>
<li>在开始连接之前，客户端的 TCP 进程处于 <code>CLOSED</code>（关闭）状态；</li>
<li>开始连接：客户端调用 <code>connect()</code> 准备发起 TCP 连接，进入 <code>SYN_SENT</code>（准备发送）状态；<ul>
<li>服务端 TCP 进程需为 <code>LISTEN</code>（收听）状态；</li>
<li>客户端发送 <strong>SYN = 1</strong> 的<strong>连接建立请求报文</strong>到服务端；</li>
<li>连接建立请求报文不携带数据字段，这次传输的报文序号 <code>seq = x</code>；</li>
<li>x 值随机产生，但不能为 0：避免因 TCP 连接非正常断开而可能引起的混乱</li>
</ul>
</li>
<li>如果连接突然中断：可能有一两个进程同时等待双方确认应答<ol>
<li>此时有一个新连接的序号也从 0 开始；</li>
<li>则接收进程有可能认为是对方重传的报文：可能造成连接错误</li>
</ol>
</li>
<li>服务端收到连接建立请求报文后：<ol>
<li>如果同意建立连接，则向客户端返回<strong>连接建立请求确认报文</strong>；</li>
<li>报文的标识位 SYN = 1, ACK = 1；</li>
<li>不携带数据字段，序号 <code>seq = y</code>；</li>
<li>报文的确认号 <code>ack = x + 1</code>，意为对上一个连接建立请求报文序号 <code>seq = x</code> 的确认</li>
</ol>
</li>
<li>服务器端从 LISTEN 进入 <code>SYN_RCVD</code>（准备接收）状态</li>
<li>客户端收到服务端的连接建立请求确认报文，再向服务端发送又一个<strong>连接建立请求确认报文</strong>：<ol>
<li>报文标识位 ACK = 1；</li>
<li>不携带数据字段，序号 <code>seq = x + 1</code>，意为承接客户端发送到同一服务端的上一报文的序号，即之前的连接建立请求报文；且响应上一个连接建立请求报文的确认号 <code>ack = x + 1</code>；</li>
<li>报文确认号 <code>ack = y + 1</code>，为对前一个连接建立请求确认报文序号 <code>seq = y</code> 的确认</li>
</ol>
</li>
<li>客户端发出该确认报文后进入 <code>ESTABLISHED</code>（连接建立）状态</li>
<li>服务器端接收到该报文之后也进入 <code>ESTABLISHED</code> 状态</li>
</ol>
<p>总的来说，全过程相当于试探一下对方是否遵循 TCP/IP 协议，协商完成之后就可以进行通信了。</p>
<p><strong>报文传输</strong></p>
<p>TCP 传输连接建立后，客户端便可与服务端进行全双工字节流传输。</p>
<p>为保证 TCP 工作正常、有序进行，TCP 会为某一次会话设置保持计时器（keep timer），防止 TCP 连接处于长时间空闲状态。</p>
<ul>
<li>如果服务端接收到了客户端的报文，服务端则将保持计时器复位；</li>
<li>如果服务端超过了计时器设定的时间没有收到客户端信息，则发送探测报文；</li>
<li>如发送了 10 个探测报文（每个相隔 75 秒）还没有响应，服务端会认为客户端故障，从而终止连接。</li>
</ul>
<p>连接释放的过程俗称“<strong>四次挥手</strong>”，客户端和服务端都可以主动提出连接释放请求。</p>
<p>以客户端提出释放 TCP 连接的“四次挥手”为例：</p>
<ol>
<li>客户端调用 <code>close()</code> 执行“主动关闭”（active close），随后进入 <code>FIN-WAIT-1</code>（释放等待 - 1）状态：<ol>
<li>客户端会向服务端发送<strong>连接释放请求报文</strong>，并停止发送数据；</li>
<li>报文的标识位 FIN = 1, ACK = 1；</li>
<li>报文不携带数据字段,序号 <code>seq = u</code>（客户端发送的最后一个字节序号 + 1）</li>
</ol>
</li>
<li>服务端接收到连接释放请求报文后，执行“被动关闭”（passive close），进入 <code>CLOSE-WAIT</code>（等待关闭）状态：<ol>
<li>服务端向客户端响应<strong>连接释放请求确认报文</strong>，为对接收到第一个连接释放请求报文的确认；</li>
<li>报文序号 <code>seq = v</code>，为服务端发送的最后一个字节序号 + 1；</li>
<li>确认号 <code>ack = u + 1</code></li>
<li>⚠️ 此时客户端到服务端的 TCP 连接已经断开，但服务端到客户端的 TCP 连接依然保持连接，服务器可继续发送未发送的数据报文；此时为“<strong>半关闭</strong>（half-close）”状态</li>
</ol>
</li>
<li>客户端收到服务端的连接释放请求确认报文后，进入 <code>FIN-WAIT-2</code>（释放等待 - 2）状态</li>
<li>服务端将所有要发送的报文发送完毕后，向客户端发送<strong>连接释放请求报文</strong><ol>
<li>服务端进入 <code>LAST-ACK</code>（最终确认）状态，通知 TCP 可以释放连接；</li>
<li>报文的标识位 FIN = 1, ACK = 1；</li>
<li>报文序号假定为 seq = w（取决于从半关闭到最终确认状态之间，服务端是否发送过报文；如没有则 <code>seq = v</code>）；</li>
<li>确认号 <code>ack = u + 1</code></li>
</ol>
</li>
<li>此时客户端早无数据传输，因此服务端的确认号不变</li>
<li>服务端转回 <code>LISTEN</code> 或 <code>CLOSED</code> 状态</li>
<li>客户端收到服务端的连接释放请求报文后，向服务器端返回<strong>连接释放请求确认报文</strong><ol>
<li>报文的标识位 ACK = 1；</li>
<li>seq = u + 1, ack = w + 1；</li>
<li>随后：客户端进入 TIME-WAIT 状态</li>
</ol>
</li>
</ol>
<p>客户端进入 TIME-WAIT 状态的背景是：TCP 关闭一个连接时，并不认为该连接马上得到真正的关闭。</p>
<p>为了保证 TCP 连接释放过程能正常运行，协议还设置了时间等待计时器（TIME-WAIT timer）：</p>
<ul>
<li>此时再等待两个最长报文寿命（Maximum Segment Lifetime, MSL）后，客户端才进入 CLOSED 状态；</li>
<li>这种设计是为了确保服务端在最后阶段发送给客户端的数据，以及客户端发送给服务端的最后一个请求确认报文都能被正确接收，防止因个别报文传输错误导致连接释放失败。</li>
</ul>
<p>综上，TCP 每个阶段的状态图如下：</p>
<p><img src="/2024/03/09/transport-layer/tcp-state-diagram.jpg" alt></p>
<h2 id="TCP-协议滑动窗口与确认重传机制"><a href="#TCP-协议滑动窗口与确认重传机制" class="headerlink" title="TCP 协议滑动窗口与确认重传机制"></a>TCP 协议滑动窗口与确认重传机制</h2><p>TCP 协议的设计思想，是让应用进程传输给协议的数据作为一个字节流而存在，而不是从协议本身去限制应用层数据的长度。</p>
<p>也就是说，在数据交换的过程中，应用进程无需考虑发送数据的长度；数据交由 TCP 协议负责将字节分段打包，发送端利用已建立的 TCP 连接，将字节流传送到接收端的应用进程。</p>
<p>然而，传输层往下一层的网络层里面，IP 分组在传输过程中不可避免会出错；因此需要 TCP 协议提供差错控制、确认和重传功能，保证接收的字节流正确。</p>
<p>TCP 采用以字节为单位的<strong>滑动窗口协议</strong>（Sliding-Windows Protocol）来跟踪和记录字节流的发送、接收、确认与重传，实现差错控制：</p>
<ul>
<li>发送端对缓存设置发送窗口：窗口不为 0 即可发送报文段；</li>
<li>接收端设置接收窗口：窗口值由接收端决定，等于接收缓存可以继续接收的字节流大小；与接收缓存剩余空间大小和应用进程读取数据的速度有关</li>
</ul>
<p>TCP 不可能对每一个字节进行确认，而是将字节流分成段来传输，一个 TCP 报文段打包多个字节，并通过报头序号标识，通过确认号表示已被正确接收的字节。</p>
<p>以下为滑动窗口的示意图：</p>
<p><img src="/2024/03/09/transport-layer/sliding-window.png" alt></p>
<h3 id="传输字节流状态分类"><a href="#传输字节流状态分类" class="headerlink" title="传输字节流状态分类"></a>传输字节流状态分类</h3><p>上图给传输字节流的状态分成了四个阶段：</p>
<ul>
<li>第一类：已发送，且已得到确认的字节（图中 <code>#31</code> 字节及之前的数据）；</li>
<li>第二类：已发送，但并未得到确认的字节（<code>#32</code> - <code>#45</code> 字节）；</li>
<li>第三类：未发送，但接收端（接收缓冲区）准备接收的字节（<code>#46</code> - <code>#51</code> 字节）；</li>
<li>第四类：未发送，且接收端未准备接收的字节（<code>#51</code> 字节之后）</li>
</ul>
<h3 id="发送窗口与可用窗口"><a href="#发送窗口与可用窗口" class="headerlink" title="发送窗口与可用窗口"></a>发送窗口与可用窗口</h3><p>在滑动窗口的概念中，<strong>发送窗口</strong>决定发送端在每一次发送过程中能连续发送的字节数，<strong>可用窗口</strong>表示可随时发送的字节数。</p>
<ul>
<li>发送窗口大小等于第二类与第三类字节数之和，如上图，发送窗口大小为 14 + 6 = 20 字节；</li>
<li>可用窗口大小等于第三类字节数，如上图，可用窗口大小为 6 字节。</li>
</ul>
<p>可用窗口字节发送完毕之后，第三类字节会变成第二类字节：结合上图，即 <code>#32</code> - <code>#51</code> 为第二类。</p>
<h3 id="滑动发送窗口"><a href="#滑动发送窗口" class="headerlink" title="滑动发送窗口"></a>滑动发送窗口</h3><p>当已发送的字节得到确认之后，窗口便<strong>开始滑动</strong>：</p>
<ul>
<li>结合上图的例子来说，接收端发送 ACK 确认了 <code>#32</code> - <code>#36</code> 的字节，并保持发送窗口大小不变（20）；</li>
<li>确认后，窗口<strong>开始滑动</strong>，第一类字节序号滑动到 <code>#37</code> 之前；</li>
<li>以此类推，第二类字节为 <code>#37</code> - <code>#51</code>，第三类字节为 <code>#52</code> - <code>#57</code>，第四类字节为 <code>#57</code> 之后</li>
</ul>
<p>这套处理机制的特点是：</p>
<ul>
<li>TCP 使用发送和接收缓冲区，以及滑动窗口机制来控制 TCP 连接上的字节流传输</li>
<li>TCP 滑动窗口面向字节流，起到差错控制的作用</li>
<li>接收端可在任何时候发送确认，窗口大小可由接收端来根据需要增大或减小</li>
<li>发送窗口值可小于接收窗口值，但不能超过接收窗口值；发送端可根据自身需要决定</li>
</ul>
<h3 id="选择重传策略"><a href="#选择重传策略" class="headerlink" title="选择重传策略"></a>选择重传策略</h3><p>有的时候，TCP 传输会出现接收字节流序号不连续的情况。这时候的处理方法有两种：</p>
<p><strong>1</strong>. <strong>拉回</strong></p>
<p>比如，在丢失第 2 个报文段时，不管之后的报文段接收是否正确，都要求从第 2 个报文段开始，重传所有后面的报文段。</p>
<p>这样的处理效率低。</p>
<p><strong>2</strong>. <strong>选择重传方式</strong>（Selective ACK, <code>SACK</code>）</p>
<p>如果所有字节的序号都在接收窗口内，则首先完成接收窗口内字节接收，然后将丢失的字节序号通知发送端。</p>
<p>此时发送端只需要重传丢失的报文段，不需要重传已经接收的报文段。</p>
<p>选择重传方式需要定义一个重传计时器（Retransmission Timer），用以控制报文确认与等待重传的时间。</p>
<p>在此方式下，发送端 TCP 发送报文时候会将它的一个报文副本放入重传队列，同时启动一个重传计时器（如 400 ms），然后开始倒计时：</p>
<ul>
<li>计时到 0 之前收到确认：报文传输成功；</li>
<li>到 0 时仍未收到确认：传输失败，从重传队列中取出，准备重传</li>
</ul>
<p>话说回来，这个计时器，应该设置多久？</p>
<p><br></p>
<p>假设我们有一个主机同时与其他两个主机建立两条 TCP 连接：</p>
<ul>
<li>其中一个 TCP 连接用于在本地局域网中传输文本文件；另一个则通过 Internet 访问远端 Web 服务器视频文件；</li>
<li>则两个 TCP 连接的报文发送和确认信息返回的往返时间（Rout-Trip Time, <code>RTT</code>）会相差很大；</li>
<li>因此需要分别为每个 TCP 连接分别启动一个重传计时器，设定不同的重传时间。</li>
</ul>
<p>除了不同的连接场景外，在不同的时间段，因网络用户数量变化很大，流量与传输延迟变化也会很大。即便是完全相同的两个主机完成同样的 Web 访问操作，在不同时间建立的 TCP 连接，客户端与服务器端之间的报文传输延迟也不会相同。</p>
<p>再者，传输层本就建立在“尽力而为”的 IP 协议之上，因此报文往返时间在数值上离散较大是很自然的。</p>
<p>因此超时重传时间需要合理设置：</p>
<ul>
<li>数值过低：已被接收端正确接收的报文会被重传，造成报文重复</li>
<li>数值过高：报文已经丢失但发送端等待时间过长，降低通信效率</li>
</ul>
<p>超时重传时间的选择只能采用<strong>动态的自适应</strong>的方法：根据对端 - 端报文往返时间的连续测量，来不断调整重传定时器的超时重传时间。</p>
<p><strong>1</strong>. 最佳 RTT 值的估算</p>
<p>一个 TCP 连接维护一个当前最佳 RTT 估算值，每发送一个报文段便启动一个重传计时器；</p>
<p>同时，测量该报文段从发送到被确认的往返时间；如果出现超时，则启动重传。</p>
<p>设某次测量的往返时间为 M，则更新的当前最佳 RTT 估算值为</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="21.174ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 9359 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(1463,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(2444.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3500.6,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"/></g><g data-mml-node="mi" transform="translate(4140.6,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mi" transform="translate(4918.6,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(5677.6,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(6381.6,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(7307.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(8308,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g></g></g></svg></mjx-container></p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"/></g></g></g></svg></mjx-container> 为常数加权因子（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="8.99ex" height="2.156ex" role="img" focusable="false" viewbox="0 -753 3973.6 953"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2266" d="M674 753Q682 753 688 747T694 732T687 718Q686 717 417 589L151 463L399 345Q687 209 691 204Q694 198 694 193Q694 175 676 173H670L382 309Q92 446 90 448Q83 453 83 465Q84 476 96 482Q104 486 382 617T665 751Q669 753 674 753ZM84 39Q84 49 99 59H678Q694 53 694 39Q694 26 679 19H98Q84 26 84 39ZM83 -157Q83 -153 84 -150T86 -145T89 -141T92 -139T96 -137T99 -135H678Q694 -146 694 -155Q694 -168 679 -175H98Q84 -168 83 -157Z"/></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"/></g><g data-mml-node="mi" transform="translate(2473.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">＜</text></g><g data-mml-node="mn" transform="translate(3473.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>），决定 RTT 对延迟变化的反应速度<ul>
<li>当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"/></g></g></g></svg></mjx-container> 接近 0 时，短暂的延迟变化对 RTT 影响不大；</li>
<li>当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"/></g></g></g></svg></mjx-container> 接近 1 时，RTT 将紧紧跟随往返时间变化，影响很大；</li>
<li>RFC2988 建议 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"/></g></g></g></svg></mjx-container> 的参考值为 0.125</li>
</ul>
</li>
</ul>
<p>比如最初往返时间 RTTS 估算值为 30 ms，收到了 3 个确认报文段，测量的往返时间 M 分别为 26ms，32ms，24ms，则：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="6.651ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 2939.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mn" transform="translate(645,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></g></svg></mjx-container> = 30ms</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="6.651ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 2939.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mn" transform="translate(645,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container> = 0.125 × 30 + 26 = 29.75ms</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="6.651ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 2939.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mn" transform="translate(645,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></g></svg></mjx-container> = 0.125 × 29.75 + 32 ≈ 35.72ms</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="6.651ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 2939.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mn" transform="translate(645,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></g></g></svg></mjx-container> = 0.125 × 35.72 + 24 ≈ 28.47ms</li>
</ul>
<p>以上为每次更新的 RTTS 估算值</p>
<p><strong>2</strong>. 超时重传时间（Retransmission Time-Out, RTO）</p>
<p>会略大于加权计算出来的 RTTS 估计值，建议计算公式：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="25.705ex" height="1.967ex" role="img" focusable="false" viewbox="0 -704 11361.6 869.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(1463,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(2503.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3559.6,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(4318.6,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(5022.6,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g><g data-mml-node="mo" transform="translate(6367.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(7368.1,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g><g data-mml-node="mi" transform="translate(7868.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mi" transform="translate(8646.1,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(9405.1,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(10109.1,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g></g></g></g></svg></mjx-container></p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="6.144ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 2715.5 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g></g></g></g></svg></mjx-container> 为 RTT 的偏差加权平均值，和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="5.851ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 2586.1 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></g></svg></mjx-container> 与测量值 M 之差相关<ul>
<li>第一次测量：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="6.944ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 3069 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g><g data-mml-node="mn" transform="translate(828,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container> = M1 / 2</li>
<li>以后：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="48.053ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 21239.5 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g></g><g data-mml-node="mo" transform="translate(2993.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(4049,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(4438,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(5160.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(6160.5,0)"><path data-c="1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"/></g><g data-mml-node="mo" transform="translate(6726.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mi" transform="translate(7115.5,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mo" transform="translate(7893.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(8282.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">旧</text></g><g data-mml-node="mi" transform="translate(9282.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(10282.5,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(11041.5,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(11745.5,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g><g data-mml-node="mo" transform="translate(12868.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(13479.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(14480,0)"><path data-c="1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"/></g><g data-mml-node="mi" transform="translate(15046,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mo" transform="translate(15824,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mi" transform="translate(16102,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(16861,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(17565,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g><g data-mml-node="mo" transform="translate(18910.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(19910.5,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mo" transform="translate(20961.5,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.281ex" height="2.034ex" role="img" focusable="false" viewbox="0 -705 566 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"/></g></g></g></svg></mjx-container> 为常数加权因子，建议取 0.25<ul>
<li>接近 1 ：TCP 能迅速检测报文丢失，及时重传，减少等待时间，但可能引起更多的重传报文</li>
<li>太大：重传报文减少，等待时间太长</li>
</ul>
</li>
</ul>
<p>比如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.281ex" height="2.034ex" role="img" focusable="false" viewbox="0 -705 566 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"/></g></g></g></svg></mjx-container> = 0.25，旧的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="5.851ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 2586.1 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></g></svg></mjx-container> = 30ms，新的 RTTS = 35ms，M = 32ms</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="51.179ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 22620.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="msub" transform="translate(1463,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g></g><g data-mml-node="mo" transform="translate(2993.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(4049,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(4438,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(5160.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(6160.5,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"/></g><g data-mml-node="mo" transform="translate(7938.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mi" transform="translate(8327.5,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mn" transform="translate(9105.5,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(10327.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(11327.9,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"/></g><g data-mml-node="mi" transform="translate(13105.9,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mo" transform="translate(13883.9,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mn" transform="translate(14161.9,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(15384.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(16384.4,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(17384.4,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mo" transform="translate(17940.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(18995.9,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"/><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(1000,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1278,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1778,0)"/></g><g data-mml-node="mi" transform="translate(21273.9,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(22151.9,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container></li>
<li>RTO = 35 + 4 × 23.25 = 128ms</li>
</ul>
<h2 id="TCP-协议滑动窗口与流量控制"><a href="#TCP-协议滑动窗口与流量控制" class="headerlink" title="TCP 协议滑动窗口与流量控制"></a>TCP 协议滑动窗口与流量控制</h2><p>研究流量控制（flow control）算法目的，在于控制发送端发送速率，防止由于接收端来不及接收送达的字节流，而出现报文段丢失的现象。</p>
<p>滑动窗口协议利用报头中<strong>窗口</strong>字段实现流量控制。</p>
<p>在流量控制的过程中，接收窗口又称为“通知窗口（Advertised Windows）”</p>
<ul>
<li>接收端根据自身接收能力，选择合适的接收窗口（<code>rwnd</code>, receiving window）值，将其写入 TCP 报头；</li>
<li>接收端返回时，会将当前接收端的接收状态通知发送端；</li>
<li>确定之后，发送端的发送窗口不能超过接收窗口的数值；</li>
<li>rwnd 数值单位为字节，而不是报文段</li>
</ul>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p>如接收端应用进程从缓存中读取字节的速度 ≧ 字节到达速度：接收端需要在每个返回的确认（ACK）中发送“非零窗口”通告（rwnd &gt; 0）。</p>
<p>如果发送端发送速度 &gt; 接收端消费速度：缓冲区被全部占用，后到达字节因缓冲区溢出而丢弃；</p>
<p>此时接收端必须发出“<strong>零窗口</strong>”通知（rwnd = 0），发送端接收到“零窗口”通知后会停止发送，直至下一次接收到接收端的“非零窗口”为止。</p>
<p><img src="/2024/03/09/transport-layer/flow-control.png" alt></p>
<p>如上图，接收方确定的 rwnd = 400，假设每次发送方每次发送报文段的长度为 100 字节。</p>
<h3 id="坚持计时器（Persistence-Timer）"><a href="#坚持计时器（Persistence-Timer）" class="headerlink" title="坚持计时器（Persistence Timer）"></a>坚持计时器（Persistence Timer）</h3><p>通信的稳定性是双向的，如果接收端不稳定，下一个非零窗口通告丢失了，则发送端会无休止等待接收端通知，从而陷入死锁。</p>
<p>因此坚持计时器的意义在于：</p>
<ul>
<li>当发送端 TCP 接收到一个零窗口通知时：启动坚持计时器；</li>
<li>当计时器时间到：发送端 TCP 发送一个零窗口探测报文，提示接收端：非零窗口通知丢失，需要重传；</li>
<li>其值设置为重传时间的数值，最大为 60 秒</li>
<li>如发出的第一个零窗口探测报文没收到应答：继续发送，直到收到非零窗口为止</li>
</ul>
<h3 id="流量控制的传输效率"><a href="#流量控制的传输效率" class="headerlink" title="流量控制的传输效率"></a>流量控制的传输效率</h3><ul>
<li>发送端应用进程将数据传送到 TCP 协议的发送缓存后，控制全传输任务就由 TCP 协议承担</li>
<li>TCP 协议必须注意解决好“何时”发送“多长报文段”</li>
</ul>
<p>这是个复杂的问题：受到应用进程产生数据的速度与接收端发送能力限制。</p>
<p>极端情况：每次只发送一个字节</p>
<ul>
<li>IP 分组共 41 字节，包括：1 + 20 字节 TCP 报头 + 20 字节 IP 报头</li>
<li>接收端接收后没有数据发送，也要立即返回一个 40 字节的确认分组（20 字节 TCP 报头 + 20 字节 IP 报头）</li>
<li>接收端向发送端发出窗口更新报文，通知将窗口前移 1 个字节（40 字节）</li>
<li>发送端发送一个字节的数据（41 字节）</li>
<li>则：输入一个字符需要发送 162 字节的 4 个报文段，这是大大的资源浪费</li>
</ul>
<p>采用 Nagle 算法提高效率：</p>
<ul>
<li>当数据以每次 1 字节进入发送端：第一次只发送 1 字节，其它字节存入缓存区</li>
<li>第一个报文段符合时，再将缓存中的数据（不止 1 字节）放在第二个报文段中发出去，一边发送等待应答；一边缓存待发送数据</li>
<li>当缓存的数据字节数达到发送窗口的 1/2 或接近最大报文段长度 MSS 时：立即发送</li>
</ul>
<p>另一种极端情况：糊涂窗口综合征（Silly Windows Syndrome）</p>
<ul>
<li>假设 TCP 接收缓存已满，应用进程每次只从接收缓存读取 1 字节</li>
<li>接收端缓存腾空 1 字节，并向发送端发出确认报文，且将接收窗口设为 1</li>
<li>发送端发送的确认报文长度为 40 字节</li>
<li>随后发送端发送一个字节的数据（41 字节）</li>
</ul>
<p>解决方法：禁止接收端发送只有 1 字节的窗口更新报文；而是让接收端等待一段时间至接收缓存有足够空间接收一个最大长度的报文段，或缓冲区空出一半，再发送窗口更新报文。</p>
<p>也就是说，发送端不要发送太小的报文段，接收端的 rwnd 不能太小</p>
<h2 id="TCP-滑动窗口与拥塞控制"><a href="#TCP-滑动窗口与拥塞控制" class="headerlink" title="TCP 滑动窗口与拥塞控制"></a>TCP 滑动窗口与拥塞控制</h2><p>拥塞控制用于防止过多报文进入网络，从而造成路由器与链路过载。</p>
<p>我们在这里区分一下刚学的两个名词：</p>
<ul>
<li>流量控制：重点在<strong>点 - 点链路</strong>的通信量的局部控制上</li>
<li>拥塞控制：重点在进入网络<strong>报文总量</strong>的全局控制上</li>
</ul>
<p>流量控制可以很好地解决发送端与接收端之间的端 - 端报文发送和处理速度的协调，但无法控制进入网络的总体流量。随着网络流量增加，网络通信负荷过重，引起报文传输延时增大或丢弃，报文的差错确认又会加剧网络拥塞。</p>
<p>当网络出现拥塞时，对网络资源的需求总和 &gt; 网络可用资源。比如说，某段时间用户对某类资源要求过高，就会造成拥塞。</p>
<p>比如某条链路带宽 100 M，对连接在该链路上的 100 台计算机的要求是：以不高于平均 10 M 的速度发送数据</p>
<ul>
<li>解决方法：升级链路带宽至 1 G</li>
</ul>
<p>又如某节点缓存容量过小 / 处理速度太慢，造成进入节点的大量报文不能及时被处理，不得不丢弃报文</p>
<ul>
<li>解决方法：升级主机，更换大容量缓存、高速处理器</li>
</ul>
<p>然而，以上均不能根本上解决网络拥塞问题。</p>
<h3 id="拥塞处理-congestion-handling"><a href="#拥塞处理-congestion-handling" class="headerlink" title="拥塞处理(congestion handling)"></a>拥塞处理(congestion handling)</h3><p>我们先来了解两个名词：</p>
<ol>
<li><strong>负载</strong>（<strong>load</strong>）：单位时间进入网络的字节数</li>
<li><strong>吞吐量</strong>（<strong>throughput</strong>）：单位时间内通过网络输出的字节数</li>
</ol>
<p><img src="/2024/03/09/transport-layer/congestion-handling.png" alt></p>
<p><span style="color:#32CD32">亮绿色</span>曲线：未采取拥塞控制方法</p>
<ul>
<li>开始阶段：吞吐量随网络负载增加呈线性增长</li>
<li>轻度拥塞：吞吐量增长逐渐小于负载增加量</li>
<li>网络负载继续增加而吞吐量不变：饱和状态</li>
<li>饱和状态后，吞吐量随网络负载增加而减少</li>
<li>增加到一定程度的时候，吞吐量为 0 ，系统出现死锁（deadlock）</li>
</ul>
<p><span style="color:red">红色</span>曲线：理想拥塞控制</p>
<ul>
<li>网络负载达到饱和点之前，网络吞吐量一直保持线性增长的关系</li>
<li>到达饱和点后，网络吞吐量维持不变</li>
</ul>
<p><span style="color:blue">蓝色</span>曲线：实际拥塞控制</p>
<ul>
<li>网络负载增长初期：由于需要在拥塞控制过程消耗一定的资源，导致吞吐量小于无拥塞控制状态</li>
<li>在负载增加过程中，限制进入网络的报文或丢弃部分报文，使吞吐量逐渐增长，而不出现下降和死锁现象</li>
</ul>
<p>由此可知，实现拥塞控制的前提，是<strong>网络能承受现有的网络负荷</strong>。</p>
<h3 id="最基本手段：TCP-协议滑动窗口"><a href="#最基本手段：TCP-协议滑动窗口" class="headerlink" title="最基本手段：TCP 协议滑动窗口"></a>最基本手段：TCP 协议滑动窗口</h3><p>我们将此时的滑动窗口定义为<strong>拥塞窗口</strong>（<strong>Congestion Window</strong>, cwnd），为发送端根据网络拥塞情况而确定的窗口值：</p>
<ul>
<li>发送端真正确定发送窗口时，应取“通知窗口”与“拥塞窗口”中的较小值</li>
<li>接收端需要根据自己的接收能力给出一个合适的接收窗口（Receiving Window, rwnd）</li>
</ul>
<p>从流量控制角度来看，发送窗口一定不能超过接收窗口，其上限值应取 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="17.59ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 7774.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1396,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1996,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2385,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2836,0)"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g><g data-mml-node="mi" transform="translate(3552,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4152,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(4672,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(5116.7,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(5549.7,0)"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g><g data-mml-node="mi" transform="translate(6265.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(6865.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(7385.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p>
<ul>
<li>rwnd &gt; cwnd：拥塞窗口限制发送窗口的最大值</li>
<li>rwnd &lt; cwnd：接收端接收能力限制发送窗口的最大值</li>
<li>没有发生拥塞：接收端的通知窗口和拥塞窗口一致</li>
</ul>
<p>使用到的参数如下：</p>
<ul>
<li>拥塞窗口（cwnd, <u>C</u>ongestion <u>W</u>i<u>nd</u>ow）：拥塞控制的关键参数，它描述源端在拥塞控制情况下一次最多能发送的数据包的数量</li>
<li>通告窗口（awin）：接收端给源端预设的发送窗口大小，它只在 TCP 连接建立的初始阶段发挥作用</li>
<li>发送窗口（win）：源端每次实际发送数据的窗口大小</li>
<li>慢启动阈值（ssthresh）：拥塞控制中慢启动阶段和拥塞避免阶段的分界点。初始值通常设为 65535 byte</li>
<li>回路响应时间（RTT）：一个 TCP 数据包从源端发送到接收端，源端收到接收端确认的时间间隔</li>
<li>超时重传计数器（RTO）：描述数据包从发送到失效的时间间隔，是判断数据包丢失与否及网络是否拥塞的重要参数。通常设为 2RTT 或 5RTT</li>
<li>快速重传阈值（tcprexmtthresh）：能触发快速重传的源端收到重复确认包 ACK 的个数。当此个数超过 tcprexmtthresh 时，网络就进入快速重传阶段。tcprexmtthresh 默认值为 3。</li>
</ul>
<h3 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h3><p>如上所述，拥塞窗口的大小应该根据网络的拥塞情况进行动态调整：当网络无拥塞，发送端逐步增大拥塞窗口；当出现拥塞时，拥塞窗口立即减小。</p>
<p>网络是否出现拥塞，取决于路由器是否丢弃分组（基于的假设：线路质量好，丢弃分组原因不是因为物理层传输出错，而是因为网络中分组传输总量大，超过了路由器的接收能力，造成路由器过载）。通过应用不同的拥塞控制算法，动态调节用户对网络资源的需求，来保证网络系统的稳定运行。</p>
<p>1999 年，RFC 2581 对 TCP 协议规定了四种拥塞控制方法：</p>
<ol>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ol>
<p>发送端确定拥塞窗口大小的时候，可采用慢启动和拥塞避免算法。</p>
<p>当主机开始发送数据时，因为对网络负载状态不了解，可以<strong>试探着</strong>从小到大逐步增加拥塞窗口，曰<strong>慢启动</strong>（<strong>Slow-Start</strong>）。</p>
<p>我们预定义<strong>一个往返</strong> —— 定义第一个“从发送端发送报文（MSS）到接收端，接收端在规定时间内返回了确认报文：的动作。这时候，主机在建立一个 TCP 连接的初始化时，将慢启动的初始值设为 1；</p>
<p>第一个往返首先将拥塞窗口（cwnd）设为 2，然后向接收端发送两个最大报文段。</p>
<ul>
<li>如果接收端在定时器允许的往返时间内返回确认，那就证明网络不拥塞，拥塞窗口按<strong>二进制指数</strong>增长，即：第二个往返 cwnd = 4；</li>
<li>如报文正确传输：第三个往返 cwnd = 8</li>
<li>如再正确：第四个往返 cwnd = 16，如此类推</li>
<li>若在规定时间没有收到确认报文：表明网络开始出现拥塞</li>
</ul>
<p>注意：</p>
<p><strong>1</strong>. 每一次发送的往返时间 RTT 是不同的：取决于连续发送报文段的多少</p>
<ul>
<li>每个过程的往返时间应从连续发送多个报文段，到接收到所有发送报文段确认消息需要的时间</li>
<li>如第一个往返过程中 cwnd = 2：该次可连续发送两个报文段</li>
<li>发送端必须都收到这两个报文段的确认，才能判断网络没有出现拥塞</li>
</ul>
<p><strong>2</strong>. “慢启动”的“慢”：不是指 cwnd 从 1 开始，然后按照二进制指数增长的速度</p>
<ul>
<li>而是指：试探着将 cwnd 逐步增大，比突然将很多报文发送到网络的情况要“慢”</li>
<li>意味着发送报文段的多少存在着逐步加快的过程</li>
</ul>
<p><strong>3</strong>. 定义“慢启动阀值（slow-start threshold, ssthresh）”：避免 cwnd 增长过快引起网络拥塞</p>
<ul>
<li>cwnd &lt; ssthresh：使用慢启动算法</li>
<li>cwnd &gt; ssthresh：使用拥塞控制算法</li>
<li>cwnd = ssthresh：两种算法均可使用</li>
<li>如 cwnd = 32 时出现超时：发送端可将 ssthresh 设置为：ssthresh = cwnd / 2 = 16</li>
</ul>
<p>我们再来说说拥塞避免（Congestion Avoidance）</p>
<ul>
<li>将“每增加一个往返就将 cwnd 加倍”改成每增加一个往返就将 cwnd 加一</li>
<li>cwnd 呈线性增加，缓慢增长</li>
<li>只要发现接收端没有按时返回确认：网络拥塞，将 ssthresh 值设为 cwnd / 2，并重新进入下一轮慢启动，即此时 cwnd = 1</li>
</ul>
<p>慢启动 + 拥塞避免</p>
<ul>
<li>连接初始化时 cwnd = 1，慢启动初始阀值 ssthresh = 16（单位为 MSS）</li>
<li>4 个往返后 cwnd 增长至 16，TCP 传输进入拥塞避免控制阶段</li>
<li>假设：cwnd = 24 时发送端检测出现超时 —— cwnd 被重新设成 1，ssthresh 被设成 24 / 2 = 12</li>
<li>1 - 4 往返的 cwnd 分别为 2, 4, 8, 16，5 - 12 往返的 cwnd 分别为 17 - 24</li>
<li>之后重新开始慢启动 + 拥塞避免</li>
<li>13 - 17 往返的 cwnd 分别为 1, 2, 4, 8, 12，18 之后的往返就分别加一</li>
</ul>
<p><img src="/2024/03/09/transport-layer/congestion-avoidance.png" alt></p>
<p>注：</p>
<ul>
<li>只要出现超时就将 ssthresh 减半 —— “乘法减小（Multiplicative Decrease）”算法</li>
<li>开始执行拥塞避免，缓慢加一 —— “加法增大（Additive Increase）”算法</li>
<li>合称 AIMD（Additive Increase Multiplicative Decrease）算法 —— 加性增窗，乘性减窗</li>
</ul>
<p>缺点：举例说明</p>
<ul>
<li>当发送端连续发送报文 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1406.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container> - <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1406.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g></g></g></g></svg></mjx-container>，只有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1406.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></g></svg></mjx-container> 在传输过程中丢失，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1406.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g></g></g></svg></mjx-container> - <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1406.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g></g></g></g></svg></mjx-container> 都能正确接收</li>
<li>此时不能根据一个 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1406.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></g></svg></mjx-container> 的超时而简单判断网络出现拥塞</li>
<li>替代方法：快重传 和 快恢复</li>
</ul>
<p>再说说另外两种算法：快重传（Fast Retransmit）和快恢复（Fast Recovery）</p>
<p>举例说明快重传：如接收端在正确接收 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1406.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="3.182ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1406.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mn" transform="translate(1003,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container> 报文并返回确认，没有接收到 M3 报文，而是接收到 M4：</p>
<pre><code>* 此时接收端不能对 M4 进行确认（M4 为乱序报文）
</code></pre><p>根据快重传的算法规定，接收端应及时向发送端连续三次发出对 M2 的“重复确认”，要求发送端尽早重传未被确认的报文。</p>
<p>快恢复与快恢复算法配合，规定如下：</p>
<ol>
<li>接收端收到第一个对 M2 的“重复确认”时：发送端立即将拥塞窗口 cwnd 设置为最大拥塞窗口值的 1/2 <ul>
<li>执行“拥塞避免”算法，cwnd 按照线性方式增长</li>
</ul>
</li>
<li>接收端收到第二个对 M2 的“重复确认”时：发送端立即减小 cwnd<ul>
<li>执行“拥塞避免”算法，cwnd 按照线性方式增长</li>
</ul>
</li>
<li>接收端收到第三个对 M2 的“重复确认”时：发送端立即减小 cwnd<ul>
<li>执行“拥塞避免”算法，cwnd 按照线性方式增长</li>
</ul>
</li>
</ol>
<p><img src="/2024/03/09/transport-layer/fast-retramsmit.png" alt></p>
<h2 id="TCP-连接池"><a href="#TCP-连接池" class="headerlink" title="TCP 连接池"></a>TCP 连接池</h2><p>TCP 服务器能达到的最大并发连接数，理论上是全球 IP 数 * 每台机器的端口数，而实际上是系统可打开文件数，属于系统性能。</p>
<p>在四次挥手后，需要等待两个最长报文寿命（Maximum Segment Lifetime, MSL）后才进入 CLOSED 状态，可能会产生的问题：</p>
<ul>
<li>在客户端中，一个 TIME_WAIT 状态的连接就占用了一个本地端口</li>
<li>一台机器上端口号数量最多 65536 个</li>
<li>如在同一机器上进行压测模拟上万客户请求，且循环与服务端进行短连接通信，则：<ul>
<li>机器产生 4000 左右的 TIME_WAIT socket</li>
<li>后续短连接回产生 address already in use : connect 的异常</li>
</ul>
</li>
</ul>
<p>TCP 的连接池，指的是<strong>套接字</strong>的连接池</p>
<p>建立 Socket 连接池包括：</p>
<ul>
<li>维护一定数量 Socket 长连接的集合</li>
<li>自动检测 Socket 长连接的有效性，剔除无效的连接，补充连接池中长连接的数量</li>
</ul>
<p>在代码层面上可创建相关类来实现以上功能，需要包含以下属性：</p>
<ol>
<li>空闲可使用的长连接队列</li>
<li>正在运行的通信的长连接队列</li>
<li>等待去获取一个空闲长连接的请求的队列</li>
<li>剔除无效长连接</li>
<li>配置长连接资源池的数量</li>
<li>新建长连接资源</li>
</ol>
<p>问题又来了：套接字是什么？</p>
<h1 id="通信单元-Socket"><a href="#通信单元-Socket" class="headerlink" title="通信单元 Socket"></a>通信单元 Socket</h1><h2 id="应用进程、传输层接口与套接字（socket）"><a href="#应用进程、传输层接口与套接字（socket）" class="headerlink" title="应用进程、传输层接口与套接字（socket）"></a>应用进程、传输层接口与套接字（socket）</h2><p>按照英文原义，是 Handler in the communication chain。</p>
<p>应用程序（进程）与传输层的 TCP 或 UDP 都是在主机操作系统控制下工作；在一台计算机中，不同的进程需要使用<strong>进程号</strong>（<strong>process ID</strong>）被唯一地标识，这个进程号也被称为<strong>端口号</strong>（<strong>port number</strong>）</p>
<p>端口号可用于计算机之间通信，也可用于同一计算机进程之间的通信。在计算机网络中，只有知道 IP 地址与端口号，才能唯一地找到准备该通信的进程。</p>
<p>RFC793 定义的套接字（socket）由 IP 地址与对应的端口号组成，格式为：</p>
<blockquote>
<p>IP 地址: 端口号</p>
</blockquote>
<p>如：10.116.53.141:7070</p>
<h2 id="Socket-的不同含义"><a href="#Socket-的不同含义" class="headerlink" title="Socket 的不同含义"></a>Socket 的不同含义</h2><p>在计算机 / 网络原理中，Socket 指的是 RFC793 规定的 IP 地址: 端口号格式；</p>
<p>在网络软件编程中，Socket 指的是网络程序的 API。它是 TCP/IP 协议十分流行的 PI，所支持的协议种类不光 TCP/IP 一种；</p>
<p>另外一个含义，则是将复杂的 TCP/IP 协议族隐藏到 Socket 接口后面，编程时调用对应 API，让 Socket 组织数据，以符合指定的协议。</p>
<p>这样，API 中的一个函数名也可称为 Socket，Socket 之于设计模式，属于 Facade 模式。</p>
<h2 id="进程标识方法：端口号"><a href="#进程标识方法：端口号" class="headerlink" title="进程标识方法：端口号"></a>进程标识方法：端口号</h2><p>TCP/IP 传输层的寻址是通过 TCP 与 UDP 的端口号实现的，应用层程序分别选择 TCP 或 UDP 作为传输层协议。</p>
<p>为了区分不同网络程序，TCP 和 UDP 规定用不同端口号表示不同的应用程序</p>
<h3 id="端口号分配方法"><a href="#端口号分配方法" class="headerlink" title="端口号分配方法"></a>端口号分配方法</h3><p>一共有三类：熟知端口号、注册端口号、临时端口号。端口号范围从小到大，数值范围：0 ~ 65535。</p>
<p><strong>临时端口号</strong>：49152 ~ 65535</p>
<ul>
<li>由 TCP/UDP 软件随机选取，只对一次进程通信有效</li>
</ul>
<p><strong>注册端口号</strong>：1024 ~ 49151</p>
<ul>
<li>用户开发一种新的网络应用程序时，为防止应用在 Internet 使用出现冲突而在 IANA 登记的端口号</li>
</ul>
<p><strong>熟知端口号</strong>（Well-Known Port Number，公认端口号）：0 ~ 1023（系统端口）</p>
<ul>
<li>TCP / UDP 为每种标准的 Internet 服务器进程分配一个确定的全局端口号</li>
<li>每个客户进程都知道响应的服务器进程的熟知端口号</li>
<li>由 IANA 统一分配。查询：<a href="http://www.iana.org/">http://www.iana.org/</a></li>
</ul>
<p>UDP 的熟知端口号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口号</th>
<th>服务进程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>53</td>
<td>DNS</td>
<td>域名服务</td>
</tr>
<tr>
<td>67/68</td>
<td>DHCP</td>
<td>动态主机配置协议</td>
</tr>
<tr>
<td>69</td>
<td>TFTP</td>
<td>简单文件传送协议</td>
</tr>
<tr>
<td>161/162</td>
<td>SNMP</td>
<td>简单网络管理协议</td>
</tr>
<tr>
<td>520</td>
<td>RIP</td>
<td>路由信息协议</td>
</tr>
</tbody>
</table>
</div>
<p>UDP 服务与端口号映射表定期在 RFC768 等文本中公布，并可在大多数 UNIX 主机的 /etc/services 文件中得到</p>
<p>注：DHCP 与 SNMP 熟知端口号的使用与 DNS 不同：DHCP、SNMP的客户端和服务器端在通信时都使用熟知端口号</p>
<p>TCP 的熟知端口号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口号</th>
<th>服务进程</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>20</td>
<td>FTP</td>
<td>文件传输协议（数据连接）</td>
</tr>
<tr>
<td>21</td>
<td>FTP</td>
<td>文件传输协议（控制连接）</td>
</tr>
<tr>
<td>23</td>
<td>TELNET</td>
<td>网络虚拟终端协议</td>
</tr>
<tr>
<td>25</td>
<td>SMTP</td>
<td>简单邮件传输协议</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>超文本传输协议</td>
</tr>
<tr>
<td>179</td>
<td>BGP</td>
<td>边界路由协议</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Socket-建立方法"><a href="#Socket-建立方法" class="headerlink" title="Socket 建立方法"></a>Socket 建立方法</h2><p>建立 Socket 连接：</p>
<ul>
<li>运行于客户端的 Socket （ClientSocket）</li>
<li>运行于服务器端的 Socket （ServerSocket）</li>
</ul>
<p>步骤：</p>
<ol>
<li>服务器监听<ol>
<li>服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求</li>
</ol>
</li>
<li>客户端请求<ol>
<li>客户端套接字提出连接请求，要连接的目标是服务器端的套接字：</li>
<li>客户端套接字必须首先描述它要连接的服务器套接字，指出服务器端套接字的地址和端口号，然后向服务器端套接字提出连接请求</li>
</ol>
</li>
<li>连接确认<ol>
<li>服务器端套接字监听到或接收到客户端套接字的连接请求：响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端；</li>
<li>一旦客户端确认了此描述，双方就正式建立连接。</li>
<li>服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li>
</ol>
</li>
<li>客户端和服务器端相互接收和传递信息</li>
</ol>
<p>优点：</p>
<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小</li>
<li>传输数据时间短，性能高</li>
<li>适合 C/S 之间信息即时、实时交互（建立长时间连接）<ul>
<li>不像 HTTP 请求那样，执行完之后随机关闭</li>
</ul>
</li>
<li>可加密，基于 TCP 连接，数据安全性高</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要对传输的数据进行解析，转化为应用级别的数据</li>
<li>对开发水平要求高</li>
<li>相对于 HTTP 协议传输，增加了开发量</li>
</ol>
<p>Socket 长连接：在一个 TCP 连接上连续发送多个数据包</p>
<ul>
<li>TCP 连接保持期间如没有数据包发送：依靠双方发送心跳包维持</li>
<li>连接 → 数据传输 → 保持连接（心跳）→ 数据传输 → 保持连接（心跳<br>）→ … → 关闭连接</li>
<li>多用于操作频繁、点对点的通信，而且连接数不能太多</li>
</ul>
<h1 id="多重协议的识别"><a href="#多重协议的识别" class="headerlink" title="多重协议的识别"></a>多重协议的识别</h1><ul>
<li>网络中进行通信（使用同一种应用程序）的两台主机，必须在通信前确定都采用 TCP，还是都采用 UDP</li>
<li>如考虑到进程标识和多重协议的识别，网络环境中一个进程的全网唯一标识应该使用三元组</li>
<li>在 UNIX 中称为“半相关”（half-association）：<ul>
<li>协议（TCP）</li>
<li>本地地址（10.116.50.5）</li>
<li>本地端口号（8080）</li>
</ul>
</li>
<li>完整的进程通信标识（一个完整的 Socket）—— 使用五元组（“相关”）表示：<ul>
<li>协议（TCP）</li>
<li>本地地址（202.1.2.5）</li>
<li>本地端口号（30022）</li>
<li>远程地址（121.5.21.2）</li>
<li>远程端口号（22）</li>
</ul>
</li>
</ul>
<p>传输层多路复用（multiplexing）与多路分解（demultiplexing）</p>
<ul>
<li>一台运行 TCP/IP 协议的主机可能同时运行不同的应用程序</li>
<li>TCP/IP 协议允许多个不同的应用程序的数据同时使用 IP 地址和一个物理连接来发送和接收数据<ul>
<li>发送端：IP 协议将 TCP 或 UDP 的传输协议数据单元 TPDU 都封装成一个 IP 分组发送出去</li>
<li>接收端：IP 协议将从 IP 分组拆开的 TPDU 传送到传输层，由传输层根据不同 TPDU 端口号区分不同 TPDU 属性，分别传送至对应的应用程序</li>
</ul>
</li>
</ul>
<p><img src="/2024/03/09/transport-layer/multiplexing.png" alt></p>
<p>TCP、UDP 与应用层关系：</p>
<p>应用层协议中：</p>
<ul>
<li>一种依赖 TCP（主要是需要大量传输交互式报文的协议）</li>
<li>一种依赖 UDP（如 P2P 会话类应用）</li>
<li>一些两种都依赖（如 DNS）</li>
</ul>
<p><img src="/2024/03/09/transport-layer/tcp-udp-app.jpg" alt></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>大话 LLM</title>
    <url>/2025/02/17/llm-intro/</url>
    <content><![CDATA[<p>乙巳年伊始，DeepSeek R1 的开源犹如一响惊雷，震动了寰宇大地，由 GPT 引领的大模型演进、自然语言处理、神经网络算法乃至深度学习、全图谱人工智能领域的热度再次被推上一个新的高度。新一年几乎掀起了全民学 AI 的热潮，似乎预示着颠覆性变革的到来。</p>
<span id="more"></span>
<p>硕士生涯的时候学习过 AI 基础，加上本人的风格就是在遇到一个新风口的时候喜欢探究其原理，于是乎，想借助本文简单拟一个 DeepSeek，乃至整个大模型演进的科普文章，简单阐述原理，以便在日后的工作中能够根据基础知识举一反三、触类旁通、事半功倍。</p>
<p>我们先从 DeepSeek 的基础 —— 深度学习简单展开，然后聊一下 DeepSeek 的竞对 GPT，再通过对比引出 DeepSeek 的精妙之处。</p>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="普通的神经网络"><a href="#普通的神经网络" class="headerlink" title="普通的神经网络"></a>普通的神经网络</h2><p>一个基础的神经网络包括三层：<strong>输入层</strong>、<strong>隐藏层</strong>和<strong>输出层</strong></p>
<p><img src="/2025/02/17/llm-intro/Neural-Networks-Architecture.png" alt></p>
<ul>
<li>输入层自身就是一层对接输入数据的神经网络；</li>
<li>输出层输出整个神经网络的计算结果；</li>
<li>隐藏层涉及到功能执行的参数和计算过程，不直接暴露，即“黑盒”</li>
</ul>
<p>“黑盒”的实现有很多，最简单的是单层感知机（Single-layer Perceptron），用于二分类任务的线性分类器（binary classifier），无法处理非线性问题；其它常用的神经网络包括：</p>
<ul>
<li>CNN(Convolutional Neural Network) 卷积神经网络 </li>
<li>GNN(Graph Neural Network) 图神经网络</li>
<li>RNN(Recurrent Neural Network) 循环神经网络</li>
</ul>
<h2 id="输入预处理-pre-processing"><a href="#输入预处理-pre-processing" class="headerlink" title="输入预处理 pre-processing"></a>输入预处理 pre-processing</h2><p>并不是所有的数据，都能通过隐藏层输出符合预期的结果；隐藏层往往对输入有明显的特征要求，所以对输入数据进行预处理非常重要。</p>
<h2 id="激活函数-activation-function"><a href="#激活函数-activation-function" class="headerlink" title="激活函数 activation function"></a>激活函数 activation function</h2><p>激活函数是神经网络的重要特征，决定了网络中的<strong>一个神经元是否应该被激活</strong>：神经元接收的信息与给定的条件有关。</p>
<p>激活函数对输入信息进行<strong>非线性变换</strong>，变换后的输出会作为下一个神经元的输入 —— 这个变换非常重要，如果没有激活函数，输出永远都是基于输入的线性转换，极有可能无法收敛于我们的期望结果。</p>
<p>因此激活函数存在于<strong>输入层、隐藏层和输出层的所有神经元</strong>，简单的激活函数有：</p>
<ul>
<li><code>sigmoid</code>: 适合输出预测概率，存在梯度消失（函数图像的两端，即输入值很大或很小的情况下，导数接近于 0 —— 意味着在网络的深层，由于多次连乘的影响，梯度会变得极小，导致演进停滞不前）可能；</li>
<li><code>tanh</code>: 适合输出预测概率，存在梯度消失可能；</li>
<li><code>relu</code>: 无梯度消失，几乎可以到处使用，但表现能力较弱，一般只用于隐藏层；</li>
<li><code>softmax</code>: 目前最常用，多用于<strong>多分类</strong>问题，存在梯度消失可能</li>
</ul>
<p><img src="/2025/02/17/llm-intro/activation-functions.png" alt></p>
<h2 id="损失函数-loss-function"><a href="#损失函数-loss-function" class="headerlink" title="损失函数 loss function"></a>损失函数 loss function</h2><p>损失函数用来度量模型的预测值 <code>f(x)</code> 和真实值 <code>Y</code> 的差异程度，是一个<strong>非负实值函数</strong>：损失函数越小，模型越强壮。</p>
<p><img src="/2025/02/17/llm-intro/loss-function.png" alt></p>
<p>损失函数主要用在模型的训练阶段：</p>
<ol>
<li>每个批次的训练数据被送入模型后，通过<strong>前向传播</strong>（forward pass）输出预测值；</li>
<li>损失函数根据预测值算出和真实值的损失值，通过<strong>反向传播</strong>（backward pass）更新模型的各个参数，以图降低后续的损失值；</li>
<li>由此往复，使模型预测值向真实值方向收敛，达到学习目的</li>
</ol>
<p><img src="/2025/02/17/llm-intro/Schematic-of-backpropagation-In-the-forward-pass-of-a-simple-neural-network-an-input.ppm" alt></p>
<p>因为神经网络乃至 AI 中有两个不同的场景：<strong>训练</strong>和<strong>推理</strong></p>
<ul>
<li>推理的计算过程仅包括前向传播：因为整个神经网络模型已经准备完毕，用户输入数据后可以获得相对稳定且准确的结果；</li>
<li>训练的计算过程都包括：因为此时的神经元参数为 0 或其它参数值，用户输入数据后并不能获得准确结果，需要根据损失函数的损失值，通过监督（supervised learning）或无监督（unsupervised learning）学习等进行反向传播，<strong>更新参数值</strong>，并不停地进行迭代，使模型可用于推理</li>
</ul>
<p>因此训练的计算量更大，内存访问更多，过程更复杂。</p>
<p>参数更新的方式也很简单：<strong>求导</strong>，获得梯度，以梯度的更新向合理的参数逼近。梯度更新注意避免两种情况：</p>
<ul>
<li><strong>梯度消失</strong>：梯度为 0 或接近于 0，后果是参数无更新，或更新极小，导致训练缓慢甚至停止（所谓的“神经元无法有效传导”）；</li>
<li><strong>梯度爆炸</strong>：梯度过大，参数更新过于激烈，导致损失函数一直抖动，无法收敛</li>
</ul>
<h2 id="解决过度拟合-overfitting"><a href="#解决过度拟合-overfitting" class="headerlink" title="解决过度拟合 overfitting"></a>解决过度拟合 overfitting</h2><p>类似于数据挖掘的经典问题：避免陷入局部最优解。过度拟合体现在：模型在训练集上损失值较低，预测准确率较高；但在测试集上损失值大，预测准确率低，得到的模型基本不可用。</p>
<p>常用的有一种缓解过度拟合的方法：dropout，要求所有神经元带上一个停止工作的概率 p，在前向传播的时候，某几个神经元会有一定的概率 p 停止工作，使模型不太依赖某些局部特征，更具有泛化性。</p>
<p><img src="/2025/02/17/llm-intro/dropout.png" alt></p>
<h1 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h1><p>自然语言处理（Natural Language Processing, NLP）是人工智能领域的一个重要方向，大模型的本身也是 NLP 的一部分，在 GPT 实现多模态之前，输入也是文本语言。</p>
<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>循环神经网络 RNN 是最早用于 NLP 的“黑盒”构型，<strong>不仅依赖当前输入，还取决于先前输入的中间结果</strong>。</p>
<p><img src="/2025/02/17/llm-intro/What-is-Recurrent-Neural-Network-660.webp" alt></p>
<p>因此 RNN 可以通过先前输入的中间结果影响当前输入的结果，与 NLP 的基本问题（根据先前的文本推断下文）高度吻合；故同样类型的推理（训练）任务也可以用 RNN 处理。</p>
<h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p>Long Short-Term Memory，长短期记忆属于一种特殊的 RNN 网络，主要解决了长序列训练过程中的梯度消失和梯度爆炸问题，在更长序列中有更好的表现。</p>
<p>相比于 RNN 只有一个传递状态，LSTM 有两个传递状态，cell state 和 hidden state：</p>
<ul>
<li>传递的 cell state 改变得很慢，通常的输出是上一状态的 cell state 加上一些数值；</li>
<li>hidden state 在不同的节点下往往有很大区别</li>
</ul>
<p><img src="/2025/02/17/llm-intro/lstm.png" alt></p>
<p>因为 cell state 的存在，LSTM 对长期信息的记忆更久。</p>
<h2 id="Encoder-decoder"><a href="#Encoder-decoder" class="headerlink" title="Encoder-decoder"></a>Encoder-decoder</h2><p>以上情况我们均考虑输入输出序列等长的情况，然而实际生活中大量存在输入输出序列长度不等的情况，如机器翻译、语音识别、问答系统等。</p>
<p>Encoder-decoder 能够完成从一个可变长序列至另一个可变长序列的映射，属于机器模型（Machine Translation）的产物。</p>
<p>它的基本思想非常简单：<strong>使用一个 RNN 读取输入的句子，将整个句子的信息“压缩”到一个固定维度的编码中；再使用另一个 RNN 读取这个编码，将其“解压”为目标语言的一个句子</strong>（seq2seq）。由此的“压缩”和“解压”一来一回，就组成了一个编码器（Encoder）和解码器（Decoder），大大提高灵活性。</p>
<p><img src="/2025/02/17/llm-intro/encoder_decoder2.webp" alt></p>
<p>但是它的局限性也很明显：encoder 和 decoder 之间的唯一联系是一个固定的语义编码 C，即 encoder 要将整个序列的信息压缩到一个固定长度变量中。</p>
<ol>
<li>一是语义编码 C 可能无法完全表示整个序列的信息；</li>
<li>二是先输入到网络的内容携带的信息会被后输入的信息覆盖，输入序列越长，现象越严重</li>
</ol>
<p>这两个弊端会导致解码的时候，decoder 一开始就没有获得序列足够多的信息，导致解码准确率不高。</p>
<p>为了解决这两个弊端，大牛们引入了著名的注意力（attention）机制。</p>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><p>深度学习中的注意力机制借鉴了人类的注意力思维方式。在最早提出 attention 的论文中，attention 是作为一个中间层出现的，位于 encoder 和 decoder 之间，跟原来的语义编码类似。</p>
<p>我们可以从两个方面简单理解 attention：</p>
<ol>
<li>每次处理（每次只注意）一个窗口的输入数据；</li>
<li>注重数据之间的关联性</li>
</ol>
<p>在 attention 中，语义编码不再是固定维度的编码，也不是输入序列的直接编码，而是由各个元素按照重要程度加权求和得到的值：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.378ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6354.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1319.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2375.5,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(3674.7,0)"><path data-c="B7" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(4174.9,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(4724.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(5113.9,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mo" transform="translate(5965.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.437ex" height="1.977ex" role="img" focusable="false" viewbox="0 -716 1077 873.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.932ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2180 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mo" transform="translate(1791,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 均为输入序列的长度，其中 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.437ex" height="1.977ex" role="img" focusable="false" viewbox="0 -716 1077 873.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 的计算公式：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="31.509ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 13926.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1354.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2410.5,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(2879.5,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(3364.5,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(3914.5,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(4275.5,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(5153.5,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(5682.5,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(6254.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6643.5,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(7112.5,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(7545.5,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(8030.5,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(8481.5,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(8947.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(9336.5,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(9886.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(10275.5,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mo" transform="translate(11127.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(11738.7,0)"><path data-c="B7" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="msub" transform="translate(12239,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(13148.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(13537.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> ，这里 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 为 decoder 的打分，基于前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.677ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2067.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(567.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1567.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 次输出所得；score 函数为打分函数。 </p>
<p><img src="/2025/02/17/llm-intro/attention.png" alt></p>
<p>总体而言，attention 机制可以分为四步：</p>
<ol>
<li>点积（向量在目标向量上的投影）：值越大说明关联度越大，0 说明没有关联度</li>
<li>打分：第一步的加强，获得一个更加贴合需要的匹配分布</li>
<li>softmax；基于前两步输出做重新分布；</li>
<li>点积</li>
</ol>
<p>目前业界存在很多不同的分类方法，其中使用比较多的一个是 soft-attention，另一个是 transformer 使用的 self-attention。</p>
<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p>讲到这里终于可以展开聊聊这块大模型的基石了。由于其良好的性能，导致目前大模型的发展就是堆 transformer，算力的核心就是 transformer 的各个机制。</p>
<p>虽然 attention 机制解决了 Encoder-decoder 输入输出必须等长的问题，但本质还是在 Encoder-decoder 上雕花，执行顺序是<strong>循环顺序</strong>，也就是说，只能从左到右或者从右到左计算，这样子就存在另外的问题：</p>
<ol>
<li>时间片 t 的计算依赖 t - 1 时刻的计算结果，限制了模型的并行能力，训练以及推理的过程慢；</li>
<li>尽管 LSTM 多个门和双状态输入的机制已经从一定程度上缓解了长依赖的问题，但缓解不意味着解决，对于特别长的依赖，LSTM 依旧无能为力，意味着顺序计算过程中信息还是会流失</li>
</ol>
<p>2017 年，重量级的 attention 论文发布，摒弃了传统的 NN 构型，只需要采用 attention 即可完成任务，同时 Encoder-decoder 被替换 —— 这就是著名的 Transformer 机制。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Transformer 沿用了 Encoder-decoder 的架构，但是将原来依赖于 RNN、LSTM 的 encoder 和 decoder 采用 attention 机制完全改写。</p>
<p>改写之后，一个完整的 transformer 由 encoder block 和 decoder block 两部分组成：</p>
<ul>
<li>每个 block 中的 encoder 由 self-attention 和 FNN(Feedforward Neural Network，前馈神经网络) 两部分组成；</li>
<li>每个 block 中的 decoder 同样包括 FNN，另外还有两个 self-attention，分别用于计算输入和输出的权值：<ul>
<li>Masked attention: 当前翻译和已经翻译的前文之间的关系，获取特征向量；</li>
<li>Encoder-decoder self-attention: 当前翻译和编码的特征向量之间的关系</li>
</ul>
</li>
</ul>
<p><img src="/2025/02/17/llm-intro/The-transformer-encoder-decoder-model.png" alt></p>
<p>encoder 和 decoder 都是以滑动窗口的方式分批次处理长文本的。</p>
<p>用户输入经过 transformer 得到了输出结果，是一个完整的端到端的流程。</p>
<h2 id="核心：self-attention"><a href="#核心：self-attention" class="headerlink" title="核心：self-attention"></a>核心：self-attention</h2><p>与传统 attention 的区别：</p>
<ol>
<li>传统 attention 基于 source 端和 target 端传递的大变量 hidden state 做计算，得到的结果代表了 source 端的每个词语 target 端每个词之间的依赖关系；</li>
<li>而 self-attention <strong>分别从 source 和 target 两端进行</strong>：<ul>
<li>先捕捉 source 端或 target 端自身的词与词之间的依赖关系；</li>
<li>再将 source 端得到的 self-attention 加入到 target 端得到的 attention，捕捉 source 端和 target 端词与词之间的依赖关系</li>
</ul>
</li>
</ol>
<p><img src="/2025/02/17/llm-intro/Attention_diagram_transformer.webp" alt></p>
<blockquote>
<p>self-attention 明确了三种不同的向量：查询向量 Q（query）、键向量 K（key）、值向量 V（value）。</p>
</blockquote>
<p>self-attention 比传统的 attention 机制效果要好，因为传统 attention 忽略了 source 或 target 端词与词之间的依赖关系；而 self-attention 不仅仅得到 source 和 target 端词与词之间的依赖关系，同时还可以有效获得 source 端或 target 端自身词与词之间的依赖关系。</p>
<p>在 self-attention 中：</p>
<ul>
<li>encoder 的输入为 inputs 结合 positional encoding，decoder 的输入为 outputs 结合其 positional encoding；</li>
<li>最简单的 self-attention 由一个 encoder block 和一个 decoder block 组成，每个 block 中的 attention 都是 <strong>Multi-head attention</strong>，分别由多个结构类似的 Scaled Dot-product attention 组成。</li>
</ul>
<p>Scaled Dot-product attention，缩放点乘注意力机制，跟上面讲的 attention 机制没啥区别，只是除去了维度的平方根，相对于 softmax 参数值较大时产生梯度消失的时候，可以使值的分布重新均匀，有效缓解梯度消失（关于梯度的计算，attention 机制的计算尤为复杂，本文先按下不表）。</p>
<p>回过来讲多头注意力机制：简单来说，就是多个 scaled dot-product attention 的结果进行连接后再次点乘权重；每个 scaled dot-product attention 称为一个“头”（head）。</p>
<h2 id="FNN"><a href="#FNN" class="headerlink" title="FNN"></a>FNN</h2><p>全连接层，包括第一层的非线性激活函数 relu 和第二层的线性激活函数：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="37.831ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 16721.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mi" transform="translate(749,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mi" transform="translate(1637,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2525,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2914,0)"><path data-c="1D44D" d="M58 8Q58 23 64 35Q64 36 329 334T596 635L586 637Q575 637 512 637H500H476Q442 637 420 635T365 624T311 598T266 548T228 469Q227 466 226 463T224 458T223 453T222 450L221 448Q218 443 202 443Q185 443 182 453L214 561Q228 606 241 651Q249 679 253 681Q256 683 487 683H718Q723 678 723 675Q723 673 717 649Q189 54 188 52L185 49H274Q369 50 377 51Q452 60 500 100T579 247Q587 272 590 277T603 282H607Q628 282 628 271Q547 5 541 2Q538 0 300 0H124Q58 0 58 8Z"/></g><g data-mml-node="mo" transform="translate(3637,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4303.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(5359.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(6237.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(6766.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(7338.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(7727.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(8227.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(8672.2,0)"><path data-c="1D44D" d="M58 8Q58 23 64 35Q64 36 329 334T596 635L586 637Q575 637 512 637H500H476Q442 637 420 635T365 624T311 598T266 548T228 469Q227 466 226 463T224 458T223 453T222 450L221 448Q218 443 202 443Q185 443 182 453L214 561Q228 606 241 651Q249 679 253 681Q256 683 487 683H718Q723 678 723 675Q723 673 717 649Q189 54 188 52L185 49H274Q369 50 377 51Q452 60 500 100T579 247Q587 272 590 277T603 282H607Q628 282 628 271Q547 5 541 2Q538 0 300 0H124Q58 0 58 8Z"/></g><g data-mml-node="msub" transform="translate(9395.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(10998,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(11998.2,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(12863.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="msub" transform="translate(13252.8,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(14855.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(15855.8,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container></p>
<p>FNN 的存在变换了 attention output 的空间，增加了模型的表现能力；去掉 FNN 也可以，但是效果会变差。</p>
<h2 id="输入预处理"><a href="#输入预处理" class="headerlink" title="输入预处理"></a>输入预处理</h2><p>Transformer 的输入预处理包括两点：masking 机制、位置编码</p>
<p>Masking 机制有两类：用于处理非定长序列的 padding mask，和用于防止标签泄露的 sequence mask。</p>
<ul>
<li>padding mask 针对非定长序列切割成长短不一的文本 batch 后，针对长度不足的样本<strong>使用特殊字符（如 \<pad\> 或其他统一的特殊字符）</pad\></strong> 补全形成输入矩阵，再利用 <strong>Mask 矩阵（1 表示有效字，0 代表无效字）</strong> 生成输入；</li>
<li>sequence mask 用于在同时使用上下文信息的机制中遮盖要预测的标签信息，不让模型“提前看到”</li>
</ul>
<p><img src="/2025/02/17/llm-intro/padding%20mask.png" alt></p>
<p>padding mask 常常用在最终结果输出、损失函数计算等一切受样本实际长度影响的计算，或者不需要无用 padding 参与计算的时候。</p>
<p>再来说说位置编码（Position Encoding）。位置编码主要拿来确定句子中单词的语序信息：</p>
<ol>
<li>对于任何一门语言，单词在句子里面的位置是十分重要的。一个单词在句子里面的排列顺序不同，整句话的意思就可能发生偏差；</li>
<li>Transformer 抛弃了 RNN、CNN 这些顺序结构为基础的神经网络，以 attention 取而代之，词序就会丢失，模型就无法知道每个词在句子里面的相对和绝对位置</li>
</ol>
<h2 id="优势及后续发展"><a href="#优势及后续发展" class="headerlink" title="优势及后续发展"></a>优势及后续发展</h2><p>Transformer 在 NLP 的发展中优势巨大的原因是：</p>
<ol>
<li>模型并行度高，使训练时间大为降低；</li>
<li>可以直接捕获序列中的长距离依赖关系，不仅是输入与输出之间词与词的关系，也包括输入与输出本身词与词之间的依赖；</li>
<li>可以产生更具解释性的模型</li>
</ol>
<p>针对 transformer 吃内存等一系列局限性，业界有了以下优化：</p>
<ol>
<li>多查询注意力机制（Multi-Query Attention, MQA，用于 GPT-4）：只需要每个 head 有独立的 Q，K V 均共享，由此减少了需要加载的矩阵内存量；</li>
<li>ByteTransformer：因为可变长的序列非常普遍，切割成 batch 的时候会产生巨量没有意义的 padding，造成资源浪费；byteTransformer 解决了这个问题，不仅减少了内存应用，还维持了性能；</li>
<li>SparseTransformer：针对图像和视频等更高密度计算，运用稀疏矩阵进行的 transformer 优化</li>
<li>Decoder-only transformer：只保留了 decoder block 的 transformer，将原本需要翻译的文本（encoder 输入）和翻译完成的上文（decoder 输入）合并作为一个整体输入来处理（target-specific embedding 替代 encoder 的输入）。</li>
</ol>
<p><img src="/2025/02/17/llm-intro/decoder-only.png" alt></p>
<p>⚠️ 注意：<strong>现在的 LLM 都是 decoder-only 的架构</strong>。</p>
<p>encoder-decoder 需要在一定量的标注数据上做 multitask finetuning 才能激发最佳性能；而 decoder-only 在没有任何 tuning 数据的情况下，zero-shot（零样本学习）表现最好 —— 目前 LLM 训练还是基于大规模语言材料进行自监督学习，zero-shot 具有极大便利性。</p>
<h1 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h1><p>Pre-trained Models，预训练，即先在一个基础数据集上进行任务训练，生成一个<strong>基础网络</strong>，然后将学习到的特征进行微调，或者迁移到另一个目标网络上，用来训练新目标任务。</p>
<p>预训练是在大量常规数据集上学习数据里面的“<strong>共性</strong>”，然后在特定领域的少量标注数据学习“<strong>特性</strong>”。因此模型只需要从“共性”出发，学习特定任务“特性”即可。优势在于：</p>
<ul>
<li>预训练模型的参数从大量常规数据集中得来，比起单纯在自己的数据集上从头开始训练，进度会更快；</li>
<li>预训练模型更好地学到了数据中的普遍特征，比起在自己的数据集上从头开始训练会有更好的泛化效果</li>
</ul>
<p>怎么训练？这里就涉及到了一个重要的概念：</p>
<h2 id="有监督学习与无监督学习"><a href="#有监督学习与无监督学习" class="headerlink" title="有监督学习与无监督学习"></a>有监督学习与无监督学习</h2><p>有监督学习（Supervised Learning）有明确的目的，也明确知道期待的结果；因为训练过程中数据集有明确标签，所以中间计算错误了能直接判断出来，结果很容易被量化和衡量。</p>
<p>无监督学习（Unsupervised Learning）没有明确的目的，无法提前知道结果，因此也不完全明确训练数据的关系。其目标是<strong>找到数据集的底层结构，根据相似性对这个数据集进行内在关联和区分</strong>。</p>
<p><img src="/2025/02/17/llm-intro/Supervised_and_unsupervised_learning.png" alt></p>
<p>早期训练以有监督学习为主，但模型泛化性较差；而无监督学习有着更好的泛化效果，有助于从数据中找到“有用的见解”，思考方式也<strong>更接近于人类的思考方式</strong>，所以无监督学习的潜在能力更强。</p>
<p>基于训练集中数据的类型（和测试集类型是否相同），又可以分成以下的不同方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>中文名词</th>
<th>训练集中与测试集同类别的样本数量</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Traditional learning</td>
<td>传统学习</td>
<td>&gt;&gt;1</td>
<td>测试集为一张斑马跑步的照片，训练集中有海量（比如百万的量级）有关斑马的标注的数据，有斑马休息的、几只斑马在一起的、斑马吃草的等等，也很可能有斑马各种跑步姿势的照片</td>
</tr>
<tr>
<td>Few-shot learning</td>
<td>少样本学习</td>
<td>&gt;1</td>
<td>测试集为一张斑马跑步的照片，训练集中有少量（比如数十的量级）有关斑马的标注的数据，有斑马休息的、几只斑马在一起的、斑马吃草的等等，极少和测试任务的照片相似</td>
</tr>
<tr>
<td>One-shot learning</td>
<td>单样本学习</td>
<td>=1</td>
<td>测试集为一张斑马跑步的照片，训练集中只有一张有关斑马的标注的数据，例如一张斑马休息的照片</td>
</tr>
<tr>
<td>Zero-shot learning</td>
<td>零样本学习</td>
<td>=0</td>
<td>测试集为一张斑马跑步的照片，训练集中没有有关斑马的标注的数据</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2025/02/17/llm-intro/Zero-Shot-Learning-in-NLP-Modulai.webp" alt></p>
<p>很容易看出，zero-shot 泛化性更强，而传统方法已经基本不在用了。</p>
<h2 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h2><p>Self-supervides Learning，有监督和无监督两种学习方式的混用，即一种具有监督形式的无监督学习方法，模型在学习过程中进行自我监督，而不是通过前置知识来诱发。</p>
<p>同样，自监督学习没有预设的标签，而是使用数据集本身的信息构造标签，即通过构造辅助任务（pretask）完成学习。该方法衍生出来的 transformer 被命名为  Bidirectional Encoder Representations from Transformers（<strong>BERT</strong>），被广泛应用于现代大模型的预训练中。</p>
<h1 id="再谈谈-GPT"><a href="#再谈谈-GPT" class="headerlink" title="再谈谈 GPT"></a>再谈谈 GPT</h1><p>毕竟 DeepSeek 从各方面对标的就是目前大模型中的翘楚 —— GPT，我们聊完深度学习基础后，首先深入浅出地了解一下 GPT。</p>
<p>GPT 的全称是 Generative Pre-trained Transformer。</p>
<h2 id="GPT-1"><a href="#GPT-1" class="headerlink" title="GPT-1"></a>GPT-1</h2><p>12 层（个）decoder-only transformer，单头维度 768，参数量 0.117B。</p>
<ul>
<li>采用无监督预训练 + <strong>有监督微调</strong>的方式，因此不是完全的 zero-shot；</li>
<li>其无监督预训练基于语言模型进行，模型参数使用 SGD（Stochastic Gradient Descent, 随机坡度下降）进行优化。</li>
</ul>
<p>GPT 的参数中有一个叫 <strong>token</strong>，由一个特定维度大小的向量组成，类似于 Lucene 的分词器：一段话里面，如果能够分成 5 个单位（单词、标点符号、英文句子的字母等），意味着这句话消耗了 5 个 token；不同的模型支持的上下文长度不一样，有的 2048，有的 200k。</p>
<p>另外，GPT 采用多任务学习（Multi-task Learning）的方向，多个不同目标和不同结构的任务并行处理，有效提升了泛化性。</p>
<p><img src="/2025/02/17/llm-intro/multask.png" alt></p>
<h2 id="GPT-2"><a href="#GPT-2" class="headerlink" title="GPT-2"></a>GPT-2</h2><p>48 层 decoder-only transformer，单头维度 1600，参数量 1.5B。</p>
<p>GPT-2 其实在模型和架构上没有可圈可点之处，主要贡献在于：<strong>随着模型参数和训练数据的海量增长，只用 zero-shot 也可以达到相当高的模型准确性</strong>，这个特点后来被总结为 scaling law。</p>
<p><img src="/2025/02/17/llm-intro/scaling-law.png" alt></p>
<h2 id="GPT-3"><a href="#GPT-3" class="headerlink" title="GPT-3"></a>GPT-3</h2><p>96 层 decoder-only transformer，单头维度 12888，参数量 175B，真正火起来的一代 GPT，相比较于前两代更为强大。</p>
<p>重要的技术点在于 meta learning 和 in-context learning</p>
<blockquote>
<p>meta learning：元学习，针对传统机器学习中由人设计的学习算法，改成<strong>由机器设计学习算法</strong>，即根据学习资料确定学习函数。</p>
<p>meta learning 的一种实现叫 MAML（Model-Agnostic Meta-Learning），将输入 transformer 的 batch 再分为 support set 和 query set，类似于模型学习时的训练集和测试集。</p>
<p>meta learning 和预训练的差异在于：预训练更关注于当前任务的准确性，而元学习更加关注潜力，关注未来，二者梯度的更新方向不同。</p>
</blockquote>
<p><img src="/2025/02/17/llm-intro/meta-learning.jpg" alt></p>
<blockquote>
<p>in-context learning：上下文学习，指在不进行参数更新的情况下，只<strong>在输入中加入几个示例</strong>就能让模型进行学习。</p>
<p>in-context learning 属于 GPT-2 的扩展。</p>
</blockquote>
<p><img src="/2025/02/17/llm-intro/in-context.jpg" alt></p>
<p>GPT-3 中介绍的 in-context learning 是作为 meta learning 的内循环出现的，而基于 SGD 的预训练则是外循环。</p>
<h2 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h2><h3 id="提示学习与指示学习"><a href="#提示学习与指示学习" class="headerlink" title="提示学习与指示学习"></a>提示学习与指示学习</h3><p>两者的目的都是去挖掘语言模型本身具备的知识，不同的是：</p>
<ul>
<li>Prompt Learning，提示学习，激发语言模型的补全能力（完形填空、上半句生下半句等）；in-context learning 被认为是提示学习的一种；</li>
<li>Instruction Learning，指示学习，激发语言模型的理解能力，通过<strong>给出更明显的指令</strong>让模型做出正确的行动</li>
</ul>
<p><img src="/2025/02/17/llm-intro/prompt.png" alt></p>
<p>Instruction 比 prompt 更具泛化能力，在经过多任务微调后还能做 zero shot。</p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>训练得到的模型可以看做是训练集的一个拟合。因为此时得到的模型并不非常可控，那么<strong>训练数据的分布</strong>就是影响生成内容质量的最重要因素。</p>
<p>有的时候我们希望模型不仅仅是受到训练数据的影响，而是人为可控的，从而保证生成数据的有用性、真实性、无公害性，因此我们需要需要人为的介入，目前 GPT 介入的方式就是<strong>奖励</strong>（<strong>Reward</strong>）机制，带奖励机制的学习方式就是<strong>强化学习</strong>（Reinforcement Learning, RL）。</p>
<p><img src="/2025/02/17/llm-intro/reinforcement-learning.png" alt></p>
<p>奖励机制可以被看作是传统模型训练机制的损失函数，其计算要比损失函数更灵活和多样；带来的代价是奖励计算不可导，因此不能拿来反向传播；同样人类反馈也是不可导的，故人工反馈也可作为强化学习的奖励。</p>
<p>强化学习通过对奖励的大量采样来拟合损失函数，以最大化长期累积奖励，从而实现模型的训练。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>综上，基于 GPT-3 的 ChatGPT 通过<strong>指示学习</strong>构建训练样本，以此来训练一个反映预测内容效果的<strong>奖励模型（Reward Model）</strong>，最后通过模型的打分来指导强化学习模型的训练。步骤如下：</p>
<ol>
<li>根据采集的数据集对 GPT-3 进行有监督微调（Supervised Fine-Tune, SFT）；</li>
<li>收集人工标注的对比数据，训练奖励模型（Reward Model, RM）；</li>
<li>使用 RM 作为强化学习的优化目标，利用 PPO（Proximal Policy Optimization，最近策略优化，可在多个训练步骤实现小批量的更新，解决了 Policy Gradient 算法中步长难以确定的问题）微调 SFT 模型</li>
</ol>
<h2 id="算力"><a href="#算力" class="headerlink" title="算力"></a>算力</h2><p>综上我们很容易得知，堆 transformer 的做法势必会带来算力要求的飞速增长。</p>
<h1 id="DeepSeek"><a href="#DeepSeek" class="headerlink" title="DeepSeek"></a>DeepSeek</h1><p>DeepSeek 泛指且不限于以下的模型：</p>
<ul>
<li>DeepSeek-V3：对话模型，最新的 DeepSeek 底座</li>
<li>DeepSeek-R1：推理模型，准确率相较于 DeepSeek V3更高，但思考过程过长</li>
<li>DeepSeek-R1-zero：推理模型，DeepSeek-R1 的先验版本，验证了 RL 本身对于激励 base 模型产生推理的能力</li>
<li>DeepSeek-R1-Distill-XXX-XXB：知识蒸馏版的推理模型。以 DeepSeek-R1-Distill-Qwen-7B 为例，使用 DeepSeek R1 中间阶段的训练数据，对 Qwen 2.5（参数量为 7B）进行 SFT 指令微调的模型。</li>
</ul>
<p>DeepSeek 总的特点在于，它完全抛开了预设的思维链模板（Chain of Thought）和监督式微调（SFT），仅依靠简单的奖惩信号（准确性奖励 <code>&lt;think&gt;</code> 和格式奖励 <code>&lt;answer&gt;</code>）来优化模型行为。</p>
<p>就本人肤浅的观察来看，DeepSeek 能够以 10% 不到的资源达到众多顶尖大模型的水平，采用的关键技术有两个：</p>
<h2 id="MLA"><a href="#MLA" class="headerlink" title="MLA"></a>MLA</h2><p>Multi-head Latent Attention，多头潜在注意力机制，通过动态合并（压缩 + 复用）相邻层的特征（K V）来减少计算量。</p>
<p><img src="/2025/02/17/llm-intro/mla.jpg" alt></p>
<p>同样的降本思路还在于 FP8，牺牲了一些精度来换取效率。</p>
<p>属实是：</p>
<blockquote>
<p>既然 GPU 少，那就卷工程，DeepSeek 这回确实是用东亚魔法打破西方垄断。</p>
</blockquote>
<h2 id="MoE"><a href="#MoE" class="headerlink" title="MoE"></a>MoE</h2><p>Mixture of Experts，混合专家模型，通过训练多个专家模型，每个专家针对特定的数据分布或任务进行优化。通过门控机制动态选择最合适的专家模块进行处理，从而提高模型的推理能力和效率。</p>
<p>与多任务学习（一个模型内多个学习任务）不同，MoE 是利用多个专家模型处理输入数据的不同方面或模式，通过门控网络决定如何将输入分配给各个专家，以及如何加权各位专家的输出。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://arxiv.org/pdf/1409.0473">Neural Machine Translation by Jointly Learning to Align and Translate</a></li>
<li><a href="https://arxiv.org/pdf/1706.03762">Attention Is All You Need</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/667508104">从 0 到 1 理解 GPT3</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODAzMTkyMg==&amp;mid=2247485860&amp;idx=1&amp;sn=e926a739784090b3779711164217b968&amp;chksm=c06981f9f71e08efb5f57441444f71a09f1d27fc667af656a5ad1173e32ad394201d02195a3a&amp;mpshare=1&amp;scene=1&amp;srcid=0618HMAYi4gzzwWfedLoOuSD&amp;key=cb6098335ab487a8ec84c95399379f16f975d33ce91588d73ecf857c54b543666b5927e231ad3a9b17bff0c20fff20fc49c262912dca050dee9465801de8a4cdc79e3d8f4fbc058345331fb691bcbacb&amp;ascene=1&amp;uin=MTE3NTM4MTY0NA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=ikhBXxX7PL%2Fal9hbIGXbRFA96ei74EF%2BcP8KdbP6UcV6mIpOfPWzVuju%2Bqw86q5r">动画图解 Attention 机制，让你一看就明白</a></li>
<li><a href="http://arxiv.org/pdf/2204.05832">What Language Model Architecture and Pretraining Objective Work Best for Zero-Shot Generalization?</a></li>
<li><a href="https://arxiv.org/pdf/1703.03400">Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks</a></li>
<li><a href="https://github.com/deepseek-ai/DeepSeek-V3/blob/main/DeepSeek_V3.pdf">DeepSeek-V3 Technical Report</a></li>
<li><a href="https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a></li>
<li><a href="https://www.cnblogs.com/Jcloud/p/18712775">🧐 DeepSeek-R1 原理解析及项目实践（含小白向概念解读）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mjc1NjM3MjY2MA==&amp;mid=2691554386&amp;idx=1&amp;sn=41ffc5d3a2438583dc89f64b0c83d70f">省钱也是技术活：解密 DeepSeek 的极致压榨术</a></li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
</search>
