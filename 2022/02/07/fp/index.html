<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="函数式编程（Functional Programming）是自 JDK 1.8 以来引入的一个非常重要的特性，也是 Java 编程未来的发展方向。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 中的函数式编程">
<meta property="og:url" content="http://example.com/2022/02/07/fp/index.html">
<meta property="og:site_name" content="Raymond&#39;s Cabin">
<meta property="og:description" content="函数式编程（Functional Programming）是自 JDK 1.8 以来引入的一个非常重要的特性，也是 Java 编程未来的发展方向。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/02/07/fp/stream-execution.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/filter-map-reduce.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/reduce-accumulation.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/groupingby.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/optional-schrdinger.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/optional-map.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/optional-flatmap1.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/optional-flatmap2.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/functor-monad.jpg">
<meta property="og:image" content="http://example.com/2022/02/07/fp/completablefunction-example.jpg">
<meta property="article:published_time" content="2022-02-07T10:59:57.000Z">
<meta property="article:modified_time" content="2022-03-26T09:07:28.014Z">
<meta property="article:author" content="敖惠竣｜Ao Huijun, Raymond">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/02/07/fp/stream-execution.jpg">

<link rel="canonical" href="http://example.com/2022/02/07/fp/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Java 中的函数式编程 | Raymond's Cabin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Raymond's Cabin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">for sharing thoughts</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/daca-ao" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/07/fp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="敖惠竣｜Ao Huijun, Raymond">
      <meta itemprop="description" content="Storing blogs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Raymond's Cabin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 中的函数式编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-07 18:59:57" itemprop="dateCreated datePublished" datetime="2022-02-07T18:59:57+08:00">2022-02-07</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>函数式编程（<strong>F</strong>unctional <strong>P</strong>rogramming）是自 JDK 1.8 以来引入的一个非常重要的特性，也是 Java 编程未来的发展方向。</p>
<span id="more"></span>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>作为一种<strong>编程范式</strong>来说，函数式编程面世的时间已经很早了，而且其对使用者的建模和抽象的要求是特别高的。<br>换句话来说，函数式编程具有自己的一套世界观和哲学观：</p>
<p>函数式编程以<strong>函数</strong>作为第一对象（函数作为一个变量，从而可以作为参数或返回值），注重<strong>描述</strong>（描述性的高级语言）而非具体的执行步骤，更关心代数结构之间的关系。</p>
<p>市面上常见的函数式编程语言有 JavaScript, Scala, Erlang, LISP, Clojure, Haskell 等。</p>
<h1 id="函数式编程的编程特性"><a href="#函数式编程的编程特性" class="headerlink" title="函数式编程的编程特性"></a>函数式编程的编程特性</h1><p><strong>不可变</strong><br>将对象的变化拆解开，无需考虑并发问题，大大减少发生 bug 的可能性。</p>
<p><strong>惰性求值</strong><br>需要结果的时候才进行求值。</p>
<p><strong>闭包</strong><br>FP 必须有的特性。</p>
<p><strong>高阶函数</strong><br>函数在经过一系列的转换之后生成新的函数，新函数的<strong>阶</strong>比原函数的更高。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：</span></span><br><span class="line">Function&lt;?&gt; callTwice(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>柯里化（Currying）</strong><br>由数学家 Haskell Curry 提出，指的是将一个多参数函数转化为单参数函数的方法，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">plus(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">plus(<span class="number">1</span>)(<span class="number">2</span>)  <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>
<p><strong>部分应用</strong><br>Partial Application，将多个参数的函数进行拆分，拆成多个只有一个参数或部分参数的函数，与柯里化较为相似。</p>
<p><strong>结合律</strong><br>指函数功能的组合。</p>
<p>千万不要认为函数式编程（FP）和 OOP 是两个水火不相容的东西，因为现在的发展趋势是混合式的范式编程，即：你中有我，我中有你。</p>
<p>然而要注意的一点是：以上提到的特性中的大部分，包括柯里化、部分应用等，在 JDK 1.8 都是用不了的，这也是 JVM 为了向前兼容的结果。<br>所以 JDK 1.8 所提供的所谓的“函数式”距离真正的函数式还很远，能应用到的只是<strong>阉割版</strong>的函数式编程。</p>
<h1 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h1><p>在 Java 8 之前的版本中，我们有很多适用函数式编程的场景：</p>
<ul>
<li>创建一个新的线程（Runnable）</li>
<li>UI 编程</li>
<li>异步回调</li>
<li>策略模式，如 Comparator</li>
<li>……</li>
</ul>
<p>只是基于当时版本的语言特性，需要用比较“蛋疼”的<strong>匿名内部类</strong>来实现。</p>
<p>JDK 1.8 引入函数式编程之后，我们可以使用其支持的 <strong>Lambda 表达式</strong>来简化以上场景的实现。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>一个 Lambda 表达式要表达的是一个方法（函数），经 Lambda 表达式转换过后的方法能够作为一个变量去被引用。</p>
<p>相比于普通方法，Lambda 表达式在保留<strong>方法签名</strong>（<strong>入参</strong>）、<strong>返回值</strong>和<strong>函数体</strong>这几个函数必需的部分之后，使用运算符 <strong><code>-&gt;</code></strong> 将方法签名和函数体连接起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有这个方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">(T param1, R param2)</span> </span>&#123;</span><br><span class="line">    ...  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为用 Lambda 表达式表示：</span></span><br><span class="line">XXFunction fn = (T param1, R param2) -&gt; &#123;</span><br><span class="line">    ...  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三要素：参数、函数体和箭头（-&gt;）</span></span><br></pre></td></tr></table></figure>
<p>以上：Lambda 表达式是一个表达式，它是没有名字的；我们定义了一个 Function 变量 <code>fn</code> 保存了这个 Lambda 表达式的引用。</p>
<p>Lambda 表达式包含了很多语法糖。除了忽略访问权限和返回类型之外，还包括：</p>
<ul>
<li>编译器可对参数类型进行推导</li>
<li>单行函数体可省略大括号</li>
<li>单入参可省略小括号</li>
</ul>
<p>给大家看一个普通的 Java 方法 Lambda 转化前后的过程：</p>
<h3 id="转写-Lambda-表达式步骤"><a href="#转写-Lambda-表达式步骤" class="headerlink" title="转写 Lambda 表达式步骤"></a>转写 Lambda 表达式步骤</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXFunction aBlockOfCode = <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<code>public</code> 是多余的，可以省略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXFunction aBlockOfCode = <span class="function"><span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的名字也是多余的，因为 Lambda 表达式没有名字，且方法引用已经赋值给了 aBlockOfCode：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXFunction aBlockOfCode = <span class="keyword">void</span> (String s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，编译器可以自行判断函数返回类型和入参的参数类型，因此这俩可以省略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXFunction aBlockOfCode = (s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再使用运算符 <strong><code>-&gt;</code></strong> 将方法签名和函数体连接起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXFunction aBlockOfCode = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单行函数体可省略大括号，单入参可省略小括号，最终可得：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXFunction aBlockOfCode = s -&gt; System.out.println(s);  <span class="comment">// ELEGANT!</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：没有入参的话，需要一个空括号 <code>()</code> 代替方法签名。</p>
<h3 id="表示高阶函数"><a href="#表示高阶函数" class="headerlink" title="表示高阶函数"></a>表示高阶函数</h3><p>明白了 Java 的 Lambda 表达式连接规则之后，我们就能很容易写出来属于 Java Lambda 的高阶函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; b -&gt; c -&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是：</span></span><br><span class="line">(a) -&gt; &#123;(b) -&gt; &#123;(c) -&gt; d;&#125;&#125;</span><br><span class="line"><span class="comment">// 即：</span></span><br><span class="line">methodA(a) &#123;</span><br><span class="line">    methodB(b) &#123;</span><br><span class="line">        methodC(c) &#123;</span><br><span class="line">            d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从纯函数式层面，我们可以理解为 (a, b, c) -&gt; d</span></span><br><span class="line"><span class="comment">// 但是 Java 不具备柯里化，所以还只能按照 a -&gt; b -&gt; c -&gt; d 理解</span></span><br></pre></td></tr></table></figure>
<p>从柯里化的角度来说，等于：</p>
<ul>
<li>fn = a -&gt; b -&gt; c -&gt; d</li>
<li>fn1 = fn(a)</li>
<li>fn2 = fn1(b)</li>
<li>fn3 = fn2(c) = d</li>
</ul>
<p>说完这么多，有人就问了，Lambda 既然能够表示一个函数，那它在 Java 语言里面的类型是什么？</p>
<p>回到上面我们提到的 Java 函数式编程适用场景。<br>Java 为了能够向前兼容，使用了接口（Interface）作为 Lambda 的类型；因为 Lambda 表达式表示的是函数，那么这种表示函数的接口，我们称之为“<strong>函数式接口</strong>”。</p>
<h2 id="函数式接口-SAM"><a href="#函数式接口-SAM" class="headerlink" title="函数式接口 SAM"></a>函数式接口 SAM</h2><p>能够描述某个函数的接口，其接口里面相对应的方法签名应该<strong>只有一个</strong>。<br>因此函数式接口中的 Single Abstract Method，由名字我们可以看出：给一个函数定义一个接口，接口内只能有<strong>单个非默认/静态实现方法</strong>。</p>
<p>所有 Lambda 类型都是一个接口，Lambda 表达式本身是这个接口的实现。<br>所以，即使 Lambda 表达式没有名字，但是一对应上 SAM，大家都会懂它描述的是哪个方法。</p>
<p>在接口定义中可使用 <code>@FunctionalInterface</code> 注解进行修饰，但不是必须的。</p>
<p>反过来：如果某个接口类只有一个非默认/静态方法，我们可以认为它是一个函数式接口，Lambda 表达式可以赋值给该接口类的实现中。</p>
<p>书接上回的 Lambda 表达式。定义好接口之后，可以得到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  <span class="comment">// 如果加上了注释，编译器会进行校验</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyLambdaInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span></span>;  <span class="comment">// 只能有单个非默认/静态实现方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MyLambdaInterface aBlockOfCode = s -&gt; System.out.println(s);  <span class="comment">// aBlockOfCode 的类型为 MyLambdaInterface</span></span><br></pre></td></tr></table></figure>
<p>在不同版本的 Java 中，对接口的实现和使用是不一样的。</p>
<p>我们先有这么一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enact</span><span class="params">(MyLambdaInterface myLambda, String s)</span> </span>&#123;</span><br><span class="line">    myLambda.doSomeShit(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 7 及更早版本，我们先要有一个 MyLambdaInterface 的实现类，再将实现类传入 enact() 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLambdaInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyLambdaInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeShit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">MyLambdaInterface interfaceImpl = <span class="keyword">new</span> MyLambdaInterfaceImpl();</span><br><span class="line">enact(interfaceImpl, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从 Java 8 开始，定义好了函数式接口之后，可以直接将 Lambda 表达式传入 enact()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enact(s -&gt; System.out.println(s), <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用比旧版本的方便得多了。</p>
<p>以下为 JDK 8 常用的内置函数式接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Function&lt;T,R&gt;</code></td>
<td>T</td>
<td>R</td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td><code>void</code></td>
<td>T</td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td>T</td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>Runnable</code></td>
<td><code>void</code></td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td>T</td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
</div>
<p>两个 input 用 <code>BiFunction</code>，三个 input 的没有，要自定义。</p>
<p>上述的 a -&gt; b -&gt; c -&gt; d 可以理解为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;?,Consumer&lt;?&gt;&gt; fn = a -&gt; &#123;b -&gt; c -&gt; d&#125;;</span><br><span class="line">Function&lt;?,Consumer&lt;?&gt;&gt; fn1 = b -&gt; &#123;c -&gt; d&#125;;</span><br><span class="line">Function&lt;?,?&gt; fn2 = c -&gt; &#123;d&#125;;</span><br></pre></td></tr></table></figure>
<p>区分了这么多类型的接口，是因为 Java 属于强类型的编程语言，需要对输入产出进行明确的类型划分。<br>在此背景下，任意两个接口之间因为互相没有实现或扩展关系，所以互相不能强制转换；比如：<code>Predicate&lt;?&gt;</code> 不能赋值给 <code>Function&lt;?,Boolean&gt;</code>。<br>虽然看上去像多态，但是不要将多态往函数式编程上靠。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>函数式接口不仅可以直接使用 Lambda 表达式赋值；对于已有的方法（函数）来说，要想在函数式编程中更优雅地使用，还可以通过<strong>方法引用</strong>去使用它们。</p>
<p>所谓“更优雅地使用”，指的是虽然我们可以通过给现有方法包装一层 Lambda 表达式去赋值给函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; Integer.parseInt(<span class="string">&quot;9527&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是从 Java 8 开始，可以使用方法引用去引用一个已经定义好的 Java 方法。</p>
<p>方法引用使用 <code>::</code> 操作符来确定需要引用的方法的<strong>唯一名称</strong>：</p>
<p><strong>1</strong>. 静态方法：类名<code>::</code>静态方法名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer::parseInt;  <span class="comment">// 告知属于哪个类</span></span><br></pre></td></tr></table></figure>
<p><strong>2</strong>. 构造函数引用：类名<code>::new</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person::<span class="keyword">new</span>;  <span class="comment">// 告知属于哪个类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数的引用类型是 Supplier&lt;Clazz&gt;</span></span><br><span class="line"><span class="comment">// 有参构造函数的引用类型是 Function&lt;T,Clazz&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3</strong>. 指定实例的方法引用：实例对象<code>::</code>实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str::subString;  <span class="comment">// 告知属于哪个实例</span></span><br></pre></td></tr></table></figure>
<p><strong>4</strong>. <strong>指定类型</strong>中任意一个实例方法的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设有类 T：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    method1(arg2..argN);  <span class="comment">// 参数个数为 N - 1</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现有以下函数式接口：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fn</span> </span>&#123;</span><br><span class="line">    apply(T arg1, arg2..argN)  <span class="comment">// 参数个数为 N</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那当某个方法对接口进行方法引用的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherMethod(Fn fn);</span><br></pre></td></tr></table></figure>
<p>我们可以引用指定 T 的一个形参数量比 SAM 少一个的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherMethod(T::method1);  <span class="comment">// 以此完成对指定类型中任意一个实例方法的引用</span></span><br></pre></td></tr></table></figure>
<p>如此，当调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fn.apply(TInstance arg1, arg2..argN);</span><br></pre></td></tr></table></figure>
<p>的时候，<code>arg2..argN</code> 等参数会传入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TInstance.method1(arg2..argN)</span><br></pre></td></tr></table></figure>
<p>里面；<code>method1()</code> 会被调用，同时 <code>arg1</code> 会被作为调用 <code>method1()</code> 方法的实例。可以理解为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(arg1, arg2..argN) == arg1.method1(arg2..argN)</span><br></pre></td></tr></table></figure>
<h3 id="函数式接口转换"><a href="#函数式接口转换" class="headerlink" title="函数式接口转换"></a>函数式接口转换</h3><p>由于 Java 是强类型语言，Java 8 的函数式接口有的时候比较难用；然而在某些我们并不要求函数签名完全一致的场合中（也是其他函数式编程语言的特性），希望可以就不同的函数式接口进行转换。<br>比如说：</p>
<ul>
<li>某个方法引用要求传入 <code>Function</code>，但实际应用的时候不关心输入，希望传入 <code>Supplier</code>；</li>
<li>某个方法引用要求传入 <code>Consumer</code>，但目前手头上的是 <code>Function</code>；</li>
<li>某个方法引用仅要求 <code>Runnable</code>，但目前手头上的是 <code>Supplier</code></li>
</ul>
<p>以上的情况，手头上有的都不能直接传入对方法的引用中，需要另外编写 util 方法去转换，或者：</p>
<p>就编程经验来说，我们可以采取一个特殊的 <strong>void-compatibility</strong> 规则：<br>如果 Lambda 是一个语句表达式，那么即使该 Lambda 表达式有返回值，也可以赋值给返回值签名为 void 的函数。</p>
<p>这样子的话，单句的 Lambda 表达式可以赋值给 <code>Consumer</code> 和 <code>Runnable</code>。</p>
<h1 id="进阶应用：Stream"><a href="#进阶应用：Stream" class="headerlink" title="进阶应用：Stream"></a>进阶应用：Stream</h1><p>不仅是在 Java 8，<code>Stream</code> 在整个函数式编程中都占有着举足轻重的地位。</p>
<p>首先，Stream 是一个<strong>哲学</strong>上的概念；相对于 List 来说，Stream：</p>
<ul>
<li>可以是无限的：《SICP》认为在函数式编程中，所有的东西都是不可变的；而在实际处理一些会变化的场景时，将场景看作是一个与时间有关的函数，函数本身（即场景变化的历史）不可变。</li>
<li>可以并行处理</li>
<li>可能延迟处理：在无限的流中执行操作，得到的中间结果不可能实时显示出来。</li>
</ul>
<p>相对于 List 的 foreach 将每个点分开来处理，Stream 引用一些函数将其自身<strong>变形</strong>至其他的 Stream 来做另外的处理，但是不需要拆分至每一个元素。</p>
<p>创建 Stream 的方法：</p>
<ul>
<li>静态数据构建有限流：<code>Stream.of(T)</code></li>
<li>容器：<code>[collection|map].stream()</code></li>
<li>动态生成有限/无限流：<code>Stream.iterate(T, UnaryOperator)</code> <code>Stream.generate(Supplier)</code></li>
<li>其他 API：<code>Files.lines()</code> …</li>
</ul>
<p>一个很有名的 Stream 响应式编程应用就是点击事件的处理，根据 Stream 中规定时间段内的点击次数来判断单击/双击事件。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>Java 8 中的 Stream 有很多 API，主要分两种类别：</p>
<p><strong>Intermediate</strong>：中间状态操作，应用在 Stream 的变化之中的 API；结果不能实时显示。</p>
<ul>
<li>filter</li>
<li>distinct</li>
<li>skip</li>
<li>limit</li>
<li>map / flatMap</li>
<li>sorted</li>
<li>peek</li>
<li>…</li>
</ul>
<p><strong>Terminal</strong>：这些 API 一旦被调用，Stream 就在操作调用前变为有限的流；随后 Stream 被终结，在往后的计算中不能再被使用。</p>
<ul>
<li>count / sum</li>
<li>collect / reduce</li>
<li>foreach</li>
<li>anyMatch / allMatch / noneMatch</li>
<li>…</li>
</ul>
<p><img src="/2022/02/07/fp/stream-execution.jpg" alt></p>
<p>其中被誉为函数式编程“三板斧”的三个高阶函数：</p>
<ul>
<li><code>filter(Predicate predicate)</code>：根据传入的条件过滤期望结果</li>
<li><code>map(Function mapper)</code>：根据传入的函数做映射</li>
<li><code>reduce(BinaryOperator acc)</code> / <code>reduce(T identity, BinaryOperator acc)</code> / <code>reduce(U Identity, BiFunction acc, BinaryOperator combiner)</code>：根据传入的函数将流折叠（计算 Stream 的值得到最终的累积结果）</li>
</ul>
<p>注：reduce() 与递归不同；递归是在循环里面调用自己，而 reduce() 没有调用传入的函数本身。</p>
<p><img src="/2022/02/07/fp/filter-map-reduce.jpg" alt></p>
<p>reduce() 做累加的例子：</p>
<p><img src="/2022/02/07/fp/reduce-accumulation.jpg" alt></p>
<p>用到了 <code>reduce(T identity, BinaryOperator acc)</code>，也是<strong>用得最多</strong>的 reduce() 函数。</p>
<p><em>Hadoop</em> 正是借鉴了函数式编程中 <code>map</code> 和 <code>reduce</code> 的概念，创建了属于自己的 MapReduce。</p>
<h2 id="reduce-可以用来实现什么"><a href="#reduce-可以用来实现什么" class="headerlink" title="reduce 可以用来实现什么"></a>reduce 可以用来实现什么</h2><p><strong>求和</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Collection&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(<span class="number">0</span>, (acc, curr) -&gt; acc + curr);</span><br><span class="line">    <span class="comment">// 或：return list.stream().reduce(0, Integer::sum);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>求最大值</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">max</span><span class="params">(Collection&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(Math::max).orElse(<span class="keyword">null</span>);  <span class="comment">// reduce(BinaryOperator acc) 要求累计值和当前值类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拼接字符串</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">join</span><span class="params">(Collection&lt;Integer&gt; list, String delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().map(String::valueOf)</span><br><span class="line">        .reduce((acc, curr) -&gt; String.join(delimiter, acc, curr)).orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>存放进 Collection</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">toList</span><span class="params">(Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> stream.reduce(ret,</span><br><span class="line">                         (acc, curr) -&gt; &#123;  <span class="comment">// BiFunction 规避了累计值和当前值类型必须相同的问题</span></span><br><span class="line">                             acc.add(curr);</span><br><span class="line">                             <span class="keyword">return</span> acc;  <span class="comment">// 讨巧的实现，每次都返回累加后的自己，不是一个新元素，严格来说这并不正确</span></span><br><span class="line">                         &#125;,</span><br><span class="line">                         (list1, list2) -&gt; &#123;  <span class="comment">// 并行执行 stream 的时候所要引用的表达式</span></span><br><span class="line">                             list1.addAll(list2);</span><br><span class="line">                             <span class="keyword">return</span> list1;</span><br><span class="line">                         &#125;);  <span class="comment">// 应该使用 collect 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常来说，应该用 collect()</span></span><br></pre></td></tr></table></figure>
<p><strong>实现 map</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;T,R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T,R&gt; mapFn)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(ret,</span><br><span class="line">                                (acc, curr) -&gt; &#123;</span><br><span class="line">                                    acc.add(mapFn.apply(curr));  <span class="comment">// 转换</span></span><br><span class="line">                                    <span class="keyword">return</span> acc;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                (list1, list2) -&gt; &#123;</span><br><span class="line">                                    list1.addAll(list2);</span><br><span class="line">                                    <span class="keyword">return</span> list1;</span><br><span class="line">                                &#125;);</span><br><span class="line">    <span class="comment">// for 循环也能实现，但是 for 属于有限数量的遍历，不能应用到无限的 stream 中去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现 filter</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> list.stream().reduce(ret,</span><br><span class="line">                                (acc, curr) -&gt; &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (p.test(curr)) &#123;</span><br><span class="line">                                        acc.add(curr);  <span class="comment">// 过滤</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">return</span> acc;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                (list1, list2) -&gt; &#123;</span><br><span class="line">                                    list1.addAll(list2);</span><br><span class="line">                                    <span class="keyword">return</span> list1;</span><br><span class="line">                                &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Transducer</strong>：多个 reduce 自由组合的一种模式，从而自定义 Stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取上面例子的 BiFunction 做结合：</span></span><br><span class="line">.reduce(</span><br><span class="line">    (acc, curr) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.test(curr)) &#123;  <span class="comment">// 最外层的 reduceFunction</span></span><br><span class="line">            R newValue = mapFn.apply(curr);  <span class="comment">// 里一层的 reduceFunction</span></span><br><span class="line">            acc.add(newValue);  <span class="comment">// 最里层的 reduceFunction</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 这样的组合为一个 transducer</span></span><br></pre></td></tr></table></figure>
<p>每一个 reduceFunction 由 <code>Function</code> 和 <code>BiFunction</code> 组成，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (acc,curr) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> biFunction.apply(acc, function.apply(curr));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后通过函数组合 <code>f1.compose(f2)</code> 或 <code>f2.andThen(f1)</code>（这个语义上更直观）完成组合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1 * f2 == f3(x), 相当于 f1(f2(x)).</span><br></pre></td></tr></table></figure>
<p>组合过程中没有对任意一个函数做过任何一次调用。</p>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect()"></a><strong>collect()</strong></h2><p><code>Stream.collect()</code> 跟 reduce() 是兄弟函数，是增强版的 reduce()，所使用的频率高于 reduce()。</p>
<p>函数签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner);  <span class="comment">// supplier 是承载状态改变的容器</span></span><br><span class="line">collect(Collector collector);  <span class="comment">// Collector 类封装了 .collect() 所需要的全部要素</span></span><br></pre></td></tr></table></figure>
<p>区别在于：</p>
<p>对于传入的 accumulator 函数 <code>(acc, curr)</code>，collect 会将 acc 变成一个<strong>有状态</strong>的量，每次 accumulate 的时候可以直接获取 acc 当前状态；而 reduce 设计上的本意是<strong>不让修改</strong> acc 的。</p>
<p>也就是说，collect 操作的 acc 是可变数据，语义示意如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R container = supplier.get();</span><br><span class="line"><span class="keyword">for</span> (T data : datas) &#123;</span><br><span class="line">    accumulator.accept(container, data);  <span class="comment">// 没有返回值，每一次循环更新累计值 container 的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> container;  <span class="comment">// 返回内部更改过状态的累计值</span></span><br></pre></td></tr></table></figure>
<p>而 reduce（<code>reduce(initValue, (acc, curr))</code>）操作的是不可变数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R ret = initValue;</span><br><span class="line"><span class="keyword">for</span> (T data : datas) &#123;</span><br><span class="line">    ret = accumulator.apply(ret, data);  <span class="comment">// 每一次根据累计值和当前元素返回一个新的累计值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>再多说一嘴 <code>Collector</code> 接口：</p>
<p>鉴于每一次传递参数的时候，对应特定的 collect() 结果，都会传递对应的一套 supplier, accumulator 和 combiner 的组合；所以 JDK 的开发者们干脆就设计了 Collector 的接口，将一系列的函数放在了一起。</p>
<p>因此 Collector 各个参数就很明显了：</p>
<ul>
<li><code>Supplier</code>：累计数据构造函数</li>
<li><code>Accumulator</code>：累计函数，同 reduce() 参数</li>
<li><code>Combiner</code>：合并函数，在并行场合下做处理使用，同 reduce() 参数</li>
<li><code>Finisher</code>：对累计数据做最终转换</li>
<li>*<code>Characteristics</code>：特征（并发 CONCURRENT / 无序 UNORDERED / 无 Finisher IDENTITY_FINISH）</li>
</ul>
<p><small>注：IDENTITY 函数在函数式编程的意思是：输入一个值，将其自身输出。</small></p>
<p>比如 <code>Collectors.toList()</code> 的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>,  <span class="comment">// supplier</span></span><br><span class="line">                                List::add,  <span class="comment">// accumulator</span></span><br><span class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,  <span class="comment">// combiner</span></span><br><span class="line">                                CH_ID);  <span class="comment">// characteristics</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Combiner 需满足同一律：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Combiner.apply(acc, []) == acc;</span><br></pre></td></tr></table></figure>
<p>Finisher 需满足结合律：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">acc.accept(t1);</span><br><span class="line">acc.accept(t2);</span><br><span class="line">finisher.apply(acc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line">acc1.accept(t1);</span><br><span class="line">acc2.accept(t2);</span><br><span class="line">finisher.apply(combiner.apply(t1, t2));</span><br></pre></td></tr></table></figure>
<p>以上所有的条件，都是基于 Stream 能并发处理数据的特性，需要确保数据的一致性。</p>
<h2 id="Collectors-工具类"><a href="#Collectors-工具类" class="headerlink" title="Collectors 工具类"></a>Collectors 工具类</h2><p>JDK 的静态工具类 <code>Collectors</code> 已经给我们提供了很多即用的 API 了，包括：</p>
<ul>
<li>流转容器：toList() / to(Concurrent)Map() / toSet() / toCollection()</li>
<li>counting() / averagingXX() / joining() / summingXX()</li>
<li>分组：groupingBy() / partitioningBy()</li>
<li>mapping() / reducing()</li>
<li>…</li>
</ul>
<p>下面挑一两个来简单说一下。</p>
<p><br></p>
<h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title=".groupingBy()"></a><strong>.groupingBy()</strong></h3><p>函数签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 classifier 单纯将 stream 数据分到对应的 key 上，再存放成 Map&lt;key, List&gt;，默认使用 HashMap</span></span><br><span class="line">Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt; groupingBy(Function classfier);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分到 key 上之后，对每个 key 的元素进行后续的 collect() 操作</span></span><br><span class="line">Collector&lt;T,?,Map&lt;K,D&gt;&gt; groupingBy(Function classfier, Collector downstream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，允许自定义 Map 创建</span></span><br><span class="line">Collector&lt;T,?,M&gt; groupingBy(Function classfier, Supplier mapFactory, Collector downstream);  </span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/07/fp/groupingby.jpg" alt></p>
<p>第一个函数签名是直接将分到不同的 key 上的数据流用 <strong>List</strong> 汇总并返回；<br>剩余的函数签名，使用的是<strong>传入的 Collector</strong> 对不同的 key 上分到的数据流进行处理（数据分类完之后再做事情）。<br>理论上来说，Collectors 工具类<strong>所有的 API</strong> 都可以作为传入的 Collector。</p>
<p>所以 <code>.groupingBy()</code> 能够很简单地解决多级分层的问题。</p>
<p><br></p>
<h1 id="进阶应用：Optional"><a href="#进阶应用：Optional" class="headerlink" title="进阶应用：Optional"></a>进阶应用：Optional</h1><p>Optional 在 JDK 8 中和 Stream 具有同等重要的地位，它最大的意义在于能够简化 null check，免除了编程时 NullPointerException 带来的痛苦：</p>
<p>我们可以用一个类似于“薛定谔的猫”的容器图来描述 Optional 的功能：</p>
<p><img src="/2022/02/07/fp/optional-schrdinger.jpg" alt></p>
<p>Optional 本身不会为 null。</p>
<p>Optional 的一些 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofNullable(T t);  <span class="comment">// 允许传入值为空</span></span><br><span class="line">of(T t);  <span class="comment">// 空值会报错</span></span><br><span class="line">orElse(T t);  <span class="comment">// return x != null ? x : t</span></span><br><span class="line">orElseGet(Function fn);  <span class="comment">// return x != null ? x : fn()</span></span><br><span class="line">ifPresent(Function fn);  <span class="comment">// if x != null execute fn()</span></span><br></pre></td></tr></table></figure>
<p>举个例子，假设有下面的 <code>Person</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = getSomeOne();</span><br></pre></td></tr></table></figure>
<p>在 Java 7 及之前的版本中，如果要对 person 对象进行空值判断，我们需要一个甚至多个 <code>if-else</code> 代码块。</p>
<p>从 Java 8 开始，只需要声明一个 <code>Optional</code> 对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; personOpt = Optional.ofNullable(person);  <span class="comment">// “薛定谔的箱子”</span></span><br></pre></td></tr></table></figure>
<p>存在就开干</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line">If (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">personOpt.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>存在即返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="keyword">return</span> person == <span class="keyword">null</span> ? UNKNOWN_PERSON : person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> personOpt.orElse(UNKNOWN_PERSON);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="keyword">return</span> person == <span class="keyword">null</span> ? getPersonFromDb() : person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> personOpt.orElseGet(() -&gt; getPersonFromDb());</span><br></pre></td></tr></table></figure>
<p>其实以上代码只是 Optional 边边角角的应用。<br>Optional 对于空值的判断的判断其实还不如 if-else。Optional 自身最大的意义并不仅仅在于做非空判断，而是在于它在做完非空判断之后，还能接着<strong>执行</strong>其他的诸如 <code>.filter()</code> <code>.map()</code> <code>.flatMap()</code> 等<strong>方法且不会出错</strong>。</p>
<p>上面提到的三个方法，是 Optional 的价值所在，是 Optional 相对于 if-else 代码块的优势，否则要只是做非空判断的话，还真的不如直接写 if-else。</p>
<p>先说 Optional 最重要的 <code>.map()</code>：</p>
<p><br></p>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a><strong>map()</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>map() 的返回值是 Optional 类型。</p>
<p>再来一个容器图：</p>
<p><img src="/2022/02/07/fp/optional-map.jpg" alt></p>
<p>可知如果存在值 x，随后可以通过 <code>.map(fn)</code> 计算 <code>fn(x)</code> 的值；倘若值为 null，fn 不会被调用，即使调用了 <code>.map(fn)</code>，方法也不会抛出 NullPointerException，且可以<strong>接着往下级联处理</strong>，完全不用担心，也不用理会这条处理链当中的任何一个节点会出错（抛 NullPointerException 异常）。</p>
<p>如果接着 fn(x) 之后再有 <code>.map(gn)</code> 的话，那处理链下一个节点里面就是 <code>gn(fn(x))</code>，不难看出 Optional 的处理链就是<strong>函数组合</strong>。</p>
<p>应用于多层嵌套 null 检查非常管用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String name = person.getLastName();</span><br><span class="line">    <span class="keyword">return</span> name == <span class="keyword">null</span> ? <span class="keyword">null</span> : name.toUpperCase();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> personOpt.map(p -&gt; p.getLastName())</span><br><span class="line">                .map(name -&gt; name.toUpperCase())</span><br><span class="line">                .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>如上，在抛弃一大堆嵌套的 if-else 代码块之后，处理链代码会变得非常简单明了，维护性也会大大提高。</p>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a><strong>flatMap()</strong></h2><p>如果 <code>fn(x)</code> 的结果是一个 Optional，应该怎么处理？</p>
<p><img src="/2022/02/07/fp/optional-flatmap1.jpg" alt></p>
<p>这个时候可以使用另一个方法 <code>flatMap()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatMap(Function&lt;? <span class="keyword">super</span> T,Optional&lt;U&gt;&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>根据函数式编程的语义，flatMap() 接收返回值为 Optional 的函数，将传入的 Optional 对象“外包装去掉”取出值 value，再将 value join 进 map() 生成的 Optional 中：</p>
<p><img src="/2022/02/07/fp/optional-flatmap2.jpg" alt></p>
<p>Optional 中的 map() 和 flatMap()，和 Stream 中的 map() 和 flatMap() 语义差不多，都是属于函数式编程里面<strong>范畴</strong>的概念。<br>在这个概念里面，Optional 和 Stream 被称为 <strong>Functor</strong> <strong>函子</strong> / <strong>Monad</strong> <strong>单子</strong>，它们的 map() 以及 flatMap() 这些函数能够建立它们函子所在世界里面的映射关系。</p>
<p><br></p>
<p>Optional 不太好的地方在于它与 Stream 的结合不太好，<code>ofNullable()</code> 的形参是单个元素，倘若有集合（如 List）需要处理的话，最好还是使用 Stream 的 .filter()，跟 Optional 的关系就不大了。</p>
<h2 id="Functor-amp-Monad"><a href="#Functor-amp-Monad" class="headerlink" title="Functor &amp; Monad"></a>Functor &amp; Monad</h2><p>实现了 map() 在内部世界映射的称之为 Functor；实现了 flatMap() 通过跨范畴映射并 join 到对应容器的称之为 Monad。</p>
<p>除了 Optional 和 Stream 之外，函数式编程还有非常多类似的概念：</p>
<p><img src="/2022/02/07/fp/functor-monad.jpg" alt></p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h2><p>Future 的增强版，部分实现了函数式编程中 Promise 的功能。</p>
<p>有这么一个例子：</p>
<p><img src="/2022/02/07/fp/completablefunction-example.jpg" alt></p>
<p>service4 依赖于 service2 和 service3 的结果，service2 依赖于 service1 的结果，service1 和 service3 之间无关联。</p>
<p>倘若使用 Future 实现，那么上面的一段话我们还要想一遍，用代码步骤去阐述依赖关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; task1 = pool.submit(FutureExample::service1);</span><br><span class="line">Future&lt;String&gt; task3 = pool.submit(FutureExample::service3);</span><br><span class="line"></span><br><span class="line">String ret1 = task1.get();</span><br><span class="line">Future&lt;String&gt; task2 = pool.submit(() -&gt; service2(ret1));</span><br><span class="line"></span><br><span class="line">String ret2 = task2.get();</span><br><span class="line">String ret3 = task3.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> service4(ret2, ret3);</span><br></pre></td></tr></table></figure>
<p>这种服务依赖关系一旦有所改变，修改代码的时候还要将这一大段逻辑从头到尾去看一遍；而且随着系统复杂度日渐提高，这段代码的维护成本会上涨得更快。</p>
<p>用 CompletableFuture 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(FutureExample::service1, pool).thenApply(FutureExample::service2);</span><br><span class="line">CompletableFuture&lt;String&gt; cf3 = CompletableFuture.supplyAsync(FutureExample::service3, pool);  <span class="comment">// Executor 专用方法签名</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf4 = cf2.thenCombine(cf3, FutureExample::service4);</span><br><span class="line"><span class="keyword">return</span> cf4.join();</span><br></pre></td></tr></table></figure>
<p>描述性的语言让代码变得简洁、可维护。</p>
<p>CompletableFuture API 里面的关键字：</p>
<ul>
<li><code>accept-</code>：接收参数为 Consumer</li>
<li><code>apply-</code>：接收参数为 Function</li>
<li><code>handle-</code>：接收参数为 BiFunction</li>
<li><code>runAfter-</code>：接收参数为 Runnable</li>
<li><code>-Either/Both-</code>：等待任意任务完成还是全部完成</li>
<li><code>-then-</code>：等待当前任务完成再执行另外一个</li>
<li><code>-Async-</code>：后续任务是否异步执行</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/01/spring-annotation/" rel="prev" title="Spring 注解">
      <i class="fa fa-chevron-left"></i> Spring 注解
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/09/es/" rel="next" title="Elasticsearch 概述">
      Elasticsearch 概述 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">函数式编程的编程特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">基础应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%86%99-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.1.</span> <span class="nav-text">转写 Lambda 表达式步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">表示高阶函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-SAM"><span class="nav-number">3.2.</span> <span class="nav-text">函数式接口 SAM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.3.1.</span> <span class="nav-text">函数式接口转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%EF%BC%9AStream"><span class="nav-number">4.</span> <span class="nav-text">进阶应用：Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">4.1.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reduce-%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88"><span class="nav-number">4.2.</span> <span class="nav-text">reduce 可以用来实现什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collect"><span class="nav-number">4.3.</span> <span class="nav-text">collect()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">Collectors 工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#groupingBy"><span class="nav-number">4.4.1.</span> <span class="nav-text">.groupingBy()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%EF%BC%9AOptional"><span class="nav-number">5.</span> <span class="nav-text">进阶应用：Optional</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#map"><span class="nav-number">5.1.</span> <span class="nav-text">map()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatMap"><span class="nav-number">5.2.</span> <span class="nav-text">flatMap()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functor-amp-Monad"><span class="nav-number">5.3.</span> <span class="nav-text">Functor &amp; Monad</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">5.4.</span> <span class="nav-text">CompletableFuture</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">敖惠竣｜Ao Huijun, Raymond</p>
  <div class="site-description" itemprop="description">Storing blogs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/daca-ao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;daca-ao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/realkaije" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;realkaije" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/daca.aohuijun" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;daca.aohuijun" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/kaijesugardaddy" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;kaijesugardaddy" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">敖惠竣｜Ao Huijun, Raymond</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

  

</body>
</html>
